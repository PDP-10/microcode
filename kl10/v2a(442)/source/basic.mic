.TOC	"THE INSTRUCTION LOOP"

.NOBIN
;	Comments updated [302][344][410]
;
;INSTRUCTION DECODE, EA COMPUTATION, AND OPERAND FETCH
;
;	IN GENERAL, AN INSTRUCTION IS STARTED AT XCTGO.
; AT THIS TIME THE INSTRUCTION IS IN ARX AND IR, AND PC HAS ITS ADDRESS.
; THE DRAM OUTPUTS AND "AC" BITS WILL SETTLE DURING THIS
; MICROINSTRUCTION, AND WILL BE LATCHED BY THE CLOCK WHICH ENDS
; THE CYCLE.  XCTGO DISPATCHES ON THE STATE OF THE
; INDIRECT AND INDEX BITS OF THE ARX (EA MOD DISP) TO COMPEA OR
; ONE OF THE THREE LOCATIONS FOLLOWING IT.
;	IF INDIRECT IS SPECIFIED, THE INDIRECT POINTER IS FETCHED (AT
; COMPEA+2 OR +3 (DEPENDING ON WHETHER INDEXING IS ALSO SPECIFIED).
; WE WAIT FOR IT AT INDRCT, AND THEN LOOP BACK TO EFIW, WHERE GLOBAL
; INDEXING AND INDIRECTION, AS WELL AS BAD DATA, WILL BE CHECKED.  ALL
; OF THIS WAS ADDED FOR THE MODEL B.  WHEN THIS IS DONE, OR IF NO
; INDIRECT IS CALLED FOR, WE COMPUTE THE INSTRUCTION'S EFFECTIVE ADDRESS
; (EA) AT COMPEA OR COMPEA+1 (DEPENDING ON WHETHER INDEXING IS CALLED
; FOR), OR AT EFIW+4, 5, 6, OR 7 IF THE LAST WORD IN THE INDIRECTION CHAIN
; WAS GLOBAL AND PERFORM THE FUNCTION "A READ", WHOSE OPERATION DEPENDS
; ON THE DRAM A FIELD, AS FOLLOWS:
;
; MACRO	 A-FLD	MEM FUNCTION	VMA	DISPATCH
;  I	  0	NONE		AD(=EA)  DRAM J
; I-PF	  1	FETCH		PC+1	 DRAM J
; EA	  2	30 BIT EA CALC	AD	 DRAM J
;  W	  3	WR TST		AD	   3	(The model A dispatch
;  R	  4	READ		AD	   4	 addresses were all 40
; R-PF	  5	READ		AD	   5	 greater than these)
; RW	  6	READ/WR TST	AD	   6
; RPW	  7	RD-PSE/WR TST	AD	   7
;
;	A FIELD VALUES 0 AND 1 ARE USED FOR INSTRUCTIONS WHICH NEITHER
; READ NOR WRITE THE CONTENTS OF EA (IMMEDIATE-MODE INSTRUCTIONS,
; JUMPS, ETC).  THESE DISPATCH FROM "A READ" DIRECTLY TO THE MICROCODE
; WHICH HANDLES THE INSTRUCTION.  IF THE A FIELD CONTAINS 1, "A READ"
; CAUSES A PREFETCH (FROM PC+1), SO THAT THE MBOX CAN WORK ON GETTING
; THE NEXT INSTRUCTION INTO ARX WHILE THE EBOX PERFORMS THIS ONE.
;	IF THE A FIELD CONTAINS A 2, THE EA CALCULATION WILL PROVIDE
; A FULL 30 BIT EFFECTIVE ADDRESS TO THE AD AT THE END.  THIS WAS
; INTRODUCED WITH EXTENDED ADDRESSING, TO ALLOW SUCH INSTRUCTIONS AS
; XMOVEI AND XHLLI TO COMPUTE A COMPLETE ADDRESS WITHOUT ACTUALLY
; REFERENCING IT.  OTHERWISE, THIS IS SIMILAR TO AN A FIELD OF 0.  NOTE
; THAT AN A FIELD OF 0 WILL STILL PROVIDE A 30 BIT ADDRESS TO THE VMA;
; ONLY THE RESULT IN THE AD WILL BE DIFFERENT.
;	IF THE A FIELD CONTAINS 3, THE MBOX PERFORMS A PAGING CHECK ON
; EA, AND CAUSES A PAGE FAIL IF THAT LOCATION IS NOT WRITABLE.
; THE MICROCODE GOES TO 3 TO WAIT FOR COMPLETION OF THE PAGE CHECK,
; AND AT THAT LOCATION LOADS AC INTO AR.  THE WRITABILITY OF EA IS
; VERIFIED AT THIS TIME TO PREVENT INCORRECTLY SETTING FLAGS OR
; THE PROCESSOR STATE IF THE INSTRUCTION WILL BE ABORTED BY PAGE
; FAILURE.  LOCATION 3 THEN DISPATCHES TO THE HANDLER FOR THE
; CURRENT INSTRUCTION.
;	A FIELD VALUES 4 TO 7 PERFORM READS FROM EA.  6 AND 7 ALSO TEST
; THE WRITABILITY OF THE LOCATION, AND 7 PERFORMS THE FIRST HALF OF
; A READ-PAUSE-WRITE CYCLE IF EA IS AN UN-CACHED ADDRESS.  THE DISPATCH
; IS TO A, WHERE WE WAIT FOR MEMORY DATA TO ARRIVE IN AR.  IF THE A
; FIELD WAS 5, WE PREFETCH FROM PC+1 AS SOON AS THE DATA ARRIVES.
; IN ANY CASE, WE DISPATCH ACCORDING TO THE DRAM J FIELD TO THE
; HANDLER FOR THE INSTRUCTION.
;	IF A PAGE FAIL OCCURS AT ANY TIME (EITHER IN THIS CODE OR DURING
; INSTRUCTION EXECUTION) THE MICROPROCESSOR TRAPS TO CRAM LOCATION
; 1777 OR 3777, WHERE IT CAUSES A PAGE FAIL TRAP.
;
;	MOST INSTRUCTIONS (THE MOVE, HALFWORD, AND BOOLEAN GROUPS,
; PLUS ADD AND SUB) ARE PERFORMED BY HANDLERS CONSISTING OF ONE OR
; TWO MICROINSTRUCTIONS WHICH LEAVE THE RESULT IN AR, AND COMPLETE
; BY INVOKING THE "EXIT" MACRO.  EXIT USES THE MEM/B WRITE FUNCTION
; TO BEGIN A STORE TO MEMORY FOR THOSE MODES IN WHICH THE RESULT
; GOES TO MEMORY, AND DISP/DRAM B TO GET TO ONE OF THE MICROINSTRUCTIONS
; FOLLOWING ST0.  THIS CODE DEPENDS ON A CERTAIN AMOUNT OF CORRELATION
; BETWEEN THE DRAM A AND B FIELDS.  IN PARTICULAR, STAC (STORE AC)
; ASSUMES THAT A PREFETCH HAS OCCURRED, WHILE THE OTHERS ASSUME THAT
; NO PREFETCH HAS OCCURED.  THUS NORMAL AND IMMEDIATE MODES, WHOSE
; RESULTS GO ONLY TO AC, MUST PREFETCH IN THE DRAM A FIELD, WHILE
; MEM, BOTH, AND SELF MODES, WHOSE RESULTS GO TO MEMORY, MUST NOT.
; (THIS RESTRICTION IS AVOIDED FOR THOSE INSTRUCTIONS WHICH NEVER
; PREFETCH -- IN MUL, DIV, AND IDIV BY USE OF THE EXIT TO ST2AC,
; AND IN IMUL AND THE SINGLE PRECISION FLOATING POINT
; INSTRUCTIONS BY A RESTRICTED EXIT TO ST6.)
;	ANOTHER LARGE SET OF INSTRUCTIONS (SKIP, AOS, SOS, JUMP, AOJ,
; SOJ, AOBJ, CAI, CAM, AND THE TEST GROUP) KNOWS WHERE TO PUT THE
; RESULTS WITHOUT MODE INFORMATION, AND THEY USE THE DRAM B FIELD TO
; DETERMINE WHETHER TO SKIP OR JUMP, AS A FUNCTION OF THEIR OPERANDS.
; SKIP, AOS, AND SOS ARE CONSIDERED SELF-MODE INSTRUCTIONS,
; AND AFTER MAKING THE FETCH DECISION (AND RE-WRITING MEMORY, IN
; THE CASE OF AOS OR SOS), JUMP TO STSELF TO DECIDE WHETHER OR NOT
; TO PUT THE RESULT ALSO IN AC.  THE OTHER INSTRUCTIONS OF THIS SET
; JUMP TO STORAC OR NOP AFTER MAKING THE FETCH DECISION, DEPENDING
; ON WHETHER OR NOT THE OPCODE DEFINITION REQUIRES MODIFICATION OF AC.
; (NOTE THE DIFFERENCE BETWEEN STAC AND FINI ON THE ONE HAND,
; AND STORAC AND NOP ON THE OTHER -- STORAC AND NOP MUST BE USED WHEN
; THE NEXT INSTRUCTION FETCH OCCURS ON THE PRECEDING EBOX CYCLE, BECAUSE
; NICOND MUST NOT IMMEDIATELY FOLLOW A FETCH (ONE CYCLE REQUIRED FOR
; VMA AC REF TO MAKE IT THROUGH THE NICOND LOGIC), STAC AND FINI ARE
; USED WHEN THERE HAS BEEN AN INTERVENING CYCLE.)
;
.TOC	"NEXT INSTRUCTION DISPATCH"

;
; [321] DISP/NICOND (THE "NXT INSTR" MACRO) BRINGS US TO ONE OF THE
; LOCATIONS FOLLOWING "NEXT".  PC HAS BEEN UPDATED TO ADDRESS THE NEXT
; INSTRUCTION IN THE NORMAL FLOW, AND IF IT IS FROM MEMORY
; (AS OPPOSED TO AC'S), THE INSTRUCTION IS IN ARX AND IR.
;	THE NICOND DISPATCH IS PRIORITY ENCODED, AS FOLLOWS: (see CON2)
;(1)	IF PI CYCLE IS TRUE, GO TO NEXT FOR SECOND HALF
; OF STANDARD OR VECTOR INTERRUPT.
;(2)	IF THE RUN FLOP (CON RUN) IS OFF, GO TO NEXT+2, FROM WHICH THE
; MICROCODE WILL ENTER THE HALT LOOP TO WAIT FOR THE CONSOLE TO RESTART
; INSTRUCTION PROCESSING.
;(3)	IF THE METER HAS A REQUEST, GO TO NEXT+4 (MTRINT) TO SERVE IT.
;(4)	IF THE PI SYSTEM HAS A REQUEST READY, GO TO NEXT+6 (INTRPT)
; TO START A PI CYCLE.
;(5)	IF CON UCODE STATE 05 (TRACK EN) IS SET, GO TO NEXT+10 OR 11.
; Normally NEXT+10 will be used; if a trap flag was set by the previous
; instruction, however, NEXT+11 will be reached.  This is the only
; way the trap will ever be detected, so be cautious of ignoring it.
; THIS FLOP IS ENTIRELY UNDER CONTROL OF THE MICROCODE, AND IS ONLY
; USED FOR THE SPECIAL STATISTICS-GATHERING MICROCODE.
;(6)	IF THE LAST INSTRUCTION SET A TRAP FLAG, GO TO NEXT+13 OR +17,
; IT DOESN'T MATTER WHICH.  (NEXT+17 will be reached if VMA contains
; an AC address, probably irrelevant when a trap flag was set.)
;(7)	IF VMA CONTAINS AN AC ADDRESS, IMPLYING THAT THE NEXT
; INSTRUCTION IS TO COME OUT OF FAST MEMORY, GO TO NEXT+16 TO GET IT.
;(10)	--NORMAL CASE-- THE INSTRUCTION IS IN ARX, READY TO GO, GO
; TO NEXT+12 (XCTGO).
;
;	The NICOND dispatch yields the following:
;
;	+0	CON PI CYCLE
;	+2	-CON RUN (i.e. halt)
;	+4	CON MTR INT REQ (meter interrupt)
;	+6	CON INT REQ (interrupt)
;	+10	CON UCODE STATE 05 (tracks enable)
;	+11	CON UCODE STATE 05+TRAP REQ (tracks enable+trap)
;	+12	-VM AC REF (normal instruction)
;	+13	-VM AC REF+TRAP REQ (normal instruction+trap)
;	+16	-CON PI CYCLE (AC ref)
;	+17	-CON PI CYCLE+TRAP REQ (AC ref+trap)
;
;	Other offsets are never reached.
;
.BIN
;NICOND (NXT INSTR) DISPATCH BLOCK

=11*0000				;USE LOC'NS INACCESSIBLE TO DRAM
NEXT:	AR_MQ+1,VMA/AD,			;2ND PART OF INTERRUPT
		SET PI CYCLE,J/PICYC2	;CONTINUE WITH 41+2N
=0010	CLR AR,ARX_1S,SC_#,#/23.,	;HERE IF RUN FLOP OFF
		CALL,J/ROTS		;BUILD ADDR MASK
.IFNOT/EXTEXP				;[230]
.IFNOT/OWGBP				;[344]
	ADMSK,FM_AR,AR_AR+1,J/CHALT	;SAVE MASK, GO HALT
.IF/OWGBP				;[344]
	FM[ADMSK]_AR,AR_AR*2,J/EXMSK	;[230] AR HAS 77,,777776
.ENDIF/OWGBP				;[344]
.IF/EXTEXP				;[230]
	FM[ADMSK]_AR,AR_AR*2,J/EXMSK	;[230] AR HAS 77,,777776
.ENDIF/EXTEXP				;[230]
=0100
MTRINT:	CLR ACCOUNT EN,J/MTRREQ		;HERE IF METER REQUEST UP
	AR_EBUS,SC_#,#/2,J/PICYC1	;HERE IF TAKE INTRPT DOESNT FIND
=0110					; A METER REQUEST
INTRPT:	AR_EBUS,SC_#,#/2,J/PICYC1	;HERE IF INTERRUPT PENDING
;
;	[321] Even if statistics are enabled, traps should not be lost,
;	so override TRACKS and friends when TRAP is set.
;
.IF/TRACKS
=1000	AR_TRX+1,GEN CRY18,SKP CRY0,J/TRK1;STORE PC BEFORE EXECUTING INSTR
	VMA_420+TRAP,J/TRAPX		;[321] Don't lose traps!
.ENDIF/TRACKS
.IF/OP.CNT
=1000	SC_#,#/9.,SKP USER,J/OPCT1	;COUNT THIS INSTR
	VMA_420+TRAP,J/TRAPX		;[321] Don't lose traps!
.ENDIF/OP.CNT
.IF/OP.TIME
=1000	AR_2,CLR TRK+PA EN,J/OPTM0	;TIME THIS INSTR
	VMA_420+TRAP,J/TRAPX		;[321] Don't lose traps!
.ENDIF/OP.TIME
.IF/SO.CNT
=1000
TRK0:	ARX_TRB,BRX/ARX,SKP AC REF,J/TRK1;GET PREV INSTR HOLD THIS INSTR
	VMA_420+TRAP,J/TRAPX		;[321] Don't lose traps!
.ENDIF/SO.CNT
.IF/SO2.CNT
=1000
TRK0:	ARX_TRB,BRX/ARX,SKP AC REF,J/TRK1;GET PREV INSTR HOLD THIS INSTR
	VMA_420+TRAP,J/TRAPX		;[321] Don't lose traps!
.ENDIF/SO2.CNT
=1010
XCTGO:	BRX/ARX,AR_ARX,SET ACCOUNT EN,	;SAVE INSTR, SIGN EXTEND Y,
	    CLR SC,XR,EA MOD DISP,J/COMPEA;[414] GO CALCULATE EA
TRAP:	VMA_420+TRAP,J/TRAPX		;HERE IF TRAP BITS SET
=1110	ARX_FM(VMA),TIME/3T,LOAD IR,J/XCTGO	;HERE IF INSTR IS IN FM
	VMA_420+TRAP,J/TRAPX		;HERE IF TRAP BITS SET

;HERE ON TRAPS, VMA SETUP WITH 420+TRAP CODE
=11****
TRAPX:	LOAD ARX,PT REF			;GET AND XCT TRAP INSTR
=11****	ARX_1S,SET PC+1 INH		;[412] DON'T INCREMENT PC

;HERE AFTER FETCHING INSTR TO BE EXECUTED

=11****
XCTW:	ARX_MEM,LOAD IR,J/XCTGO		;GET INSTR TO XCT
;
;	Start of everything.  PC word is in AR.
;
0:
START:	SET FLAGS_AR,J/SETPC		;LOAD FLAGS, USE REST AS ADDR
1:					;MUST BE AT START+1
CONT:	VMA/PC,FETCH,J/XCTW		;CONTINUE FROM PC
.IF/EXTEXP				;[230]
EXMSK:	AR_AR+1				;[230] GIVES 77,,777777
	FM[EXPMSK]_AR,J/CHALT		;[230] MASK FOR FORTRAN EXT EXP
.IFNOT/EXTEXP				;[344]
.IF/OWGBP				;[344]
EXMSK:	AR_AR+1				;[230] GIVES 77,,777777
	FM[EXPMSK]_AR,J/CHALT		;[230] MASK FOR FORTRAN EXT EXP
.ENDIF/OWGBP				;[344]
.ENDIF/EXTEXP				;[230]
;
;	Rotate subroutine.
;
ROTS:	AR_SHIFT,ARX_SHIFT,SC_#-SC,#/36.,RETURN3
.TOC	"EFFECTIVE ADDRESS COMPUTATION AND OPERAND FETCH"

=11*0000
EFIW:	AR_ARX (AD),GLOBAL,A INDRCT,	;LONG EXTENDED ADDR
		SKP INTRPT,J/INDRCT	;WITH INDIRECT SET
	AR_ARX+XR,GLOBAL,A INDRCT,
		SKP INTRPT,J/INDRCT
	AR_ARX (AD),GLOBAL,A INDRCT,
		SKP INTRPT,J/INDRCT
	AR_ARX+XR,GLOBAL,A INDRCT,
		SKP INTRPT,J/INDRCT

	AR_ARX (AD),GLOBAL,A READ	;LONG EXTENDED ADDR
	AR_ARX+XR,GLOBAL,A READ		; WITH INDEXING IN 2-5
	AR_ARX (AD),GLOBAL,A READ
	AR_ARX+XR,GLOBAL,A READ

PF24:	GET ECL EBUS,J/PFPAR		;[414] ARX BITS 0,1 = 11
	GET ECL EBUS,J/PFPAR		;Illegal indirection
	GET ECL EBUS,J/PFPAR
	GET ECL EBUS,J/PFPAR

=11*1100
COMPEA:	GEN AR,A READ			;LOCAL
	GEN AR+XR,INDEXED,A READ	;LOCAL UNLESS XR>0
	GEN AR,A INDRCT,
		SKP INTRPT,J/INDRCT
	GEN AR+XR,INDEXED,A INDRCT,
		SKP INTRPT
=11***0
INDRCT:	ARX_MEM,LONG EN,J/INDR1
TAKINT:	ARX_MEM,TAKE INTRPT
;
=11****
INDR1:	AR_ARX,XR,EA MOD DISP,
		FE_#,#/24,TIME/3T,J/EFIW
.TOC	"WAIT FOR (E)"

;THE EXECUTE CODE FOR EACH INSTRUCTION IS ENTERED WITH
; THE OPCODE AND AC # IN BRX AND IR, THE LAST INDIRECT WORD
; IN ARX, AND AR AND VMA SETUP AS A FUNCTION OF THE A
; FIELD OF THE DISPATCH RAM. A PREFETCH IS IN PROGRESS IF THE
; DRAM A FIELD WAS 1 OR 5 (OR IF IR CONTAINS "JRST 0,").

;ON "A READ", THE HARDWARE DISPATCHES TO THE EXECUTE CODE FOR
; THE INSTRUCTION IF THE DRAM A FIELD IS 0-2.  IF THE A FIELD
; CONTAINS 3-7, THE HARDWARE DISPATCHES TO A (MODEL B), OR 40+A
; (MODEL A), BELOW:

;COME HERE ON "A READ" FUNCTION IF DRAM A FIELD IS 3 (W macro)
; A "WRITE TST" IS IN PROGRESS

3:	BR/AR,AR_AC0,MB WAIT,		;WAIT FOR PERMISSION TO WRITE
		TIME/3T,IR DISP,J/0	;AND GO TO EXECUTE CODE

;HERE ON "A READ" FUNCTION IF DRAM A FIELD IS 4 (R macro)
; A "LOAD AR" IS IN PROGRESS.  We load FE with 2 for LDB and DPB. [337]

4:	BR/AR,AR_MEM,TIME/3T,FE_#,#/2,	;GET OPERAND, set up FE for byte
		IR DISP,J/0		; instructions [337], and go

;HERE ON "A READ" IF A FIELD IS 5 (R-PF macro)
; A "LOAD AR" IS IN PROGRESS, AND WE MUST PREFETCH WHEN IT COMPLETES

5:	BR/AR,FIN XFER,I FETCH,		;GET OPERAND, PREFETCH,
		TIME/3T,IR DISP,J/0	; & START EXECUTE

;HERE ON "A READ" IF A FIELD IS 6 (RW macro)
; A "LOAD AR" IS IN PROGRESS, PAGING IS TESTING WRITABILITY
; We load FE with 2 for ILDB and IDPB. [337]

6:	BR/AR,AR_MEM,TIME/3T,FE_#,#/2,	;GET OPERAND, load FE for byte
		IR DISP,J/0		; instructions [337], and go

;HERE ON "A READ" IF A FIELD IS 7 (RPW macro)
; A "READ-PAUSE-WRITE" IS IN PROGRESS

7:	BR/AR,AR_MEM,TIME/3T,		;GET OPERAND
		IR DISP,J/0		; START EXECUTE
.TOC	"TERMINATION"

;DISPATCH HERE WITH THE "EXIT" MACRO,
; OR JUMP DIRECTLY TO ONE OF THESE LOCATIONS.

=0****00*000				;[430]
ST0:					;BASE FOR B DISP IN EXIT MACRO
=001
ST2AC:	MQ_AR,AR_SIGN,I FETCH,J/DSHIFT	;[430] HERE TO STORE AC0 & AC1
	FIN STORE,MQ_AR,AR_SIGN,	;[430] MULB, DIVB, etc. Wait for
	    I FETCH,J/DSHIFT		; mem, gen low sign bit, and store
SLFEND:	FIN STORE,I FETCH,		;[440] SELF MODE
		SKP AC#0,J/STSELF	; RESULT TO AC TOO?
SHFLOD:	AR_SHIFT			;[337] Shift byte load result
STAC:	AC0_AR,NXT INSTR		;NORMAL AND IMMEDIATE MODES
ST6:
IFNOP:
STMEM:	FIN STORE,I FETCH,J/NOP		;MEM MODE
IFSTAC:
STBOTH:	FIN STORE,I FETCH,J/STORAC	;BOTH mode
=
;
;HERE TO FINISH, AFTER FETCHING NEXT INSTRUCTION.
; WE MUST GUARANTEE AT LEAST ONE EBOX CYCLE BETWEEN FETCH AND NICOND,
; TO ALLOW VMA AC REF TO MAKE IT THROUGH THE NICOND LOGIC.
; Most noops come here directly. [412]
216:					;[440]
STSELF:					;SKIP, AOS, SOS COME HERE
STORAC:	SR_0,J/STAC			;STORE AC, TOO
217:					;[440] TRN, CAI, etc. get here  
NOP:	SR_0				;Must be near CAIx instructions
FINI:	NXT INSTR			;Load IR and PC, test PI cycle, RUN,
					; PI READY, TRAPS
;
;	Store AC1 and finish up.
;
STD1:	AR_SHIFT,SR_0			;BRING IN LOW PART
;
;	[356] The next two locations are fixed at 136 and 137.  We don't
;	really care where they are, but the front end looks at the # field
;	of these to get the microcode major version (# bits 0-5 of 136),
;	minor version (# bits 6-8 of 136), and edit number (# bits 0-8 of
;	137).
;
136:					;[357]
STAC1:	AC1_AR,FINISH,			;GO DO NEXT INSTRUCTION
		MAJVER/MAJOR,MINVER/MINOR;[356]
;
;HERE TO GET MICRO-CODE VERSION #.  FIXED LOC'N SO SOFTWARE CAN FIND IT
;
137:
UVERS:	BR/AR,AR0-8_#,#/EDIT,J/GTAR08	;COPY VERSION TO AR
.TOC	"MOVE GROUP, EXCH, XMOVEI, XHLLI"

	.DCODE
200:	R-PF,	AC,	J/MOVE		;MOVE
	I-PF,	AC,	J/MOVE		;MOVEI
	I,	B/1,	J/MOVEM		;MOVEM--no write test needed
	RW,		J/MOVES		;MOVES [440]

204:	R-PF,	AC,	J/MOVS		;MOVS
	I-PF,	AC,	J/MOVS		;MOVSI
	W,	M,	J/MOVS		;MOVSM
	RPW,	S,	J/MOVS		;MOVSS

210:	R-PF,	AC,	J/MOVN		;MOVN
	I-PF,	AC,	J/MOVN		;MOVNI
	W,	M,	J/MOVN		;MOVNM
	RPW,	S,	J/MOVN		;MOVNS

214:	R-PF,	AC,	J/MOVM		;MOVM
	I-PF,	AC,	J/HRRZ		;MOVMI <==> HRRZI <==> MOVEI
	W,	M,	J/MOVM		;MOVMM
	RPW,	S,	J/MOVM		;MOVMS

250:	RPW,	B/0,	J/EXCH		;EXCH--adjoins BLT
	.UCODE

=0****00****
MOVS:	AR_AR SWAP,EXIT			;ALSO USED BY HALFWORD GROUP
=
202:					;Must be near HRRZ
MOVM:	BR/AR,SKP AR0,J/MOVE		;FORCE POSITIVE
;
=0****00****
MOVN:	BR/AR,J/MOVNEG			;GET NEGATIVE
=
100:
MOVE:	EXIT				;STORE AS IS FROM AR
101:
MOVNEG:	AR_-BR,AD FLAGS,EXIT		;[412] Negate before storing
313:					;[440] Near SKIP, MOVEM
MOVES:	I FETCH,SKP AC#0,J/STSELF	;Like MOVE if AC not 0
314:					;[440] Near BLT, SKIP, MOVES
MOVEM:					;LIKE EXCH, EXCEPT NO STORE AC
EXCH:	ARX_AR,AR_AC0,STORE,J/STMAC	;PUT AC AT E, THEN STORE AC
;
102:					;Near SETM (MOVE)
XMOVEI:	SKP -LOCAL AC ADDR,I FETCH	;30 bit version of MOVEI
=0
XMOVEI1:ARL_1.M,ARR_ARR,J/STAC		;AC IN NON-ZERO SECTION
	CLR P,J/STAC			;RETURN 30-BIT ADDRESS
317:					;[440] Near HLL
XHLLI:	SKP -LOCAL AC ADDR,I FETCH,
		ARR_AC0.S,ARL_ARL.S,J/XMOVEI1
.TOC	"Physical MOVE Instructions--PMOVE, PMOVEM"
;
;	PMOVE and PMOVEM were added to the architecture as something of an
;	afterthought (as their opcodes may suggest) primarily to improve
;	the monitor performance of certain I/O devices which require
;	manipulation of data structures in physical memory.  Note that
;	the effective address of the instruction CONTAINS the physical
;	address to move from or to, somewhat akin to XJRST.  This extra
;	level of indirection is necessary to make section zero physical
;	addresses easily accessible from a non zero section and vice versa.
;	(Without this mechanism, the EA calculation logic would consider
;	addresses in section zero to be local, and would insert the current
;	section into the VMA.)
;

	.DCODE
052:	R,	B/0,	J/PMOVE		;PMOVE (Was reserved to DEC)
	R,	B/2,	J/PMOVEM	;PMOVEM (Ditto)
	.UCODE

=0****00****
PMOVE:					;Share the code with PMOVEM
PMOVEM:	VMA_AR,SKP IO LEGAL,B DISP	;Set VMA for PMOVEM. OK to do?
=
=00	AR_BR,J/UUO			;Illegal to do a PMOVE
	VMA_AR,LOAD AR,PHYS REF,J/STBOTH;PMOVE OK. Do a physical load
	AR_BR,J/UUO			;Illegal to do a PMOVEM
	AR_AC0,STORE,PHYS REF,J/STMEM	;PMOVEM OK. Do the physical store
.TOC	"DMOVE, DMOVN, DMOVEM, DMOVNM"

;	Double word moves to ACs.

	.DCODE
120:	I,	B/0,	J/DMOVE		;DMOVE [413]
	I,	B/1,	J/DMOVN		;DMOVN [413]
	.UCODE

=0****00****
DMOVN:
DMOVE:	VMA_VMA+1,LOAD AR		;PICK UP (E+1)
=
TWJUNK:	FIN LOAD,VMA_VMA-1,LOAD ARX,	;And (E)--redundant if from ADJBP
	    B DISP			;Split DMOVE from DMOVN
=100	FIN LOAD,I FETCH,J/DLOAD	;DMOVE. Start I FETCH and load
	ARX_MEM,MQ_0.S,CALL [DNSUB]	;DMOVN. Do the negation
=111	AR_SHIFT,ARX/MQ,GEN -BR LONG,	;Force 0 into AC1 high bit
	    AD FLAGS,I FETCH		; and set carry/overflow flags
DLOAD:	AC1_AR,AR_ARX,J/STAC		;Now load AC1, then AC0
;
;	DNSUB--Subroutine to swallow the high bit of the low order word of
;	a double pair, copy both words to BR/BRX, negate the pair and store
;	the high order word (if DMOVNM), and set up to zero the high bit of
;	the low order word.  Return 2.
;
DNSUB:	ARX_AR*2,AR_ARX,SC_#,#/35.	;Eat low order bit 0, set count
	BR_AR LONG,AR_-AR LONG,B STORE	;Negate, store if DMOVNM
	MEM_AR,MQ_AR,AR_0S,RETURN [2]	;Set up for shift, keep AC0

;	DOUBLE MOVES TO MEMORY

	.DCODE
124:	I,		J/DMOVEM	;DMOVEM [413]
	W,	B/2,	J/DMOVNM	;DMOVNM
	.UCODE

=0****00**00
DMOVEM:	AR_AC0,STORE,SC_#,#/36.,J/GETAC1;Store AC0 and set for later grab
;
DMOVNM:	MQ_0.S,AR_AC1,ARL/AD,ARX_AR,	;[421] Get second word, do
	    CALL [DNSUB]		; negation, and store high word
=11	GEN -BR LONG,AD FLAGS,J/STLOW	;Set carry/overflow flags
=
;
GETAC1:	ARX_AC1				;For DMOVEM, ready second word
STLOW:	FIN STORE,VMA_VMA+1,AR_SHIFT,	;Store, then done
	    STORE,J/STMEM
;
;	Come in here from meter code (DMVM1) and floating point (DBLST).
;	These are hacks which should be killed, if possible.
;
DMVM1:	MEM_AR,AR_0S,J/STLOW		;Set up to zero AC1 high bit
;
DBLST:	AC0_AR,AR_0S,I FETCH,J/STD1	;Store high word, ready low
.TOC	"HALFWORD GROUP"
;	DESTINATION LEFT HALF

	.DCODE
500:	R-PF,	AC,	J/HLL		;HLL
	EA,	AC,	J/XHLLI		;XHLLI--Use 30 bit address
	RPW,	M,	J/HRR		;HLLM = HRR EXCEPT FOR STORE
	RW,		J/MOVES		;HLLS <==> MOVES [440]

	R-PF,	AC,	J/HRL		;HRL
	I-PF,	AC,	J/HRL		;HRLI
	RPW,	M,	J/HRLM		;HRLM
	RPW,	S,	J/HRLS		;HRLS

510:	R-PF,	AC,	J/HLLZ		;HLLZ
	I-PF,	AC,	J/HLLZ		;HLLZI <==> SETZ
	W,	M,	J/HLLZ		;HLLZM
	RPW,	S,	J/HLLZ		;HLLZS

	R-PF,	AC,	J/HRLZ		;HRLZ
	I-PF,	AC,	J/HRLZ		;HRLZI <==> MOVSI
	W,	M,	J/HRLZ		;HRLZM
	RPW,	S,	J/HRLZ		;HRLZS

520:	R-PF,	AC,	J/HLLO		;HLLO
	I-PF,	AC,	J/HLLO		;HLLOI
	W,	M,	J/HLLO		;HLLOM
	RPW,	S,	J/HLLO		;HLLOS

	R-PF,	AC,	J/HRLO		;HRLO
	I-PF,	AC,	J/HRLO		;HRLOI
	W,	M,	J/HRLO		;HRLOM
	RPW,	S,	J/HRLO		;HRLOS

530:	R-PF,	AC,	J/HLLE		;HLLE
	I-PF,	AC,	J/SETZ		;HLLEI <==> SETZ [412]
	W,	M,	J/HLLE		;HLLEM
	RPW,	S,	J/HLLE		;HLLES

	R-PF,	AC,	J/HRLE		;HRLE
	I-PF,	AC,	J/HRLE		;HRLEI
	W,	M,	J/HRLE		;HRLEM
	RPW,	S,	J/HRLE		;HRLES
;	DESTINATION RIGHT HALF

540:	R-PF,	AC,	J/HRR		;HRR
	I-PF,	AC,	J/HRR		;HRRI
	RPW,	M,	J/HLL		;HRRM = HLL EXCEPT FOR STORE
	RW,		J/MOVES		;HRRS <==> MOVES [440]

	R-PF,	AC,	J/HLR		;HLR
	I-PF,	AC,	J/HLR		;HLRI
	RPW,	M,	J/HLRM		;HLRM
	RPW,	S,	J/HLRS		;HLRS

550:	R-PF,	AC,	J/HRRZ		;HRRZ
	I-PF,	AC,	J/HRRZ		;HRRZI <==> MOVEI
	I,		J/HRRZM		;HRRZM [442]
	RPW,	S,	J/HRRZ		;HRRZS

	R-PF,	AC,	J/HLRZ		;HLRZ
	I-PF,	AC,	J/HLRZ		;HLRZI <==> SETZ
	W,	M,	J/HLRZ		;HLRZM
	RPW,	S,	J/HLRZ		;HLRZS

560:	R-PF,	AC,	J/HRRO		;HRRO
	I-PF,	AC,	J/HRRO		;HRROI
	W,	M,	J/HRRO		;HRROM
	RPW,	S,	J/HRRO		;HRROS

	R-PF,	AC,	J/HLRO		;HLRO
	I-PF,	AC,	J/HLRO		;HLROI
	W,	M,	J/HLRO		;HLROM
	RPW,	S,	J/HLRO		;HLROS

570:	R-PF,	AC,	J/HRRE		;HRRE
	I-PF,	AC,	J/HRRE		;HRREI
	W,	M,	J/HRRE		;HRREM
	RPW,	S,	J/HRRE		;HRRES

	R-PF,	AC,	J/HLRE		;HLRE
	I-PF,	AC,	J/SETZ		;HLREI <==> SETZ [412]
	W,	M,	J/HLRE		;HLREM
	RPW,	S,	J/HLRE		;HLRES

	.UCODE
;FIRST, THE 16 OPS WHICH DO NOT AFFECT THE "OTHER" HALF.
;THESE MUST BE TREATED SEPARATELY, BECAUSE THEY COMBINE MEMORY DATA
;IN AR WITH DATA FROM THE FM.  ENTER WITH 0,E OR (E) IN AR.

315:					;[440] Near MOVES (for HLLS)
HRR:	ARL_AC0,ARR_ARR,EXIT		;HRR, HRRI, HLLM
316:					;[440] Near XHLLI, MOVES (for HRRS)
HLL:	ARR_AC0,ARL_ARL,EXIT		;HLL, HRRM
			;HRRS, HLLS ARE BOTH EQUIVALENT TO MOVES
=0****00****
HRL:	ARL_ARR,ARR_AC0,EXIT		;HRL, HRLI
=
=0****00****
HLR:	ARR_ARL,ARL_AC0,EXIT		;HLR, HLRI
=
=0****00***0
HRLM:	ARL_ARR,ARR_AC0,J/MOVS		;HRLM
HRLS:	ARL_ARR,ARR_ARR,EXIT		;HRLS
=
=0****00***0
HLRM:	ARR_ARL,ARL_AC0,J/MOVS		;HLRM
HLRS:	ARR_ARL,ARL_ARL,EXIT		;HLRS
=
;NOW THE HALFWORD OPS WHICH CONTROL THE "OTHER" HALF
; ENTER WITH 0,E, (E), OR (AC) IN AR

=0****00****
HRRE:	SKP AR18			;SELECT HRRZ OR HRRO ON SIGN
=
200:					;Must be near MOVMI, HRRZM
HRRZ:	ARL_0S,ARR_ARR,EXIT
201:
HRRO:	ARL_1S,ARR_ARR,EXIT
203:					;[442] Near HRRZ
HRRZM:	ARL_0S,ARR_AC0,STORE,J/STMEM	;[442] No need for write test
;
=0****00****
HRLE:	SKP AR18
=
=0****00***0
HRLZ:	ARL_ARR,ARR_0S,EXIT
HRLO:	ARL_ARR,ARR_1S,EXIT
=
702:					;Must be near SETZ
HLRE:	SKP AR0
=0****00***0
HLRZ:	ARR_ARL,ARL_0S,EXIT
HLRO:	ARR_ARL,ARL_1S,EXIT
=
703:					;Must be near SETZ
HLLE:	SKP AR0
704:					;Must be near HLRE and HLLE
SETZ:					;[421] ARL already 0 for SETZ
HLLZ:	ARR_0S,ARL_ARL,EXIT
705:					;Must follow HLLZ
HLLO:	ARR_1S,ARL_ARL,EXIT.TOC	"BOOLEAN GROUP"
	.DCODE
400:	I-PF,	AC,	J/SETZ		;SETZ <==> HLLZI--use that code
	I-PF,	AC,	J/SETZ		;SETZI <==> SETZ
	I,	M,	J/SETZ		;SETZM [421]
	I,	B,	J/SETZ		;SETZB [421]

404:	R-PF,	AC,	J/AND		;AND
	I-PF,	AC,	J/AND		;ANDI
	RPW,	M,	J/AND		;ANDM
	RPW,	B,	J/AND		;ANDB
	.UCODE

=0****00****
AND:	AR_AR*AC0,AD/AND,EXIT
=
	.DCODE
410:	R-PF,	AC,	J/ANDCA		;ANDCA
	I-PF,	AC,	J/ANDCA		;ANDCAI
	RPW,	M,	J/ANDCA		;ANDCAM
	RPW,	B,	J/ANDCA		;ANDCAB
	.UCODE

=0****00****
ANDCA:	AR_AR*AC0,AD/ANDCB,EXIT
=
	.DCODE
414:	R-PF,	AC,	J/MOVE		;SETM <==> MOVE
	EA,	AC,	J/XMOVEI	;XMOVEI (SETMI)--Use 30 bit EA
	W,		J/IFNOP		;[430] SETMM = NOP+memory write
	RW,		J/IFSTAC	;[430] SETMB = MOVE+memory write

420:	R-PF,	AC,	J/ANDCM		;ANDCM
	I-PF,	AC,	J/ANDCM		;ANDCMI
	RPW,	M,	J/ANDCM		;ANDCMM
	RPW,	B,	J/ANDCM		;ANDCMB
	.UCODE

110:					;Must be near TLX
ANDCM:	AR_AR*AC0,AD/ANDCA,EXIT

	.DCODE
424:	I-PF,		J/NOP		;SETA <==> TRN (NOP) [413]
	I-PF,		J/NOP		;SETAI <==> TRN
	I,	B/1,	J/MOVEM		;SETAM <==> MOVEM [412]
	I,	B/1,	J/MOVEM		;SETAB <==> MOVEM [412]

430:	R-PF,	AC,	J/XOR		;XOR
	I-PF,	AC,	J/XOR		;XORI
	RPW,	M,	J/XOR		;XORM
	RPW,	B,	J/XOR		;XORB
	.UCODE

111:					;Must be near TLX
XOR:	AR_AR*AC0,AD/XOR,EXIT
	.DCODE
434:	R-PF,	AC,	J/IOR		;OR
	I-PF,	AC,	J/IOR		;ORI
	RPW,	M,	J/IOR		;ORM
	RPW,	B,	J/IOR		;ORB
	.UCODE

112:					;Must be near TLX
IOR:	AR_AR*AC0,AD/OR,EXIT

	.DCODE
440:	R-PF,	AC,	J/ANDCB		;ANDCB
	I-PF,	AC,	J/ANDCB		;ANDCBI
	RPW,	M,	J/ANDCB		;ANDCBM
	RPW,	B,	J/ANDCB		;ANDCBB
	.UCODE

=0****00****
ANDCB:	AR_AR*AC0,AD/ANDC,EXIT		;NOR function
=
	.DCODE
444:	R-PF,	AC,	J/EQV		;EQV
	I-PF,	AC,	J/EQV		;EQVI
	RPW,	M,	J/EQV		;EQVM
	RPW,	B,	J/EQV		;EQVB
	.UCODE

=0****00****
EQV:	AR_AR*AC0,AD/EQV,EXIT
=
	.DCODE
450:	I-PF,	AC,	J/SETCA		;SETCA
	I-PF,	AC,	J/SETCA		;SETCAI <==> SETCA
	I,	M,	J/SETCA		;SETCAM
	I,	B,	J/SETCA		;SETCAB
	.UCODE

=0****00****
SETCA:	AR_AC0 COMP,EXIT		;[442]
=
	.DCODE
454:	R-PF,	AC,	J/ORCA		;ORCA
	I-PF,	AC,	J/ORCA		;ORCAI
	RPW,	M,	J/ORCA		;ORCAM
	RPW,	B,	J/ORCA		;ORCAB
	.UCODE

=0****00****
ORCA:	AR_AR*AC0,AD/ORCB,EXIT
=
	.DCODE
460:	R-PF,	AC,	J/SETCM		;SETCM
	I-PF,	AC,	J/SETCM		;SETCMI
	RPW,	M,	J/SETCM		;SETCMM
	RPW,	B,	J/SETCM		;SETCMB
	.UCODE

=0****00****
SETCM:	ADA/AR,AD/SETCA,AR/AD,EXIT
=
	.DCODE
464:	R-PF,	AC,	J/ORCM		;ORCM
	I-PF,	AC,	J/ORCM		;ORCMI
	RPW,	M,	J/ORCM		;ORCMM
	RPW,	B,	J/ORCM		;ORCMB
	.UCODE

=0****00****
ORCM:	AR_AR*AC0,AD/ORCA,EXIT
=
	.DCODE
470:	R-PF,	AC,	J/ORCB		;ORCB
	I-PF,	AC,	J/ORCB		;ORCBI
	RPW,	M,	J/ORCB		;ORCBM
	RPW,	B,	J/ORCB		;ORCBB
	.UCODE

=0****00****
ORCB:	AR_AR*AC0,AD/ORC,EXIT		;NAND function
=
	.DCODE
474:	I-PF,	AC,	J/SETO		;SETO
	I-PF,	AC,	J/SETO		;SETOI <==> SETO
	I,	M,	J/SETO		;SETOM
	I,	B,	J/SETO		;SETOB
	.UCODE

=0****00****
SETO:	AR_1S,EXIT
=
