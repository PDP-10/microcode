.TOC	"THE INSTRUCTION LOOP"

;INSTRUCTION DECODE, EA COMPUTATION, AND OPERAND FETCH
;	IN GENERAL, AN INSTRUCTION IS STARTED AT XCTGOõÃE;AAT THù4ÐT“ù±PT‘E INSTRUCTION Iúh$ÎAø4¬ ƒND IR, AND PC Hø4ÐI©S ADDúQiÓ]
; THE DRAM OUú”*Ô§ AND ôPa¢AøRjSAWILL SETTLE DURù3£ ©ùi; MICúSäÎ§TRUCTION, AND Wù3& …ø¨&A©ør"ÄABY THE CLOCK WHICH ENDS
; THEôìÃ™E.  XCTGO DISPAúäE§ôç ©ùPS©ATE OF THE
; INDIRECT AND INDø¶B“TS OFô$EAARX (EA MOD DISP) TOôçÍ¡ø°PO¥
; ONE OFô$EAú’)E‹ô'ÃƒTIONS FOLLùõäÎôj.;	IF INDIRECT IS SPECIFIø± ©HE INDIRECT POINTER ù4ÐF‹TCHED (ATîñNÐCŸù´"ÁW2 OR +3 DEúgD“NG ONôäE©HER IùÑ"Ø“ùÑÐI§ ALSO SPECIFIED).
;ôâ ¯AIT FùôI©ôj “ùÑ)C©, AND THEN LOOP BACKô' ‡OMPEA.  WHEN NO
; INDIRECT ISôàÌ™ø±FŸR, WE COMPUTE THE INSTRUCTION'úh"ÆECTIVE ADDúQiÓ; (EA) ATôçÍ¡EA OR COMPø°U±A(DEPEùÑ$Îôç ¯ùjH‹úH$Î‰ø¶$Îôi ‡ALLED
; Fùô”¬AAND Pø´£O¥M THEôªÎ‡TION ôPPR‹AD", úò'Ó‹ OPERATION DEPEùÑ); ON ú’" ‰RAM A FIELD, ASô§Ì™ùõéº;
; MACRùâPA[FLD	MEM FUùÐêIŸN	VMA	DISPø5!È;  I	  0	NONE		AD(=EA)  ø” ÍAJ
; I-PF	ô‰ETCH		PC+1	 DRAM J
;	  2ñ3§Î‹		AD	   42
;  W	  3	WR TST		Aø‚P AöŒÆŠw  R	  4	READ		Aø‚P AöŠwô–Ð	  5	READ		AD	   45
; RW	  6	úQ`Ä_WR TSú‚`Äô4mñ¢ ¥PW	  öâiD[úâ¯¯úH*S©ñ0b	Aô7;
;ñ0PF“ELD VALUESôAD 1 AúQPU§ø±FŸR INSTRUCTIONS úò$Ã‘ô¢É©ùi; READ NOR WRITE THE CONTENTS OF EAô
$Í›EDIATE-MODø¨$Î§TRUCTIONS,ñ¢ •UMPS, ETC).  THESE DISPATørF¥OM "A READôH"I¥ECTLY TO THE MICROCOø‘FŠwôäI‡H HANDLES THE IùÔêR«øu$Ï.  IFô$EAA FIEù‘CŸNTAINS 1, ôPPR‹ø1; CAUSES A PREFETCH (FROM PC+1), SOô$A© THE MBOX øpg ¯ORK ON GETTINGîñNÐT‘ø¨'E±úˆ$Î§ú”ªÃ©ION INTO ARX WHù3" ©ùPE…OX PERFORMúh*H“S ONEõÃE;IF THE A FIELD CONTAINS 3õˆ*H‹ MBOXô"Òùô¦ÓAA PAGù3£ ‡HECK ùó†Šw EA, AND Cø5iÅ§ôPPƒøñPFƒIL IF THATô'ÃƒTION IS NOúˆ+Ò“TABLE.
; THE Mù0éO‡ùñ" ùñi ©O 43 ú“ÐWƒIT FOR COMú"Ô“ON OF THE PAGE CHECK,
; AND Aúˆ*HƒT LOCATION LOADS AC INTO AR.  ú’" ¯RITABù3$Ô³ôã ‹A ISîñNÐV‹RIFIED AT THIS ú’fÅAú“ÐP¥EVENTôgCŸRRECTLY SEú•$Î FLAGS OR
; THE PROCESSOR STATE IF THE INSTRUCTION WILL BE ø0§Ò©ED BY PAGEñ¢ ø2fU¥ø« ™OCATION 43ô$Eô$Ó¡ø5!È‹S TO THE HANDLER FOR THEîñNÐC«úT¢Î©ôgS©RUCTIùó—;	A FIELD VALUEúh ©O 7 PERFORù¨)Eƒø”ÐF¥ùóPEƒ.  6 AND 7 ALSO TESTñ¢ ©HE WRù5 Â“LITY OF THE LOCATIONõˆ Î‰ 7 PEúQ§Ò›úh*H‹ô¤Ò§úˆ$A™F OFîñNÐAAúQ`Ä[PAUSE-WRITE CYCLE IFô` “S AN ú³–ÃƒCHED ø1"R‹SS.  ú’" ‰ù4èA©ørŠw IS Tùè0WA, WHø´¢ ¯E WAIúˆ#O¥ôbÍŸúVPDƒTA TOôiR“VE IN AR.  IF THE AîñNÐF“ELD WAS 5, WE PREFETørF¥OM PC+1 AS SOON AS TùPDƒTA ARúRkE§.
; IN ANY CASE, WE DISPATCH ACCORø’gGATO THE DRAù¨% IELD ú“ÐT‘ø£E;AHANDLER FOúH*H‹ INSTRUCTION.
;	IF A PAGE FAIùˆ'Ã‡URS AT ANY TIMEô
"É©ùi “N THIS CODE OR DURINøãE;Aù3©Ô¥ú°êIŸùÈ"Ø‹øujIŸùÊPT‘E MICROPROøqiÓŸúH*RƒúÐTŸ CRAMô'Ãƒú’gÎ; 1777, WHERE IT CAUSES A PAGE FAIL TRAP.
;	MOST INSTRUCTù3çSA(THE MOVE, HALFúóéDY AND BOOLEAN GROUPS,
; Pù•i ƒø‘Aøˆ)Õ…) AREô"Òùô¦Å‰ô¬ ‘ANDLERS COùÔäÓ©ù3£ ŸF ONE OR
; TWO MICROINSTúUaÔ“ONS WHICH LEAVEô$EARESULT IN AR, AND COMPLETE
; BY INVOKING THEô¢Ø“úˆMƒøt§®A EXIT USESô$EAMEM/BôéI©E FUNøu$Ï
; TO BEGIN A STORE TO MEMORYô§ÒATHOSE MODEúh$ÎAWHICH THE RESULT
; GOES TO MEMORY, AND DISP/DRAM B TO GET TO ONEôã ©HE MICROINSTRUCTIONS
; FOLLOWING ST0.  THIS CODE DEPENDS ON A CERTAIN AMOUNT OF CORRELATIùó†Šw BETWø±g ©ùPD¥AM A AND B FIELø”× AIN PARTICULAR, úu ÃAõêO¥E AC)ñ¢ ƒSSUMES THAT A PREFETCH HAS OCCURREDõˆ+È“ù‘PT‘ø¨'Ô‘ø´© ƒSSUME THAT
; Nùè(R‹øÑjC‘ô ÓAOCCURED.  ú’*ÓANORMAùˆ Î‰ôfÍ‹ø’`Ô‹ MODES, WHOSE
; RESULTS GO ONù–PTŸ AC, MUST PREFEúä “N THE DRAM A FIELD, WHILE
; MEM, BOTH, ø3¢ §ELF MODES, WHOSE RESULTS GO TO MEMORY, Mú´ê ùõ; (THIS RESTRICú’gÎAIS AVOIDED FOR ú’'Ó‹ INSTRUCTIONS WHICH NEVER
; PúQcE©ør-[ IN Mú³ ‰ù5– ƒND IDù5B³ USE OF THE EXIT TO ST2ACõƒE;Aø3¢ “N IMUL AND THE SINGLø¨(R‹CISIOùÈ#LŸATINGô'ÉúƒE;AINSTRUCTIONS BY A RESTRICTED EXIT TO ST6.)
;ñ0gO©ùi ™ARGE úqj ŸøÈ$Î§ú”ªÃ©IONS õåÉ¡, AOSõˆ)Ï§õˆ%U›P, AOùKŠwôçÊY AOBJõˆ!Á“, CAMõˆ Î‰ô$EAú‘iÔAGROUPõ(%ÎŸWS WHø´¢ ©O PUTô$E; RESULTS WITHOUT MODE INFORMATION, ANDô$E³ USE THE DRAM Bô¤Å™D TO
; DETERMIùÑPW‘øµ$E¥ TO SKIP OR JUMP, AS A FUùÐêIŸN OF THEIR OPERANDS.ñ¢ §KIP, ø3é¬AAND SOS ARE CONSIDERED SEù‘–ÍŸø‘PISTRUCú’gÎ§,
; ø3¢ ƒFTER MAKING THE FETCH DECISIONô
 Î‰ RE-WRITING MEMùô¬¬AIN
; THE CASE OF AOS OR SOS), JUMP TO Sú”âÌ TO DECIDE WHETHER OR NOT
; Tùè(U©ô$EARESULúˆ Ì§O IN AC.  THE Oú’"ÒAINSTRú°êIŸNS OFô$I§ôâÔ; JUMP TO STORAC ORô§ÐAAFTER MAKING THE FETørD‹CISIOùËD‹PENDING
;ôç ¯HETHER OR NOT TùPO¡CODE ø‘cIITION REQUIRES ù³âIICATION OF AC.
; (Nùõ" ©HE DIøÑ¢Ò‹NCE BETWEEN STAC AND FINI ON THE ONø¨$AD,
;ôgDASTORAC ANDô§ÐAùóT‘ø¨'Ô‘ER -- STORø0ÐAøˆ'O¡ôjÓ©ô¢ «SED Wùg; THE NEXT INSTúUaÔ“ON FETCH OCCURSôç ©HE PRECEDING EBOX CYCLE, BECAUSE
; NICOùÑM«ST NOT IMMEDIATELY Fùó&O¯ A FETCH (ùó¢ ‡YCLE úQhÕ“RED FOR
; VMA AC REF TO MAKE ù5T‘úSêÇ‘ THE ùÒaÏD LOGIC), STAC ø3¢ INI ARE
;ôiÅ‰ WHENô$E¥E HAS BEEN AN IùÕ"Ò­ø³¤Î CYCLø«”.TOC	"NEXúˆ$Î§ú”ªÃ©ù3ç ‰ISPATørñ¢Ó©ART BY PUTú’gGAúÐWŸRD INôi,AJUMP HERE
0:
START:	SET FLAGS_AR,BR/AR,J/BRJMP	;ù“àÄAUP FLAGS
øsçTu	VMA/úÖF‹TCH,J/XCTWñ"]È‹úQPTŸ CONTù3ªÅAFROM úÆŠ;	DIútÎ“COND (THE "NXT INSTR" MACRO) BRINGS US TO ONE OF THE
; LOCATIONS FOLLùõäÎ "NEXT".  PC HAúh!E‹N UPDATED TO ADDRESSô$EAùÑlTñNÐISTRUCú’gÎAIN THø¨'O¥MAL Fù“ë¬AAND IøÈ$ÔAIS FRùóPM‹MORY
; (AS OPPOSED TO AC'S), THE INSTRUøu$Ï IS IN ARX AND IR.
;	THE NICOùÑD“SPATCH IS ú¤Ï¥ù5, ‹ùÐçÄ‹D, AS FOLLOWS:
; [FOR FULL DETAILS, SEE PRINT CONöWFŠw(1)	IøÈ(IACYCLEôi ©RUE, GO TO NEXT FOR SECONøˆ$A™F
; ùñS©ANDARD OR VECTOR INTERRUPT.
;õ”‰“F THE RUN øÓ'ÐA(CON úUg)AIS OFF, GO TO NEXT+2, FROM WHICH THø£E;Aù²aÒŸøsâEAWILL ENTER THE HALT LOOP ú“ÐWƒIT FOúH*H‹ CONSOLE TO RESTART
; INSTRUCTION ú§Ã‹útäÎõÃE;Q3)	IF THE METER HAS A REQUEST, GO TO NEXT+4 (MTRINT) TO SERVE IT.
;(4)	IF THE PI SYSTEM HAS A REQUEST READY, GO TO NEXT+6 (INTRPT)
; TO START A PI CYCLE.
;(5)	IF CON UCODE STATE 05 (TRACK EN) IS SET, GO TO NEXT+10 OR 11.
; THIS FLOP IS ENTIRELY UNDER CONTROL OF THE MICROCODE, AND IS ONLY
; USED FOR THE SPECIAL STATISTICS-GATHERING MICROCODE.
;(6)	IF THE LAST INSTRUCTION SET A TRAP FLAG, GO TO NEXT+13 OR +17,
; IT DOESN'T MATTER WHICH.
;(7)	IF VMA CONTAINS AN AC ADDRESS, IMPLYING THAT THE NEXT
; INSTRUCTION IS TO COME OUT OF FAST MEMORY, GO TO NEXT+16 TO GET IT.
;(10)	--NORMAL CASE-- THE INSTRUCTION IS IN ARX, READY TO GO, GO
; TO NEXT+12 (XCTGO).

=11*0000				;USE LOC'NS INACCESSIBLE TO DRAM
NEXT:	SET PI CYCLE,GEN FE,		;2ND PART OF INTERRUPT
		BYTE DISP,J/PICYC2	;SKIP IF VECTOR INT
=0010	AR_0S,SET HALTED,J/HALT1	;HERE IF RUN FLOP OFF
=0100
MTRINT:	CLR ACCOUNT EN,J/MTRREQ		;HERE IF METER REQUEST UP
	AR_EBUS,SC_#,#/2,J/PICYC1	;HERE IF TAKE INTRPT DOESNT FIND
=0110					; A METER REQUEST
INTRPT:	AR_EBUS,SC_#,#/2,J/PICYC1	;HERE IF INTERRUPT PENDING
.IF/TRACKS
=1000	AR_TRX+1,GEN CRY18,SKP CRY0,J/TRK1	;HERE TO STORE PC BEFORE
	AR_TRX+1,GEN CRY18,SKP CRY0,J/TRK1	; EXECUTING NEXT INSTR
.ENDIF/TRACKS
.IF/OP.CNT
=1000	SC_#,#/9.,SKP USER,J/OPCT1	;COUNT THIS INSTR
	SC_#,#/9.,SKP USER,J/OPCT1
.ENDIF/OP.CNT
.IF/OP.TIME
=1000	AR_2,CLR TRK+PA EN,J/OPTM1	;TIME OUT THIS INSTR
	AR_2,CLR TRK+PA EN,J/OPTM1
.ENDIF/OP.TIME
;-- THE NICOND DISPATCH BLOCK CONTINUES ON THE NEXT PAGE --
;-- NICOND DISPATCH CONTINUED --

=1010
XCTGO:	BRX/ARX,SET ACCOUNT EN,		;SAVE INSTR, ENABLE ACCOUNTING,
	    EA MOD DISP,J/COMPEA,AR_1S	;GO CALCULATE EA, -1 FOR SOJ HACK
.IFNOT/ONE PROCEED
TRAP:	VMA_420+TRAP,J/TRAPX		;HERE IF TRAP BITS SET
.IF/ONE PROCEED
TRAP:	GET ECL EBUS,SC_1,J/TR3CHK	;TRAP, CHECK FOR ONE PROCEED
.ENDIF/ONE PROCEED
=1110	ARX_FM(VMA),TIME/3T,LOAD IR,J/XCTGO	;HERE IF INSTR IS IN FM
.IFNOT/ONE PROCEED
	VMA_420+TRAP,J/TRAPX		;HERE IF TRAP BITS SET
.IF/ONE PROCEED
	ARX_FM(VMA),TIME/3T,LOAD IR,	;HERE IF TRAP AND VMA->ACS
		J/TRAP			;FETCH THE INSTR THEN TRAP
.ENDIF/ONE PROCEED

.IF/ONE PROCEED
;HERE ON TRAPS, WITH INSTRUCTION IN ARX AND IR, 1 IN SC,
;AND ECL EBUS GRABBED.  UNFORTUNATELY THE HARDWARE CAREFULLY
;CLEARS THE TRAP BITS IN THE PC WORD ON A NICOND, BUT
;WE CAN USE A DIAGNOSTIC FUNCTION TO READ THE TRAP CYC BITS (SCD4).
;THE "ADDRESS BREAK INHIBIT" HAIR (SCD5) IS USED TO
;DETECT WHEN AN INSTRUCTION IS COMPLETED.
;IF THIS IS A TRAP 3, AND SCD ADDR BRK CYC IS TRUE, WE ARE
;IN THE MIDDLE OF A ONE-PROCEED, SO SUPPRESS THE TRAP.
;SCD ADDR BRK CYC IS ON WHEN NICOND IS DONE WITH
;ADR BRK INH SET IN THE PC FLAGS (I.E. JUST STARTING
;OR RE-STARTING THE INSTRUCTION BEING ONE-PROCEEDED.)

TR3CHK:	AR03-04_SCD TRAP CYC
	VMA_420+TRAP,SH DISP,J/TR3DSP	;VMA -> TRAP INST, CHECK TRAP NUMBER
=11100
TR3DSP:
=01
	REL ECL EBUS,J/TRAPX		;TRAP 1 - TAKE TRAP
	REL ECL EBUS,J/TRAPX		;TRAP 2 - TAKE TRAP
	AR05_SCD ADDR BRK CYC		;TRAP 3 - CHECK FOR ONE PROCEED
	GEN P AND SC,SKP SCAD NE	;SKIP IF ONE-PROCEEDING
=1***0
	REL ECL EBUS,J/TRAPX		;NO, TAKE THE TRAP
	REL ECL EBUS			;YES, DO THE INSTR THEN
	TRAP3,J/XCTGO			;ARRANGE FOR ANOTHER TRAP
					;WHEN THE INSTRUCTION COMPLETES
.ENDIF/ONE PROCEED

;HERE ON TRAPS, VMA SETUP WITH 420+TRAP CODE

TRAPX:	LOAD ARX,PT REF			;GET AND XCT TRAP INSTR
	SET PC+1 INH			;DON'T INCREMENT PC FOR THIS INSTR

;HERE AFTER FETCHING INSTR TO BE EXECUTED

XCTW:	ARX_MEM,LOAD IR,J/XCTGO		;GET INSTR TO XCT
.TOC	"EFFECTIVE ADDRESS COMPUTATION AND OPERAND FETCH"

;COME HERE WITH -1 IN AR IF YOU EXPECT SOJ TO WORK!
=11***00				;HERE WITH XR CALC IN PROG
COMPEA:	AR_ARX (AD),A READ,		;NO MOD, GET OPERAND IF ANY
		MQ_AR			;SOJ SERIES EXPECTS -1 IN MQ
	AR_ARX+XR,A READ,		;INDEXED, NO @
		MQ_AR			;SOJ SERIES EXPECTS -1 IN MQ
	GEN ARX,A INDRCT,		;DO INDIRECT, NO INDEX
		SKP INTRPT,J/INDRCT
	GEN ARX+XR,A INDRCT,		;BOTH @ AND XR
		SKP INTRPT,J/INDRCT
=11****0
INDRCT:	ARX_MEM,J/INDLP			;GET INDIRECT POINTER, EVAL
TAKINT:	ARX_MEM,TAKE INTRPT		;INTERRUPT DURING INDIRECT

;APPARENTLY  A INDRCT  AT COMPEA+2/+3 CAN
; CAUSE AR AS WELL AS ARX TO BE CLOBBERED BY ARX_MEM.
;HENCE WE MUST RESTORE THE -1 THAT THE  SOJ  SERIES DEPENDS ON.

INDLP:	EA MOD DISP,AR_1S,J/COMPEA	;EVALUATE POINTER
.TOC	"WAIT FOR (E)"

;THE EXECUTE CODE FOR EACH INSTRUCTION IS ENTERED WITH
; THE OPCODE AND AC # IN BRX AND IR, THE LAST INDIRECT WORD
; IN ARX, AND AR AND VMA SETUP AS A FUNCTION OF THE A
; FIELD OF THE DISPATCH RAM. A PREFETCH IS IN PROGRESS IF THE
; DRAM A FIELD WAS 1 OR 5 (OR IF IR CONTAINS "JRST 0,").

;ON "A READ", THE HARDWARE DISPATCHES TO THE EXECUTE CODE FOR
; THE INSTRUCTION IF THE DRAM A FIELD IS 0 OR 1.  IF THE A FIELD
; CONTAINS 2-7, THE HARDWARE DISPATCHES TO 40+A, BELOW:

;COME HERE ON "A READ" FUNCTION IF DRAM A FIELD IS 3
; A "WRITE TST" IS IN PROGRESS

43:	BR/AR,AR_AC0,MB WAIT,		;WAIT FOR PERMISSION TO WRITE
		TIME/3T,IR DISP,J/0	;AND GO TO EXECUTE CODE

;HERE ON "A READ" FUNCTION IF DRAM A FIELD IS 4
; A "LOAD AR" IS IN PROGRESS

44:	BR/AR,AR_MEM,TIME/3T,		;GET OPERAND
		IR DISP,J/0		; START EXECUTE

;HERE ON "A READ" IF A FIELD IS 5
; A "LOAD AR" IS IN PROGRESS, AND WE MUST PREFETCH WHEN IT COMPLETES

45:	BR/AR,FIN XFER,I FETCH,		;GET OPERAND, PREFETCH,
		TIME/3T,IR DISP,J/0	; & START EXECUTE

;HERE ON "A READ" IF A FIELD IS 6
; A "LOAD AR" IS IN PROGRESS, BUT PAGING IS TESTING WRITABILITY

46:	BR/AR,AR_MEM,TIME/3T,		;GET OPERAND
		IR DISP,J/0		; START EXECUTE

;HERE ON "A READ" IF A FIELD IS 7
; A "READ-PAUSE-WRITE" IS IN PROGRESS

47:	BR/AR,AR_MEM,TIME/3T,		;GET OPERAND
		IR DISP,J/0		; START EXECUTE
.TOC	"TERMINATION"

;DISPATCH HERE WITH THE "EXIT" MACRO,
; OR JUMP DIRECTLY TO ONE OF THESE LOCATIONS.

=11*000
ST0:					;BASE FOR B DISP IN EXIT MACRO
=001
ST2AC:	AC0_AR,AR_SIGN,I FETCH,J/STD1	;HERE TO STORE AC0 & AC1
	FIN STORE,EXIT DBL		;MULB, DIVB, ETC ...
	FIN STORE,I FETCH,		;SELF MODE
		SKP AC#0,J/STSELF	; RESULT TO AC TOO?
=101
STAC:	AC0_AR,NXT INSTR		;NORMAL AND IMMEDIATE MODES
ST6:
IFNOP:
STMEM:	FIN STORE,I FETCH,J/NOP		;MEM MODE
IFSTAC:
STBOTH:	FIN STORE,I FETCH,J/STORAC	;BOTH MODE
=
;HERE TO FINISH, AFTER FETCHING NEXT INSTRUCTION.
; WE MUST GUARANTEE AT LEAST ONE EBOX CYCLE BETWEEN FETCH AND NICOND,
; TO ALLOW VMA AC REF TO MAKE IT THROUGH THE NICOND LOGIC.
=11***0
STSELF:					;SKIP, AOS, SOS COME HERE
STORAC:	SR_0,J/STAC			;STORE AC, TOO
NOP:	J/FINI				;DELAY THEN NXT INSTR

.IF/JPC SUPPORT
=110
NJPCP:	AR_PC,SKP USER,J/JPCEX		;FOR JPC HACK - SKIP IF NOT JUMPING
.ENDIF/JPC SUPPORT
FINI:	SR_0,NXT INSTR			;GET NEXT INSTR IN ARX & IR,
					; LOAD PC, TEST PI CYCLE, RUN,
					; PI READY, TRAPS

;HERE TO STORE ARITHMETIC DOUBLE RESULTS

DSTAC:	AC0_AR,AR_SIGN			;HERE WITH FETCH STARTED
STD1:	AR_SHIFT,SR_0			;BRING IN LOW PART
STAC1:	AC1_AR,NXT INSTR AFTER AC1	;STORE AC1


;HERE TO GET MICRO-CODE VERSION #.  FIXED LOC'N SO SOFTWARE CAN FIND IT
137:
UVERS:	BR/AR,AR0-8_#,#/VERS,J/GTAR08	;COPY VERSION TO AR
.TOC	"MOVE GROUP, EXCH, BLT"

	.DCODE
200:	R-PF,	AC,	J/MOVE	;BASIC MOVE
	I-PF,	AC,	J/MOVE
.IF/WRTST
	W,	M,	J/MOVE
.IFNOT/WRTST
	I,	B/1,	J/MOVEM
.ENDIF/WRTST
	RPW,	S,	J/MOVE

204:	R-PF,	AC,	J/MOVS
	I-PF,	AC,	J/MOVS
	W,	M,	J/MOVS
	RPW,	S,	J/MOVS

210:	R-PF,	AC,	J/MOVN
	I-PF,	AC,	J/MOVN
	W,	M,	J/MOVN
	RPW,	S,	J/MOVN

214:	R-PF,	AC,	J/MOVM
	I-PF,	AC,	J/MOVM
	W,	M,	J/MOVM
	RPW,	S,	J/MOVM
	.UCODE

; ENTER WITH 0,E, (E), OR (AC) IN AR

=00****
MOVS:	AR_AR SWAP,EXIT			;ALSO USED BY HALFWORD GROUP
=
=00****
MOVM:	BR/AR,SKP AR0,J/MOVE		;FORCE POSITIVE
=
=00****
MOVN:	BR/AR,J/MOVNEG			;GET NEGATIVE
=
=00*000
MOVE:	EXIT				;STORE AS IS FROM AR
MOVNEG:	AR_-BR,AD FLAGS,FETCH WAIT,J/MOVE

;EXCH, BLT

	.DCODE
250:	RPW,	B/0,	J/EXCH
	I,		J/BLT
	.UCODE

=00***0
MOVEM:					;LIKE EXCH, EXCEPT NO STORE AC
EXCH:	ARX_AR,AR_AC0,STORE,J/STMAC	;PUT AC AT E, THEN STORE AC

BLT:	MQ_AR,ARX_AR,			;END ADDR TO MQ & ARX
		ARR_AC0,ARL_ARL,J/BLT1	;FIRST DEST ADDR TO AR
.TOC	"HALFWORD GROUP"
;	DESTINATION LEFT HALF

	.DCODE
500:	R-PF,	AC,	J/HLL
	I-PF,	AC,	J/HLL
	RPW,	M,	J/HRR		;HLLM = HRR EXCEPT FOR STORE
	RPW,	S,	J/MOVE		;HLLS = MOVES

	R-PF,	AC,	J/HRL
	I-PF,	AC,	J/HRL
	RPW,	M,	J/HRLM
	RPW,	S,	J/HRLS

510:	R-PF,	AC,	J/HLLZ
	I-PF,	AC,	J/HLLZ
	W,	M,	J/HLLZ
	RPW,	S,	J/HLLZ

	R-PF,	AC,	J/HRLZ
	I-PF,	AC,	J/HRLZ
	W,	M,	J/HRLZ
	RPW,	S,	J/HRLZ

520:	R-PF,	AC,	J/HLLO
	I-PF,	AC,	J/HLLO
	W,	M,	J/HLLO
	RPW,	S,	J/HLLO

	R-PF,	AC,	J/HRLO
	I-PF,	AC,	J/HRLO
	W,	M,	J/HRLO
	RPW,	S,	J/HRLO

530:	R-PF,	AC,	J/HLLE
	I-PF,	AC,	J/HLLE
	W,	M,	J/HLLE
	RPW,	S,	J/HLLE

	R-PF,	AC,	J/HRLE
	I-PF,	AC,	J/HRLE
	W,	M,	J/HRLE
	RPW,	S,	J/HRLE
;	DESTINATION RIGHT HALF

540:	R-PF,	AC,	J/HRR
	I-PF,	AC,	J/HRR
	RPW,	M,	J/HLL		;HRRM = HLL EXCEPT FOR STORE
	RPW,	S,	J/MOVE		;HRRS = MOVES

	R-PF,	AC,	J/HLR
	I-PF,	AC,	J/HLR
	RPW,	M,	J/HLRM
	RPW,	S,	J/HLRS

550:	R-PF,	AC,	J/HRRZ
	I-PF,	AC,	J/HRRZ
	W,	M,	J/HRRZ
	RPW,	S,	J/HRRZ

	R-PF,	AC,	J/HLRZ
	I-PF,	AC,	J/HLRZ
	W,	M,	J/HLRZ
	RPW,	S,	J/HLRZ

560:	R-PF,	AC,	J/HRRO
	I-PF,	AC,	J/HRRO
	W,	M,	J/HRRO
	RPW,	S,	J/HRRO

	R-PF,	AC,	J/HLRO
	I-PF,	AC,	J/HLRO
	W,	M,	J/HLRO
	RPW,	S,	J/HLRO

570:	R-PF,	AC,	J/HRRE
	I-PF,	AC,	J/HRRE
	W,	M,	J/HRRE
	RPW,	S,	J/HRRE

	R-PF,	AC,	J/HLRE
	I-PF,	AC,	J/HLRE
	W,	M,	J/HLRE
	RPW,	S,	J/HLRE

	.UCODE
;FIRST, THE 16 OPS WHICH DO NOT AFFECT THE "OTHER" HALF.
;THESE MUST BE TREATED SEPARATELY, BECAUSE THEY COMBINE MEMORY DATA
;IN AR WITH DATA FROM THE FM.  ENTER WITH 0,E OR (E) IN AR.

=00***0
HRR:	ARL_AC0,ARR_ARR,EXIT		;HRR, HRRI, HLLM
=00****
HLL:	ARR_AC0,ARL_ARL,EXIT		;HLL, HLLI, HRRM
=			;HRRS, HLLS ARE BOTH EQUIVALENT TO MOVES
=00****
HRL:	ARL_ARR,ARR_AC0,EXIT		;HRL, HRLI
=
=00****
HLR:	ARR_ARL,ARL_AC0,EXIT		;HLR, HLRI
=
=00***0
HRLM:	ARL_ARR,ARR_AC0,J/MOVS		;HRLM
HRLS:	ARL_ARR,ARR_ARR,EXIT		;HRLS
=
=00***0
HLRM:	ARR_ARL,ARL_AC0,J/MOVS		;HLRM
HLRS:	ARR_ARL,ARL_ARL,EXIT		;HLRS
=
;NOW THE HALFWORD OPS WHICH CONTROL THE "OTHER" HALF
; ENTER WITH 0,E, (E), OR (AC) IN AR

=00****
HRRE:	SKP AR18			;SELECT HRRZ OR HRRO ON SIGN
=
=00***0
HRRZ:	ARL_0S,ARR_ARR,EXIT
HRRO:	ARL_1S,ARR_ARR,EXIT
=
=00****
HRLE:	SKP AR18
=
=00***0
HRLZ:	ARL_ARR,ARR_0S,EXIT
HRLO:	ARL_ARR,ARR_1S,EXIT
=
=00****
HLRE:	SKP AR0
=
=00***0
HLRZ:	ARR_ARL,ARL_0S,EXIT
HLRO:	ARR_ARL,ARL_1S,EXIT
=
=00****
HLLE:	SKP AR0
=
=00***0
HLLZ:	ARR_0S,ARL_ARL,EXIT
HLLO:	ARR_1S,ARL_ARL,EXIT
=
.TOC	"DMOVE, DMOVN, DMOVEM, DMOVNM"
;DOUBLE-WORD MOVES

	.DCODE
120:	R,	B/0,	J/DMOVE
	R,	B/1,	J/DMOVN
	.UCODE

; ENTER WITH (E) IN AR
=00****
DMOVN:
DMOVE:	VMA_VMA+1,LOAD ARX,B DISP	;PICK UP (E+1)
=
=1**00
	ARX_MEM,J/STDAC			;GO STORE DOUBLE AC
	ARX_MEM,MQ_0.S,CALL.S,J/GTDBR	;LOAD BR WITH DOUBLE OPERAND
=11	AR_-BR LONG,AD FLAGS,		;NEGATE DOUBLE OPERAND
		SC_#,#/35.		;& STORE RESULT
DBLST:	AC0_AR,AR_0S,I FETCH,J/STD1	;STORE HIGH WORD, READY LOW


;DOUBLE MOVES TO MEMORY

	.DCODE
124:	W,		J/DMOVEM
	W,		J/DMOVNM
	.UCODE

;ENTER WITH (AC) IN AR
=00**00
DMOVEM:	ARX_AC1,STORE,SC_#,#/36.,J/DMVM1
DMOVNM:	ARX_AC1,MQ_0.S,CALL.S,J/GTDBR	;HIGH WORD IS ALREADY IN AR
=11	AR_-BR LONG,AD FLAGS,		;NEGATE
		STORE,SC_#,#/35.	; & STORE
=
DMVM1:	MEM_AR,VMA_VMA+1,AR_0S
	AR_SHIFT,STORE,J/STMEM

GTDBR:	ARX_ARX*2			;SHIFT OUT LOW SIGN
LDBRL:	BR_AR LONG,RETURN3		;COPY TO BR LONG
.TOC	"BOOLEAN GROUP"

	.DCODE
400:	I-PF,	AC,	J/SETZ
	I-PF,	AC,	J/SETZ
	IW,	M,	J/SETZ
	IW,	B,	J/SETZ
	.UCODE

=00****
SETZ:	AR_0S,EXIT
=
	.DCODE
404:	R-PF,	AC,	J/AND
	I-PF,	AC,	J/AND
	RPW,	M,	J/AND
	RPW,	B,	J/AND
	.UCODE

=00****
AND:	AR_AR*AC0,AD/AND,EXIT
=
	.DCODE
410:	R-PF,	AC,	J/ANDCA
	I-PF,	AC,	J/ANDCA
	RPW,	M,	J/ANDCA
	RPW,	B,	J/ANDCA
	.UCODE

=00****
ANDCA:	AR_AR*AC0,AD/ANDCB,EXIT
=
	.DCODE
414:	R-PF,	AC,	J/MOVE		;SETM = MOVE
	I-PF,	AC,	J/MOVE
	RPW,	M,	J/MOVE		;SETMM = NOP THAT WRITES MEMORY
	RPW,	B,	J/MOVE		;SETMB = MOVE THAT WRITES MEMORY

420:	R-PF,	AC,	J/ANDCM
	I-PF,	AC,	J/ANDCM
	RPW,	M,	J/ANDCM
	RPW,	B,	J/ANDCM
	.UCODE

=00****
ANDCM:	AR_AR*AC0,AD/ANDCA,EXIT
=
	.DCODE
424:	R-PF,		J/TDN
	I-PF,		J/TDN
	W,	M,	J/MOVE		;SETAM = MOVEM
	W,	M,	J/MOVE		;SETAB, TOO
	.UCODE
	.DCODE
430:	R-PF,	AC,	J/XOR
	I-PF,	AC,	J/XOR
	RPW,	M,	J/XOR
	RPW,	B,	J/XOR
	.UCODE

=00****
XOR:	AR_AR*AC0,AD/XOR,EXIT
=
	.DCODE
434:	R-PF,	AC,	J/IOR
	I-PF,	AC,	J/IOR
	RPW,	M,	J/IOR
	RPW,	B,	J/IOR
	.UCODE

=00****
IOR:	AR_AR*AC0,AD/OR,EXIT
=
	.DCODE
440:	R-PF,	AC,	J/ANDCB
	I-PF,	AC,	J/ANDCB
	RPW,	M,	J/ANDCB
	RPW,	B,	J/ANDCB
	.UCODE

=00****
ANDCB:	AR_AR*AC0,AD/ANDC,EXIT
=
	.DCODE
444:	R-PF,	AC,	J/EQV
	I-PF,	AC,	J/EQV
	RPW,	M,	J/EQV
	RPW,	B,	J/EQV
	.UCODE

=00****
EQV:	AR_AR*AC0,AD/EQV,EXIT
=
	.DCODE
450:	I-PF,	AC,	J/SETCA
	I-PF,	AC,	J/SETCA
	IW,	M,	J/SETCA
	IW,	B,	J/SETCA
	.UCODE

=00****
SETCA:	AR_AR*AC0,AD/SETCB,EXIT
=
	.DCODE
454:	R-PF,	AC,	J/ORCA
	I-PF,	AC,	J/ORCA
	RPW,	M,	J/ORCA
	RPW,	B,	J/ORCA
	.UCODE

=00****
ORCA:	AR_AR*AC0,AD/ORCB,EXIT
=
	.DCODE
460:	R-PF,	AC,	J/SETCM
	I-PF,	AC,	J/SETCM
	RPW,	M,	J/SETCM
	RPW,	B,	J/SETCM
	.UCODE

=00****
SETCM:	ADA/AR,AD/SETCA,AR/AD,EXIT
=
	.DCODE
464:	R-PF,	AC,	J/ORCM
	I-PF,	AC,	J/ORCM
	RPW,	M,	J/ORCM
	RPW,	B,	J/ORCM
	.UCODE

=00****
ORCM:	AR_AR*AC0,AD/ORCA,EXIT
=
	.DCODE
470:	R-PF,	AC,	J/ORCB
	I-PF,	AC,	J/ORCB
	RPW,	M,	J/ORCB
	RPW,	B,	J/ORCB
	.UCODE

=00****
ORCB:	AR_AR*AC0,AD/ORC,EXIT
=
	.DCODE
474:	I-PF,	AC,	J/SETO
	I-PF,	AC,	J/SETO
	IW,	M,	J/SETO
	IW,	B,	J/SETO
	.UCODE

=00****
SETO:	AR_1S,EXIT
=
