.TOC	"TEST GROUP"
	.DCODE
600:	I-PF,		J/TDN		;TRN- IS NOP
	I-PF,		J/TDN		;SO IS TLN-
	I,	TNE,	J/TDXX
	I,	TNE,	J/TSXX
	I,	TNA,	J/TDX
	I,	TNA,	J/TSX
	I,	TNN,	J/TDXX
	I,	TNN,	J/TSXX

610:	I-PF,		J/TDN		;TDN- IS A NOP
	I-PF,		J/TDN		;TSN- ALSO
	R,	TNE,	J/TDXX
	R,	TNE,	J/TSXX
	R,	TNA,	J/TDX
	R,	TNA,	J/TSX
	R,	TNN,	J/TDXX
	R,	TNN,	J/TSXX

620:	I,	TZ-,	J/TDX
	I,	TZ-,	J/TSX
	I,	TZE,	J/TDXX
	I,	TZE,	J/TSXX
	I,	TZA,	J/TDX
	I,	TZA,	J/TSX
	I,	TZN,	J/TDXX
	I,	TZN,	J/TSXX

630:	R,	TZ-,	J/TDX
	R,	TZ-,	J/TSX
	R,	TZE,	J/TDXX
	R,	TZE,	J/TSXX
	R,	TZA,	J/TDX
	R,	TZA,	J/TSX
	R,	TZN,	J/TDXX
	R,	TZN,	J/TSXX

640:	I,	TC-,	J/TDX
	I,	TC-,	J/TSX
	I,	TCE,	J/TDXX
	I,	TCE,	J/TSXX
	I,	TCA,	J/TDX
	I,	TCA,	J/TSX
	I,	TCN,	J/TDXX
	I,	TCN,	J/TSXX

650:	R,	TC-,	J/TDX
	R,	TC-,	J/TSX
	R,	TCE,	J/TDXX
	R,	TCE,	J/TSXX
	R,	TCA,	J/TDX
	R,	TCA,	J/TSX
	R,	TCN,	J/TDXX
	R,	TCN,	J/TSXX
660:	I,	TO-,	J/TDX
	I,	TO-,	J/TSX
	I,	TOE,	J/TDXX
	I,	TOE,	J/TSXX
	I,	TOA,	J/TDX
	I,	TOA,	J/TSX
	I,	TON,	J/TDXX
	I,	TON,	J/TSXX

670:	R,	TO-,	J/TDX
	R,	TO-,	J/TSX
	R,	TOE,	J/TDXX
	R,	TOE,	J/TSXX
	R,	TOA,	J/TDX
	R,	TOA,	J/TSX
	R,	TON,	J/TDXX
	R,	TON,	J/TSXX
	.UCODE

;THESE 64 INSTRUCTIONS ARE DECODED BY MASK MODE (IMMEDIATE OR MEMORY)
; IN THE A FIELD, DISPATCH TO HERE ON THE J FIELD, AND RE-DISPATCH
; FOR THE MODIFICATION ON THE B FIELD.

; ENTER WITH 0,E OR (E) IN AR, B FIELD BITS 1 AND 2 AS FOLLOWS:
; 0 0	NO MODIFICATION
; 0 1	ZEROS
; 1 0	COMPLEMENT
; 1 1	ONES
;   THIS ORDER HAS NO SIGNIFICANCE EXCEPT THAT IT CORRESPONDS TO THE
;   ORDER OF INSTRUCTIONS AT TGROUP.

;THE HIGH ORDER BIT OF THE B FIELD (B0) IS XOR'D WITH AD CRY0 TO
;   DETERMINE THE SENSE OF THE SKIP:
; 0	SKIP IF CRY0=1 (TXX- AND TXXN)
; 1	SKIP IF CRY0=0 (TXXA AND TXXE)

=0****00*000
TDX:	TEST FETCH,NO CRY,		;TDXA AND TRXA
		B DISP,J/TDN

TSX:	AR_AR SWAP,TEST FETCH,NO CRY,	;TSX, TSXA, TLX, AND TLXA
		B DISP,J/TDN

TSXX:	AR_AR SWAP			;TSXE, TSXN, TLXE, AND TLXN

TDXX:	TEST AR.AC0,TEST FETCH,B DISP	;TDXE, TDXN, TRXE, AND TRXN

TDN:	J/FINI				;NO MODIFICATION
TDZ:	AR_AR*AC0,AD/ANDCA,TIME/2T,J/STAC	;ZEROS
TDC:	AR_AR*AC0,AD/XOR,TIME/2T,J/STAC		;COMP
TDO:	AR_AR*AC0,AD/OR,TIME/2T,J/STAC		;ONES
=
.TOC	"COMPARE -- CAI, CAM"

	.DCODE
300:	I,	SJC-,	J/CAIM	;CAI
	I,	SJCL,	J/CAIM
	I,	SJCE,	J/CAIM
	I,	SJCLE,	J/CAIM
	I,	SJCA,	J/CAIM
	I,	SJCGE,	J/CAIM
	I,	SJCN,	J/CAIM
	I,	SJCG,	J/CAIM

310:	R,	SJC-,	J/CAIM	;CAM
	R,	SJCL,	J/CAIM
	R,	SJCE,	J/CAIM
	R,	SJCLE,	J/CAIM
	R,	SJCA,	J/CAIM
	R,	SJCGE,	J/CAIM
	R,	SJCN,	J/CAIM
	R,	SJCG,	J/CAIM
	.UCODE

=0****00****
CAIM:	GEN AR*AC0,COMP FETCH,J/NOP
=
.TOC	"ARITHMETIC SKIPS -- AOS, SOS, SKIP"
;ENTER WITH (E) IN AR

	.DCODE
330:	R,	SJC-,	J/SKIP	;NOT A NOP IF AC .NE. 0
	R,	SJCL,	J/SKIP
	R,	SJCE,	J/SKIP
	R,	SJCLE,	J/SKIP
	R,	SJCA,	J/SKIP
	R,	SJCGE,	J/SKIP
	R,	SJCN,	J/SKIP
	R,	SJCG,	J/SKIP
	.UCODE

=0****00****
SKIP:	FIN STORE,SKIP FETCH,
		SKP AC#0,J/STSELF	;STORE IN SELF MODE
=

	.DCODE
350:	RPW,	SJC-,	J/AOS
	RPW,	SJCL,	J/AOS
	RPW,	SJCE,	J/AOS
	RPW,	SJCLE,	J/AOS
	RPW,	SJCA,	J/AOS
	RPW,	SJCGE,	J/AOS
	RPW,	SJCN,	J/AOS
	RPW,	SJCG,	J/AOS
	.UCODE

=0****00****
AOS:	AR_AR+1,AD FLAGS,STORE,J/SKIP
=

	.DCODE
370:	RPW,	SJC-,	J/SOS
	RPW,	SJCL,	J/SOS
	RPW,	SJCE,	J/SOS
	RPW,	SJCLE,	J/SOS
	RPW,	SJCA,	J/SOS
	RPW,	SJCGE,	J/SOS
	RPW,	SJCN,	J/SOS
	RPW,	SJCG,	J/SOS
	.UCODE

=0****00****
SOS:	AR_AR-1,AD FLAGS,STORE,J/SKIP
=
.TOC	"CONDITIONAL JUMPS -- JUMP, AOJ, SOJ, AOBJ"

	.DCODE
320:	I,	SJC-,	J/JUMP
	I,	SJCL,	J/JUMP
	I,	SJCE,	J/JUMP
	I,	SJCLE,	J/JUMP
	I,	SJCA,	J/JUMP
	I,	SJCGE,	J/JUMP
	I,	SJCN,	J/JUMP
	I,	SJCG,	J/JUMP
	.UCODE

=0****00****
JUMP:	AR_AC0,JUMP FETCH,J/NOP		; E IS IN VMA (HERE AND BELOW)
=

	.DCODE
340:	I,	SJC-,	J/AOJ
	I,	SJCL,	J/AOJ
	I,	SJCE,	J/AOJ
	I,	SJCLE,	J/AOJ
	I,	SJCA,	J/AOJ
	I,	SJCGE,	J/AOJ
	I,	SJCN,	J/AOJ
	I,	SJCG,	J/AOJ
	.UCODE

=0****00****
AOJ:	AR_AC0+1,AD FLAGS,JUMP FETCH,J/STORAC
=

	.DCODE
360:	I,	SJC-,	J/SOJ
	I,	SJCL,	J/SOJ
	I,	SJCE,	J/SOJ
	I,	SJCLE,	J/SOJ
	I,	SJCA,	J/SOJ
	I,	SJCGE,	J/SOJ
	I,	SJCN,	J/SOJ
	I,	SJCG,	J/SOJ
	.UCODE

=0****00****
SOJ:	AR_AC0
=	AR_AR-1,AD FLAGS,JUMP FETCH,J/STORAC

	.DCODE
252:	I,	SJCGE,	J/AOBJ
	I,	SJCL,	J/AOBJ
	.UCODE

=0****00****
AOBJ:	AR_AC0+1,GEN CRY18,JUMP FETCH,J/STORAC
=
.TOC	"AC DECODE JUMPS -- JRST, JFCL"

	.DCODE
254:	EA,	J/JRST		;DISPATCHES TO 1 OF 16 ON AC BITS
	I,TNN,	J/JFCL
	.UCODE

;A READ DETECTS JRST, AND DISPATCHES TO ONE OF 16 LOC'NS ON AC BITS

600:				;DRAM REQUIRES JRST AT MULTIPLE OF 200
JRST:	J/FINI				;(0) A READ PREFETCHES ON JRST 0,
601:	PORTAL,BR/AR,J/BRJMP		;(1) PORTAL
602:
JRST2:	EA MOD DISP,BR/AR,J/JRSTF	;(2) JRSTF
603:	J/UUO				;(3)
604:	SKP KERNEL,J/IHALT		;(4) HALT
.IF/LONG.PC
605:	LOAD AR,J/XJRSTF1		;(5) XJRSTF -- VALID ANYWHERE
606:	SKP IO LEGAL,J/604		;(6) XJEN -- TRAP IF USER
607:	SKP IO LEGAL,ARX_PC+1,J/XPCW1	;(7) XPCW -- TRAP IF USER
.IFNOT/LONG.PC
605:	J/UUO				;(5)
606:	J/UUO				;(6)
607:	J/UUO				;(7)
.ENDIF/LONG.PC
610:	SKP IO LEGAL,J/DISM		;(10) JRST 10, DISMISS ONLY
611:	J/UUO				;(11)
612:	SKP IO LEGAL,J/DISM		;(12) JEN
613:	J/UUO				;(13)
.IF/LONG.PC
614:	AR_0.C,ARX_PC+1,J/XSFM1		;(14) XSFM [331]
615:	LOAD AR,J/PCA			;(15) XJRST [301]
.IFNOT/LONG.PC
614:	J/UUO				;(14)
615:	J/UUO				;(15)
.ENDIF/LONG.PC
616:	J/UUO				;(16)
617:	J/UUO				;(17)
;HERE TO FINISH THE MORE COMPLEX FORMS OF JRST

.IFNOT/XADDR
=1110
JRSTF:	AR_ARX,J/RSTF			;NO XR, RESTORE FROM INDIRECT WORD
	AR_XR,J/RSTF			;INDEXED, RESTORE FROM REGISTER
.IF/XADDR
=1110
JRSTF:	AR_ARX,SKP PC SEC0,J/RSTF0	;NO XR, RESTORE FROM INDIRECT WORD
	AR_XR,SKP PC SEC0		;INDEXED, RESTORE FROM REGISTER
=0
RSTF0:	J/UUO
.ENDIF/XADDR
RSTF:	RSTR FLAGS_AR,J/BRJMP

=0
DISM:	J/UUO				;ATTEMPT TO DISMISS FROM USER
	DISMISS,BR/AR
	IR DISP,J/20			;SPLIT OUT AGAIN
630:					;JRST 10,
BRJMP:	VMA_BR,FETCH,J/NOP		;RELOAD VMA WITH NEW FLAGS
632:	EA MOD DISP,J/JRSTF		;JEN, MUST RESTORE FLAGS

.IF/LONG.PC
XSFM1:	ARX_ARX ANDC ADMSK,SKP USER    	;[331] XSFM now legal everywhere
=0	AR12-17_PREV SEC,CALL [ARSWAP]	;[334] SAVE PCS IN AR
	ARL_ARXL,ARR_ARR,        	;STORE FLAG WORD
		STORE,J/XSFM2
;					;[334]

.IFNOT/XADDR
=0
XPCW1:	J/UUO				;BAD USE OF XPCW 
	AR_ARX ANDC ADMSK,STORE,	;STORE FLAGS WORD
		BRX/ARX,ARX/AD,
		IR DISP,J/20		;IS THIS XSFM OR XPCW
.IF/XADDR
=0
XPCW1:	J/UUO				;BAD USE OF XPCW
	AR_ARX ANDC ADMSK,BRX/ARX,	;SAVE FLAGS,PC IN BRX AND
		ARX/AD			;FLAGS IN ARX
	AR_0.S,BR/AR,SKP USER
=0	AR12-17_PREV SEC,CALL [ARSWAP]	;[334] SAVE PCS IN AR
	ARL_BRL,ARR_ARR,STORE,		;STORE FLAGS WORD
		IR DISP,J/20		;IS THIS XSFM, OR XPCW?
.ENDIF/XADDR
627:	FIN STORE,AR_ARX*BRX,AD/ANDCA,	;XPCW.  GET ADDRESS TO AR
		VMA_VMA+1,STORE,J/XPCW2
634:
XSFM2:	FIN STORE,I FETCH,J/NOP		;XSFM.  DONE.

XJRSTF1:FIN XFER,VMA_VMA+1,LOAD AR,	;GETS TO 625 OR 626 FOR XJRSTF
		IR DISP,J/20		; OR XJEN

.IFNOT/XADDR
XPCW2:	FIN STORE,VMA_VMA+1,LOAD AR	;STORE PC ADDR, GET NEW FLAGS
	FIN XFER,VMA_VMA+1,LOAD AR	;GOT FLAGS GET PC ADDRESS
625:	RSTR FLAGS_AR,AR_MEM,J/ARJMP	;XJRSTF WINDS UP HERE
626:	RSTR FLAGS_AR,AR_MEM		;XJEN WINDS UP HERE
	DISMISS,J/ARJMP
.IF/XADDR
XPCW2:	FIN STORE,VMA_VMA+1,LOAD AR	;STORE PC ADDR, GET NEW FLAGS
	FIN XFER,VMA_VMA+1,LOAD AR	;GOT FLAGS, GET PC ADDRESS
	RSTR FLAGS_AR,AR_MEM,J/ARJMP
625:	RSTR FLAGS_AR,AR_MEM,       	;XJRSTF WINDS UP HERE
		ARX_AR SWAP,		;SAVE PCS,FLAGS IN ARX
		SKP USER,J/XJRSTF2
626:	RSTR FLAGS_AR,AR_MEM,SKP USER,	;XJEN WINDS UP HERE
		ARX_AR SWAP		;SAVE PCS,FLAGS IN ARX
=0	DISMISS,J/XJRSTF2
	DISMISS,J/ARJMP
=0
XJRSTF2:SKP USER,J/XJRSTF3
	VMA_AR,FETCH,J/NOP
=0
XJRSTF3:CALL,J/LDPCS			;RESTORE PCS FROM FLAGS WORD
.ENDIF/XADDR
ARJMP:	VMA_AR,FETCH,J/NOP		;DONE
.IF/XADDR
PCA:	AR_MEM,SR_0,J/ARJMP		;[301] End of LUUO and XJRST
;
LDPCS:	GET ECL EBUS
	LD PCS
	COND/EBUS CTL,EBUS CTL/2,	;RELEASE ECL BUS
		RETURN1
.ENDIF/XADDR
.ENDIF/LONG.PC
;
;	[334] Subroutine to swap AR halves.  Used in a couple of places.
;
ARSWAP:	AR_AR SWAP,RETURN1		;[334] Rearrange things
;
700:					;JFCL MUST BE AT JRST+100
JFCL:	ARX_BRX,SC_#,#/13.		;GET BACK AC FIELD
=0*	AR_SHIFT,ARX_0S,		;MOVE AC TO AR32-35
		SC_#,#/32.,CALL,J/SHIFT	;SHIFTER WILL MOVE TO 0-3
	BR/AR,AR_PC,JFCL T		;GET PC FLAGS INTO AR
	TEST AR.BR,JFCL FETCH		;JUMP IF TEST SATISFIED
	AR_AR*BR,AD/ANDCB		;CLEAR TESTED FLAGS IN AR
	JFCL S,J/FINI			;SET PC FROM THEM
.TOC	"HALT LOOP"
;HERE WHILE PROCESSOR IS "HALTED"

1016:
UUO107:					;OP 107 COMES HERE
IHALT:	J/UUO				;HERE IF HALT NOT IN KERNEL
1017:	HALT

CHALT:	AR_0S,CLR SC,CLR FE,SET HALTED,	;KERNEL OR CONSOLE HALT
		VMA/PC,PC_VMA		; IF JRST 4, COPY EA TO PC
.IF/PAGCNT				;[327] PFH, DATAO PAG bit 2 counts
	TRX2_AR				;[327] Zero count registers
	TRX3_AR
.ENDIF/PAGCNT				;[327]
=0
HALT1:	SKP -START,TIME/3T,		;CHECK FOR CONTINUE BUTTON
		FE_AR0-8,ARX_AR,J/HALT2	;PICK UP OPCODE IN CASE XCT
	TAKE INTRPT			;HERE IF EXAMINE/DEPOSIT UP
=0
HALT2:	GEN FE-1,BYTE DISP,CONTINUE,J/UNHALT	;INSTR FROM SWITCHES?
	SKP INTRPT,TIME/2T,J/HALT1	;HALT LOOP MUST BE AN ODD
					; NUMBER OF TICKS TO ALLOW
					; DIAGNOSTICS TO SYNCRONIZE
					; EBOX WITH E & SBUS CLK PHASES.
=110
UNHALT:	SET CONS XCT,CLR FE,J/UXCT	;XCT ONE FROM "SWITCHES"
	SKP AR EQ,J/START		;NOT AN INSTR.  START, OR CONT?


.TOC	"MAP, XCT"

	.DCODE
256:	R,		J/XCT	;OPERAND FETCHED AS DATA
	I,	AC,	J/MAP
	.UCODE

=0****00***0
XCT:	SKP INTRPT,J/XCT1		;CHECK FOR XCT . LOOP

MAP:	MAP,BR/AR			;MAP E, GO READ BACK EBRG
=
.IF/KLPAGE				;IN KL PAGING MODE,
	SR_MAP				;MAP CAN PAGE FAIL
.ENDIF/KLPAGE
=0
RDEBRG:	AR_0S,SKP IO LEGAL,MB WAIT,	;FINISH READ REG FUNC
		CALL,J/GETEEB		;AND GET EBUS
	AR_EBUS REG			;READ DATA
	REL ECL EBUS,B WRITE,J/ST6	;GIVE IT TO USER
.IF/KLPAGE
=0
MAP2:	SR_0,J/UUO			;NO MAPS IN USER MODE
	SKP INTRPT			;DO NOT BUM THIS CODE OUT
=0					;IT IS NECESSARY TO DO NOTHING
	I FETCH,J/STORAC		;INTERESTING AFTER A MAP IF
	SET ACCOUNT EN,J/TAKINT		;AN INTERRUPT IS PENDING
.ENDIF/KLPAGE
.TOC	"STACK INSTRUCTIONS -- PUSHJ, PUSH, POP, POPJ"

	.DCODE
260:	EA,		J/PUSHJ
	R,	B/0,	J/PUSH
	EA,	B/0,	J/POP
	I,		J/POPJ
	.UCODE

;PUSHJ
; ENTER WITH E IN AR
;PUSH
; ENTER WITH (E) IN AR

=0****00***0
.IFNOT/MODEL.B
PUSH:	ARX_AC0+1,GEN CRY18,SKP CRY0,	;BUMP BOTH HALVES OF AC,
		VMA/AD,STORE,J/STMAC	;PUT AR ONTO LIST

PUSHJ:	BR/AR,AR_PC+1			;SAVE JUMP ADDR, GET PC
=	ARX_AC0+1,GEN CRY18,SKP CRY0,	;COMPUTE STACK ADDRESS
		VMA/AD,STORE,J/JSTAC	;AND PREPARE TO STORE PC
.IF/MODEL.B		;COULD SIMPLIFY IFNOT XADDR
PUSH:	ARX_AC0+1,PUSH,SKP CRY0,J/STMAC	;BUMP AC ACCORDING TO FORMAT
					; AND SECTION NUMBER
PUSHJ:	BR/AR,AR_PC+1,SKP PC SEC0	;GET PC WITH FLAGS
=
=0	AR_AR AND ADMSK			;STRIP OFF FLAGS IF NOT SEC0
	ARX_AC0+1,PUSH,SKP CRY0,J/JSTAC	;UPDATE STACK POINTER, STORE
.ENDIF/MODEL.B
=00
JRA1:	VMA_AR,LOAD ARX,CALL,J/XFERW	;GET SAVED AC
=10
JSTAC:	FIN STORE,VMA_BR,FETCH,		;STORE PC, JUMP ADDR TO VMA
		AR_ARX,J/STORAC		;PREPARE TO STORE AC VALUE
	TRAP2,MEM_AR,J/JSTAC		;CAUSE PDL OVRFLO

=0
STMAC:	FIN STORE,I FETCH,		;STORE RESULT, GET NEXT INSTR
		AR_ARX,B DISP,J/STSELF	;STORE AC IF B=0
	MEM_AR,TRAP2,			;PDL OVFLO, CAUSE TRAP
		AR_ARX,J/IFSTAC		;UPDATE AC BEFORE TRAPPING
;
;	A one line subroutine to wait for a memory fetch (either AR
;	or ARX) and return.  Used by all sorts of things.
;
XFERW:	AR_MEM,ARX_MEM,TIME/3T,RETURN2	; Cross reference both macros [313]
;POP, POPJ
;ENTER WITH E IN AR

.IFNOT/MODEL.B
=0****00***0
POP:	BR/AR,AR_AC0,VMA/AD,		;GET PUSHDOWN POINTER
		LOAD AR,J/POP1		;BEGIN DATA FETCH FROM STACK

POPJ:	AR_AC0,VMA/AD,LOAD ARX		;START FETCH FROM STACK
=	AR_AR-1,INH CRY18,SKP CRY0	;DECR STACK POINTER, CHECK UNDERFLOW
=0	ARX_MEM,TRAP2,J/POPJ1		;UNDERFLOW OCCURRED
	ARX_MEM				;GET STACK WORD
POPJ1:	AC0_AR,VMA_ARX,FETCH,J/NOP	;SET NEW AC VALUE, JUMP


POP1:	ARX_AR-1,INH CRY18,SKP CRY0	;ADJUST POINTER, CHECK TRAP
=0	AR_MEM,TRAP2			;PDL OVFLO, CAUSE TRAP
	AR_MEM,SR_#,#/100		;SET DEST CONTEXT FLAG
	VMA_BR,STORE,SR_0,J/STMAC	;PUT RESULT AWAY, THEN AC
.IF/MODEL.B		;COULD SIMPLIFY IFNOT XADDR
=0****00***0
POP:	BR/AR,AR_AC0,POP AR,J/POP2	;GET FROM STACK

POPJ:	AR_AC0,POP AR-ARX		;GET STACK TO AR AND ARX
=	AR_AR-1,TIME/3T,		;BACK OFF POINTER
		AC0,STACK UPDATE,SKP CRY0	; UNDERFLOW?
=0	BR/AR,AR_MEM,ARL_0.S,		;AC TO BR, HALFWORD PC TO AR
		ARX_MEM,TIME/3T,	;FULL PC TO ARX.
		SKP PC SEC0,J/POPJT	; GO SET TRAP
	BR/AR,AR_MEM,ARL_0.S,		;AC TO BR, HALFWORD PC TO AR
		ARX_MEM,TIME/3T,	;FULL PC TO ARX.
		SKP PC SEC0		;EXTENDED FORM?
=0
POPJ2:	VMA_ARX,FETCH,J/POPJ4		;YES.  LOAD ENTIRE ADDR
POPJ3:	VMA_AR,FETCH			;NO, LOAD HALFWORD ADDRESS
POPJ4:	AR_BR,J/STAC			;GET AC BACK, GO STUFF IT

;HERE IF POPJ GETS STACK UNDERFLOW
; SKIP IF PC SECTION 0
=0
POPJT:	TRAP2,J/POPJ2
	TRAP2,J/POPJ3

POP2:	ARX_AR-1,AC0,STACK UPDATE,	;BACK UP POINTER
		SKP CRY0
=0	AR_MEM,TRAP2,J/POP3
	AR_MEM
POP3:	GEN BR,WRITE (E),J/STMAC	;STORE RESULT & AC
.ENDIF/MODEL.B
.TOC	"SUBROUTINE CALL/RETURN -- JSR, JSP, JSA, JRA"

	.DCODE
264:	EA,		J/JSR		; [301] Make sure these can cross
	EA,		J/JSP		; section boundaries
	I,		J/JSA
	I,		J/JRA
	.UCODE

=0****00***0
.IFNOT/XADDR
JSP:	AR_PC+1,FETCH,J/STORAC

JSR:	AR_PC+1,STORE
=	FIN STORE,VMA_VMA+1,FETCH,J/NOP
.IF/XADDR
JSP:	AR_PC+1,FETCH,SKP PC SEC0,J/JSP1

JSR:	AR_PC+1,SKP PC SEC0
=
=0	AR_AR AND ADMSK,STORE,J/JSR1
	STORE				;IN SECT 0, SAVE FLAGS, TOO
JSR1:	FIN STORE,VMA_VMA+1,FETCH,J/NOP

=0
JSP1:	AR_AR AND ADMSK,J/STAC		;NON-ZERO SEC, NO FLAGS
	AC0_AR,J/FINI
.ENDIF/XADDR


=0****00***0
JSA:	ARX_AR SWAP,AR_AC0,STORE,J/JSA1	;SAVE E IN ARX LEFT, GET AC

JRA:
.IFNOT/XADDR				;[235]
	BR/AR, AR_AC0			;get AC, save jump address.
=
	ARR_ARL, ARL_0.M, J/JRA1	;E to ARR.
.IF/XADDR				;[235]
	AR12-17_PC SEC			;[235] put section in jump address.
=
	BR/AR, AR_AC0, SKP PC SEC0	;[235] save jump address, get AC.
=0	ARR_ARL, ARL_0.M, J/JRAB	;[235] in section part to ARR.
	ARR_ARL, ARL_0.M, J/JRA1	;[235] E to ARR.
JRAB:	AR12-17_PC SEC, J/JRA1		;[235] section to ARL.
.ENDIF/XADDR				;[235]

JSA1:	FIN STORE,VMA_VMA+1,FETCH	;JUMP TO E+1
	ARR_PC+1,ARL_ARXL,J/STAC	;PC+1,,E GOES TO AC
.TOC	"UUO'S"
;LUUO'S TRAP TO CURRENT CONTEXT
; EXTENDED INSTRUCTION SET IS "HIDDEN" BENEATH LUUO OPCODES
;
;	WARNING:  use extreme caution if E1 for MOVSRJ or CMPSE should
;	ever be used for anything, as they are sign smeared if they are
;	> 377777 (they fall in with MOVSO and friends at EXT2). [301]
;	Use similar caution if new EXTEND codes are created which
;	must have the DCODE B field be 1 or 3.
;
	.DCODE
000:	EA,		J/UUO
	EA,	SJCL,	J/L-CMS		;CMSX HIDDEN BENEATH LUUO
	EA,	SJCE,	J/L-CMS
	EA,	SJCLE,	J/L-CMS

004:	EA,	B/2,	J/L-EDIT	;EDIT
	EA,	SJCGE,	J/L-CMS
	EA,	SJCN,	J/L-CMS
	EA,	SJCG,	J/L-CMS

010:	EA,	B/1,	J/L-DBIN	;CVTDBO
	EA,	B/4,	J/L-DBIN	;CVTDBT
	EA,	B/1,	J/L-BDEC	;CVTBDO
	EA,	B/0,	J/L-BDEC	;CVTBDT

014:	EA,	B/1,	J/L-MVS		;MOVSO
	EA,	B/0,	J/L-MVS		;MOVST
	EA,	B/2,	J/L-MVS		;MOVSLJ
	EA,	B/3,	J/L-MVS		;MOVSRJ

020:	
	EA,		J/L-XBLT	;XBLT
	EA,	AC,	J/L-GTPI	;GSNGL
.IF/EXTEXP				;[337]
	EA,		J/L-SFTE	;GDBLE
	EA,	B/0,	J/L-GTDI	;DGFIX
024:	EA,	B/2,	J/L-GTSI	;GFIX
	EA,	B/4,	J/L-GTDR	;DGFIXR
	EA,	B/6,	J/L-GTSR	;GFIXR
	EA,		J/L-DITE	;DGFLTR
030:	EA,		J/L-SITE	;GFLTR
	EA,		J/L-EFSC	;GFSC
.IFNOT/EXTEXP
	EA,	J/LUUO
	EA,	J/LUUO
024:	EA,	J/LUUO
	EA,	J/LUUO
	EA,	J/LUUO
	EA,	J/LUUO
030:	EA,	J/LUUO
	EA,	J/LUUO
.ENDIF/EXTEXP
	EA,	J/LUUO			;These are reserved to Cobol.
	EA,	J/LUUO
	EA,	J/LUUO
	EA,	J/LUUO
	EA,	J/LUUO
	EA,	J/LUUO
;MONITOR UUO'S -- TRAP TO EXEC

040:	EA,	J/MUUO		;CALL
	EA,	J/MUUO		;INIT
	EA,	J/MUUO
	EA,	J/MUUO
	EA,	J/MUUO
	EA,	J/MUUO
	EA,	J/MUUO
	EA,	J/MUUO		;CALLI
	EA,	J/MUUO		;OPEN
	EA,	J/MUUO		;TTCALL
	EA,	J/MUUO
	EA,	J/MUUO
	EA,	J/MUUO
	EA,	J/MUUO		;RENAME
	EA,	J/MUUO		;IN
	EA,	J/MUUO		;OUT
	EA,	J/MUUO		;SETSTS
	EA,	J/MUUO		;STATO
	EA,	J/MUUO		;GETSTS
	EA,	J/MUUO		;STATZ
	EA,	J/MUUO		;INBUF
	EA,	J/MUUO		;OUTBUF
	EA,	J/MUUO		;INPUT
	EA,	J/MUUO		;OUTPUT
	EA,	J/MUUO		;CLOSE
	EA,	J/MUUO		;RELEAS
	EA,	J/MUUO		;MTAPE
	EA,	J/MUUO		;UGETF
	EA,	J/MUUO		;USETI
	EA,	J/MUUO		;USETO
	EA,	J/MUUO		;LOOKUP
	EA,	J/MUUO		;ENTER

;EXPANSION OPCODES

100:	EA,	J/UUO		;UJEN
	EA,	J/UUO
.IFNOT/EXTEXP
102:	EA,	J/UUO
	EA,	J/UUO
.ENDIF/EXTEXP
	.UCODE
;HERE FOR UNDEFINED OPS (UUO'S) AND ILLEGAL INSTRUCTIONS
;E IS IN AR, OPCODE AND AC IN BRX

;HERE ON LUUO'S
; E IN AR, INSTR IN BRX
1005:
L-CMS:	J/LUUO				;LOC FOR HIDING STRING COMPARE
1006:
L-EDIT:					;HIDE EDIT HERE
.IFNOT/XADDR
LUUO:	ARX_BRX,SC_#,#/13.,
		SKP INTRPT,CALL,J/ROTS	;COMBINE E WITH UUO
1007:	AR_SHIFT,VMA_40,STORE		;STORE OPCODE ETC AT 40
	FIN STORE,VMA_41,
		LOAD ARX,J/XCTW		;GO PERFORM 41
.IF/XADDR
LUUO:	ARX_BRX,SKP PC SEC0,J/LUUO1	;WHICH KIND OF UUO?
=0***0
LUUO1:	SKP -LOCAL AC ADDR,CALL,J/UUOCOM	;EXTENDED.  DO IT
	BR/AR,AR_ARX ANDC ADMSK,	;COMPATABLE.  ADDR TO BR
		SKP INTRPT,J/LUUO2	; DO IT THE OLD WAY
	VMA_#,#/420			;PT LOC FOR LUUO BLOCK POINTER
=
=00	LOAD ARX,PT REF,CALL,J/XFERW	;GET LUUO BLOCK ADDRESS
=10	VMA_ARX,STORE,CALL,J/UUOC2	;STORE UUO OPCODE AND FLAGS
	FIN STORE,VMA_VMA+1,LOAD AR,	;NOW GET A NEW PC
		J/PCA			; [301]

;HERE FOR COMPATIBLE UUO
=0
LUUO2:	AR_AR*BR,AD/OR,VMA_#,#/40,	;SAVE OPCODE AND EA
		STORE,J/LUUO3		;THEN GET INSTR FROM 41
	TAKE INTRPT			;ONE MOMENT, PLEASE
LUUO3:	FIN STORE,VMA_VMA+1,LOAD ARX,J/XCTW
.ENDIF/XADDR

1010:
L-DBIN:	J/LUUO				;DBIN AT 2010
1011:
L-BDEC:	J/LUUO				;BDEC AT 2011
1012:
L-MVS:	J/LUUO				;MOVE STRING AT 2012

;ROTATE SUBROUTINE

=0
ROTS:	AR_SHIFT,ARX_SHIFT,SC_#-SC,#/36.,RETURN3
	TAKE INTRPT
;HERE ON MUUO'S
; E IN AR, OP AND AC IN BRX
.IFNOT/XADDR
1002:					;FIXED ADDRESS TO COOPERATE
					;WITH EXTEND AND OTHER OPS
UUO:					;UNDEFINED OP'S .GE. 100
MUUO:	ARX_BRX,SC_#,#/13.,
		SKP INTRPT,CALL,J/ROTS
.IFNOT/SHIFT.MUUO
1003:	AR_SHIFT,VMA_#,#/424
.IF/SHIFT.MUUO
1003:	AR_SHIFT,VMA_#,#/425
.ENDIF/SHIFT.MUUO
	STORE,UPT REF			;FIRST, STORE INSTRUCTION
	FIN STORE,AR_PC+1,VMA_VMA+1,STORE	;NEXT, PC
=100	MEM_AR,VMA_VMA+1,SC_#,#/60,
		CALL,J/GTEEB1
	DATAI PAG(L),CALL,J/PCTXT	;GET PROCESS CONTEXT VARIABLES
=11	LD PREV CTXT			;PCS FROM PC, CWSX FROM SXCT
	AR_SHIFT,ARL_BRL.S,		;COMBINE UBR WITH AC BLKS, CWSX
		STORE,			; STORE THAT AT 426 (XADDR =427)
		COND/EBUS CTL,EBUS CTL/2; & RELEASE ECL EBUS
	MEM_AR,VMA_430+MODE		;NOW READY TO GET NEW PC
	LOAD AR,UPT REF			;FETCH NEW PC
NEWPC:	AR_MEM,SR_0,J/START		;USE IT
.IF/MODEL.B
SETPC:	VMA_AR AND ADMSK,FETCH,J/NOP	;USE LOW AR AS ADDRESS
.IFNOT/MODEL.B
SETPC:	PC_VMA,J/BRJMP			;LOAD PC, INCLUDING SECTION
.ENDIF/MODEL.B
.IF/XADDR
1002:
UUO:					;A PEDANTIC DISTINCTION...
MUUO:	ARX_BRX,SKP -LOCAL AC ADDR,	;PULL TOGETHER PIECES OF UUO
		CALL,J/UUOCOM
1022:	VMA_430+MODE			;GET NEW PC
	LOAD ARX,UPT REF
	ARX_MEM,VMA_#,#/424		;LOC'N OF MUUO DATA BLOCK
=0	BRX/ARX,STORE,UPT REF,		;STORE OPCODE, FLAGS
		CALL,J/UUOC2		;NOW RETURN TO COMMON CODE
	MEM_AR,AR_PC,SC_#,#/4		;READY TO SETUP NEW FLAGS
=00	VMA_VMA+1,SC_#,#/60,		;SET UP FOR CONTEXT WORD
		SH DISP,AR_0S,		;TEST USER AND PUBLIC FLAGS
		CALL,J/MUUOF		;SET NEW PREV FLAGS, GET EBUS
	DATAI PAG(L),ARX_1B17-1,	;GO COLLECT DATAI PAG INFO
		CALL,J/PCTXT
=11	LD PREV CTXT			;PCS FROM PC, CWSX FROM SXCT
	AR_SHIFT,ARL_BRL.S,		;COMBINE UBR WITH AC BLKS, CWSX
		STORE,			; STORE THAT AT 426 (XADDR =427)
		COND/EBUS CTL,EBUS CTL/2; & RELEASE ECL EBUS
	MEM_AR,AR_BRX,SR_0		;NOW GET NEW PC
SETPC:	VMA_AR AND ADMSK,FETCH,J/NOP

=0
UUOCOM:	ARL_1.M,J/UUOC1			;FORCE AC ADDRESS
	CLR P				;NOT AC, GET CLEAN SECT #
UUOC1:	MQ_AR,AR_ARX ANDC ADMSK		;SAVE ADDR IN MQ.  GET OPCODE
	BR/AR,AR_0.S,SKP USER		;SAVE OPCODE IN BR
=0	AR12-17_PREV SEC		;GET PCS
	AR_AR*BR,AD/OR			;OPCODE/PCS COMBINED
	ARX_AR SWAP,AR_PC FLAGS		;GET FLAGS FROM PC
	ARL_ARL,AR_ARX,RETURN20		;FLAGS AND OPCODE COMBINED
					;GO BACK TO CALLER TO STORE
UUOC2:	MEM_AR,ARX_PC+1			;FINISH STORE
	AR_ARX AND ADMSK,		;PC+1 ADDRESS TO AR
		VMA_VMA+1,STORE,ARX/MQ	;PUT PC AWAY, GET EFFECTIVE ADDR
	FIN STORE,AR_ARX,
		VMA_VMA+1,STORE,RETURN1	;PUT EA AWAY.

=1010					;HERE TO SETUP NEW FLAGS
MUUOF:	SET FLAGS_AR,J/GTEEB1		;GO GET ECL EBUS
	AR0-8_#,#/400,J/MUUOF		;PREV CTXT SUPERVISOR
	AR0-8_#,#/004,J/MUUOF		;  USER/CONCEALED
	AR0-8_#,#/404,J/MUUOF		;  USER/PUBLIC
.ENDIF/XADDR
.TOC	"JSYS, ADJSP"
.IF/DIAG.INST
	.DCODE
104:	EA,		J/DIADISP		;DIAG
	I,	B/0,	J/ADJSP
	.UCODE

;HERE FOR DIAG INSTRUCTION

1001:
DIADISP:	J/DIAGINSTR

.IFNOT/DIAG.INST
	.DCODE
104:	EA,		J/UUO		;JSYS
	I,	B/0,	J/ADJSP
	.UCODE
.ENDIF/DIAG.INST

;HERE FOR ADJSP INSTRUCTION
; ENTER WITH E IN AR, PREFETCH IN PROGRESS

1000:					;PUT ADJSP NEXT TO UUO
.IFNOT/XADDR
ADJSP:	ARL_ARR,ARR_ARR			;PUT E IN BOTH HALVES
	AR_AR*AC0,AD/A+B,INH CRY18,	;ADJUST POINTER,
		ARX/AD,SKP AR0		;SKIP IF NEGATIVE
.IF/XADDR
ADJSP:	ARX_1,ARL_ARR,ARR_ARR		;MUST TEST FOR SHORT STACK
	AC0,STACK UPDATE,		;MCL SHORT STACK ENABLES CRY18
		GEN ARX-1,SKP CRY0	; THUS CRY IFF LONG POINTER
=0	AR_AR*AC0,AD/A+B,INH CRY18,	;ADJUST POINTER,
		ARX/AD,SKP AR0,J/ADJSP1	;SKIP IF NEGATIVE
	ARL_SIGN,ARR_ARR,I FETCH	;LONG:  SIGN EXTEND E
	AR_AR*AC0,AD/A+B,J/STAC		;DONE
.ENDIF/XADDR
=0
ADJSP1:	GEN AR*AC0,AD/ANDCA,		;TEST FOR - TO + CHANGE
		SKP AD0,J/STMAC
	GEN AR*AC0,AD/ANDCB,		;TEST FOR + TO - CHANGE
		SKP AD0,J/STMAC
.TOC	"XCT, PXCT, SXCT"
;HERE FOR EXTENDED ADDRESSING INSTRUCTIONS

=0
XCT1:	SKP USER,J/PXCT			;HERE ON XCT, NO INTERRUPT
	TAKE INTRPT			;GET OUT OF LONG XCT CHAIN
=0
PXCT:	SET PXCT			;SETUP PXCT CONTROLS FROM 9-12
UXCT:	ARX_AR (AD),LOAD IR,#/0,J/XCTGO	;COPY INSTR TO ARX, IR

	.DCODE
.IFNOT/SXCT
  .IF/DIAG.INST
106:	R,	J/DIAGXCT			;DIAG MODEL B SXCT = XCT
	EA,	J/XCTUUO
.UCODE
			;UNSUPPORTED FEATURE
			;SEPERATE FROM XCT BECAUSE OF DRAM CONSTRAINTS
=0****00***0
DIAGXCT:	SKP INTRPT,J/XCT1		;CHECK FOR XCT . LOOP
XCTUUO:	J/UUO				;INST PAIR FOR XCT
=
  .IFNOT/DIAG.INST
   .IFNOT/EXTEXP
    .IFNOT/PUSHM
106:	EA,	J/UUO
	EA,	J/UUO
	.UCODE
    .IF/PUSHM
106:	R,	J/PUSHM			;PUSH MULTIPLE
107:	EA,	J/POPM			;POP MULTIPLE
.UCODE
    .ENDIF/PUSHM
   .ENDIF/EXTEXP
  .ENDIF/DIAG.INST

.IF/SXCT	;NOTE: THE SXCT INSTRUCTION IS A TEMPORARY MECHANISM
106:	R,	J/SXCT		;INTENDED FOR DIAGNOSTICS ONLY
	EA,	J/UUO107
	.UCODE

1014:					;PUT NEXT TO UUO107
SXCT:	SKP KERNEL,CALL,J/IOCHK		;LEGAL IN KERNEL MODE ONLY
1015:	BR/AR,ARX_AR,AR_AC0,		;SHUFFLE INSTR TO GET BASE REG
		SET SXCT		;SETUP HARDWARE FLAGS
	SKP AC#0			;CHOOSE LOOP FOR EA CALC
=0	BR/AR,AR_BR,LOAD IR,		;AC0 IS BASE INDEX
		BRX/ARX,ARL_0.M,
		EA MOD DISP,J/SXCTB
	AR_BR,LOAD IR,ARL_0.M,		;GET EXT ADDR FROM XR OR INDRCT
		BRX/ARX,J/XIND2
=00
PXLOOP:	GEN AR,A READ			;GO DO INSTR
	AR_AR+XR,A READ
	GEN AR,A INDRCT,SKP INTRPT,J/XIND1
	GEN AR+XR,A INDRCT,SKP INTRPT

=0
XIND1:	AR_MEM,ARX_MEM,EA TYPE DISP,J/XIND2
	MB WAIT,TAKE INTRPT
=00
XIND2:	EA MOD DISP,J/PXLOOP		;CURRENT OR PREV WITHOUT CWSX
	AR_ARX (AD),A READ		;PREV AND CWSX
	AR_ARX (AD),A READ		;SXCT 0,
	EA MOD DISP,J/SXCTB		;SXCT B,

=00
SXCTB:	AR_AR+BR,A READ			;GO
	AR_AR+XR,ARL_0.C,J/SXCTB	;NO MORE INDIRECTS
	GEN AR,A INDRCT,		;FOLLOW INDRCT POINTER
		SKP INTRPT,J/XIND1
	GEN AR+XR,A INDRCT,
		SKP INTRPT,J/XIND1
.ENDIF/SXCT
  