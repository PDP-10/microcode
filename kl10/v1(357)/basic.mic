.TOC	"THE INSTRUCTION LOOP"

;	Comments updated [302][344]
;
;INSTRUCTION DECODE, EA COMPUTATION, AND OPERAND FETCH
;
;	IN GENERAL, AN INSTRUCTION IS STARTED AT XCTGO.
; AT THIS TIME THE INSTRUCTION IS IN ARX AND IR, AND PC HAS ITS ADDRESS.
; THE DRAM OUTPUTS AND "AC" BITS WILL SETTLE DURING THIS
; MICROINSTRUCTION, AND WILL BE LATCHED BY THE CLOCK WHICH ENDS
; THE CYCLE.  XCTGO DISPATCHES ON THE STATE OF THE
; INDIRECT AND INDEX BITS OF THE ARX (EA MOD DISP) TO COMPEA OR
; ONE OF THE THREE LOCATIONS FOLLOWING IT.
;	IF INDIRECT IS SPECIFIED, THE INDIRECT POINTER IS FETCHED (AT
; COMPEA+2 OR +3 DEPENDING ON WHETHER INDEXING IS ALSO SPECIFIED).
; WE WAIT FOR IT AT INDRCT, AND THEN LOOP BACK TO COMPEA.  WHEN NO
; INDIRECT IS CALLED FOR, WE COMPUTE THE INSTRUCTION'S EFFECTIVE ADDRESS
; (EA) AT COMPEA OR COMPEA+1 (DEPENDING ON WHETHER INDEXING IS CALLED
; FOR), AND PERFORM THE FUNCTION "A READ", WHOSE OPERATION DEPENDS
; ON THE DRAM A FIELD, AS FOLLOWS:
;
; MACRO	 A-FLD	MEM FUNCTION	VMA	DISPATCH
;  I	  0	NONE		AD(=EA)  DRAM J
; I-PF	  1	FETCH		PC+1	 DRAM J
; EA	  2	30 BIT EA CALC	AD	 DRAM J
;  W	  3	WR TST		AD	   3 (MODEL B)	43 (MODEL A)
;  R	  4	READ		AD	   4		44
; R-PF	  5	READ		AD	   5		45
; RW	  6	READ/WR TST	AD	   6		46
; RPW	  7	RD-PSE/WR TST	AD	   7		47
;
;	A FIELD VALUES 0 AND 1 ARE USED FOR INSTRUCTIONS WHICH NEITHER
; READ NOR WRITE THE CONTENTS OF EA (IMMEDIATE-MODE INSTRUCTIONS,
; JUMPS, ETC).  THESE DISPATCH FROM "A READ" DIRECTLY TO THE MICROCODE
; WHICH HANDLES THE INSTRUCTION.  IF THE A FIELD CONTAINS 1, "A READ"
; CAUSES A PREFETCH (FROM PC+1), SO THAT THE MBOX CAN WORK ON GETTING
; THE NEXT INSTRUCTION INTO ARX WHILE THE EBOX PERFORMS THIS ONE.
;	IF THE A FIELD CONTAINS A 2, THE EA CALCULATION WILL PROVIDE
; A FULL 30 BIT EFFECTIVE ADDRESS TO THE AD AT THE END.  THIS WAS
; INTRODUCED WITH EXTENDED ADDRESSING, TO ALLOW SUCH INSTRUCTIONS AS
; XMOVEI AND XHLLI TO COMPUTE A COMPLETE ADDRESS WITHOUT ACTUALLY
; REFERENCING IT.  OTHERWISE, THIS IS SIMILAR TO AN A FIELD OF 0.  NOTE
; THAT AN A FIELD OF 0 WILL STILL PROVIDE A 30 BIT ADDRESS TO THE VMA;
; ONLY THE RESULT IN THE AD WILL BE DIFFERENT.
;	IF THE A FIELD CONTAINS 3, THE MBOX PERFORMS A PAGING CHECK ON
; EA, AND CAUSES A PAGE FAIL IF THAT LOCATION IS NOT WRITABLE.
; THE MICROCODE GOES TO 3 TO WAIT FOR COMPLETION OF THE PAGE CHECK,
; AND AT THAT LOCATION LOADS AC INTO AR.  THE WRITABILITY OF EA IS
; VERIFIED AT THIS TIME TO PREVENT INCORRECTLY SETTING FLAGS OR
; THE PROCESSOR STATE IF THE INSTRUCTION WILL BE ABORTED BY PAGE
; FAILURE.  LOCATION 3 THEN DISPATCHES TO THE HANDLER FOR THE
; CURRENT INSTRUCTION.
;	A FIELD VALUES 4 TO 7 PERFORM READS FROM EA.  6 AND 7 ALSO TEST
; THE WRITABILITY OF THE LOCATION, AND 7 PERFORMS THE FIRST HALF OF
; A READ-PAUSE-WRITE CYCLE IF EA IS AN UN-CACHED ADDRESS.  THE DISPATCH
; IS TO A, WHERE WE WAIT FOR MEMORY DATA TO ARRIVE IN AR.  IF THE A
; FIELD WAS 5, WE PREFETCH FROM PC+1 AS SOON AS THE DATA ARRIVES.
; IN ANY CASE, WE DISPATCH ACCORDING TO THE DRAM J FIELD TO THE
; HANDLER FOR THE INSTRUCTION.
;	IF A PAGE FAIL OCCURS AT ANY TIME (EITHER IN THIS CODE OR DURING
; INSTRUCTION EXECUTION) THE MICROPROCESSOR TRAPS TO CRAM LOCATION
; 1777 OR 3777, WHERE IT CAUSES A PAGE FAIL TRAP.
;
;	MOST INSTRUCTIONS (THE MOVE, HALFWORD, AND BOOLEAN GROUPS,
; PLUS ADD AND SUB) ARE PERFORMED BY HANDLERS CONSISTING OF ONE OR
; TWO MICROINSTRUCTIONS WHICH LEAVE THE RESULT IN AR, AND COMPLETE
; BY INVOKING THE "EXIT" MACRO.  EXIT USES THE MEM/B WRITE FUNCTION
; TO BEGIN A STORE TO MEMORY FOR THOSE MODES IN WHICH THE RESULT
; GOES TO MEMORY, AND DISP/DRAM B TO GET TO ONE OF THE MICROINSTRUCTIONS
; FOLLOWING ST0.  THIS CODE DEPENDS ON A CERTAIN AMOUNT OF CORRELATION
; BETWEEN THE DRAM A AND B FIELDS.  IN PARTICULAR, STAC (STORE AC)
; ASSUMES THAT A PREFETCH HAS OCCURRED, WHILE THE OTHERS ASSUME THAT
; NO PREFETCH HAS OCCURED.  THUS NORMAL AND IMMEDIATE MODES, WHOSE
; RESULTS GO ONLY TO AC, MUST PREFETCH IN THE DRAM A FIELD, WHILE
; MEM, BOTH, AND SELF MODES, WHOSE RESULTS GO TO MEMORY, MUST NOT.
; (THIS RESTRICTION IS AVOIDED FOR THOSE INSTRUCTIONS WHICH NEVER
; PREFETCH -- IN MUL, DIV, AND IDIV BY USE OF THE EXIT TO ST2AC,
; AND IN IMUL AND THE SINGLE PRECISION FLOATING POINT
; INSTRUCTIONS BY A RESTRICTED EXIT TO ST6.)
;	ANOTHER LARGE SET OF INSTRUCTIONS (SKIP, AOS, SOS, JUMP, AOJ,
; SOJ, AOBJ, CAI, CAM, AND THE TEST GROUP) KNOWS WHERE TO PUT THE
; RESULTS WITHOUT MODE INFORMATION, AND THEY USE THE DRAM B FIELD TO
; DETERMINE WHETHER TO SKIP OR JUMP, AS A FUNCTION OF THEIR OPERANDS.
; SKIP, AOS, AND SOS ARE CONSIDERED SELF-MODE INSTRUCTIONS,
; AND AFTER MAKING THE FETCH DECISION (AND RE-WRITING MEMORY, IN
; THE CASE OF AOS OR SOS), JUMP TO STSELF TO DECIDE WHETHER OR NOT
; TO PUT THE RESULT ALSO IN AC.  THE OTHER INSTRUCTIONS OF THIS SET
; JUMP TO STORAC OR NOP AFTER MAKING THE FETCH DECISION, DEPENDING
; ON WHETHER OR NOT THE OPCODE DEFINITION REQUIRES MODIFICATION OF AC.
; (NOTE THE DIFFERENCE BETWEEN STAC AND FINI ON THE ONE HAND,
; AND STORAC AND NOP ON THE OTHER -- STORAC AND NOP MUST BE USED WHEN
; THE NEXT INSTRUCTION FETCH OCCURS ON THE PRECEDING EBOX CYCLE, BECAUSE
; NICOND MUST NOT IMMEDIATELY FOLLOW A FETCH (ONE CYCLE REQUIRED FOR
; VMA AC REF TO MAKE IT THROUGH THE NICOND LOGIC), STAC AND FINI ARE
; USED WHEN THERE HAS BEEN AN INTERVENING CYCLE.)
.TOC	"NEXT INSTRUCTION DISPATCH"

;START BY PUTTING PC WORD IN AR, JUMP HERE
0:
.IFNOT/MODEL.B
START:	SET FLAGS_AR,VMA_AR,MEM/SEC 0,	;LOAD FLAGS, CLEAR VMAX
		BR/AR,J/SETPC		;THEN JUMP TO ADDR IN AR
.IF/MODEL.B
START:	SET FLAGS_AR,J/SETPC		;LOAD FLAGS, USE REST AS ADDR
.ENDIF/MODEL.B
1:					;MUST BE AT START+1
CONT:	VMA/PC,FETCH,J/XCTW		;HERE TO CONTINUE FROM PC
;
;	Comments updated [321].
;
;	DISP/NICOND (THE "NXT INSTR" MACRO) BRINGS US TO ONE OF THE
; LOCATIONS FOLLOWING "NEXT".  PC HAS BEEN UPDATED TO ADDRESS THE NEXT
; INSTRUCTION IN THE NORMAL FLOW, AND IF IT IS FROM MEMORY
; (AS OPPOSED TO AC'S), THE INSTRUCTION IS IN ARX AND IR.
;	THE NICOND DISPATCH IS PRIORITY ENCODED, AS FOLLOWS:
; [FOR FULL DETAILS, SEE PRINT CON2]
;(1)	IF PI CYCLE IS TRUE, GO TO NEXT FOR SECOND HALF
; OF STANDARD OR VECTOR INTERRUPT.
;(2)	IF THE RUN FLOP (CON RUN) IS OFF, GO TO NEXT+2, FROM WHICH THE
; MICROCODE WILL ENTER THE HALT LOOP TO WAIT FOR THE CONSOLE TO RESTART
; INSTRUCTION PROCESSING.
;(3)	IF THE METER HAS A REQUEST, GO TO NEXT+4 (MTRINT) TO SERVE IT.
;(4)	IF THE PI SYSTEM HAS A REQUEST READY, GO TO NEXT+6 (INTRPT)
; TO START A PI CYCLE.
;(5)	IF CON UCODE STATE 05 (TRACK EN) IS SET, GO TO NEXT+10 OR 11.
; Normally NEXT+10 will be used; if a trap flag was set by the previous
; instruction, however, NEXT+11 will be reached.  This is the only
; way the trap will ever be detected, so be cautious of ignoring it.
; THIS FLOP IS ENTIRELY UNDER CONTROL OF THE MICROCODE, AND IS ONLY
; USED FOR THE SPECIAL STATISTICS-GATHERING MICROCODE.
;(6)	IF THE LAST INSTRUCTION SET A TRAP FLAG, GO TO NEXT+13 OR +17,
; IT DOESN'T MATTER WHICH.  (NEXT+17 will be reached if VMA contains
; an AC address, probably irrelevant when a trap flag was set.)
;(7)	IF VMA CONTAINS AN AC ADDRESS, IMPLYING THAT THE NEXT
; INSTRUCTION IS TO COME OUT OF FAST MEMORY, GO TO NEXT+16 TO GET IT.
;(10)	--NORMAL CASE-- THE INSTRUCTION IS IN ARX, READY TO GO, GO
; TO NEXT+12 (XCTGO).
;
;	The NICOND dispatch yields the following:
;
;	+0	CON PI CYCLE
;	+1	Unused
;	+2	-CON RUN (i.e. halt)
;	+3	Unused
;	+4	CON MTR INT REQ (meter interrupt)
;	+5	Unused
;	+6	CON INT REQ (interrupt)
;	+7	Unused
;	+10	CON UCODE STATE 05 (tracks enable)
;	+11	CON UCODE STATE 05+TRAP REQ (tracks enable+trap)
;	+12	-VM AC REF (normal instruction)
;	+13	-VM AC REF+TRAP REQ (normal instruction+trap)
;	+14	Unused
;	+15	Unused
;	+16	-CON PI CYCLE (AC ref)
;	+17	-CON PI CYCLE+TRAP REQ (AC ref+trap)
;NICOND (NXT INSTR) DISPATCH BLOCK

=11*0000				;USE LOC'NS INACCESSIBLE TO DRAM
NEXT:	AR_MQ+1,VMA/AD,			;2ND PART OF INTERRUPT
		SET PI CYCLE,J/PICYC2	;CONTINUE WITH 41+2N
=0010	CLR AR,ARX_1S,SC_#,#/23.,	;HERE IF RUN FLOP OFF
		CALL,J/ROTS		;BUILD ADDR MASK
.IFNOT/EXTEXP				;[230]
.IFNOT/OWGBP				;[344]
	ADMSK,FM_AR,AR_AR+1,J/CHALT	;SAVE MASK, GO HALT
.IF/OWGBP				;[344]
	FM[ADMSK]_AR,AR_AR*2,J/EXMSK	;[230] AR HAS 77,,777776
.ENDIF/OWGBP				;[344]
.IF/EXTEXP				;[230]
	FM[ADMSK]_AR,AR_AR*2,J/EXMSK	;[230] AR HAS 77,,777776
.ENDIF/EXTEXP				;[230]
=0100
MTRINT:	CLR ACCOUNT EN,J/MTRREQ		;HERE IF METER REQUEST UP
	AR_EBUS,SC_#,#/2,J/PICYC1	;HERE IF TAKE INTRPT DOESNT FIND
=0110					; A METER REQUEST
INTRPT:	AR_EBUS,SC_#,#/2,J/PICYC1	;HERE IF INTERRUPT PENDING
;
;	[321] Even if statistics are enabled, traps should not be lost,
;	so override TRACKS and friends when TRAP is set.
;
.IF/TRACKS
=1000	AR_TRX+1,GEN CRY18,SKP CRY0,J/TRK1;STORE PC BEFORE EXECUTING INSTR
	VMA_420+TRAP,J/TRAPX		;[321] Don't lose traps!
.ENDIF/TRACKS
.IF/OP.CNT
=1000	SC_#,#/9.,SKP USER,J/OPCT1	;COUNT THIS INSTR
	VMA_420+TRAP,J/TRAPX		;[321] Don't lose traps!
.ENDIF/OP.CNT
.IF/OP.TIME
=1000	AR_2,CLR TRK+PA EN,J/OPTM0	;TIME THIS INSTR
	VMA_420+TRAP,J/TRAPX		;[321] Don't lose traps!
.ENDIF/OP.TIME
.IF/SO.CNT
=1000
TRK0:	ARX_TRB,BRX/ARX,SKP AC REF,J/TRK1;GET PREV INSTR HOLD THIS INSTR
	VMA_420+TRAP,J/TRAPX		;[321] Don't lose traps!
.ENDIF/SO.CNT
.IF/SO2.CNT
=1000
TRK0:	ARX_TRB,BRX/ARX,SKP AC REF,J/TRK1;GET PREV INSTR HOLD THIS INSTR
	VMA_420+TRAP,J/TRAPX		;[321] Don't lose traps!
.ENDIF/SO2.CNT
=1010
XCTGO:	BRX/ARX,AR_ARX,SET ACCOUNT EN,	;SAVE INSTR, SIGN EXTEND Y,
		XR,EA MOD DISP,J/COMPEA	; GO CALCULATE EA
TRAP:	VMA_420+TRAP,J/TRAPX		;HERE IF TRAP BITS SET
=1110	ARX_FM(VMA),TIME/3T,LOAD IR,J/XCTGO	;HERE IF INSTR IS IN FM
	VMA_420+TRAP,J/TRAPX		;HERE IF TRAP BITS SET

;HERE ON TRAPS, VMA SETUP WITH 420+TRAP CODE
=11****
TRAPX:	LOAD ARX,PT REF			;GET AND XCT TRAP INSTR
=11****	SET PC+1 INH			;DON'T INCREMENT PC FOR THIS INSTR

;HERE AFTER FETCHING INSTR TO BE EXECUTED

=11****
XCTW:	ARX_MEM,LOAD IR,J/XCTGO		;GET INSTR TO XCT
.IF/EXTEXP				;[230]
EXMSK:	AR_AR+1				;[230] GIVES 77,,777777
	FM[EXPMSK]_AR,J/CHALT		;[230] MASK FOR FORTRAN EXT EXP
.IFNOT/EXTEXP				;[344]
.IF/OWGBP				;[344]
EXMSK:	AR_AR+1				;[230] GIVES 77,,777777
	FM[EXPMSK]_AR,J/CHALT		;[230] MASK FOR FORTRAN EXT EXP
.ENDIF/OWGBP				;[344]
.ENDIF/EXTEXP				;[230]
.TOC	"EFFECTIVE ADDRESS COMPUTATION AND OPERAND FETCH"

.IF/XADDR
=11*0000
EFIW:	AR_ARX (AD),GLOBAL,A INDRCT,	;LONG EXTENDED ADDR
		SKP INTRPT,J/INDRCT	;WITH INDIRECT SET
	AR_ARX+XR,GLOBAL,A INDRCT,
		SKP INTRPT,J/INDRCT
	AR_ARX (AD),GLOBAL,A INDRCT,
		SKP INTRPT,J/INDRCT
	AR_ARX+XR,GLOBAL,A INDRCT,
		SKP INTRPT,J/INDRCT

	AR_ARX (AD),GLOBAL,A READ	;LONG EXTENDED ADDR
	AR_ARX+XR,GLOBAL,A READ		; WITH INDEXING IN 2-5
	AR_ARX (AD),GLOBAL,A READ
	AR_ARX+XR,GLOBAL,A READ

PF24:	GET ECL EBUS,J/ILLIND		;[234]ARX BITS 0,1 = 11
	GET ECL EBUS,J/ILLIND
	GET ECL EBUS,J/ILLIND
	GET ECL EBUS,J/ILLIND

.ENDIF/XADDR

=11*1100
COMPEA:	GEN AR,A READ			;LOCAL
	GEN AR+XR,INDEXED,A READ	;LOCAL UNLESS XR>0
	GEN AR,A INDRCT,
		SKP INTRPT,J/INDRCT
	GEN AR+XR,INDEXED,A INDRCT,
		SKP INTRPT,J/INDRCT
.IFNOT/MODEL.B
=11***0
INDRCT:	ARX_MEM,EA TYPE DISP,J/INDR1
TAKINT:	ARX_MEM,TAKE INTRPT
=11**01
INDR1:	AR_ARX,XR,EA MOD DISP,J/COMPEA
.IF/SXCT
	AR_ARX (AD),A READ		;HERE IF SXCT 0,
.IFNOT/SXCT
=
.ENDIF/SXCT
.IF/MODEL.B
.IFNOT/XADDR
=11***0
INDRCT:	ARX_MEM,J/INDR1
TAKINT:	ARX_MEM,TAKE INTRPT

=11****
INDR1:	AR_ARX,EA MOD DISP,J/COMPEA
.IF/XADDR
=11***0
INDRCT:	ARX_MEM,LONG EN,J/INDR1
TAKINT:	ARX_MEM,TAKE INTRPT
=11****
INDR1:	AR_ARX,XR,EA MOD DISP,
		FE_#,#/24,TIME/3T,J/EFIW

ILLIND:	VMA_VMA HELD, FE_#, #/24	;[234]ILLEGAL INDIRECT PF
	SC_#, #/140			;[234][242]
					;[271]MASK TO INSERT PF CODE.
	MAP, J/PFPAR2			;[234]GET MAP INFO, JOIN PF ROUTINE
.ENDIF/XADDR
.ENDIF/MODEL.B
.TOC	"WAIT FOR (E)"

;THE EXECUTE CODE FOR EACH INSTRUCTION IS ENTERED WITH
; THE OPCODE AND AC # IN BRX AND IR, THE LAST INDIRECT WORD
; IN ARX, AND AR AND VMA SETUP AS A FUNCTION OF THE A
; FIELD OF THE DISPATCH RAM. A PREFETCH IS IN PROGRESS IF THE
; DRAM A FIELD WAS 1 OR 5 (OR IF IR CONTAINS "JRST 0,").

;ON "A READ", THE HARDWARE DISPATCHES TO THE EXECUTE CODE FOR
; THE INSTRUCTION IF THE DRAM A FIELD IS 0-2.  IF THE A FIELD
; CONTAINS 3-7, THE HARDWARE DISPATCHES TO A (MODEL B), OR 40+A
; (MODEL A), BELOW:

;COME HERE ON "A READ" FUNCTION IF DRAM A FIELD IS 3
; A "WRITE TST" IS IN PROGRESS

.IF/MODEL.B
3:
.IFNOT/MODEL.B
43:
.ENDIF/MODEL.B
	BR/AR,AR_AC0,MB WAIT,		;WAIT FOR PERMISSION TO WRITE
		TIME/3T,IR DISP,J/0	;AND GO TO EXECUTE CODE

;HERE ON "A READ" FUNCTION IF DRAM A FIELD IS 4
; A "LOAD AR" IS IN PROGRESS.  We load FE with 2 for LDB and DPB. [337]

.IF/MODEL.B
4:
.IFNOT/MODEL.B
44:
.ENDIF/MODEL.B
	BR/AR,AR_MEM,TIME/3T,FE_#,#/2,	;GET OPERAND, set up FE for byte
		IR DISP,J/0		; instructions [337], and go
;HERE ON "A READ" IF A FIELD IS 5
; A "LOAD AR" IS IN PROGRESS, AND WE MUST PREFETCH WHEN IT COMPLETES

.IF/MODEL.B
5:
.IFNOT/MODEL.B
45:
.ENDIF/MODEL.B
	BR/AR,FIN XFER,I FETCH,		;GET OPERAND, PREFETCH,
		TIME/3T,IR DISP,J/0	; & START EXECUTE

;HERE ON "A READ" IF A FIELD IS 6
; A "LOAD AR" IS IN PROGRESS, BUT PAGING IS TESTING WRITABILITY
; We load FE with 2 for ILDB and IDPB. [337]
.IF/MODEL.B
6:
.IFNOT/MODEL.B
46:
.ENDIF/MODEL.B
	BR/AR,AR_MEM,TIME/3T,FE_#,#/2,	;GET OPERAND, load FE for byte
		IR DISP,J/0		; instructions [337], and go

;HERE ON "A READ" IF A FIELD IS 7
; A "READ-PAUSE-WRITE" IS IN PROGRESS

.IF/MODEL.B
7:
.IFNOT/MODEL.B
47:
.ENDIF/MODEL.B
	BR/AR,AR_MEM,TIME/3T,		;GET OPERAND
		IR DISP,J/0		; START EXECUTE
.TOC	"TERMINATION"

;DISPATCH HERE WITH THE "EXIT" MACRO,
; OR JUMP DIRECTLY TO ONE OF THESE LOCATIONS.

=11*000
ST0:					;BASE FOR B DISP IN EXIT MACRO
=001
ST2AC:	AC0_AR,AR_SIGN,I FETCH,J/STD1	;HERE TO STORE AC0 & AC1
	FIN STORE,EXIT DBL		;MULB, DIVB, ETC ...
	FIN STORE,I FETCH,		;SELF MODE
		SKP AC#0,J/STSELF	; RESULT TO AC TOO?
SHFLOD:	AR_SHIFT			;[337] Shift byte load result
STAC:	AC0_AR,NXT INSTR		;NORMAL AND IMMEDIATE MODES
ST6:
IFNOP:
STMEM:	FIN STORE,I FETCH,J/NOP		;MEM MODE
IFSTAC:
STBOTH:	FIN STORE,I FETCH,J/STORAC	;BOTH MODE
=
;HERE TO FINISH, AFTER FETCHING NEXT INSTRUCTION.
; WE MUST GUARANTEE AT LEAST ONE EBOX CYCLE BETWEEN FETCH AND NICOND,
; TO ALLOW VMA AC REF TO MAKE IT THROUGH THE NICOND LOGIC.
=11***0
STSELF:					;SKIP, AOS, SOS COME HERE
STORAC:	SR_0,J/STAC			;STORE AC, TOO
NOP:	SR_0,J/FINI

=0
CLRFPD:	CLR FPD,J/FINI			;CAN'T DO THIS UNTIL STORE COMPLETE
NOP2:	SR_0,J/FINI			;THE CODE SEEMS TO WORK WITHOUT THIS
					; BUT THE TIMING IS VERY HAIRY AND
					; THE HARDWARE PROBABLY ISN'T
					; SUPPOSED TO

FINI:	NXT INSTR			;GET NEXT INSTR IN ARX & IR,
					; LOAD PC, TEST PI CYCLE, RUN,
					; PI READY, TRAPS

;HERE TO STORE ARITHMETIC DOUBLE RESULTS

DSTAC:	AC0_AR,AR_SIGN			;HERE WITH FETCH STARTED
STD1:	AR_SHIFT,SR_0			;BRING IN LOW PART
;
;	[356] The next two locations are fixed at 136 and 137.  We don't
;	really care where they are, but the front end looks at the # field
;	of these to get the microcode major version (# bits 0-5 of 136),
;	minor version (# bits 6-8 of 136), and edit number (# bits 0-8 of
;	137).
;	
136:					;[357]
STAC1:	AC1_AR,FINISH,			;GO DO NEXT INSTRUCTION
		MAJVER/MAJOR,MINVER/MINOR;[356]
;
;HERE TO GET MICRO-CODE VERSION #.  FIXED LOC'N SO SOFTWARE CAN FIND IT
;
137:
UVERS:	BR/AR,AR0-8_#,#/EDIT,J/GTAR08	;COPY VERSION TO AR
.TOC	"MOVE GROUP, EXCH, BLT"

	.DCODE
200:	R-PF,	AC,	J/MOVE	;BASIC MOVE
	I-PF,	AC,	J/MOVE
.IF/WRTST
	W,	M,	J/MOVE
.IFNOT/WRTST
	I,	B/1,	J/MOVEM
.ENDIF/WRTST
	RPW,	S,	J/MOVE

204:	R-PF,	AC,	J/MOVS
	I-PF,	AC,	J/MOVS
	W,	M,	J/MOVS
	RPW,	S,	J/MOVS

210:	R-PF,	AC,	J/MOVN
	I-PF,	AC,	J/MOVN
	W,	M,	J/MOVN
	RPW,	S,	J/MOVN

214:	R-PF,	AC,	J/MOVM
	I-PF,	AC,	J/MOVM
	W,	M,	J/MOVM
	RPW,	S,	J/MOVM
	.UCODE

; ENTER WITH 0,E, (E), OR (AC) IN AR
=0****00****
MOVS:	AR_AR SWAP,EXIT			;ALSO USED BY HALFWORD GROUP
=
=0****00****
MOVM:	BR/AR,SKP AR0,J/MOVE		;FORCE POSITIVE
=
=0****00****
MOVN:	BR/AR,J/MOVNEG			;GET NEGATIVE
=
100:
MOVE:	EXIT				;STORE AS IS FROM AR
101:
MOVNEG:	AR_-BR,AD FLAGS,FETCH WAIT,J/MOVE
.TOC	"XMOVEI, XHLLI, MOVEM, EXCH, BLT"

;HERE FOR XMOVEI (=SETMI), WITH 36-BIT ADDRESS IN VMA AND AR

.IF/XADDR
102:
XMOVEI:	SKP -LOCAL AC ADDR,I FETCH
=0
XMOVEI1:ARL_1.M,ARR_ARR,J/STAC		;AC IN NON-ZERO SECTION
	CLR P,J/STAC			;RETURN 30-BIT ADDRESS

;HERE FOR XHLLI (=HLLI), WITH 36-BIT ADDRESS IN VMA AND AR
107:
XHLLI:	SKP -LOCAL AC ADDR,I FETCH,
		ARR_AC0.S,ARL_ARL.S,J/XMOVEI1
.ENDIF/XADDR

;EXCH, BLT

	.DCODE
250:	RPW,	B/0,	J/EXCH
	EA,		J/BLT
	.UCODE

103:
MOVEM:					;LIKE EXCH, EXCEPT NO STORE AC
EXCH:	ARX_AR,AR_AC0,STORE,J/STMAC	;PUT AC AT E, THEN STORE AC
104:
BLT:	MQ_AR,ARX_AR,			;END ADDR TO MQ & ARX
		ARR_AC0,ARL_ARL,J/BLT1	;FIRST DEST ADDR TO AR
.TOC	"HALFWORD GROUP"
;	DESTINATION LEFT HALF

	.DCODE
500:	R-PF,	AC,	J/HLL
.IF/XADDR
	EA,	AC,	J/XHLLI		;GET 36 BIT ADDRESS IN AR AND VMA
.IFNOT/XADDR
	I-PF,	AC,	J/HLL
.ENDIF/XADDR
	RPW,	M,	J/HRR		;HLLM = HRR EXCEPT FOR STORE
	RPW,	S,	J/MOVE		;HLLS = MOVES

	R-PF,	AC,	J/HRL
	I-PF,	AC,	J/HRL
	RPW,	M,	J/HRLM
	RPW,	S,	J/HRLS

510:	R-PF,	AC,	J/HLLZ
	I-PF,	AC,	J/HLLZ
	W,	M,	J/HLLZ
	RPW,	S,	J/HLLZ

	R-PF,	AC,	J/HRLZ
	I-PF,	AC,	J/HRLZ
	W,	M,	J/HRLZ
	RPW,	S,	J/HRLZ

520:	R-PF,	AC,	J/HLLO
	I-PF,	AC,	J/HLLO
	W,	M,	J/HLLO
	RPW,	S,	J/HLLO

	R-PF,	AC,	J/HRLO
	I-PF,	AC,	J/HRLO
	W,	M,	J/HRLO
	RPW,	S,	J/HRLO

530:	R-PF,	AC,	J/HLLE
	I-PF,	AC,	J/HLLE
	W,	M,	J/HLLE
	RPW,	S,	J/HLLE

	R-PF,	AC,	J/HRLE
	I-PF,	AC,	J/HRLE
	W,	M,	J/HRLE
	RPW,	S,	J/HRLE
;	DESTINATION RIGHT HALF

540:	R-PF,	AC,	J/HRR
	I-PF,	AC,	J/HRR
	RPW,	M,	J/HLL		;HRRM = HLL EXCEPT FOR STORE
	RPW,	S,	J/MOVE		;HRRS = MOVES

	R-PF,	AC,	J/HLR
	I-PF,	AC,	J/HLR
	RPW,	M,	J/HLRM
	RPW,	S,	J/HLRS

550:	R-PF,	AC,	J/HRRZ
	I-PF,	AC,	J/HRRZ
	W,	M,	J/HRRZ
	RPW,	S,	J/HRRZ

	R-PF,	AC,	J/HLRZ
	I-PF,	AC,	J/HLRZ
	W,	M,	J/HLRZ
	RPW,	S,	J/HLRZ

560:	R-PF,	AC,	J/HRRO
	I-PF,	AC,	J/HRRO
	W,	M,	J/HRRO
	RPW,	S,	J/HRRO

	R-PF,	AC,	J/HLRO
	I-PF,	AC,	J/HLRO
	W,	M,	J/HLRO
	RPW,	S,	J/HLRO

570:	R-PF,	AC,	J/HRRE
	I-PF,	AC,	J/HRRE
	W,	M,	J/HRRE
	RPW,	S,	J/HRRE

	R-PF,	AC,	J/HLRE
	I-PF,	AC,	J/HLRE
	W,	M,	J/HLRE
	RPW,	S,	J/HLRE

	.UCODE
;FIRST, THE 16 OPS WHICH DO NOT AFFECT THE "OTHER" HALF.
;THESE MUST BE TREATED SEPARATELY, BECAUSE THEY COMBINE MEMORY DATA
;IN AR WITH DATA FROM THE FM.  ENTER WITH 0,E OR (E) IN AR.

105:
HRR:	ARL_AC0,ARR_ARR,EXIT		;HRR, HRRI, HLLM
106:
HLL:	ARR_AC0,ARL_ARL,EXIT		;HLL, HLLI, HRRM
			;HRRS, HLLS ARE BOTH EQUIVALENT TO MOVES
=0****00****
HRL:	ARL_ARR,ARR_AC0,EXIT		;HRL, HRLI
=
=0****00****
HLR:	ARR_ARL,ARL_AC0,EXIT		;HLR, HLRI
=
=0****00***0
HRLM:	ARL_ARR,ARR_AC0,J/MOVS		;HRLM
HRLS:	ARL_ARR,ARR_ARR,EXIT		;HRLS
=
=0****00***0
HLRM:	ARR_ARL,ARL_AC0,J/MOVS		;HLRM
HLRS:	ARR_ARL,ARL_ARL,EXIT		;HLRS
=
;NOW THE HALFWORD OPS WHICH CONTROL THE "OTHER" HALF
; ENTER WITH 0,E, (E), OR (AC) IN AR

=0****00****
HRRE:	SKP AR18			;SELECT HRRZ OR HRRO ON SIGN
=
=0****00***0
HRRZ:	ARL_0S,ARR_ARR,EXIT
HRRO:	ARL_1S,ARR_ARR,EXIT
=
=0****00****
HRLE:	SKP AR18
=
=0****00***0
HRLZ:	ARL_ARR,ARR_0S,EXIT
HRLO:	ARL_ARR,ARR_1S,EXIT
=
=0****00****
HLRE:	SKP AR0
=
=0****00***0
HLRZ:	ARR_ARL,ARL_0S,EXIT
HLRO:	ARR_ARL,ARL_1S,EXIT
=
=0****00****
HLLE:	SKP AR0
=
=0****00***0
HLLZ:	ARR_0S,ARL_ARL,EXIT
HLLO:	ARR_1S,ARL_ARL,EXIT
=
.TOC	"DMOVE, DMOVN, DMOVEM, DMOVNM"
;DOUBLE-WORD MOVES

	.DCODE
120:	R,	B/0,	J/DMOVE
	R,	B/1,	J/DMOVN
	.UCODE

; ENTER WITH (E) IN AR
=0****00****
DMOVN:
DMOVE:	VMA_VMA+1,LOAD ARX,B DISP	;PICK UP (E+1)
=
=00
DLOAD:	ARX_MEM,J/STDAC			;[343] GO STORE DOUBLE AC
	ARX_MEM,MQ_0.S,CALL.S,J/GTDBR	;LOAD BR WITH DOUBLE OPERAND
=11	AR_-BR LONG,AD FLAGS,		;NEGATE DOUBLE OPERAND
		SC_#,#/35.		;& STORE RESULT
DBLST:	AC0_AR,AR_0S,I FETCH,J/STD1	;STORE HIGH WORD, READY LOW


;DOUBLE MOVES TO MEMORY

	.DCODE
124:	W,		J/DMOVEM
	W,		J/DMOVNM
	.UCODE

;ENTER WITH (AC) IN AR
=0****00**00
DMOVEM:	ARX_AC1,STORE,SC_#,#/36.,J/DMVM1
DMOVNM:	ARX_AC1,MQ_0.S,CALL.S,J/GTDBR	;HIGH WORD IS ALREADY IN AR
=11	AR_-BR LONG,AD FLAGS,		;NEGATE
		STORE,SC_#,#/35.	; & STORE
=
DMVM1:	MEM_AR,VMA_VMA+1,AR_0S
	AR_SHIFT,STORE,J/STMEM

GTDBR:	ARX_ARX*2			;SHIFT OUT LOW SIGN
LDBRL:	BR_AR LONG,RETURN3		;COPY TO BR LONG
.TOC	"BOOLEAN GROUP"
	.DCODE
400:	I-PF,	AC,	J/SETZ
	I-PF,	AC,	J/SETZ
	IW,	M,	J/SETZ
	IW,	B,	J/SETZ
	.UCODE

=0****00****
SETZ:	AR_0S,EXIT
=
	.DCODE
404:	R-PF,	AC,	J/AND
	I-PF,	AC,	J/AND
	RPW,	M,	J/AND
	RPW,	B,	J/AND
	.UCODE

=0****00****
AND:	AR_AR*AC0,AD/AND,EXIT
=
	.DCODE
410:	R-PF,	AC,	J/ANDCA
	I-PF,	AC,	J/ANDCA
	RPW,	M,	J/ANDCA
	RPW,	B,	J/ANDCA
	.UCODE

=0****00****
ANDCA:	AR_AR*AC0,AD/ANDCB,EXIT
=
	.DCODE
414:	R-PF,	AC,	J/MOVE		;SETM = MOVE
.IF/XADDR
	EA,	AC,	J/XMOVEI	;XMOVEI <=> SETMI
.IFNOT/XADDR
	I-PF,	AC,	J/MOVE
.ENDIF/XADDR
	RPW,	M,	J/MOVE		;SETMM = NOP THAT WRITES MEMORY
	RPW,	B,	J/MOVE		;SETMB = MOVE THAT WRITES MEMORY

420:	R-PF,	AC,	J/ANDCM
	I-PF,	AC,	J/ANDCM
	RPW,	M,	J/ANDCM
	RPW,	B,	J/ANDCM
	.UCODE

=0****00****
ANDCM:	AR_AR*AC0,AD/ANDCA,EXIT
=
	.DCODE
424:	R-PF,		J/TDN		;SETA = NOP
	I-PF,		J/TDN		;SETAI IS, TOO
	W,	M,	J/MOVE		;SETAM = MOVEM
	W,	M,	J/MOVE		;SETAB, TOO
	.DCODE
430:	R-PF,	AC,	J/XOR
	I-PF,	AC,	J/XOR
	RPW,	M,	J/XOR
	RPW,	B,	J/XOR
	.UCODE

=0****00****
XOR:	AR_AR*AC0,AD/XOR,EXIT
=
	.DCODE
434:	R-PF,	AC,	J/IOR
	I-PF,	AC,	J/IOR
	RPW,	M,	J/IOR
	RPW,	B,	J/IOR
	.UCODE

=0****00****
IOR:	AR_AR*AC0,AD/OR,EXIT
=
	.DCODE
440:	R-PF,	AC,	J/ANDCB
	I-PF,	AC,	J/ANDCB
	RPW,	M,	J/ANDCB
	RPW,	B,	J/ANDCB
	.UCODE

=0****00****
ANDCB:	AR_AR*AC0,AD/ANDC,EXIT
=
	.DCODE
444:	R-PF,	AC,	J/EQV
	I-PF,	AC,	J/EQV
	RPW,	M,	J/EQV
	RPW,	B,	J/EQV
	.UCODE

=0****00****
EQV:	AR_AR*AC0,AD/EQV,EXIT
=
	.DCODE
450:	I-PF,	AC,	J/SETCA
	I-PF,	AC,	J/SETCA
	IW,	M,	J/SETCA
	IW,	B,	J/SETCA
	.UCODE

=0****00****
SETCA:	AR_AR*AC0,AD/SETCB,EXIT
=
	.DCODE
454:	R-PF,	AC,	J/ORCA
	I-PF,	AC,	J/ORCA
	RPW,	M,	J/ORCA
	RPW,	B,	J/ORCA
	.UCODE

=0****00****
ORCA:	AR_AR*AC0,AD/ORCB,EXIT
=
	.DCODE
460:	R-PF,	AC,	J/SETCM
	I-PF,	AC,	J/SETCM
	RPW,	M,	J/SETCM
	RPW,	B,	J/SETCM
	.UCODE

=0****00****
SETCM:	ADA/AR,AD/SETCA,AR/AD,EXIT
=
	.DCODE
464:	R-PF,	AC,	J/ORCM
	I-PF,	AC,	J/ORCM
	RPW,	M,	J/ORCM
	RPW,	B,	J/ORCM
	.UCODE

=0****00****
ORCM:	AR_AR*AC0,AD/ORCA,EXIT
=
	.DCODE
470:	R-PF,	AC,	J/ORCB
	I-PF,	AC,	J/ORCB
	RPW,	M,	J/ORCB
	RPW,	B,	J/ORCB
	.UCODE

=0****00****
ORCB:	AR_AR*AC0,AD/ORC,EXIT
=
	.DCODE
474:	I-PF,	AC,	J/SETO
	I-PF,	AC,	J/SETO
	IW,	M,	J/SETO
	IW,	B,	J/SETO
	.UCODE

=0****00****
SETO:	AR_1S,EXIT
=
