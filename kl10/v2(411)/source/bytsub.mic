.TOC	"BYTE GROUP -- Some Old Style Subroutines"
;
;	This file once included all of the byte instruction code.
;	With the coming of the new version of the byte instructions,
;	however, much of this stuff became unnecessary and has
;	been eliminated as a result.  It is hoped to be able to
;	eliminate more of this once we rewrite the string instructions.
;	[345]
;
.TOC	"INCREMENT BYTE POINTER SUBROUTINE"

;THIS SUBROUTINE IS CALLED BY THE INSTRUCTIONS ILDB, IDPB AS
;WELL AS THE MICROCODED 10/11 INTERFACE HANDLER.
;CALL WITH BYTE DISP TESTING FPD AND SIGN OF P-S
;[TIME=2+2(BP OVFLO)]

.IFNOT/XADDR
=010					;BR12 IRELEVANT
IBPS:	STORE,RETURN4			;SIMPLE, NO OVERFLOW
	FE_#,#/36.,GEN AR+1,TIME/2T,	;HERE IF OVRFLO OF WORD
		ARX_AR,J/NXTWRD
	AR_BR,RETURN4			;FPD WAS SET, RESTORE AR
	AR_BR,RETURN4			; AND CONVERT TO LDB OR DPB
					;TEST BR12 ONLY
NXTWRD:	AR_AR+1,P_FE-S,STORE,
		TIME/2T,RETURN4


.TOC	"BYTE EFFECTIVE ADDRESS EVALUATOR - NO XADDR"

;ENTER WITH POINTER IN AR, ARX, AND BR
;RETURN1 WITH (EA) LOADING INTO AR AND ARX,
;FPD SET, P IN SC, AND S IN FE
;[TIME=4+1(INDEXED)+?(INDIRECT)]

BYTEA:	MEM_AR,FE_S,SET FPD,		;PUT AWAY UPDATED POINTER
		EA MOD DISP		;EVAL BP ADDR
=1100
BFETCH:	GEN ARX,BYTE READ,RETURN1	;START DATA FETCH
	GEN ARX+XR,BYTE READ,RETURN1	;ADDRESS IS INDEXED
	GEN ARX,BYTE INDRCT,J/BYTEI	;DO INDIRECT
	GEN ARX+XR,BYTE INDRCT,J/BYTEI	;INDIRECT INDEXED!!!

BYTEI:	ARX_MEM,SKP INTRPT		;WAIT FOR INDIRECT WORD
=0	EA MOD DISP,J/BFETCH		;PROCEED IN ADDR EVAL
	SR DISP,J/CLEAN			;INTERRUPTED, CLEAN UP AS REQ'D
.IF/XADDR
;IBP SUBROUTINE
; CALL WITH BP IN AR, P_P-S, BYTE DISP

=010
IBPS:	STORE,RETURN4			;SIMPLE CASE
	FE_#,#/36.,GEN AR+1,TIME/2T,	;POINTER OVERFLOW, B12=0
		J/NXTWRD
	AR_BR,RETURN4
	AR_BR,RETURN4
=0
NXTWRD:	P_FE-S,AR_AR+1,TIME/2T,		;SINGLE WORD BP
		STORE,RETURN4
.TOC	"BYTE EFFECTIVE ADDRESS EVALUATOR - XADDR"
;HERE TO EVALUATE EFFECTIVE ADDRESS OF BYTE POINTER.
; ENTER AT BYTEA WITH BYTE DISP (SCAD0=0), EXCEPT FOR EXTENDED
; INSTRUCTION SET, WHICH MUST GET SECOND PART OF POINTER FROM
; AC AND MUST NOT SET FPD, AND THEREFORE ENTERS AT BFETCH (FOR
; SINGLE-WORD POINTERS) OR BYTEI (FOR LONG POINTERS).

=100
BYTEA:	MEM_AR,FE_S,SET FPD,
		EA MOD DISP,J/BFETCH
	READ BP2,FE_S,J/BPART2		;GET SECOND WORD
	MEM_AR,SKP -VMA SEC0,J/BYTEA	;B12=1.  OBEY IF NOT SEC0
=
=0000
BXA:	GEN ARX,GLOBAL,BYTE INDRCT,
		SKP INTRPT,J/BYTEI
	GEN ARX+XR,GLOBAL,BYTE INDRCT,
		SKP INTRPT,J/BYTEI
	GEN ARX,GLOBAL,BYTE INDRCT,
		SKP INTRPT,J/BYTEI
	GEN ARX+XR,GLOBAL,BYTE INDRCT,
		SKP INTRPT,J/BYTEI

	GEN ARX,GLOBAL,BYTE READ,RETURN1
	GEN ARX+XR,GLOBAL,BYTE READ,RETURN1
	GEN ARX,GLOBAL,BYTE READ,RETURN1
	GEN ARX+XR,GLOBAL,BYTE READ,RETURN1

	FE_#,#/24,J/PF24		;ILLEGAL FORMAT INDIRECT WORD
	FE_#,#/24,J/PF24
	FE_#,#/24,J/PF24
	FE_#,#/24,J/PF24

BFETCH:
	GEN AR,BYTE READ,RETURN1
	GEN AR+XR,INDEXED,BYTE READ,RETURN1
	GEN AR,BYTE INDRCT,
		SKP INTRPT,J/BYTEI
	GEN AR+XR,INDEXED,BYTE INDRCT,
		SKP INTRPT,J/BYTEI

BPART2:	SET FPD				;SET BEFORE FAULTING
=0
BYTEI:	ARX_MEM,LONG EN,J/BYTEI2
	ARX_MEM,TAKE INTRPT
BYTEI2:	AR_ARX,XR,EA MOD DISP,TIME/3T,J/BXA
.ENDIF/XADDR
.TOC	"LOAD BYTE SUBROUTINE"
;ENTER WITH S IN FE, P+S IN SC, AND AR LOAD IN PROGRESS
;SKP INTERRUPT AT ENTRY IS OPTIONAL
;RETURN2 WITH BYTE RIGHT JUSTIFIED IN AR
;[TIME=7]
=0
LDB1:	AR_MEM,SC_#-SC,#/36.,SKP SCAD0,	;36-(P+S)
		TIME/3T,J/LDB2
	AR_MEM,SR DISP,J/CLEAN		;HERE IF INTERRUPT PENDING

=0
LDB2:	ARX_SHIFT,AR_0S,SC_FE,J/SHIFT	;BYTE IN ARX HI, READY TO SHIFT
	ARX_AR,AR_0S,			;P+S > 36, PUT BYTE IN ARX HI
		SC_FE+SC,SKP SCAD0	;ADJUST S AND SHIFT BYTE

;PUT BYTE INTO AR RIGHT-JUSTIFIED
; THIS INSTRUCTION ALSO CALLED ALONE AS A SUBROUTINE

=0
SHIFT:	AR_SHIFT,RETURN2		;RETURN WITH BYTE IN AR
	RETURN2				;BYTE WAS OFF THE END, RETURN AR=0


.TOC	"DEPOSIT BYTE SUBROUTINE"
;ENTER WITH BYTE RIGHT JUSTIFIED IN AR, POINTER IN BR,
; S IN FE, 36-P IN SC, AND LOAD AR-ARX STARTED
; SKP IF P>36
;RETURN3 WITH FINAL STORE IN PROGRESS
;[TIME=11]

=0
DPB1:	MQ_AR,AR_MEM,ARX_MEM,		;GET WORD TO ROTATE 36-P
		GEN FE-SC-1,TIME/3T,	; [303] COMPUTE S-(36-P)-1
		SKP SCAD0,J/DPB2	;CHECK THAT P+S<=36
	AR_MEM,RETURN3			;[226]P>36, STORE NOTHING

=0
DPB2:	FE_SC				;P+S>36, S_36-P
	ARX_SHIFT,AR_MQ,SC_FE,		;ARX HAS P,X,S
		FE_#-SC,#/72.		;SC_S, FE_72-(36-P)=36+P
	SC_#-SC,#/36.			;SC_36-S (KNOWN .LE. P)
	AR_SHIFT,ARX_SHIFT,		;S,P,X
		SC_FE-SC		;SC_(36+P)-(36-S)=P+S
	AR_SHIFT,STORE,RETURN3		;[335][345] DONE, STORE IT BACK
;SUBROUTINE TO GET CONTENTS OF SC RIGHT ALIGNED IN AR
;[TIME=6]

GETSC:	AR0-8_SC			;PUT SC INTO AR
	ARX_AR,SC_#,#/9.,J/SHIFT	;HERE WITH DATA IN AR0-8
;
;	Some one word global subroutines.
;
.IF/OWGBP
=0
GTST:	SC_P-#,#/45, SKP SCAD0,J/GTST1	;TEST FOR ONE WORD GLOBAL [265]
	RETURN1				;NOT IN SEC 0
=0
GTST1:	BR/AR,RETURN2			;DO OWG CODE
	RETURN1				;NOT OWG
;
;CNV2WD -- ROUTINE TO CALCULATE NEW P FIELD OF ONE WORD GLOBAL BYTE
;POINTER AND STORE NEW POINTER. A TABLE IS IN THE EPT STARTING AT 700
;AND THIS IS USED TO CONVERT THE OWGBP TO A TWO WORD GLOBAL POINTER
;AND TO CALCULATE THE NEW P FOR THE STORE.
;
;ENTER WITH P-45 IN SC
;	    BYTE POINTER IN BR
;

CNV2WD:	AR_VMA HELD			;[326] GET FULL VMA FOR WRITE
	MQ_AR				;SAVE FOR WRITE BACK
	AR0-8_SC			;P-45 IN AR
=0*	AR_ARX (AD),ARX_AR,SC_#,#/9.,	;SWAP AROUND FOR SHIFT
		CALL [SHIFT]		;NOW SHIFT IT TO BIT 35
	AR_AR*.5 LONG			;MAKE IT AN OFFSET, LSB IN ARX0
	VMA_#+AR32-35,#/700		;POINT TO RIGHT WORD
	LOAD AR,EPT REF CACHE		;GET AND CACHE DATA FROM EPT [260]
	MB WAIT,GEN ARX,SKP AD0		;TEST FOR EVEN/ODD
=0
CNV01:	FE_S,ARX_AR,J/CNV02		;SKIP SWAP
	AR_AR SWAP,J/CNV01		;SWAP HALVES FOR ODD
CNV02:	BRX/ARX,GEN AR,SKP AD NE	;DID WE GET 0 DATA ?
=0	BR/AR,J/UUO			;P=77 OR EPT NOT SET UP
	RSTR VMA_MQ,RETURN1		;[307][326]NO, RESTORE VMA AND EXIT
.ENDIF/OWGBP
