01 0001  	;Symbolics F2 with 8K micro-memory
01 0002  	
01 0003  	;Initialize switch settings
01 0004  	.INSERT SWINIT.SLO

SLOE   Oct  30, 2543 00:00:00  file DSK:SWINIT.SLO  --  of -- f2sym

01 0001  	;INIT ALL SWITCHES FOR CF TO 0.
01 0002  	
01 0003  	.DEFINE FOOLIST[01 0004  	
01 0005  0 	!-.INSERT-'SWINIT.SLO'-! = 0  ;ERROR MESSAGE FOR LOSERS
01 0006  	
01 0007  1 	F2SW = 1        ; SET F2SW = 1 FOR F2,  F2SW = 0 FOR F3
01 0008  	
01 0009  1 	FAST = 1        ;IF 0, ALL CYCLES ARE 500NS OR MORE.
01 0010  	
01 0011  1 	SLOW1 = 1       ;MAKES 350NS CYCLES LONGER BY 50*SLOW1 NS. DWP 2/10
01 0012  	
01 0013  0 	SLOW2 = 0       ;MAKES 400NS CYCLES LONGER BY 50*SLOW2 NS.
01 0014  	
01 0015  0 	TYMNET = 0
01 0016  	
01 0017  0 	DR11P = 0
01 0018  	
01 0019  0 	TLXTAPE = 0
01 0020  	
01 0021  0 	125TAPE = 0
01 0022  	
01 0023  0 	SLOWTAPE = 0
01 0024  	
01 0025  0 	KNYTAPE = 0
01 0026  	
01 0027  0 	NTP = 0         ;NEW TAPE CTRL (DMA TYPE)
01 0028  	
01 0029  0 	TAPE = 0        ;New tape ctrl with long records.
01 0030  	
01 0031  0 	75IPS = 0       ;Not 75IPS drive -- implies 125IPS
01 0032  	
01 0033  0 	DLS = 0
01 0034  	
01 0035  0 	IMP = 0
01 0036  0 	IMP1 = 0        ;HIGH U-MEM VERSION OF IMP
01 0037  	
01 0038  0 	WK = 0          ;Walt's Kluge
01 0039  	
01 0040  0 	VID = 0         ;FooVision
01 0041  0 	VIC2 = 0        ;Smart video controler (with sysnthsis)
01 0042  	
01 0043  0 	LPT = 0         ;Lineprinter (Printronix, etc.)
01 0044  	
01 0045  0 	VC = 0          ;Versatec/Varian plotter interface.
01 0046  	
01 0047  1 	NEWMAP = 1      ;SET FOR MACHINES F3-3 AND LATER.
01 0048  	
01 0049  1 	CROCK = 1       ;set to 1 to get some old crockish code back
01 0050  	
01 0051  0 	DEBUGSW = 0     ;Set to 1 to get some debugging crocks
01 0052  	
01 0053  0 	TIMER = 0       ;INTERVAL TIMER
01 0054  	
01 0055  0 	STANSW = 0      ;Special Stanford I/O devices
01 0056  	
01 0057  0 	WAITS = 0       ;BBN Pager was modified for WAITS
SLOE   Oct  30, 2543 00:00:00  file DSK:SWINIT.SLO  --  of -- f2sym

01 0058  	
01 0059  0 	XUCODE = 0      ;Set to 1 (exactly !) if 8k u-memory present.

SLOE   Oct  30, 2543 00:00:00  file DSK:F2SYM.SLO  --  of -- f2sym

01 0004  	
01 0005  	; F2 VERSION OF MICROCODE
01 0006  	
01 0007  	; SET F2SW = 1 FOR F2,  F2SW = 0 FOR F3
01 0008  	
01 0009  1 	F2SW = 1
01 0010  	
01 0011  1 	XUCODE = 1      ;8K u-mem present
01 0012  	
01 0013  1 	NEWMAP = 1
01 0014  	
01 0015  1 	TIMER = 1
01 0016  	
01 0017  1 	DR11P = 1       ;DR11 interface with packet-oriented microcode
01 0018  	
01 0019  	;;;IMP = 1
01 0020  	
01 0021  20  	DLSDEV = 20     ; udevice code for TTY scanner
01 0022  	
01 0023  1 	DLS = 1
01 0024  	
01 0025  1 	DLSDEB = 1
01 0026  	
01 0027  1 	DLS2 = 1
01 0028  	
01 0029  1 	NTP = 1
01 0030  	
01 0031  1 	TAPE = 1        ; New tape code
01 0032  1 	75IPS = 1 ;75 IPS TAPE SPEED -- USED FOR READING OLD CCRMA TAPES.
01 0033  	
01 0034  0 	VID = 0         ; FooVision video turned off 3/31/81 Moon
01 0035  0 	VIC2 = 0        ; No smart video control (with synthesis)
01 0036  36  	DPYDEV = 36
01 0037  2 	DPYDEV2 = 2
01 0038  	
01 0039  	;;VC = 1                ; Set to 1 for Versatec
01 0040  14  	VCDEV = 14      ; udevice code for Versatec
01 0041  	
01 0042  	;-----------------------------------------------------------------------
01 0043  	;Default DLS configuration.  Lines are reset to this on initialization.
01 0044  	;See DLS definition page for meaning of this bits.
01 0045  	
01 0046  	;Caution:  Only lower 6 bits are permissible here.  This means you
01 0047  	;          can't start out with looped, in break mode, or with character
01 0048  	;          length other than 8.  You must use macro code to set those.
01 0049  	;
01 0050  	;-----------------------------------------------------------------------
01 0051  	;The following comments are bogus -- Moon
01 0052  	;
01 0053  	;Three groups of
01 0054  	;lines may be initialized, allowing for local terminal, 300 buad modems
01 0055  	;and split speed modems.
01 0056  	;Note:  Groups can be omitted by setting DLSGRPxN to zero.
01 0057  	;-----------------------------------------------------------------------
01 0058  	.DEFINE DLSINI 01 0061  	;DLSINI
01 0062  	
SLOE   Oct  30, 2543 00:00:00  file DSK:F2SYM.SLO  --  of -- f2sym

01 0063  	.DEFINE DLIST ;Define as LIST to enable FOOLIST
01 0064  	.DEFINE DXLIST ;Define as XLIST for FOOLIST stuff
01 0065  	
01 0066  	XLIST
01m0068                               	LIST
01m0068                               	
01m0068                               	.INSERT CFNEW

SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

01m0001                               	COMMENT \       FOONLY F2-F3 MICRO-CODE
01m0001                               	
01m0001                               	
01m0001                               	Recent history:
01m0001                               	
01m0001                               	21 Mar 80 TVR   Added DMOVE, DMOVEM and ADJSP instructions.  Changed opcode of
01m0001                               	                XMOVE to 107, as it conflicted with ADJSP.  Experimental boot
01m0001                               	                switches in preparation for auto-loading tapes.
01m0001                               	22 Mar 80 TVR   Fixed some typos with above.  
01m0001                               	26 Mar 80 TVR   Added WAITS switch to modify pager to make references to user
01m0001                               	                ACs go to user shadow memory (instead of special place pointed
01m0001                               	                to by AC Base Register in BBN Pager).  Since the addresses
01m0001                               	                supplied to the random instructions must be larger than 17
01m0001                               	                to prevent references to ACs in 2901, a page was stolen from
01m0001                               	                the EXEC address space, currently 770xxx, and that page table
01m0001                               	                entry in the hardware is copied from entry 0 of the user page
01m0001                               	                table in core.
01m0001                               	                Also, for Stanford only, defined ILGIOT to reference the PAN
01m0001                               	                interface, so that CONSZ will skip when no device is present
01m0001                               	                and new devices can be added to that bus without microcode
01m0001                               	                changes.
01m0001                               	                Fixed dispatch for UUO0 to look at opcode field only.  Made
01m0001                               	                indirect dispatch test for the stop switch, so that stop will
01m0001                               	                stop indirection loops
01m0001                               	                Fixed DATAO PI, to page fault properly.
01m0001                               	27 Mar 80 TVR   Pager mods and tape hack for CCRMA were both buggy.  Fixed.
01m0001                               	                Fixed bug in pager: PC was being over-decremented on page
01m0001                               	                fill cycle when indirection failed in XCTR'ed instruction.
01m0001                               	29 Mar 80 TVR   Flushed a spurious DEST-A-MEM which prevented WAITS from
01m0001                               	                working at XCTAC+1.
01m0001                               	02 Apr 80 TVR   Added code to trap IOT references if not Exec or IOT-User
01m0001                               	                mode.  New macro, UIOTRP, jumps if in IOT-USER mode.
01m0001                               	                ILGIOT still is a no-op for non-Stanford microcode for
01m0001                               	                the moment.
01m0001                               	                For Stanford only, the PAN interface has its micro-interrupts
01m0001                               	                re-enabled on PI-CHECK-RQS.
01m0001                               	                Bummed an instruction out of IOTDIS. Indirect bit is guaranteed
01m0001                               	                zero so one can double by shifting instead of doing an add.
01m0001                               	03 Apr 80 TVR   Fixed ADJSP.  XCT n,[PUSH x,y] failed if x was a user AC
01m0001                               	                reference.  Added code to emulate PUSH/POP.
01m0001                               	04 Apr 80 TVR   XCT 1,[POP x,AC] didn't have a chance of working.  It gets
01m0001                               	                emulated as well.  Added code for KAFIX.
01m0001                               	11 Apr 80 TVR   Changed PAN interrupt enables in PI-CHECK-RQS.  Added reset
01m0001                               	                code and IOT dispatch for temp. Grinnell code (under STANSW).
01m0001                               	                Looked at DIV code to try to fix divide-by-zero.  Gave up in
01m0001                               	                disgust.  I won't touch that code with a 10 ft battle axe!
01m0001                               	                Fixed another stupid typo in ADJSP.
01m0001                               	22 Apr 80 TVR   Fixed two bugs in DPB (and one in LDB).  DPB sets half flag
01m0001                               	                if it gets a page fault on the pointer reference.  The monitor
01m0001                               	                doesn't care much, but some user programs look at the fault
01m0001                               	                PC and flags to decide what kind of Pager and CPU they are
01m0001                               	                running under.  The other bug was that in LDB and DPB; they
01m0001                               	                do not handle bytes which 'wrap-around', i.e. 36-P<S.  If this
01m0001                               	                is the case, i think the right thing is S:=P.
01m0001                               	                Fixed bug in DMOVEM references to ACs.  One more time on ADJSP.
01m0001                               	                Added code (MAPRST) the clear entire map (not just valid bits)
01m0001                               	                on 'power-up' to prevent immediate mode references from going
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

01m0001                               	                to non-ex memory and/or causing spurious ECC traps.
01m0001                               	                Wrote some code for DMOVN, DMOVNM, and KIFIX.
01m0001                               	                Re-arranged a few things to make things fix (%$%@*#& orgs).
01m0001                               	26 Apr 80 TVR   Merged with DWP's version, which did not contain indications
01m0001                               	                of alterations.  Unfortunately, i did not have the most recent
01m0001                               	                CCRMA version available, so another merge will be necessary.
01m0001                               	                Many comments added.
01m0001                               	30 Apr 80 TVR   Attempted merge with CCRMA version.  That tape was not complete
01m0001                               	                so only some of the code will be merged.  Enough to proceed
01m0001                               	                with cleanup.
01m0001                               	                Replaced most :<expression> with macro calls in order to use
01m0001                               	                microcode memory in a more reasonable fashion.
01m0001                               	                More comments added.
01m0001                               	07 May 80 TVR   The assembler is a loser!  It redefines macros alright, some of
01m0001                               	                the time.  At any rate, the macros were rewritten and all
01m0001                               	                (shudder) of the macro calls changed.
01m0001                               	10 May 80 TVR   Merged in the rest of the CCRMA changes.
01m0001                               	11 May 80 TVR   Grumble, curse, moan!!!  No, the assembler isn't THAT bad.
01m0001                               	                The REAL loser not the assembler, but the person who wrote oet
01m0001                               	                the old version (which had a different name) onto
01m0001                               	                SCI:<POOLE>SLOEXP.SAV and which contains various and sundry
01m0001                               	                bugs, one of which appears to be macro re-definition and
01m0001                               	                another being an unusable storage map.  So, everything was
01m0001                               	                delayed a week while i tried to get around bugs which had
01m0001                               	                already been fixed.
01m0001                               	                Fortunately, this time it could be converted back to the
01m0001                               	                original form with the aid of a TECO macro.
01m0001                               	                Adjusted memory usage and it now assembles except for
01m0001                               	                re-usage of 5300 and 5301.
01m0001                               	12 May 80 TVR   Adjusted some of memory usage to make the silly thing assemble
01m0001                               	                WAITS version in preparation for making larger adjustments.
01m0001                               	                PAN interrupts are come out in the status word as low true. PAN
01m0001                               	                interrupt code has been corrected for that.
01m0001                               	                Fixed a rather obscure bug in SETHLF.  Because SETHLF stores
01m0001                               	                into CRYOV, the EXEC mode shift register (what COND[USER] is
01m0001                               	                based on) gets forced to be the current space.  Thus,
01m0001                               	                page faults from User pages in Exec mode on certain
01m0001                               	                instructions (like IDPB) were being processed as being Exec
01m0001                               	                mode page faults.
01m0001                               	13 May 80 TVR   Added .QUAD macro and put it in places jumped to by SLOOP
01m0001                               	                which were previously controlled by :<absolute number>.
01m0001                               	                Adjusted memory usage to make the one area using .QUAD fit.
01m0001                               	                Fixed misfeature in experimental boot.
01m0001                               	                LDB/DPB for bytes that wrap around just isn't right at all!
01m0001                               	                BYTE-OVERF is condition BEFORE incrementing, not after.  So,
01m0001                               	                i will have to rethink this one to come up with something
01m0001                               	                that handles that case properly without slowing byte
01m0001                               	                instructions down significantly.
01m0001                               	
01m0001                               	Changes at CCRMA follow:
01m0001                               	
01m0001                               	15 May 80 TVR   Fixed bug in DMOVNM.  Changed mechanism for PAN interrupts.
01m0001                               	                The PAN microinterrupt enable is turned off when the interrupt
01m0001                               	                for that channel is recieved and turned on by PI-CHECK-RQS
01m0001                               	                by setting all of the microinterrupt enables for the PAN to
01m0001                               	                the complement of PI IN PROGRESS and PI REQUEST.  This means
01m0001                               	                that the PAN can only request interrupts whenever something
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

01m0001                               	                else isn't using those channels.  This implies that any PAN
01m0001                               	                devices must be on the end of CONSZ chains, or else they will
01m0001                               	                steal interrupts from other, interrupt counting devices.
01m0001                               	24 May 80 TVR   Grinnell interrupt bug fixes.  Starting putting names on
01m0001                               	                opcodes and stuff to make it easier to use with E.
01m0001                               	26 May 80 TVR   Fixed problem in JRST1+1 falling thru to nothingness.  A few
01m0001                               	                more editorial changes.
01m0001                               	07 Jul 80 TVR   Changed CONO APR, code to turn on AR INT ENB and also made
01m0001                               	                symbols some references to APR A-MEM relating to APR.
01m0001                               	                Fixed bugs in F2 version of overflow interrupt.
01m0001                               	                *** Did not look at F3 code for same. ***
01m0001                               	                More comments added.
01m0001                               	08 Jul 80 TVR   Made attempt to fix [I]DIV by zero and no divide.
01m0001                               	                As part of that, commented the setup part of DODIV, and added
01m0001                               	                code to try to restore AC after finding no divide case.  I'm
01m0001                               	                not sure the DIV case will work properly, but we'll see...
01m0001                               	                Fixed bug in FDVR of negative number which set the flags wrong.
01m0001                               	                It had the wrong MASK when complementing a negative dividend
01m0001                               	                exponent.
01m0001                               	                Many comments added to divide and KA floating point as a result
01m0001                               	                of chasing these.  Some have (???) being i'm not sure that either
01m0001                               	                the code and/or the comments are right.
01m0001                               	15 Jul 80 TVR   Installed LPT device.  Microcode for LPT is still being tested.
01m0001                               	                Fixed bug in PAN enabling, so that PI channels that are not
01m0001                               	                turned on do not have their micro interrupts enabled.
01m0001                               	22 Jul 80 TVR   Fixed bug in [I]DIV which clobbered PC on divide by zero.
01m0001                               	                Sets overflow on KIFIX now.  Also, sets overflow on KAFIX, which
01m0001                               	                should not cause any problems.
01m0001                               	25 Jul 80 TVR   Added FIXR and FLTR.
01m0001                               	23 Aug 80 TVR   Fixed bugs in LDB/DPB having to do with bytes which overflow
01m0001                               	                word boundaries.
01m0001                               	                Ran out of micro-code space and re-adjusted .USEs to recover
01m0001                               	                some wasted space.
01m0001                               	                More work on LPT device.
01m0001                               	20 Sep 80 TVR   Added a new switch, MUM2.  At the moment, this only causes
01m0001                               	                ECC logging information to go to 1776x instead of 0776x.
01m0001                               	                Under WAITS switch, changed APR CONI, and clock interrupt
01m0001                               	                decision, to implement special feature of SAIL's KA, which
01m0001                               	                turns on bit 27 in APR CONI when it is NOT interrupting.
01m0001                               	25 Sep 80 TVR   Began merge of CCRMA version with DWP version.  MUM2 became
01m0001                               	                XUCODE.
01m0001                               	                Tape code got moved to separate files in order to make SRCCOM
01m0001                               	                feasible.
01m0001                               	                New symbol TYMORG defines where absolute part of TYMNET code
01m0001                               	                is assembled. It only need be changed in the future.
01m0001                               	
01m0001                               	Changes at Foonly follow:
01m0001                               	
01m0001                               	
01m0001                               	15 Aug 80 BO    Added Versatec to unused half of CTY IOT dispatch,
01m0001                               	                device code 124.
01m0001                               	                Removed the 16 NOP's at the very end of memory.  VC code
01m0001                               	                is broken up to fit available space.
01m0001                               	                Used absolute locations 5340-5437 (5340 defined as
01m0001                               	                VCORG1) and 7733-7777 (VCORG2) defined in VC.SLO
01m0001                               	                
01m0001                               	25 Sep 80 TVR   Following changes were not documented but evident from source
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

01m0001                               	                comparison:
01m0001                               	
01m0001                               	                MASK[18] was added to dispatch code at 2002. Presumably, this
01m0001                               	                        done to make the interrupt bug trap work properly.
01m0001                               	                CONSZ to DLS when no code is assembled now always skips, so
01m0001                               	                        that TENEX can tell if the DLS exists.
01m0001                               	                New device, VID, added.  This is Gossett's new display.
01m0001                               	                uDevice numbers for the DLS, VC are now variables.
01m0001                               	                Code for DMA tape controller was added.
01m0001                               	                Two new switches were added, OTP and NTP, which stand for
01m0001                               	                        Old Tape and New Tape controllers.  NTP is for
01m0001                               	                        the DMA tape controller and all others are OTP.
01m0001                               	                Changes to CTY code and TYMNet code to account for differences
01m0001                               	                        in MAPF fields for new tape controller.
01m0001                               	                Some adjustment of .ORG and .USE were done to make things fit.
01m0001                               	                FDVL was fixed.  This involved making changes to A-MEM usage
01m0001                               	                        in floating divide code.
01m0001                               	                SLOEXP was modified to truncate jump addresses to 12 bits without
01m0001                               	                        complaint.
01m0001                               	                New switch, XUCODE, was added.  If XUCODE=1, then some I/O devices
01m0001                               	                        are assembled into the upper 4K of microcode memory.
01m0001                               	                A new macro, .GETADR(X), constructs a 12 bit number in Q.
01m0001                               	                Tape code is optionally moved into upper 4K of microcode memory
01m0001                               	                        if XUCODE=1.  Dispatches for tape code were moved.
01m0001                               	                
01m0001                               	Versions merged.  This version is designated 1.02 by fiat of TVR.
01m0001                               	
01m0001                               	25 Sep 80 TVR   Completed merge.
01m0001                               	                *** VC needs a new device code.  It had used the slot assigned
01m0001                               	                historically to the LPT.
01m0001                               	                Some other minor formatting/comment changes were made to make
01m0001                               	                the source merge program work properly.
01m0001                               	                There were strong differences between the two in the floating
01m0001                               	                divide code.  Hopefully, all of the A-MEM changes made it
01m0001                               	                across.  I have checked them by hand.
01m0001                               	
01m0001                               	26 Sep 80 TVR   Assigned device 520 to VC (Versatec interface), and modified
01m0001                               	                VC.SLO to accomdate that.
01m0001                               	
01m0001                               	4 Nov 80 PG     Added new display service for FooVision (VID.SLO). This
01m0001                               	                stuff makes use of high memory, since it is quite large. Note
01m0001                               	                that the ,INSERT must be right after the tape code, since
01m0001                               	                (due to kludgery) .USE[OTHER] doesn't work properly for getting
01m0001                               	                you back to low memory (see TYMFOO). For your information:
01m0001                               	                .USE[HIGHMEM]   gets you to high memory
01m0001                               	                .USE[OTHER]     gets you back to low memory
01m0001                               	                GETADR[FOO] JUMP[GOHIGH] $      jumps to high memory 10000+FOO
01m0001                               	                                                (Note that this expands
01m0001                               	                                                to 2 microcode words.)
01m0001                               	                JUMP[GOMAIN] $                  jumps to MAIN in low memory
01m0001                               	
01m0001                               	21 Nov 80 - PG  Added new output instruction to TYMNET for F5 diagnostics.
01m0001                               	                Takes the data in the effective address, using the right
01m0001                               	                16. bits of the right half as data to go out;
01m0001                               	                AC=1 => STB DATA, and AC=2 => STB CTRL.
01m0001                               	
01m0001                               	Above is version 55 as received at Symbolics
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

01m0001                               	
01m0001                               	16 Mar 81 Moon  Moved TYMNET code into separate file, added new file DR11
01m0001                               	                under new switch DR11P providing packet oriented DR11C
01m0001                               	                support.  Involves new version of SWINIT also.
01m0001                               	
01m0001                               	19 Mar 81 Moon  Moved DLSINI macro into F2X and F2SYM files.  This is the
01m0001                               	                macro that defines the initial line speeds and characteristics.
01m0001                               	
01m0001                               	21 Mar 81 Moon  Removed setting of TNODIBN etc. from CFDEF since having these
01m0001                               	                as definitions in the ROT field stimulates all sorts of bugs
01m0001                               	                in the microassembler.  Made them ordinary symbol definitions
01m0001                               	                separately in both the TYMNET and DR11 files.
01m0001                               	
01m0001                               	31 Mar 81 Moon  Made XCT 3,[LDB x,[foo(xr)]] get xr from the previous context.
01m0001                               	                Also turned off Foovision in the Symbolics version of the
01m0001                               	                microcode, since it takes forever to assemble and we don't
01m0001                               	                have one.
01m0001                               	
01m0001                               	24 Apr 81 Moon  Merged Poole's recent changes:
01m0001                               	                Fix pdl overflow to work correctly with page faults by setting
01m0001                               	                a bit in the PC and checking for it in the main loop, rather
01m0001                               	                than setting a bit in the APRSTS then signalling an interrupt
01m0001                               	                which can easily get lost if there is a page fault.
01m0001                               	
01m0001                               	                Add "WK" and "IMP1" include files.
01m0001                               	
01m0001                               	                Make byte-pointer indirection loops interruptible.
01m0001                               	
01m0001                               	                Don't increment counters in locations 30-32 of events having
01m0001                               	                to do with the map.  I guess this is supposed to be an
01m0001                               	                efficiency improvement.
01m0001                               	
01m0001                               	28 Apr 81 Moon  Also fix typos at APRCK1 and APRCII, testing wrong bit in
01m0001                               	                APRSTS for pdl-overflow.
01m0001                               	
01m0001                               	1 May 81 Moon   Fix HSMAIN+1 to use correct MAPF field so that HLRZS at the
01m0001                               	                end of a page does not sometimes get executed twice.
01m0001                               	
01m0001                               	3 June 81 Moon  Fix bug introduced by Poole's changes for pdl overflow.
01m0001                               	                JRST 4, in user mode loops forever because instruction
01m0001                               	                after JRST9 was spuriously deleted.  Also added some
01m0001                               	                comments to this bletcherous JRST microcode and removed
01m0001                               	                an instruction that didn't do anything (JUMP[JRST4]).
01m0001                               	
01m0001                               	(End history)
01m0001                               	\
01m0001                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

02m0001                               	COMMENT \
02m0001                               	
02m0001                               	********************************************************
02m0001                               	
02m0001                               	        USEFUL MICROCODE WORD DEFINITIONS
02m0001                               	
02m0001                               	********************************************************
02m0001                               	\
02m0001                               	
02m0001       0	F3SW = 1 - F2SW
02m0001                               	
02m0001       0	OTP = 1 - NTP
02m0001                               	
02m0001                               	
02m0001       740007602375400000170000	FIXM1 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-RD] CYLEN[FIXM] $
02m0001       740007602375400000170000	FIXML = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-RD] CYLEN[LONG] $
02m0001       740007602375400000170000	FIXM2 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM] $
02m0001       740007602375400000170000	FIXM0 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[0] CYLEN[FIXM] $
02m0001                               	.DEFINE MEMST 02m0001                               	  ;  NOTE:  BECAUSE OF XCT MAPPED, MEMST IS SAME AS MEMSTMA
02m0001                               	 ; .DEFINE MEMST [] [COND[-MA-AC] LBJUMP[SMAIN] NORM ]
02m0001                               	.DEFINE MEMSTMA 02m0001                               	
02m0001       740767676376000000007777	DOSKIP = D[PC] ALU[D+1] DEST[MA PC] JUMP[MAIN1] NORM $
02m0001       000760000000000003607777	DONTSKIP = DEST[MA] SPEC[MA_PC] JUMP[MAIN1] $
02m0001       740767674000000000007777	DOJUMP = D[IR] DEST[MA PC] JUMP[MAIN1] NORM $
02m0001       740740000000000003607777	DOM1    = SPEC[MA_PC] JUMP[MAIN1] NORM $
02m0001                               	
02m0001       000000077775576770000000	CLRR    = ROT 22 D[MASK 22] ALU[D&AC] ACSEL[AC] DEST[AC] $
02m0001       000000077775400770000000	CLRL    =        D[MASK 22] ALU[D&AC] ACSEL[AC] DEST[AC] $
02m0001                               	
02m0001                               	;SLFFXM - Self FIXM (?)
02m0001                               	;Finish read fetch of read-modify-write type cycle.
02m0001                               	;Check to make sure effective address is writable.
02m0001                               	;Jump if AC field in IR is non-zero
02m0001                               	.DEFINE SLFFXM[02m0001                               	
02m0001                               	;;;;;;APR-A-MEM DEFINITIONS -- THERE SHOULD BE 7 MORE OF THESE !
02m0001                               	
02m0001       1	A-MEM-ECC-DATA = 1      ;Data on last ECC error -- readable by op. 750
02m0001                               	
02m0001                               	;;;;;;;
02m0001                               	
02m0001       000740000000000000007777	BADLOC = JUMP[MAIN] $;NOP FOR NOWJUMP BADPC $           ;FOR WORDS WE SHOULDN'T USE
02m0001                               	;;;;;ILGIOT = NORM JUMP[2000] $
02m0001                               	
02m0001                               	;The standard case for IOTs without devices
02m0001                               	.REPEAT 1 - STANSW [
02m0001                               	.DEFINE ILGIOT[02m0001                               	].REPEAT 1 - STANSW
02m0001                               	
02m0001                               	;At Stanford, any devices we don't know about go to the PAN interface.  It
02m0001                               	;may have something plugged into it that will respond to that address in a
02m0001                               	;PDP-10ish manner.
02m0001                               	.REPEAT STANSW [
02m0001                               	.REPEAT STANSW
02m0001                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

02m0001                               	;Jump not IOT-USER mode
02m0001                               	.DEFINE UIOTRP[02m0001                               	DEFINE
02m0001                               	
02m0001                               	.DEFINE GETADR[02m0001                               	 ;Low-order 6 bits
02m0001                               	         ;NOTICE that a "$" is REQUIRED after a call of GETADR.
02m0001                               	
02m0001       740740074000001770007777	UUOLOC = D[CONST 40] JUMP[UUO1] NORM $
02m0001                               	
02m0001                               	   .DEFINE MUUO1 02m0001                               	   .DEFINE UAOP1 02m0001                               	
02m0001       740007674000177770000000	SET-TEMP-USER = D[CONST 17] ROT[11] DEST[MAP-EXEC-SR] NORM $
02m0001       740007674000177770000000	SET-TEMP-EXEC = D[CONST 0] ROT[11] DEST[MAP-EXEC-SR] NORM $
02m0001                               	
02m0001                               	;
02m0001                               	; THESE OUTLANDISHLY EXPLICIT DEFINITIONS OF NOP ASSURE THAT THE
02m0001                               	; DECODER WILL PRINT 'NOP' ONLY WHEN YOU REALLY MEAN IT.
02m0001                               	;
02m0001       037747602374000000000000	NOP =    COND[0] DEST[0] CONT ALU[D]
02m0001                               	        ACSEL[AC] NO-MA-STB NO-AR-STB ROT[0] MASK[-1] ALU-D[NONE] $
02m0001                               	
02m0001       037007602374000000000000	DONOP  = COND 0 DEST[ 0] ALU[D]
02m0001                               	         ROT[0] MASK[-1] ACSEL[AC] JUMP[MAIN] ALU-D[NONE] NORM $
02m0001                               	
02m0001       740777674000000003607777	DODISP  = D[MEM] DEST[IR-ALL MA AR] SPEC[PC+1-IF&] DISP[2374] CYLEN[DISP] $
02m0001                               	
02m0001                               	;------------------------------------------------------------------------------
02m0001                               	;
02m0001                               	;       CPU special registers                           uDevice 0
02m0001                               	;
02m0001                               	;------------------------------------------------------------------------------
02m0001                               	;
02m0001                               	; Dev  Subsel       Read                            Write
02m0001                               	;
02m0001                               	;  0     1                                      Address Break Register
02m0001                               	;        2      Data switches                   Data lights
02m0001                               	;        4      Address and console switches    Clear latched switches (no data)
02m0001                               	;       10      PC History (unimplemented)      Set AR,ECC enables, MAP ON, etc.
02m0001                               	;
02m0001                               	;  1     1      ECC status
02m0001                               	;        2      MAP status                      MAP (address in MA, LOCAL USER)
02m0001                               	;        4      (Same as 1)
02m0001                               	;       10      (Same as 1)
02m0001                               	;
02m0001                               	
02m0001                               	;------------------------------------------------------------------------------
02m0001                               	;
02m0001                               	;       A-Mem usage                                     uDevice 0 & 1
02m0001                               	;       (Note: Not all references are symbolic as yet.
02m0001                               	;
02m0001                               	;------------------------------------------------------------------------------
02m0001                               	;Device 0
02m0001       1	A-MEM-ECC-DATA = 1      ;Data on last ECC error -- readable by op. 750
02m0001       2	APRSTS = 2      ;Firmware status bits for APR
02m0001       7	APRENB = 7      ;Used to save ECC,AR interrupt enables, MAP ON, etc. during map
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

02m0001                               	                ;trap processing
02m0001                               	;Device 1
02m0001       3	ECCSVP = 3      ;Pointer to next place to remember ECC interrupt in microcode
02m0001                               	                ;memory
02m0001                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

03m0001                               	
03m0001                               	COMMENT \
03m0001                               	
03m0001                               	*****************************************************
03m0001                               	
03m0001                               	                REAL CODE
03m0001                               	
03m0001                               	*****************************************************
03m0001                               	\
03m0001                               	
03m0001       2000	INST-DISP = 2000        ;Address of instruction dispatch.
03m0001       4001	NORMAL = 4001           ;Assembly starts here
03m0001                               	  .REPEAT XUCODE [
03m0001       10001	HIGHMEM = 10001         ;Upper 4K of 8K u-mem.
03m0001                               	    ]
03m0001                               	                        ;**** Next macro blows up with multiply defined symbol.          
03m0001                               	       ;**** Note that it usually does not complain!!!
03m0001                               	        .OPCODE[LIST 
03m0001                               	 LIST            ]      UUO 0 COMES HERE (ALONG WITH UUO 1 - 7 )
03m0001                               	
03m0001 02000 640140000571000440000000	        NORM JUMP[UUO0-7] $
03m0001                               	
03m0001                               	;; Location 2001 is used elsewhere !!!
03m0001                               	
03m0001                               	.REPEAT F3SW [
03m0001                               	
03m0001                               	.REPEAT F2SW [
03m0001                               	.REPEAT 0 [
03m0001                               	1 - DLS 9 JAN 80 BO
03m0001                               	
03m0001                               	:2002   ;I/O INTERRUPTS TRAP HERE
03m0001 02002 440540040571000440000000	        D[10] SDISP C600 $
03m0001                               	                ;Just dispatch to ucode intrpt. routine for device.
03m0001                               	: 2003 ;STOP SWITCH TRAPS HERE
03m0001 02003 640142400571000440000000	        DEST[CLR-DEV-FROM-INTR] JUMP[STOPS] NORM $
03m0001                               	: 2004  ;CAN'T GET HERE FROM THERE...
03m0001 02004 000140000571000440002004	        JUMP[.] $ ;HANG FOR NOW.
03m0001                               	: 2005  ;ECC ERRORS TRAP HERE
03m0001 02005 640142400571000440000000	        DEST[CLR-DEV-FROM-INTR] JUMP[SECCS] NORM $
03m0001                               	: 2006  ;PC OV TRAPS HERE
03m0001                               	;;;     DEST[CLR-DEV-FROM-INTR] JUMP[SOVRS] NORM $
03m0001 02006 640141614571000010000000	        D[CONST 1] DEST[DEV-ADR] JUMP[SOVRS] NORM $
03m0001                               	                ;Start setting up to read AR enabling
03m0001                               	: 2007 ;BOTH ECC AND OV (AT THE SAME TIME) TRAPS HERE
03m0001 02007 640142400571000440000000	        DEST[CLR-DEV-FROM-INTR] JUMP[SECCS] NORM $
03m0001                               	: 2010 ;NORMAL INDIRECT TRAPS HERE
03m0001 02010 640706000550400440010000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
03m0001 02011 540530404571000441602374	        D[MEM] DEST[IR-23 MA AR] DISP[2374] SPEC[PC+1-IF] CYLEN[DISP] $
03m0001                               	                ;WHEN EXTEND HAPPENS, DISP[2176]? NO-- HOW WOULD WE SEE
03m0001                               	                ;EXTENDED AREA OF IX REG?
03m0001                               	                ;Changed from 2174 to 2374 to allow stop switch to stop
03m0001                               	                ;indirection loops.  TVR-Mar80
03m0001                               	: 2012  ;NORMAL INDEXING TRAPS HERE
03m0001 02012 540530234420400221602024	        ALU[IX+D] D[IR] MASK[18.] DEST[AR IR-ADR MA] DISP[2024] SPEC[PC+1-IF]
03m0001                               	 CYLEN[DISP]$
03m0001                               	                ;WHEN EXTEND HAPPENS, DISP[2026]
03m0001                               	: 2014  ;EXTENDED INDIRECT TRAPS HERE
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

03m0001                               	; SOMETHING MAKES THIS DIFFERENT FROM 2010 -- MAYBE LOADING H.O. MA??
03m0001 02014 000140000571000440002014	 JUMP[.] $      ;FOR NOW ;;;ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
03m0001                               	
03m0001 02015 540530404571000441602176	        D[MEM] DEST[IR-23 MA AR] DISP[2176] SPEC[PC+1-IF] CYLEN[DISP] $
03m0001                               	: 2016  ;EXTENDED INDEXING TRAPS HERE
03m0001 02016 000140000571000440002016	 JUMP[.] $      ;FOR NOW ;;;D[AR] ROT[6] MASK[4] DEST[AC-SEL] NORM $
03m0001 02017 540530200420000441602026	        D[AR] ALU[D+AC] ACSEL[REG] DEST[IR-ADR MA AR] SPEC[PC+1-IF] DISP[2026]
03m0001                               	 CYLEN[DISP] $
03m0001                               	  ]
03m0001                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

04m0001                               	;UUO1 UUO2 SMAIN SMAIN1 MAIN MAIN1 MAIN2 MSMAIN MSMAIN1 MUUO MUUO2 MUUO3 MUUO4 PIMUUO
04m0001                               	 MUUO44 UUOPJ MUUO5X MUUO5Y UAOP AREA216 UMOVE JSYS JSYS3 ADJSP XMOVEM1 DMOVE DMOVN KIFIX
04m0001                               	 DMOVEM DMOVNM FIXR FLTR UFA DFN FSC
04m0001                               	;------------------------------------------------------------------------------
04m0001                               	;       User UUO Trap
04m0001                               	;
04m0001                               	;       Traps thru location 40 of the current space
04m0001                               	;
04m0001                               	;       Instruction is stored in 40 (with effective address computed and
04m0001                               	;               index/indirection removed)
04m0001                               	;       Instruction in location 41 is executed, in the current space.  It
04m0001                               	;               customarily either jumps, saving the PC and flags, or halts.
04m0001                               	;------------------------------------------------------------------------------
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ];User UUOs 010:017
04m0001 02020 640060014571000400000000	UUO1:   D[CONST 40] DEST[MA] PUSHJ[UUOPJ] NORM  $
04m0001                               	                ;Setup MA for trap area and make mask for removing index/indir.
04m0001 02021 640704234635000440000000	UUO2:   D[IR] ALU[D&Q] DEST[MEMSTO] NORM $
04m0001                               	                ;Store instruction which caused trap.
04m0001 02022 640704620531000440170000	        D[PC] ALU[D-1] DEST[PC] MAPF[MASTO] CYLEN[MEMSTO] $
04m0001                               	                ;Ordinary page fault if not writable.  (*** Is PC correct???)
04m0001                               	                ;Backup the PC to point at the offensive instruction
04m0001 02023 640160014571000410000000	        D[CONST 41] DEST[MA] JUMP[MAIN1] NORM $
04m0001                               	                ;Execute contents of (same space) location 41, usually a JSR or
04m0001                               	                ;a HALT instruction
04m0001                               	
04m0001                               	: 2024
04m0001 02024 640170005570400440640000	SMAIN: ACSEL[MA] D[MEM] DEST[AC AR MA] SPEC[MA_PC] JUMP[MAIN1] NORM MAPF[STO] $
04m0001 02025 640170004571000440640000	SMAIN1: D[MEM] SPEC[MA_PC] DEST[AR MA] JUMP[MAIN1] CYLEN[MEMSTO] MAPF[STO] $
04m0001                               	
04m0001                               	MAIN:   SPEC[MA_PC] DEST[MA]   DEST[CLR-DEV-FROM-INTR]
04m0001 02026 451162420571022440600000	          D[PC] ROT[9.] C600 COND[OBUS<0] JUMP[PDLTRP] $
04m0001                               	           ;START THE INSTR. FETCH, un-force DEV-ADR (from last intrpt.),
04m0001                               	           ; and jump if a PDL OV is hanging.
04m0001                               	
04m0001 02027 640346000550400440010000	MAIN1:  ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] JPOP[MAIN2] NORM $ 
04m0001                               	
04m0001 02030 540530604571000441602374	MAIN2:  D[MEM] DEST[IR-ALL MA AR] SPEC[PC+1-IF&] DISP[2374] CYLEN[DISP] $
04m0001                               	
04m0001                               	        .PAIR   . \ 2 + .
04m0001                               	];: 2032 ; .PAIR
04m0001 02032 640140005570400440172026	MSMAIN: ACSEL[MA] D[MEM] DEST[AC] JUMP[MAIN] CYLEN[MEMSTO] MAPF[MASTO] $
04m0001 02033 640140000571000440172026	MSMAIN1:        MAPF[MASTO] JUMP[MAIN] CYLEN[MEMSTO] $
04m0001                               	
04m0001       2034	AREA202 = .     ;(Not a lot left)
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ]      User UUOs 020-027
04m0001 02040 640140014571000400002020	        UUOLOC $
04m0001       2041	AREA204 = .
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ]      User UUOs 030-037
04m0001 02060 640140014571000400002020	UUOGO:  UUOLOC $
04m0001                               	
04m0001       2061	AREA206 = .
04m0001                               	
04m0001                               	;$*$*$*$ This should go somewhere else!!!
04m0001                               	  .OPCODE[LIST 
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

04m0001                               	 LIST            ] ;Set loc 2 wds. before MUUO (opcode 37 doesn't come here).
04m0001                               	               ;We come here (from 2000) on opcodes 0-7.
04m0001 02076 510140034571022110000000	UUO0-7: D[IR] ROT[9.] MASK[9.] COND[OBUS=0] JUMP[MUUO] C550 $;J IF 0 UUO
04m0001 02077 640140014571000400002020	        UUOLOC $
04m0001                               	
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ]      Monitor UUOs 040-047 (CALL,INIT,CALLI)
04m0001                               	MUUO:   MUUO1
04m0001 02100 640150020171000440000000	D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
04m0002                               	];The following need not be contiguous with MUUO, it is merely here for clarity.
04m0002                               	;It may be moved to another area if necessary.  TVR-Apr80
04m0002                               	
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;       Monitor UUO Trap
04m0002                               	;
04m0002                               	;       Traps thru location 40 of the current space, typically to handle user 
04m0002                               	;               request to the Monitor
04m0002                               	;
04m0002                               	;       Instruction is stored in 40 (with effective address computed and
04m0002                               	;               index/indirection removed)
04m0002                               	;       Instruction in Monitor 41 is executed, in the Monitor space.  It
04m0002                               	;               should save PC and flags, and handle the user's request.
04m0002                               	;------------------------------------------------------------------------------
04m0002 02101 640705410635076430000000	MUUO2:  D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $
04m0002                               	                ;Clear USER
04m0002 02102 640060014571000400000000	        D[CONST 40] DEST[MA] PUSHJ[UUOPJ] NORM $
04m0002                               	                ;Setup MA for trap area and make mask for removing index/indir.
04m0002                               	;       \ /
04m0002                               	;Common code for instruction traps
04m0002 02103 640704234635000440000000	MUUO3:  D[IR] ALU[D&Q] DEST[MEMSTO] NORM $
04m0002                               	                ;Store instruction which caused trap.
04m0002 02104 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] CYLEN[MEMSTO] $
04m0002                               	                ;Now, get dispatch instruction
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;***  CAUTION:  If write fails, micro-machine hangs at 6100.  This should be
04m0002                               	;***            fixed when a more general page-fault mechanism is added.  The
04m0002                               	;***            best thing would be to just halt the macro machine.
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	MUUO4:
04m0002 02105 640706014171004550000000	PIMUUO: D[CONST 55] ROT[2] DEST[Q FIXMAC-MAPF-RD] CYLEN[FIXM] $; JSR OPCODE
04m0002                               	                ;TVR-Apr80:  I don't have the foggiest notion what that FIXMAC
04m0002                               	                ;is supposed to do here.  The FIXM is needed for memory timing,
04m0002                               	                ;but aren't we guaranteed not to be fetching from ACs here????
04m0002 02106 410140004735022110000000	MUUO44: D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSR] CYLEN[C650] $
04m0002                               	                ;Jump if trap instruction is a JSR (opcode 264 = 55*4)
04m0002 02107 640700000017000440000000	        ALU[Q+1] DEST[Q] SHORT $
04m0002 02110 510140004735022110000000	        D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSP] C550 $
04m0002                               	                ;Jump if trap instruction is a JSP (opcode 265)
04m0002 02111 640700000017000440000000	        ALU[Q+1] DEST[Q] SHORT $
04m0002 02112 510140004735022110000000	        D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSA] C550 $
04m0002                               	                ;Jump if trap instruction is a JSA (opcode 266)
04m0002 02113 640700014171002420000000	        D[CONST 42] ROT[1] DEST[Q] SHORT $; JSYS OP
04m0002 02114 510140004735022110000000	        D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSYS] C550 $
04m0002                               	                ;Jump if trap instruction is a JSYS (opcode 104 = 42*2)
04m0002 02115 640704620531000440000000	        D[PC] ALU[D-1] DEST[PC] SHORT $
04m0002                               	                ;Any other opcode will be XCTed and the regular code will
04m0002                               	                ;resume.
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;***  CAUTION:  No special dispensation has been made for BLKI/BLKO.  They
04m0002                               	;***            MUST be handled specially, as if they DON'T skip, the
04m0002                               	;***            second trap location should be executed and should be a JSR
04m0002                               	;***            or some other instruction which saves flags.    TVR-Apr80
04m0002                               	;------------------------------------------------------------------------------
04m0002 02116 000145400571000440002030	        D[AR] DEST[CRYOV] JUMP[MAIN2] $
04m0002                               	                ;Else restore flags and dispatch
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;***  CAUTION:  This probably will not work proper if reference is being made
04m0002                               	;***            to EXEC memory and trap was from USER.  What really needs to
04m0002                               	;***            happen here is that the instruction should be XCTRed instead,
04m0002                               	;***            It may be sufficient to SET-TEMP-EXEC.  I haven't looked at
04m0002                               	;***            the problem seriously.                          TVR-Apr80
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	
04m0002                               	;Construct a mask which excludes indexing and indirection.  Used by UUO trap
04m0002                               	;routines (and currently no where else)
04m0002 02117 640300010171056370000000	UUOPJ:  D[MASK 37] ROT[27] DEST[Q] POPJ NORM $
04m0002                               	
04m0002                               	;(NO SPACE IS LEFT.  You will have plant jumps to another area to expand the
04m0002                               	; above code!)
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      Monitor UUOs 050-057 (OPEN,INIT,RENAME,IN,OUT)
04m0002                               	
04m0002 02120 640700034171016010000000	MUUO5X: D[IR] ROT[7] MASK[1] DEST[Q] NORM $
04m0002                               	                ;Special check for UUOs actually used by monitors we care about
04m0002 02121 510140034735020010002100	        D[IR] ROT[10] MASK[1] ALU[D#Q] COND[OBUS=0] JUMP[MUUO] C550 $
04m0002                               	                ;Jump if UUO 50,51,56, OR 57
04m0002 02122 610140000555000440000000	        ALU[Q] COND[OBUS=0] JUMP[MUUO5Y] CYLEN[C450] $
04m0002                               	                ;Jump if 52 OR 53 ("Reserved for DEC")
04m0002 02123 530140034571022010002100	        D[IR] ROT[11] MASK[1] COND[-OBUS=0] JUMP[MUUO] C550 $
04m0002                               	                ;Jump if 55
04m0002 02124 640150020171000440000000	MUUO5Y: D[PC] DEST[Q AR] NORM JUMP[UAOP] $
04m0002                               	                ;Take illegal inst. trap.
04m0002                               	
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;       Illegal Instruction Trap
04m0002                               	;
04m0002                               	;       Traps thru Monitor 60
04m0002                               	;
04m0002                               	;       Instruction is stored in 60 (with effective address computed and
04m0002                               	;               index/indirection removed)
04m0002                               	;       Instruction in Monitor 61 is executed, in the Monitor space.  It
04m0002                               	;               should save PC and flags, and stop the offensive process.
04m0002                               	;------------------------------------------------------------------------------
04m0002 02125 640705410635076430000000	UAOP:   D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $; CLR USER
04m0002 02126 640700010171056370000000	        D[MASK 37] ROT[27] DEST[Q] NORM $
04m0002 02127 640160014571000600002103	        D[CONST 60] DEST[MA] JUMP[MUUO3] NORM $
04m0002                               	
04m0002       2130	AREA212 = .     ;$*$** Stupid interrupt code makes this unusable!
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      Monitor UUOs 060-067
04m0002                               	                        ;(SETSTS,STATO,GETSTS,STATZ,INBUF,OUTBUF,INPUT,OUTPUT)
04m0002 02140 640150020171000440002101	        MUUO1 D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

04m0002                               	]$
04m0002                               	;;;AREA214 = .
04m0002       2142	area214 = 2142          ;Sigh... Another fixed location
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      Monitor UUOs 070-077
04m0002                               	                        ;(CLOSE,RELEAS,MTAPE,UGETF,USETI,USETO,LOOKUP,ENTER)
04m0002 02160 640150020171000440002101	        MUUO1 D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
04m0002                               	]$
04m0002                               	AREA216:
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      UMOVE
04m0002 02200 640724620531000440000000	UMOVE:  D[PC] ALU[D-1] DEST[MA PC] NORM $ ;RE-FETCH INSTR.
04m0002 02201 640146000550400440020000	        FIXM1 JUMP[UMOVX] $     ;WAIT FOR FETCH.
04m0002                               	
04m0002                               	; UMOVEI, UMOVEM, UMOVES
04m0002                               	        .REPEAT 3 [ 04m0002 02202 640140000571000440002200	JUMP[UMOVE] NORM $
04m0002 02203 000700000571000440000000	                        NOP $ 
04m0002 02204 640140000571000440002200	                ]JUMP[UMOVE] NORM $
04m0002 02205 000700000571000440000000	                        NOP $ 
04m0002 02206 640140000571000440002200	                ]JUMP[UMOVE] NORM $
04m0002 02207 000700000571000440000000	                        NOP $ 
04m0002                               	                ]
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      JSYS
04m0002                               	JSYS:
04m0002                               	.REPEAT 1 - WAITS [
04m0002 02210 530140034571066110000000	        D[IR] ROT[33] MASK[11] COND[-OBUS=0] JUMP[JSYS1] C550 $; J IF NOT EX JSYS
04m0002                               	].REPEAT 1 - WAITS
04m0002                               	.REPEAT WAITS [
04m0002                               	.REPEAT WAITS
04m0002 02211 000150020171000440000000	JSYS3:  D[PC] DEST[Q AR] JUMP[JSYS2] $; GET PC & FLAGS
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      ADJSP
04m0002                               	ADJSP:  D[IR] ROT[22] MASK[0] ALU[D+AC] SPEC[LEFT] DEST[Q]
04m0002 02212 511140034021044000200000	                        COND[OBUS<0] JUMP[ADJSP1] C550$
04m0002                               	                ;Jump if left result is negative
04m0002 02213 640150034421000220000000	        D[IR] MASK[22] ALU[D+AC] DEST[AR] JUMP[ADJSP2] NORM $   ;Add right half
04m0002                               	        ;(Continued just before TYMNET code)
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ];XMOVEM
04m0002 02214 640722600551400440000000	        ALU[AC] ACSEL[AC+1] DEST[HI-ABS-MA MA] NORM $
04m0002 02215 640144200551000440000000	        ALU[AC] DEST[MEMSTO] NORM JUMP[XMOVEM1] $
04m0002                               	        .USE[04m0002                               	XLIST
04m0003 02041 640142600615000440002026	 LIST ]XMOVEM1: ALU[0] DEST[HI-ABS-MA] NORM JUMP[MAIN] $
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];XMOVE
04m0003 02216 640722600551400440000000	        ALU[AC] ACSEL[AC+1] DEST[HI-ABS-MA MA] NORM $
04m0003 02217 640142600615000440002401	        ALU[0] DEST[HI-ABS-MA] JUMP[2401] NORM $
04m0003                               	
04m0003                               	;Illegal instructions (?)
04m0003                               	        .REPEAT 113 - 110 + 1
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

04m0003 02220 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02221 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02222 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02223 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02224 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02225 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02226 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02227 000700000571000440000000	        NOP $
04m0003                               	        ]
04m0003                               	 .REPEAT 1 - WK  [
04m0003                               	
04m0003                               	;Illegal instructions (?)
04m0003                               	        .REPEAT 117 - 114 + 1
04m0003 02230 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02231 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02232 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02233 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02234 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02235 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02236 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02237 000700000571000440000000	        NOP $
04m0003                               	        ]              ]
04m0003                               	   .REPEAT WK [
04m0003                               	
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DMOVE
04m0003 02240 640706000550400440020000	DMOVE:  FIXM1 $                 ; Fetch first word
04m0003 02241 640140005571000440000000	        ACSEL[AC] D[MEM] DEST[AC] JUMP[DMOVE2] CYLEN[FIXM+1] $
04m0003                               	                ;Put it in an AC [*** Is CYLEN right? ***]
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DMOVN
04m0003 02242 640706000550400440020000	DMOVN:  FIXM1 $ ;Fetch first word
04m0003                               	        ACSEL[AC] D[MEM] ALU[NOTD] DEST[AC] SPEC[CRYOV]
04m0003 02243 640140005771000441200000	                        JUMP[DMOVN2] CYLEN[FIXM+1] $
04m0003                               	                ;Ones complement high order word.  Set result flags
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];KIFIX
04m0003 02244 640706000550400440020000	KIFIX:  FIXM1 $ ;Fetch first word
04m0003 02245 640140014171000330000000	        D[CONST 33] DEST[Q] JUMP[KIFIX1] NORM $
04m0003                               	                ;Start making magic constant
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	;123
04m0003 02246 640150020171000440002125	        UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02247 000700000571000440000000	        NOP $
04m0003                               	
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DMOVEM
04m0003                               	;*** Note: Like on the KI10, DMOVEM AC,AC+1 will lose.
04m0003 02250 640706200550400440030000	DMOVEM: FIXM2 $                 ; Make sure first word is in core
04m0003 02251 662104200551000440000000	        ACSEL[AC] ALU[AC] DEST[MEMSTO] COND[-MA-AC] LBJUMP[DMOVM2] NORM $
04m0003                               	                ;Store first word.  Decide where it really goes.
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DMOVNM
04m0003                               	;*** Note: Like on the KI10, DMOVNM AC,AC+1 will lose.
04m0003 02252 640706200550400440030000	DMOVNM: FIXM2 $                 ; Make sure first word is in core
04m0003 02253 640150000751000441200000	        ACSEL[AC] ALU[NOTAC] DEST[AR] SPEC[CRYOV] JUMP[DMVNM2] NORM $
04m0003                               	                ;Ones complement high order word, leave result in IR
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];FIXR
04m0003 02254 640706000550400440020000	FIXR:   FIXM1 $ ;Fetch first word
04m0003 02255 640140014171060040000000	        D[CONST 04] ROT[24.] DEST[Q] JUMP[FIXR1] NORM $
04m0003                               	                ;Start making constant 0.5
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];FLTR
04m0003 02256 640706000550400440020000	FLTR:   FIXM1 $ ;Fetch first word
04m0003 02257 000150004571000440000000	        D[MEM] DEST[AR] JUMP[FLTR1] $
04m0003                               	                ;Setup for normalize
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];UFA
04m0003 02260 640706000550400440020000	UFA:    FIXM1 $
04m0003 02261 000141614571000110000000	        D[CONST 11] DEST[DEV-ADR] JUMP[UFA1] $
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DFN
04m0003 02262 640706200550400440030000	DFN:    FIXM2 $
04m0003 02263 450110004473000330000000	        D[MEM] MASK[27.] ALU[0-D] DEST[AR] COND[OBUS=0] LBJUMP[DFN1] C600 $
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];FSC
04m0003 02264 510140010621000330000000	FSC:    D[MASK 27.] ALU[D&AC] ACSEL[AC] COND[OBUS=0] JUMP[FSCZAP] C550 $
04m0003 02265 640150000551000440000000	        ACSEL[AC] ALU[AC] DEST[AR] JUMP[FSC1] NORM $
04m0003                               	
04m0003                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

05m0003                               	;IBP ILDB LDB IDPB DPB FAD FSB FMP FDV
05m0003                               	;------------------------------------------------------------------------------
05m0003                               	;
05m0003                               	;       Byte Manipulation Instructions
05m0003                               	;
05m0003                               	;------------------------------------------------------------------------------
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ];IBP (and ADJBP)
05m0003 02266 656146200550400440032026	IBP:    FIXM2 COND[HALF] JUMP[MAIN] $
05m0003                               	                ;A no-op if we're already incremented.
05m0003 02267 643110004171000440000000	        D[MEM] DEST[Q AR] COND[AC=0] LBJUMP[IBP1] NORM $
05m0003                               	                ;Get byte pointer and decide if it's an ADJBP or a IBP
05m0003                               	
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ];ILDB
05m0003 02270 640706200550400440030000	ILDB:   FIXM2 $
05m0003 02271 676110004171000440000000	        D[MEM] DEST[Q AR] COND[-HALF] LBJUMP[ILDB1] NORM $
05m0003                               	
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ];LDB
05m0003 02272 640706000550400440020000	LDB:    FIXM1 $
05m0003 02273 564130004171000440000000	        D[MEM] DEST[Q AR MA] COND[-MEM-IDX-IND] LBJUMP[LDB1] CYLEN[C500] $
05m0003                               	
05m0003                               	IDPB:   .OPCODE[LIST 
05m0003                               	 LIST            ];IDPB
05m0003 02274 640706200550400440030000	        FIXM2 $
05m0003 02275 676110004171000440000000	        D[MEM] DEST[Q AR] COND[-HALF] LBJUMP[IDPB1] NORM $
05m0003                               	
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ];DPB
05m0003 02276 640706000550400440020000	DPB:    FIXM1 $
05m0003 02277 564130004171000440000000	        D[MEM] DEST[Q AR MA] LBJUMP[DPB1] COND[-MEM-IDX-IND] CYLEN[C500]  $
05m0003                               	
05m0003                               	;------------------------------------------------------------------------------
05m0003                               	;
05m0003                               	;       Single Procession Floating Point
05m0003                               	;
05m0003                               	;------------------------------------------------------------------------------
05m0003                               	
05m0003                               	;
05m0003                               	;FAD FADL FADM FADB FADR FADRI FADRM FADRB
05m0003                               	;
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ]      ;Opcodes 140-147
05m0003 02300 640146000550400440020000	FAD:    FIXM1 JUMP[FAOS1] $ NOP $
05m0003 02301 000700000571000440000000	
05m0003 02302 640146000550400440020000	        FIXM1 JUMP[FAOS2] $ NOP $
05m0003 02303 000700000571000440000000	
05m0003 02304 640146200550400440030000	        FIXM2 JUMP[FAOS3] $ NOP $
05m0003 02305 000700000571000440000000	
05m0003 02306 640146200550400440030000	        FIXM2 JUMP[FAOS4] $ NOP $
05m0003 02307 000700000571000440000000	
05m0003 02310 640146000550400440020000	        FIXM1 JUMP[FAOS1] $ NOP $
05m0003 02311 000700000571000440000000	
05m0003 02312 640144424571044000200000	        D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] JUMP[FAOS5] NORM $ NOP $
05m0003 02313 000700000571000440000000	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

05m0003 02314 640146200550400440030000	        FIXM2 JUMP[FAOS3] $ NOP $
05m0003 02315 000700000571000440000000	
05m0003 02316 640146200550400440030000	        FIXM2 JUMP[FAOS4] $ NOP $
05m0003 02317 000700000571000440000000	
05m0003                               	
05m0003                               	;
05m0003                               	;FSB FSBL FSBM FSBB FSBR FSBRI FSBRM FSBRB
05m0003                               	;
05m0003                               	.DEFINE FSBMAC[05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ]      ;Opcodes 150-157
05m0003 02320 640706000550400440020000	FSB:    FIXM1 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS1] NORM 
05m0003 02321 640144404473000440000000	]$
05m0003 02322 640706000550400440020000	        FIXM1 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS2] NORM 
05m0003 02323 640144404473000440000000	]$
05m0003 02324 640706200550400440030000	        FIXM2 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS3] NORM 
05m0003 02325 640144404473000440000000	]$
05m0003 02326 640706200550400440030000	        FIXM2 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS4] NORM 
05m0003 02327 640144404473000440000000	]$
05m0003 02330 640706000550400440020000	        FIXM1 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS1] NORM 
05m0003 02331 640144404473000440000000	]$
05m0003 02332 640144424473044000200000	        D[MA] ROT[18.] DEST[HOLD] ALU[0-D] SPEC[LEFT] JUMP[FAOS5] NORM $ NOP $
05m0003 02333 000700000571000440000000	
05m0003 02334 640706200550400440030000	        FIXM2 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS3] NORM 
05m0003 02335 640144404473000440000000	]$
05m0003 02336 640706200550400440030000	        FIXM2 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS4] NORM 
05m0003 02337 640144404473000440000000	]$
05m0003                               	
05m0003                               	;
05m0003                               	;FMP FMPL FMPM FMPB FMPR FMPRI FMPRM FMPRB
05m0003                               	;
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ]      ;Opcodes 160-167
05m0003 02340 640146000550400440020000	FMP:    FIXM1 JUMP[FMP1] $ NOP $
05m0003 02341 000700000571000440000000	
05m0003 02342 640146000550400440020000	        FIXM1 JUMP[FMP2] $ NOP $
05m0003 02343 000700000571000440000000	
05m0003 02344 640146200550400440030000	        FIXM2 JUMP[FMP3] $ NOP $
05m0003 02345 000700000571000440000000	
05m0003 02346 640146200550400440030000	        FIXM2 JUMP[FMP4] $ NOP $
05m0003 02347 000700000571000440000000	
05m0003 02350 640146000550400440020000	        FIXM1 JUMP[FMP1] $ NOP $
05m0003 02351 000700000571000440000000	
05m0003 02352 640144424571044000200000	        D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] JUMP[FMP5] NORM $ NOP $
05m0003 02353 000700000571000440000000	
05m0003 02354 640146200550400440030000	        FIXM2 JUMP[FMP3] $ NOP $
05m0003 02355 000700000571000440000000	
05m0003 02356 640146200550400440030000	        FIXM2 JUMP[FMP4] $ NOP $
05m0003 02357 000700000571000440000000	
05m0003                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

05m0003                               	;FDV FDVL FDVM FDVB FDVR FDVRI FDVRM FDVRB
05m0003                               	.DEFINE DIVMAC[05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ]      ;Opcodes 170-177
05m0003 02360 640706000550400440020000	FDV:    FIXM1 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD1] NORM
05m0003 02361 640141614571000110000000	]$
05m0003 02362 640706000550400440020000	        FIXM1 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD2] NORM
05m0003 02363 640141614571000110000000	]$
05m0003 02364 640706200550400440030000	        FIXM2 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD3] NORM
05m0003 02365 640141614571000110000000	]$
05m0003 02366 640706200550400440030000	        FIXM2 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD4] NORM
05m0003 02367 640141614571000110000000	]$
05m0003 02370 640706000550400440020000	        FIXM1 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD1] NORM
05m0003 02371 640141614571000110000000	]$
05m0003 02372 640704424571044000200000	        D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] NORM $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD1] NORM
05m0003 02373 640141614571000110000000	]$
05m0003 02374 640706200550400440030000	        FIXM2 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD3] NORM
05m0003 02375 640141614571000110000000	]$
05m0003 02376 640706200550400440030000	        FIXM2 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD4] NORM
05m0003 02377 640141614571000110000000	]$
05m0003                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

06m0003                               	;MOVE MOVE1 MOVEI MOVEM MOVES MOVS MOVSI MOVSM MOVSS MOVN MOVNI MOVNM MOVNS MOVM MOVM1
06m0003                               	 MOVMI MOVMM MOVMS MOVMS1 MOVMS3 MOVMS4 MOVMS5 MOVMS6 MOVMS2
06m0003                               	;------------------------------------------------------------------------------
06m0003                               	;
06m0003                               	;       MOVE Group
06m0003                               	;
06m0003                               	;------------------------------------------------------------------------------
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVE
06m0003 02400 640706000550400440020000	MOVE:   FIXM1 $
06m0003                               	                ;Wait for memory, handle page faults, and fixup AC references
06m0003 02401 640160005571000440602027	MOVE1:  ACSEL[AC] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
06m0003                               	                ;Store result of read in AC
06m0003                               	                ;Start next instruction fetch (DEST[MA] refers to SPEC[MA_PC])
06m0003                               	                ;We are referring to the AC specified by the AC field in the IR
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVEI
06m0003 02402 640160035571000220602027	MOVEI:  ACSEL[AC] D[IR] MASK[18.] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
06m0003                               	                ;Store effective address into AC
06m0003                               	                ;Ignore any page faults or other memory related problems.  Read
06m0003                               	                ;will be ignored (except for ECC checking)
06m0003                               	                ;Start next instruction fetch (DEST[MA] refers to SPEC[MA_PC])
06m0003                               	                ;We are referring to the AC specified by the AC field in the IR
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVEM
06m0003 02404 662104200551000440002032	MOVEM:  ACSEL[AC] ALU[AC] DEST[MEMSTO]  MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	                ;Start writing AC (selected by AC field in IR) into memory.
06m0003                               	                ;MEMST macro will send us to MSMAIN (if we're writing to
06m0003                               	                ;another AC) or MSMAIN1 (if it's a real memory reference)
06m0003                               	                ;to complete to store.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVES
06m0003 02406 663146000550400440022401	MOVES:  FIXM1 COND[-AC=0] JUMP[MOVE1]  $
06m0003                               	                ;If AC field (in IR) is non-zero, we treat this as if it
06m0003                               	                ;were a MOVE instruction (a slight fudge).
06m0003                               	                ;*** Shouldn't this be a FIXM2?  Then it would do the right
06m0003                               	                ;*** thing for the clever person trying to fetch and dirty
06m0003                               	                ;*** a page.   TVR-Apr80
06m0003 02407 662104204571000440002032	        D[MEM] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	                ;If AC field is zero, this is a no-op which writes memory.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVS
06m0003 02410 640706000550400440020000	MOVS:   FIXM1 $
06m0003                               	        ACSEL[AC] D[MEM] ROT[18.] DEST[AC MA] SPEC[MA_PC]
06m0003 02411 640160005571044440602027	                        JUMP[MAIN1] CYLEN[FIXM+1] $
06m0003                               	                ;Rotating by 18 swaps halves.  Otherwise, it's just like a MOVE
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVSI
06m0003 02412 640160035571044000402027	MOVSI:  ACSEL[AC] D[IR] ROT[18.] DEST[AC MA] SPEC[LEFT&MA_PC] JUMP[MAIN1] NORM$
06m0003                               	                ;Just like a MOVEI except it puts the result in the left half
06m0003                               	                ;of the AC.  (SPEC[LEFT] makes a mask of -1,,0)
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVSM
06m0003 02414 640710000551000440000000	MOVSM:  ALU[AC] ACSEL[AC] DEST[AR] NORM $
06m0003 02415 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	                ;Swap halves and write it into memory like a MOVEM
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVSS
06m0003                               	MOVSS:  SLFFXM[06m0003 02416 663146200550400440030000	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM] COND[-AC=0] JUMP[
06m0003                               	 MOVSS1 ] $
06m0003                               	]$
06m0003                               	                ;Finish read fetch of read-modify-write type cycle.
06m0003                               	                ;Check to make sure effective address is writable.
06m0003                               	                ;Jump if AC field in IR is non-zero
06m0003 02417 662104204571044440002032	        D[MEM] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	                ;Swap halves and write backing into same place in memory.
06m0003                               	
06m0003                               	;*$*$*$ Move MOVSS1 here, a single instruction
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVN
06m0003 02420 640706000550400440020000	MOVN:   FIXM1 $
06m0003                               	        ACSEL[AC] D[MEM] ALU[0-D] DEST[AC MA] SPEC[CRYOV&MA_PC]
06m0003 02421 640160005473000441002027	                        JUMP[MAIN1] CYLEN[FIXM+1] $
06m0003                               	                ;Like MOVE except it negates the number it loads.
06m0003                               	                ;Set flags.  400000,,0 will overflow.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVNI
06m0003                               	MOVNI:  ACSEL[AC] D[IR] ALU[0-D] MASK[18.] DEST[AC MA] SPEC[CRYOV&MA_PC]
06m0003 02422 640160035473000221002027	                        JUMP[MAIN1] NORM $
06m0003                               	                ;Like MOVEI except that it load a negative number
06m0003                               	                ;Set flags.  Cannot overflow.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVNM
06m0003 02424 662104200513000441202032	MOVNM:  ACSEL[AC] ALU[0-AC] DEST[MEMSTO] SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN]
06m0003                               	 NORM ]$
06m0003                               	                ;Write negative of AC into memory.
06m0003                               	                ;Set flags.  400000,,0 will overflow.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVNS
06m0003                               	MOVNS:  SLFFXM[06m0003 02426 663146200550400440030000	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM] COND[-AC=0] JUMP[
06m0003                               	 MOVNS1 ] $
06m0003                               	]$
06m0003                               	                ;Complete fetch of read-modify-write
06m0003                               	                ;Jump if AC field (of IR) is non-zero, i.e. it loads an AC
06m0003 02427 662104204473000441202032	        D[MEM] ALU[0-D] DEST[MEMSTO] SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	
06m0003                               	                ;Write negative of number read back into memory.
06m0003                               	
06m0003                               	;
06m0003                               	; MOVM - Move Magnitude (Absolute value)
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

06m0003                               	;
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVM
06m0003 02430 640706000550400440020000	MOVM:   FIXM1 $ ;Complete data fetch
06m0003 02431 451100005571000440000000	        ACSEL[AC] D[MEM] DEST[AC] COND[OBUS<0] LBJUMP[MOVM1] C600 $
06m0003                               	                ;Load number.
06m0003                               	                ;If negative, negate it to make it positive.
06m0003                               	                ;In either case, start fetch of next instruction
06m0003                               	        .USE[XLIST
06m0003                               	 LIST ];$*$*$ Random hole
06m0003                               	        .PAIR
06m0003                               	. \ 2 + .
06m0004 02142 640160000571000440602027	]MOVM1: SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
06m0004                               	                ;Number is positive, leave it alone
06m0004                               	                ;Start next instruction fetch
06m0004 02143 640160001513000441002027	        ACSEL[AC] ALU[0-AC] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1] NORM$
06m0004                               	                ;Number is negative, make it positive.
06m0004                               	                ;Start next instruction fetch
06m0004                               	
06m0004                               	        .OPCODE[LIST 
06m0004                               	 LIST            ];MOVMI
06m0004 02432 640160035571000220602027	MOVMI:  ACSEL[AC] D[IR] MASK[18.] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
06m0004                               	                ;Immediate implies it's positive.  Equivalent to MOVEI
06m0004                               	
06m0004                               	        .OPCODE[LIST 
06m0004                               	 LIST            ];MOVMM
06m0004 02434 611140000551000440002424	MOVMM:  ACSEL[AC] ALU[AC] COND[OBUS<0] JUMP[MOVNM] CYLEN[C450] $
06m0004                               	                ;If AC is negative, store its negation and set flags
06m0004                               	                ;Note:  It will set overflow if AC contains 400000,,0
06m0004 02435 662104200551000441202032	        ACSEL[AC] ALU[AC] DEST[MEMSTO] SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM
06m0004                               	 ]$
06m0004                               	                ;Otherwise, store positive form.  (Both paths take same amount
06m0004                               	                ;of time.)
06m0004                               	                ;Also, set flags.
06m0004                               	
06m0004                               	        .OPCODE[LIST 
06m0004                               	 LIST            ];MOVMS
06m0004                               	MOVMS:  COND[MA-AC] JUMP[MOVMS2]
06m0004 02436 642146200571000440030000	                        DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM]$
06m0004                               	                ;Finish fetch of read-modify-write
06m0004                               	                ;Jump if we have to deal with two ACs
06m0004 02437 643100000571000440000000	        COND[AC=0] LBJUMP[MOVMS1] NORM $
06m0004                               	                ;Split off case where we load AC as side effect
06m0004                               	        .USE[06m0004                               	XLIST
06m0005                               	 LIST ] .PAIR
06m0005                               	. \ 2 + .
06m0006 02042 511100004571000440000000	]MOVMS1:        D[MEM] COND[OBUS<0] LBJUMP[MOVMS3] C550 $
06m0006                               	                ;AC field of IR is non-zero, AC is loaded as side effect
06m0006 02043 511100004571000440000000	        D[MEM] COND[OBUS<0] LBJUMP[MOVMS4] C550 $
06m0006                               	                ;Reference is only to memory
06m0006                               	        .PAIR
06m0006                               	. \ 2 + .
06m0007 02044 640160005571000440602027	]MOVMS3:        D[MEM] ACSEL[AC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $
06m0007                               	                ;Memory location is positive, just load AC
06m0007 02045 662104205473000441202032	        D[MEM] ALU[0-D] ACSEL[AC] DEST[MEMSTO AC] SPEC[CRYOV] MEMST OND[-MA-AC]
06m0007                               	 LBJUMP[MSMAIN] NORM ]$
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

06m0007                               	                ;Load AC with negative of memory and write negative back
06m0007                               	                ;into memory.
06m0007                               	                ;Set flags.  Will overflow if memory contains 400000,,0
06m0007                               	        .PAIR
06m0007                               	. \ 2 + .
06m0008 02046 640160000571000440602027	]MOVMS4:        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
06m0008                               	                ;Memory is positive.  Don't have to do anything here.
06m0008 02047 640144204473000441202033	        D[MEM] ALU[0-D] DEST[MEMSTO] SPEC[CRYOV] JUMP[MSMAIN1] NORM $
06m0008                               	                ;Memory is negative.  Store negation.
06m0008                               	                ;Set flags.  Will overflow if memory contains 400000,,0
06m0008                               	;Special cases for references to two ACs
06m0008                               	        .PAIR
06m0008                               	. \ 2 + .
06m0009                               	]MOVMS5:        ACSEL[MA] ALU[0-AC] DEST[AC AR] SPEC[CRYOV]
06m0009 02050 643110001512400441200000	                        COND[AC=0] LBJUMP[MOVMS6] NORM $
06m0009                               	                ;'memory' AC is negative, negate it and put it somewhere
06m0009                               	                ;the other AC loaded from.
06m0009                               	                ;Then, decide whether to load it into another AC
06m0009 02051 643110000550400440000000	        ACSEL[MA] ALU[AC] DEST[AR] COND[AC=0] LBJUMP[MOVMS6] NORM $
06m0009                               	                ;'memory' AC is positive.  Put it somewhere the other AC
06m0009                               	                ;can reference.
06m0009                               	                ;Decide whether to load it into another AC
06m0009                               	        .PAIR
06m0009                               	. \ 2 + .
06m0010 02052 640160001571000440602027	]MOVMS6:        ACSEL[AC] D[AR] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
06m0010                               	                ;AC field (of IR) is non-zero, load corresponding AC from
06m0010                               	                ;saved value of 'memory' AC.
06m0010                               	                ;Start next instruction fetch
06m0010 02053 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
06m0010                               	                ;AC field (of IR) is zero, just start next instruction fetch
06m0010                               	;       ---
06m0010                               	;MA refers to an AC.  Decide which special case we're dealing with.
06m0010 02054 571100000550400440002050	MOVMS2: ACSEL[MA] ALU[AC] COND[-OBUS<0] LBJUMP[MOVMS5] CYLEN[C500] $
06m0010                               	                ;Decide sign of 'memory' AC
06m0010                               	
06m0010                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

07m0010                               	;------------------------------------------------------------------------------
07m0010                               	;
07m0010                               	;       Integer Multiply
07m0010                               	;
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IMUL
07m0010 02440 640706000550400440020000	        FIXM1 $
07m0010 02441 640140004171000440000000	        D[MEM] DEST[Q] JUMP[IMUL1] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IMULI
07m0010 02442 640140034171000220000000	        D[IR] MASK[18.] DEST[Q] JUMP[IMUL1] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IMULM
07m0010 02444 640706200550400440030000	        FIXM2 $
07m0010 02445 640140004171000440000000	        D[MEM] DEST[Q] JUMP[IMUL2] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IMULB
07m0010 02446 640706200550400440030000	        FIXM2 $
07m0010 02447 640140004171000440000000	        D[MEM] DEST[Q] JUMP[IMUL3] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];MUL
07m0010 02450 640706000550400440020000	        FIXM1 $
07m0010 02451 640140004171000440000000	        D[MEM] DEST[Q] JUMP[MUL1] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];MULI
07m0010 02452 640140034171000220000000	        D[IR] MASK[18.] DEST[Q] JUMP[MUL1] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];MULM
07m0010 02454 640706200550400440030000	        FIXM2 $
07m0010 02455 640140004171000440000000	        D[MEM] DEST[Q] JUMP[MUL2] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];MULB
07m0010 02456 640706200550400440030000	        FIXM2 $
07m0010 02457 640140004171000440000000	        D[MEM] DEST[Q] JUMP[MUL3] NORM $
07m0010                               	
07m0010                               	;*$*$* Move rest of multiply code here
07m0010                               	
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	;
07m0010                               	;       Integer Divide
07m0010                               	;
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IDIV
07m0010 02460 640706000550400440020000	        FIXM1 $
07m0010 02461 571110000151000440000000	IDIV9:  ACSEL[AC] ALU[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV1] CYLEN[C500] $
07m0010                               	                ;LO PART TO Q, CHECK SIGN
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IDIVI
07m0010 02462 640144434571000220002461	        D[IR] MASK[18.] DEST[HOLD] JUMP[IDIV9]  NORM $ ;IMMD
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IDIVM
07m0010 02464 640706200550400440030000	        FIXM2 $
07m0010 02465 571110000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV2]  CYLEN[C500] $
07m0010                               	                ;LO PART TO Q, SAVE AC, CHECK SIGN
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IDIVB
07m0010 02466 640706200550400440030000	        FIXM2 $
07m0010 02467 571110000151000440000000	        ACSEL[AC] ALU[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV3] CYLEN[C500] $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];DIV
07m0010 02470 640706000550400440020000	        FIXM1 $
07m0010 02471 000140000151400440000000	DIV9:   ACSEL[AC+1] ALU[AC] DEST[Q] JUMP[DIV1] $ ;LO PART
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];DIVI
07m0010 02472 000144434571000220002471	        D[IR] MASK[18.] DEST[HOLD] JUMP[DIV9] $ ;IMMD
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];DIVM
07m0010 02474 640706200550400440030000	        FIXM2 $
07m0010 02475 000140000151400440000000	        ALU[AC] ACSEL[AC+1] DEST[Q] JUMP[DIV2] $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];DIVB
07m0010 02476 640706200550400440030000	        FIXM2 $
07m0010 02477 000140000151400440000000	        ALU[AC] ACSEL[AC+1] DEST[Q] JUMP[DIV3] $
07m0010                               	
07m0010                               	;$*$*$  Move rest of divide code here
07m0010                               	
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	;
07m0010                               	;       Shifts and Rotates
07m0010                               	;
07m0010                               	;       Two branches are taken for each shift/rotate, depending on direction.
07m0010                               	;       The macro SH1ST handles that.  The positive case gets ROTR loaded by
07m0010                               	;       that macro and other negative case will have to load it itself.
07m0010                               	;
07m0010                               	;       Note that by the time we get here, indexing and indirection have
07m0010                               	;       already been done, so the left half of the IR contains an honest
07m0010                               	;       shift count, albeit not necessarily in the range -35..35
07m0010                               	;
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	   .DEFINE SH1ST 07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];ASH
07m0010                               	        SH1ST 07m0010 02500 513140034171000440000000	D[IR] COND[OBUS18] DEST[Q] JUMP[ASHNEG] C550 $
07m0010 02501 640141234171000100000000	        D[IR] MASK[10] DEST[Q ROTR] JUMP[ASHPLS] NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

07m0011                               	]
07m0011                               	        .OPCODE[LIST 
07m0011                               	 LIST            ];ROT
07m0011                               	        SH1ST 07m0011 02502 513140034171000440000000	D[IR] COND[OBUS18] DEST[Q] JUMP[ROTNEG] C550 $
07m0011 02503 640141234171000100000000	        D[IR] MASK[10] DEST[Q ROTR] JUMP[ROTPLS] NORM $
07m0012                               	]
07m0012                               	        .OPCODE[LIST 
07m0012                               	 LIST            ];LSH
07m0012                               	        SH1ST 07m0012 02504 513140034171000440000000	D[IR] COND[OBUS18] DEST[Q] JUMP[LSHNEG] C550 $
07m0012 02505 640141234171000100000000	        D[IR] MASK[10] DEST[Q ROTR] JUMP[LSHPLS] NORM $
07m0013                               	]
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];JFFO (a funny kind of shift instruction)
07m0013 02506 610150000551000440000000	        ACSEL[AC] ALU[AC] COND[OBUS=0] JUMP[JFFO1] DEST[AR] CYLEN[C450] $
07m0013 02507 640140001615400440000000	        ACSEL[AC+1] ALU[0] DEST[AC] JUMP[JFFO2] NORM $
07m0013                               	
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];ASHC
07m0013 02510 640710010621400430000000	        ACSEL[AC+1] D[MASK 43] ALU[D&AC]   DEST[AR] NORM $
07m0013 02511 640140000171002440000000	        D[AR] ROT[1] DEST[Q] JUMP[ASHC1] NORM $
07m0013                               	
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];ROTC
07m0013 02512 640700000151400440000000	        ACSEL[AC+1] ALU[AC] DEST[Q]   NORM $
07m0013 02513 533100034571000440000000	        D[IR] COND[-OBUS18] LBJUMP[ROTC1] C550 $
07m0013                               	
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];LSHC
07m0013 02514 640700000151400440000000	        ACSEL[AC+1] ALU[AC] DEST[Q]   NORM $
07m0013 02515 533100034571000440000000	        D[IR] COND[-OBUS18] LBJUMP[LSHC1] C550 $
07m0013                               	
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];(KAFIX at SAIL: "A. Kotok should have done this")
07m0013 02516 531154400551000440000000	        ACSEL[AC] ALU[AC] DEST[HOLD AR] COND[-OBUS<0] JUMP[KAFIXP] C550 $
07m0013                               	                ;Load up things for FIXER, check for positive mantissa
07m0013 02517 640150000513000440000000	        ACSEL[AC] ALU[0-AC] DEST[AR] JUMP[KAFIXN] NORM $
07m0013                               	                ;Negate AR so that its exponent can be used.
07m0013                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;       Exchange AC and memory
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];EXCH
08m0013 02520 640706200550400440030000	        FIXM2 $
08m0013                               	                ;Finish fetch of read-modify-write, checking for faults
08m0013 02521 662104205171000440002032	        ACSEL[AC] D[MEM] DEST[MEMSTO O_AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
08m0013                               	                ;Store result of fetch into AC, writing the old contents of
08m0013                               	                ;that AC into memory (O_AC means store new AC and output old
08m0013                               	                ;contents).
08m0013                               	
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;       Block Transfer Instruction
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];BLT
08m0013 02522 510140010621010160000000	        D[MASK 16] ROT[4] ACSEL[AC] ALU[D&AC] COND[OBUS=0] JUMP[BLTA1] C550 $ ;J IF DEST
08m0013                               	 IS AC
08m0013 02523 470100010621054160000000	        D[MASK 16] ROT[26] ACSEL[AC] ALU[D&AC] COND[-OBUS=0] LBJUMP[BLTA2] C600 $ ; J ON
08m0013                               	 SRC NOT AC
08m0013                               	
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;       Conditional jumps which add one to both halves
08m0013                               	;
08m0013                               	;  Caution:     With these instructions, overflow from the right half will be
08m0013                               	;               added to the left half, as on a KA.
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];AOBJP
08m0013                               	        D[CONST 1,,1] ACSEL[AC] ALU[D+AC] DEST[AC]
08m0013 02524 451140015421001000002026	                        COND[OBUS<0] JUMP[MAIN] C600 $
08m0013                               	                ;Add to both halves.  If result is negative, do not jump
08m0013 02525 640164634571000440002027	        DOJUMP $
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];AOBJN
08m0013                               	        D[CONST 1,,1] ACSEL[AC] ALU[D+AC]   DEST[AC]
08m0013 02526 471140015421001000002026	          COND[-OBUS<0] JUMP[MAIN] C600 $
08m0013 02527 640164634571000440002027	        DOJUMP $
08m0013                               	
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;       Jump Instructions (and halts)
08m0013                               	;
08m0013                               	;  Caution:     Halts set PC to effective address instead of the instruction
08m0013                               	;               that caused the halt.  This is especially bad because most
08m0013                               	;               programs which do not use UUOs place a halt in location 40,
08m0013                               	;               and the location of the UUO is then lost on an F2.  This
08m0013                               	;               might be cured by replicating the instruction fetch seqeunce
08m0013                               	;               herein with the copying of the IR into the PC happening later
08m0013                               	;               during that sequence.
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JRST
08m0013 02530 643164634571000440002027	        D[IR] DEST[MA PC] COND[AC=0] JUMP[MAIN1] NORM $
08m0013                               	                ;Make ordinary jumps as fast as possible.  Always load the PC
08m0013                               	                ;from the effective address, even on halts!?!
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

08m0013 02531 510100034571024010000000	        D[IR] ROT[12] MASK[1] COND[OBUS=0] LBJUMP[JRST1] C550 $
08m0013                               	                ;Seperate according to the 10 bit of the AC field.
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JFCL
08m0013 02532 643150034571032040002026	        D[IR] ROT[15] MASK[4] DEST[AR] COND[AC=0] JUMP[MAIN] NORM $
08m0013                               	                ;Check AC field and jump to instruction fetch if zero.
08m0013                               	                ;JFCL 0,  is the fastest no-op on a KA
08m0013 02533 640140020171000440000000	        D[PC] DEST[Q] JUMP[JFCL1] NORM $
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];XCT
08m0013 02534 663146000550400440020000	        FIXM1 COND[-AC=0] JUMP[XCT1] $
08m0013 02535 640144620531000440000000	        D[PC] ALU[D-1] DEST[PC] JUMP[XCT2] NORM $
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];A No-Op on KA's not having special features
08m0013 02536 640140000571000440002026	        JUMP[MAIN] NORM $
08m0013                               	
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;
08m0013                               	;       Stack Instructions
08m0013                               	;
08m0013                               	;  Caution:     If a stack crosses zero (i.e. a carry from the right half
08m0013                               	;               occurs, the left half will be off by one, as on a KA
08m0013                               	;               (People who wrap their stacks around and thru ACs deserve to
08m0013                               	;               lose!)
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];PUSHJ
08m0013                               	        ACSEL[AC] D[CONST 1,,1] ALU[D+AC]   DEST[AC MA]
08m0013 02540 455160015421001000000000	          COND[CRY0] JUMP[PDLO1] C600 $
08m0013                               	                ;Increment stack pointer.
08m0013                               	                ;Jump on overflow (overflow code will complete instruction)
08m0013 02541 640144220571000440000000	        D[PC] DEST[MEMSTO] JUMP[PUSHJ1] NORM $
08m0013                               	                ;Store the PC and flags on the stack
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];PUSH
08m0013 02542 640706000550400440020000	        FIXM1 $
08m0013                               	                ;Complete fetch of thing to push
08m0013 02543 640150004571000440000000	        D[MEM] DEST[AR] JUMP[PUSH1] NORM $
08m0013                               	                ;Move it somewhere else so we set MA to point to stack.
08m0013                               	                ;(Setting the MA implies a read, which would destroy the thing
08m0013                               	                ;to push).
08m0013                               	                ;*$*$* Go elsewhere to finish instruction
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];POP
08m0013                               	        ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC]
08m0013 02544 475160015063001000000000	                        COND[-CRY0] JUMP[PDLO3] C600 $
08m0013                               	                ;Decrement stack pointer, but setting the MA to the old top of
08m0013                               	                ;stack.
08m0013                               	                ;If stack underflow, jump.  (Underflow code will finish the
08m0013                               	                ;instruction).
08m0013                               	         MAPF[PPOP] ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD]
08m0013 02545 640146000550400440160000	                        JUMP[POP1] CYLEN[FIXM] $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

08m0013                               	                ;If page fault, trap to special code to handle POP
08m0013                               	                ;*$*$* Go elsewhere to finish instruction
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];POPJ
08m0013                               	        ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC]
08m0013 02546 475160015063001000000000	                        COND[-CRY0] JUMP[PDLO4] C600 $
08m0013                               	                ;Decrement stack pointer, but setting the MA to the old top of
08m0013                               	                ;stack.
08m0013                               	                ;If stack underflow, jump.  (Underflow code will finish the
08m0013                               	                ;instruction).
08m0013                               	        MAPF[PPOP] ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD]
08m0013 02547 640146000550400440160000	                        JUMP[POPJ1] CYLEN[FIXM] $
08m0013                               	                ;If page fault, trap to special code to handle POP
08m0013                               	                ;*$*$* Go elsewhere to finish instruction
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JSR
08m0013 02550 642154220571000440000000	        D[PC] DEST[AR MEMSTO] COND[MA-AC] JUMP[JSR2] NORM $
08m0013                               	                ;Write PC (and flags) into effective address.
08m0013                               	                ;Watch for special case of store into AC
08m0013                               	        MAPF[STO] D[MA] ALU[D+1] DEST[PC] SPEC[CLR-HALF]
08m0013 02551 640144624433000442242026	                        JUMP[MAIN] CYLEN[MEMSTO] $
08m0013                               	                ;Set PC into one after effective address (where we stored old
08m0013                               	                ;PC) and take next instruction from there.
08m0013                               	                ;Make sure some nurd hasn't left the BIS flag on. (*** i assume
08m0013                               	                ;  that's what going on here.  TVR-Apr80)
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JSP
08m0013 02552 640700021571000440000000	        D[PC] ACSEL[AC] DEST[AC] NORM $
08m0013                               	                ;Store PC (and flags) in AC
08m0013 02553 640144624571000442202027	JSP1:   D[MA] DEST[PC] JUMP[MAIN1] SPEC[CLR-HALF] NORM $
08m0013                               	                ;Jump to effective address
08m0013                               	                ;Make sure some nurd hasn't left the BIS flag on. (*** i assume
08m0013                               	                ;  that's what going on here.  TVR-Apr80)
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JSA
08m0013 02554 640710021171000220000000	        D[PC] MASK[18.] DEST[O_AC AR] ACSEL[AC] NORM $
08m0013                               	                ;Copy PC into left half of AC and save old contents of AC in AR
08m0013                               	                ; DID SAVE A CYCLE WITH O_AC ****
08m0013                               	        D[MA] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC]
08m0013 02555 640140025561044000200000	                        JUMP[JSA1] NORM $
08m0013                               	                ;Put effective address into right half, i.e. were the old
08m0013                               	                ;contents of the AC is stored.
08m0013                               	                ;(This is the FORTRAN subroutine call, in case you were
08m0013                               	                ; wondering why it was so wierd...)
08m0013                               	                ;*$*$* (Finish instruction elsewhere)
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JRA
08m0013 02556 640710000551000440000000	        ACSEL[AC] ALU[AC] DEST[AR] NORM  $
08m0013                               	                ;Save the return address in AR
08m0013 02557 640160000571044220000000	        D[AR] ROT[18.] MASK[18.] DEST[MA] JUMP[JRA1] NORM $
08m0013                               	                ;Begin read of location containing what's to be restored into
08m0013                               	                ;the AC (to invert a JSA)
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

08m0013                               	                ;*$*$* (Finish instruction elsewhere)
08m0013                               	
08m0013                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

09m0013                               	;------------------------------------------------------------------------------
09m0013                               	;
09m0013                               	;       Integer Add and Subtract
09m0013                               	;
09m0013                               	;------------------------------------------------------------------------------
09m0013                               	
09m0013                               	;These two macros make xxx,xxxI,xxxM,xxxB for instructions which map into a
09m0013                               	;single 2901 instruction involving AC and MEM.  OP is thing to put in the 
09m0013                               	;ALU field to do this 2901 instruction.
09m0013                               	;
09m0013                               	;ADOP and LOGOP differ only in that ADOP sets flags, and can get integer
09m0013                               	;overflow
09m0013                               	;
09m0013                               	.DEFINE ADOP 09m0013                               	
09m0013                               	.DEFINE LOGOP 09m0013                               	
09m0013                               	        .OPCODE[LIST 
09m0013                               	 LIST            ];Opcodes 270-273: ADD,ADDI,ADDM,ADDB
09m0013                               	        ADOP[09m0013 02560 640706000550400440020000	        FIXM1 $
09m0013 02561 640160005421000441002027	        ACSEL[AC] D[MEM] ALU[ D+AC ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1]
09m0013                               	 CYLEN[FIXM+1] $
09m0013                               	
09m0013 02562 640160035421000221002027	        ACSEL[AC] D[IR] MASK[18.] ALU[ D+AC ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1]
09m0013                               	 NORM $
09m0013 02563 000700000571000440000000	        NOP $
09m0013                               	
09m0013 02564 640706200550400440030000	        FIXM2 $
09m0013                               	        ACSEL[AC] D[MEM] ALU[ D+AC ] DEST[MEMSTO]
09m0013 02565 662104204421000441202032	          SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0013                               	
09m0013 02566 640706200550400440030000	        FIXM2 $
09m0013                               	        ACSEL[AC] D[MEM] ALU[ D+AC ] DEST[MEMSTO AC]
09m0013 02567 662104205421000441202032	          SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0014                               	END ADOP                ;Macro defines four instructions.  See above
09m0014                               	
09m0014                               	        .OPCODE[LIST 
09m0014                               	 LIST            ];Opcodes 274-277: SUB,SUBI,SUBM,SUBB
09m0014                               	        ADOP[09m0014 02570 640706000550400440020000	        FIXM1 $
09m0014 02571 640160005463000441002027	        ACSEL[AC] D[MEM] ALU[ AC-D ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1]
09m0014                               	 CYLEN[FIXM+1] $
09m0014                               	
09m0014 02572 640160035463000221002027	        ACSEL[AC] D[IR] MASK[18.] ALU[ AC-D ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1]
09m0014                               	 NORM $
09m0014 02573 000700000571000440000000	        NOP $
09m0014                               	
09m0014 02574 640706200550400440030000	        FIXM2 $
09m0014                               	        ACSEL[AC] D[MEM] ALU[ AC-D ] DEST[MEMSTO]
09m0014 02575 662104204463000441202032	          SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0014                               	
09m0014 02576 640706200550400440030000	        FIXM2 $
09m0014                               	        ACSEL[AC] D[MEM] ALU[ AC-D ] DEST[MEMSTO AC]
09m0014 02577 662104205463000441202032	          SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0015                               	END ADOP                ;Macro defines four instructions.  See above
09m0015                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

09m0015                               	;------------------------------------------------------------------------------
09m0015                               	;
09m0015                               	;       Conditional Instructions
09m0015                               	;
09m0015                               	;       Instruction dispatch sends each group of eight instructions to one 
09m0015                               	;       place.  The condition JCOND looks at the IR to decide whether the
09m0015                               	;       condition specified by the low order three bits of the opcode has
09m0015                               	;       been satisfied.
09m0015                               	;
09m0015                               	;------------------------------------------------------------------------------
09m0015                               	
09m0015                               	;Compare AC to effective address
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];CAI
09m0015 02600 472140034463000220002026	        D[IR] MASK[18.] ACSEL[AC] ALU[AC-D] COND[-JCOND] JUMP[MAIN] C600 $
09m0015 02601 640164620433000440002027	        DOSKIP $
09m0015                               	
09m0015                               	AREA260:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Compare AC to memory
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];CAM
09m0015 02620 640706000550400440020000	        FIXM1 $
09m0015 02621 472140004463000440002026	        D[MEM] ACSEL[AC] ALU[AC-D] COND[-JCOND] JUMP[MAIN] C600 $
09m0015 02622 640164620433000440002027	DOSKP1: DOSKIP $
09m0015                               	
09m0015                               	AREA262:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Jump on AC [compared with zero]
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];JUMP
09m0015 02640 472140014421000000002026	        D[CONST 0] ACSEL[AC] ALU[AC+D] COND[-JCOND] JUMP[MAIN] C600 $
09m0015 02641 640164634571000440002027	        DOJUMP $
09m0015                               	
09m0015                               	AREA264:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Skip on memory [compared with zero]
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];SKIP
09m0015 02660 643146000550400440020000	        FIXM1 COND[AC=0] JUMP[SKIPX1] $
09m0015                               	                ;Jump if AC not loaded as side effect
09m0015 02661 472140005533000440002026	        D[MEM] ALU[D-0] ACSEL[AC] DEST[AC] COND[-JCOND] JUMP[MAIN] C600 $
09m0015                               	                ;AC field (in IR) is zero.  Just skip on appropriate condition
09m0015 02662 640164620433000440002027	        DOSKIP $
09m0015 02663 472140004533000440002026	SKIPX1: D[MEM] ALU[D-0] COND[-JCOND] JUMP[MAIN] C600 $
09m0015                               	                ;Load memory into AC as well as skipping on appropriate
09m0015                               	                ;condition
09m0015 02664 640164620433000440002027	        DOSKIP $
09m0015                               	
09m0015                               	AREA266:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Add One to AC and jump [on AC compared with zero]
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];AOJ
09m0015 02700 472140001413000441202026	        ACSEL[AC] ALU[AC+1] DEST[AC] SPEC[CRYOV] COND[-JCOND] JUMP[MAIN] C600 $
09m0015 02701 640164634571000440002027	        DOJUMP $
09m0015                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

09m0015                               	AREA270:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Add One to Memory and skip [on memory compared to zero]
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];AOS
09m0015 02720 643146200550400440030000	        FIXM2 COND[AC=0] JUMP[ASOS1]  $
09m0015                               	                ;Finish fetch part of read-modify-write
09m0015                               	                ;Jump if AC is not loaded as a side effect.
09m0015                               	        D[MEM] ALU[D+1] ACSEL[AC] DEST[AC MEMSTO] SPEC[CRYOV]
09m0015 02721 452104205433000441200000	                        COND[JCOND] LBJUMP[ASOS2] C600 $
09m0015                               	                ;(AC field (in IR) is non-zero.  Load AC as side effect.)
09m0015                               	                ;Increment memory and store result in AC.
09m0015                               	                ;Set flags (set overflow if memory was 377777,,777777)
09m0015                               	                ;Decide where or not to skip before checking for store to AC
09m0015                               	        .PAIR
09m0015                               	. \ 2 + .
09m0016 02722 662100000571000440002032	]ASOS2: MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0016                               	                ;Do not skip.  Finish store (checking for store to AC)
09m0016 02723 662104620433000440002032	        D[PC] ALU[D+1] DEST[PC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0016                               	                ;Do skip.  Finish store.
09m0016                               	;       ---
09m0016                               	ASOS1:  D[MEM] ALU[D+1] DEST[MEMSTO] SPEC[CRYOV]
09m0016 02724 452104204433000441202722	                        COND[JCOND] LBJUMP[ASOS2] C600 $
09m0016                               	                ;Simply increment memory location.  Otherwise, same as above.
09m0016                               	
09m0016       2725	AREA272 = .     ;Recover space from hole in instruction dispatch
09m0016                               	
09m0016                               	;Subtract One from AC and jump [on AC compared with zero]
09m0016                               	        .OPCODE[LIST 
09m0016                               	 LIST            ];SOJ
09m0016 02740 472140001451000441202026	        ACSEL[AC] ALU[AC-1] DEST[AC] SPEC[CRYOV] COND[-JCOND] JUMP[MAIN] C600 $
09m0016 02741 640164634571000440002027	        DOJUMP $
09m0016                               	
09m0016                               	AREA274:        ;Recover space from hole in instruction dispatch
09m0016                               	
09m0016                               	;Subtract One from Memory and skip [on memory compared to zero]
09m0016                               	        .OPCODE[LIST 
09m0016                               	 LIST            ];SOS
09m0016 02760 643146200550400440030000	        FIXM2 COND[AC=0] JUMP[ASOS3] $
09m0016                               	                ;Finish fetch part of read-modify-write
09m0016                               	                ;Jump if AC is not loaded as a side effect.
09m0016                               	        D[MEM] ALU[D-1] ACSEL[AC] DEST[AC MEMSTO] SPEC[CRYOV]
09m0016 02761 452104205531000441202722	                        COND[JCOND] LBJUMP[ASOS2] C600 $
09m0016                               	                ;(AC field (in IR) is non-zero.  Load AC as side effect.)
09m0016                               	                ;Decrement memory and store result in AC.
09m0016                               	                ;Set flags (set overflow if memory was 400000,,0)
09m0016                               	                ;Decide where or not to skip before checking for store to AC
09m0016                               	ASOS3:  D[MEM] ALU[D-1] DEST[MEMSTO] SPEC[CRYOV]
09m0016 02762 452104204531000441202722	                        COND[JCOND] LBJUMP[ASOS2] C600 $
09m0016                               	                ;Simply decrement memory location.  Otherwise, same as above.
09m0016                               	
09m0016       2763	AREA276 = .     ;Recover space from hole in instruction dispatch
09m0016                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

10m0016                               	;------------------------------------------------------------------------------
10m0016                               	;
10m0016                               	;       Boolean Instructions
10m0016                               	;
10m0016                               	;------------------------------------------------------------------------------
10m0016                               	
10m0016                               	.DEFINE CLRAC 10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];SETZ
10m0016 03000 640140001615000440002026	        CLRAC ALU[0] ACSEL[AC] DEST[AC] NORM ]  JUMP[MAIN] $
10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];SETZI
10m0016 03002 640140001615000440002026	        CLRAC ALU[0] ACSEL[AC] DEST[AC] NORM ]  JUMP[MAIN] $
10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];SETZM
10m0016 03004 662104200615000440002032	          ALU[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];SETZB
10m0016 03006 662104201615000440002032	          ALU[0] DEST[MEMSTO AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];AND,ANDI,ANDM,ANDB
10m0016                               	                ;Generates code for four instructions.  See ADD (ADOP)  
10m0016                               	        LOGOP[10m0016 03010 640706000550400440020000	        FIXM1 $
10m0016 03011 640160005621000440602027	        ACSEL[AC] D[MEM] ALU[ D&AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0016                               	
10m0016                               	
10m0016 03012 640160035621000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ D&AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0016                               	
10m0016 03013 000700000571000440000000	        NOP $
10m0016                               	
10m0016 03014 640706200550400440030000	        FIXM2 $
10m0016                               	        ACSEL[AC] D[MEM] ALU[ D&AC ] DEST[MEMSTO]
10m0016 03015 662104204621000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0016                               	
10m0016 03016 640706200550400440030000	        FIXM2 $
10m0016                               	        ACSEL[AC] D[MEM] ALU[ D&AC ] DEST[MEMSTO AC]
10m0016 03017 662104205621000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0017                               	END LOGOP
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];ANDCA
10m0017 03020 640706000550400440020000	        FIXM1 $
10m0017 03021 640140000351000440000000	        ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA1] CYLEN[FIXM+1] $
10m0017                               	
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];ANDCAI
10m0017 03022 640700000351000440000000	        ALU[NOTAC] DEST[Q] ACSEL[AC] NORM $
10m0017                               	        D[IR] MASK[18.] ACSEL[AC] ALU[D&Q] DEST[AC MA] SPEC[MA_PC]
10m0017 03023 640160035635000220602027	                        JUMP[MAIN1] NORM $
10m0017                               	
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];ANDCAM
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

10m0017 03024 640706200550400440030000	        FIXM2 $
10m0017 03025 640140000351000440000000	        ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA2] CYLEN[FIXM+1] $
10m0017                               	
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];ANDCAB
10m0017 03026 640706200550400440030000	        FIXM2 $
10m0017 03027 640140000351000440000000	        ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA3] CYLEN[FIXM+1] $
10m0017                               	
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];SETM,SETMI,SETMM,SETMB
10m0017                               	SETM:   LOGOP[10m0017 03030 640706000550400440020000	        FIXM1 $
10m0017 03031 640160005571000440602027	        ACSEL[AC] D[MEM] ALU[ D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0017                               	
10m0017 03032 640160035571000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0017 03033 000700000571000440000000	        NOP $
10m0017                               	
10m0017 03034 640706200550400440030000	        FIXM2 $
10m0017                               	        ACSEL[AC] D[MEM] ALU[ D ] DEST[MEMSTO]
10m0017 03035 662104204571000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0017                               	
10m0017 03036 640706200550400440030000	        FIXM2 $
10m0017                               	        ACSEL[AC] D[MEM] ALU[ D ] DEST[MEMSTO AC]
10m0017 03037 662104205571000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0018                               	END LOGOP
10m0018                               	        .OPCODE[LIST 
10m0018                               	 LIST            ];ANDCM,ANDCMI,ANDCMM,ANDCMB
10m0018                               	        LOGOP[10m0018 03040 640706000550400440020000	        FIXM1 $
10m0018 03041 640160005661000440602027	        ACSEL[AC] D[MEM] ALU[ -D&AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0018                               	
10m0018                               	
10m0018 03042 640160035661000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ -D&AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0018                               	
10m0018 03043 000700000571000440000000	        NOP $
10m0018                               	
10m0018 03044 640706200550400440030000	        FIXM2 $
10m0018                               	        ACSEL[AC] D[MEM] ALU[ -D&AC ] DEST[MEMSTO]
10m0018 03045 662104204661000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0018                               	
10m0018 03046 640706200550400440030000	        FIXM2 $
10m0018                               	        ACSEL[AC] D[MEM] ALU[ -D&AC ] DEST[MEMSTO AC]
10m0018 03047 662104205661000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0019                               	END LOGOP
10m0019                               	        .OPCODE[LIST 
10m0019                               	 LIST            ];SETA,SETAI,SETAM,SETAB
10m0019                               	        LOGOP[10m0019 03050 640706000550400440020000	        FIXM1 $
10m0019 03051 640160005551000440602027	        ACSEL[AC] D[MEM] ALU[ AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0019                               	
10m0019 03052 640160035551000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0019 03053 000700000571000440000000	        NOP $
10m0019                               	
10m0019 03054 640706200550400440030000	        FIXM2 $
10m0019                               	        ACSEL[AC] D[MEM] ALU[ AC ] DEST[MEMSTO]
10m0019 03055 662104204551000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0019                               	
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

10m0019 03056 640706200550400440030000	        FIXM2 $
10m0019                               	        ACSEL[AC] D[MEM] ALU[ AC ] DEST[MEMSTO AC]
10m0019 03057 662104205551000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0019                               	END LOGOP$
10m0019                               	
10m0019                               	        .OPCODE[LIST 
10m0019                               	 LIST            ];XOR,XORI,XORM,XORB
10m0019                               	        LOGOP[10m0019 03060 640706000550400440020000	        FIXM1 $
10m0019 03061 640160005721000440602027	        ACSEL[AC] D[MEM] ALU[ AC#D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0019                               	
10m0019                               	
10m0019 03062 640160035721000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ AC#D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0019                               	
10m0019 03063 000700000571000440000000	        NOP $
10m0019                               	
10m0019 03064 640706200550400440030000	        FIXM2 $
10m0019                               	        ACSEL[AC] D[MEM] ALU[ AC#D ] DEST[MEMSTO]
10m0019 03065 662104204721000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0019                               	
10m0019 03066 640706200550400440030000	        FIXM2 $
10m0019                               	        ACSEL[AC] D[MEM] ALU[ AC#D ] DEST[MEMSTO AC]
10m0019 03067 662104205721000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0020                               	END LOGOP
10m0020                               	        .OPCODE[LIST 
10m0020                               	 LIST            ];IOR,IORI,IORM,IORB
10m0020                               	        LOGOP[10m0020 03070 640706000550400440020000	        FIXM1 $
10m0020 03071 640160005561000440602027	        ACSEL[AC] D[MEM] ALU[ DORAC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0020                               	
10m0020                               	
10m0020 03072 640160035561000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ DORAC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0020                               	
10m0020 03073 000700000571000440000000	        NOP $
10m0020                               	
10m0020 03074 640706200550400440030000	        FIXM2 $
10m0020                               	        ACSEL[AC] D[MEM] ALU[ DORAC ] DEST[MEMSTO]
10m0020 03075 662104204561000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0020                               	
10m0020 03076 640706200550400440030000	        FIXM2 $
10m0020                               	        ACSEL[AC] D[MEM] ALU[ DORAC ] DEST[MEMSTO AC]
10m0020 03077 662104205561000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0021                               	END LOGOP
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];ANDCB
10m0021 03100 640706000550400440020000	        FIXM1 $
10m0021 03101 640140004161000440000000	        ACSEL[AC] ALU[DORAC] DEST[Q] D[MEM] JUMP[ACBI1] CYLEN[FIXM+1] $
10m0021                               	
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];ANDCBI
10m0021 03102 640700034161000220000000	          ACSEL[AC] D[IR] MASK[18.] ALU[DORAC] DEST[Q] NORM $
10m0021 03103 640160001755000440602027	ACBI1:  ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0021                               	
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];ANDCBM
10m0021 03104 640706200550400440030000	        FIXM2 $
10m0021 03105 640140004161000440000000	        ACSEL[AC] ALU[DORAC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

10m0021                               	
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];ANDCBB
10m0021 03106 640706200550400440030000	        FIXM2 $
10m0021 03107 640140004161000440000000	        ACSEL[AC] ALU[DORAC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $
10m0021                               	
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];EQV,EQVI,EQVM,EQVB
10m0021                               	        LOGOP[10m0021 03110 640706000550400440020000	        FIXM1 $
10m0021 03111 640160005761000440602027	        ACSEL[AC] D[MEM] ALU[ AC/#D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0021                               	
10m0021                               	
10m0021 03112 640160035761000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ AC/#D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0021                               	
10m0021 03113 000700000571000440000000	        NOP $
10m0021                               	
10m0021 03114 640706200550400440030000	        FIXM2 $
10m0021                               	        ACSEL[AC] D[MEM] ALU[ AC/#D ] DEST[MEMSTO]
10m0021 03115 662104204761000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0021                               	
10m0021 03116 640706200550400440030000	        FIXM2 $
10m0021                               	        ACSEL[AC] D[MEM] ALU[ AC/#D ] DEST[MEMSTO AC]
10m0021 03117 662104205761000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0022                               	END LOGOP
10m0022                               	        .OPCODE[LIST 
10m0022                               	 LIST            ];SETCA,SETCAI,SETCAM,SETCAB
10m0022                               	        LOGOP[10m0022 03120 640706000550400440020000	        FIXM1 $
10m0022 03121 640160005751000440602027	        ACSEL[AC] D[MEM] ALU[ NOTAC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0022                               	
10m0022                               	
10m0022 03122 640160035751000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ NOTAC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0022                               	
10m0022 03123 000700000571000440000000	        NOP $
10m0022                               	
10m0022 03124 640706200550400440030000	        FIXM2 $
10m0022                               	        ACSEL[AC] D[MEM] ALU[ NOTAC ] DEST[MEMSTO]
10m0022 03125 662104204751000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0022                               	
10m0022 03126 640706200550400440030000	        FIXM2 $
10m0022                               	        ACSEL[AC] D[MEM] ALU[ NOTAC ] DEST[MEMSTO AC]
10m0022 03127 662104205751000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0023                               	END LOGOP
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];ORCA
10m0023 03130 640706000550400440020000	        FIXM1 $
10m0023 03131 640140004261000440000000	        ACSEL[AC] D[MEM] ALU[-D&AC] DEST[Q] JUMP[OCAI1] CYLEN[FIXM+1] $
10m0023                               	
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];ORCAI
10m0023 03132 640700034261000220000000	          ACSEL[AC] D[IR] MASK[18.] ALU[-D&AC] DEST[Q] NORM $
10m0023 03133 640160001755000440602027	OCAI1:  ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0023                               	
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];ORCAM
10m0023 03134 640706200550400440030000	        FIXM2 $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

10m0023 03135 640140004261000440000000	        ACSEL[AC] ALU[-D&AC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $
10m0023                               	
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];ORCAB
10m0023 03136 640706200550400440030000	        FIXM2 $
10m0023 03137 640140004261000440000000	        ACSEL[AC] ALU[-D&AC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $
10m0023                               	
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];SETCM,SETCMI,SETCMM,SETCMB
10m0023                               	        LOGOP[10m0023 03140 640706000550400440020000	        FIXM1 $
10m0023 03141 640160005771000440602027	        ACSEL[AC] D[MEM] ALU[ NOTD ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0023                               	
10m0023                               	
10m0023 03142 640160035771000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ NOTD ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0023                               	
10m0023 03143 000700000571000440000000	        NOP $
10m0023                               	
10m0023 03144 640706200550400440030000	        FIXM2 $
10m0023                               	        ACSEL[AC] D[MEM] ALU[ NOTD ] DEST[MEMSTO]
10m0023 03145 662104204771000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0023                               	
10m0023 03146 640706200550400440030000	        FIXM2 $
10m0023                               	        ACSEL[AC] D[MEM] ALU[ NOTD ] DEST[MEMSTO AC]
10m0023 03147 662104205771000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0024                               	END LOGOP
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCM,ORCMI,ORCMM,ORCMB
10m0024 03150 640706000550400440020000	        FIXM1 $
10m0024 03151 640140004371000440000000	        D[MEM] ALU[NOTD] DEST[Q] JUMP[OCMI1] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCMI
10m0024 03152 640700034371000220000000	          D[IR] MASK[18.] ALU[NOTD] DEST[Q] NORM $
10m0024 03153 640160001545000440602027	OCMI1:  ACSEL[AC] ALU[QORAC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCMM
10m0024 03154 640706200550400440030000	        FIXM2 $
10m0024 03155 640140004371000440000000	        D[MEM] ALU[NOTD] DEST[Q] JUMP[ORCM2] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCMB
10m0024 03156 640706200550400440030000	        FIXM2 $
10m0024 03157 640140004371000440000000	        D[MEM] ALU[NOTD] DEST[Q] JUMP[ORCM3] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCB
10m0024 03160 640706000550400440020000	        FIXM1 $
10m0024 03161 640140004221000440000000	        ACSEL[AC] D[MEM] ALU[D&AC] DEST[Q] JUMP[OCBI1] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCBI
10m0024 03162 640700034221000220000000	          ACSEL[AC] D[IR] MASK[18.] ALU[D&AC] DEST[Q] NORM $
10m0024 03163 640160001755000440602027	OCBI1:  ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

10m0024                               	 LIST            ];ORCBM
10m0024 03164 640706200550400440030000	        FIXM2 $
10m0024 03165 640140004221000440000000	        ACSEL[AC] ALU[D&AC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCBB
10m0024 03166 640706200550400440030000	        FIXM2 $
10m0024 03167 640140004221000440000000	        ACSEL[AC] ALU[D&AC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];SETO
10m0024 03170 640160001741000440602027	        ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];SETOI
10m0024 03172 640160001741000440602027	        ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];SETOM
10m0024 03174 662104200741000440002032	        ALU[-1] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]    $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];SETOB
10m0024 03176 662104201741000440002032	        ALU[-1] ACSEL[AC] DEST[MEMSTO AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0024 03177 000700000571000440000000	        NOP $
10m0024                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

11m0024                               	;------------------------------------------------------------------------------
11m0024                               	;
11m0024                               	;       Half Word Instructions
11m0024                               	;
11m0024                               	;------------------------------------------------------------------------------
11m0024                               	
11m0024                               	.DEFINE MH1 11m0024                               	
11m0024                               	.DEFINE MH2 11m0024                               	
11m0024                               	.DEFINE MH3 11m0024                               	
11m0024                               	        .OPCODE[LIST 
11m0024                               	 LIST            ];HLL,HLLI,HLLM,HLLS
11m0024                               	        MH3[11m0024 03200 640706000550400440020000	FIXM1 $
11m0024 03201 640150005171000000200000	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[O_AC AR] JUMP[ HRAR ]
11m0024                               	 CYLEN[FIXM+1] $
11m0024 03202 640150025171000000200000	        D[MA] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[O_AC AR] JUMP[ HRAR ] NORM $
11m0024                               	
11m0024 03203 000700000571000440000000	        NOP $
11m0024 03204 640706200550400440030000	        FIXM2 $
11m0024 03205 640150010221044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ HLLM1 ] CYLEN[FIXM+1] $
11m0024                               	
11m0024 03206 663100000550400440030000	        ACSEL[MA] ALU[AC] DEST[ 0 ] MAPF[3] COND[-AC=0] LBJUMP[HMV] CYLEN[FIXM] $
11m0024 03207 663110004171000000200000	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS]
11m0024                               	 CYLEN[FIXM+1] $
11m0025                               	];HRL
11m0025                               	        MH3[11m0025 03210 640706000550400440020000	FIXM1 $
11m0025 03211 640150005171044000200000	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[O_AC AR] JUMP[ HRAR ]
11m0025                               	 CYLEN[FIXM+1] $
11m0025 03212 640150025171044000200000	        D[MA] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[O_AC AR] JUMP[ HRAR ] NORM
11m0025                               	 $
11m0025 03213 000700000571000440000000	        NOP $
11m0025 03214 640706200550400440030000	        FIXM2 $
11m0025 03215 640150010221000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ HRLM1 ] CYLEN[FIXM+1] $
11m0025                               	
11m0025 03216 663706200550400440030000	        ACSEL[MA] ALU[AC] DEST[ FIXMAC-MAPF-WRT ] MAPF[3] COND[-AC=0] CONTA[0]
11m0025                               	 CYLEN[FIXM] $
11m0025 03217 663110004171044000200000	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS]
11m0025                               	 CYLEN[FIXM+1] $
11m0026                               	];HLLZ
11m0026                               	        MH1[11m0026 03220 640706000550400440020000	FIXM1 $
11m0026 03221 640160005571000000402027	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT&MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1]
11m0026                               	 CYLEN[FIXM+1] $
11m0026 03222 640160025571000000402027	        D[MA] ROT[0] MASK[ 0 ] SPEC[ LEFT&MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM
11m0026                               	 $
11m0026 03223 000700000571000440000000	        NOP $
11m0026 03224 662104210621044220002032	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[D&AC] DEST[ MEMSTO ] COND[-MA-AC] LBJUMP [
11m0026                               	 MSMAIN ]  CYLEN[ NORM ] $
11m0026 03225 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0026 03226 642146200550400440030000	        ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ HLLZS1 ] DEST[FIXMAC-MAPF-WRT] MAPF[3]
11m0026                               	 CYLEN[FIXM] $
11m0026 03227 663104204571000000200000	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1]
11m0026                               	 CYLEN[FIXM+1] $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

11m0027                               	];HRLZ
11m0027                               	        MH1[11m0027 03230 640706000550400440020000	FIXM1 $
11m0027 03231 640160005571044000402027	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT&MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1]
11m0027                               	 CYLEN[FIXM+1] $
11m0027 03232 640160025571044000402027	        D[MA] ROT[22] MASK[ 0 ] SPEC[ LEFT&MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM
11m0027                               	 $
11m0027 03233 000700000571000440000000	        NOP $
11m0027 03234 662710010621000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[D&AC] DEST[ AR ] COND[-MA-AC] CONTA [ 0 ] 
11m0027                               	 CYLEN[ NORM ] $
11m0027 03235 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0027 03236 642146200550400440030000	        ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ HRLZS1 ] DEST[FIXMAC-MAPF-WRT] MAPF[3]
11m0027                               	 CYLEN[FIXM] $
11m0027 03237 663104204571044000200000	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1]
11m0027                               	 CYLEN[FIXM+1] $
11m0028                               	];HLLO
11m0028                               	        MH2[11m0028 03240 640706000550400440020000	FIXM1 $
11m0028 03241 640150005571000440000000	        D[MEM] ROT[ 0 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOR ]
11m0028                               	 CYLEN[FIXM+1] $
11m0028 03242 640150025571000440000000	        D[MA] ROT[ 0 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOR ]
11m0028                               	 NORM $
11m0028 03243 000700000571000440000000	        NOP $
11m0028 03244 662104210161000220002032	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[DORAC] DEST[Q MEMSTO ] COND[ -MA-AC ]
11m0028                               	 LBJUMP[MSMAIN] CYLEN[ NORM ] $
11m0028 03245 662104200571000440002032	        D[AR] ROT[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0028 03246 640706200550400440030000	        FIXM2 $
11m0028 03247 663110004171000440000000	        D[MEM] ROT[ 0 ] DEST[Q AR] COND[ -AC=0 ] LBJUMP[ HLLOS1] CYLEN[FIXM+1] $
11m0029                               	];HRLO
11m0029                               	        MH2[11m0029 03250 640706000550400440020000	FIXM1 $
11m0029 03251 640150005571044440000000	        D[MEM] ROT[ 22 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOR
11m0029                               	 ] CYLEN[FIXM+1] $
11m0029 03252 640150025571044440000000	        D[MA] ROT[ 22 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOR ]
11m0029                               	 NORM $
11m0029 03253 000700000571000440000000	        NOP $
11m0029 03254 640710010161044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ 0 ] CONTA[0] CYLEN[
11m0029                               	 NORM ] $
11m0029 03255 662104200571044440002032	        D[AR] ROT[22] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0029 03256 640706200550400440030000	        FIXM2 $
11m0029 03257 663110004171044440000000	        D[MEM] ROT[ 22 ] DEST[Q AR] COND[ -AC=0 ] LBJUMP[ HLLOS1] CYLEN[FIXM+1] $
11m0030                               	];HLLE
11m0030                               	        MH2[11m0030 03260 640706000550400440020000	FIXM1 $
11m0030 03261 651110005571000000200000	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[AC AR] COND[ OBUS<0 ]
11m0030                               	 LBJUMP [ HLSZ ] CYLEN[FIXM+1] $
11m0030 03262 651110025571000000200000	        D[MA] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[AC AR] COND[ OBUS<0 ] LBJUMP
11m0030                               	 [ HLSZ ] NORM $
11m0030 03263 000700000571000440000000	        NOP $
11m0030 03264 531150010161000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ -OBUS<0 ] JUMP[HLLEM1]
11m0030                               	 CYLEN[ C550 ] $
11m0030 03265 662104200571000440002032	        D[AR] ROT[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0030 03266 640706200550400440030000	        FIXM2 $
11m0030 03267 651110004171000440000000	        D[MEM] ROT[ 0 ] DEST[Q AR] COND[ OBUS<0 ] LBJUMP[ HLLES1] CYLEN[FIXM+1] $
11m0031                               	];HRLE
11m0031                               	        MH2[11m0031 03270 640706000550400440020000	FIXM1 $
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

11m0031 03271 651110005571044000200000	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[AC AR] COND[ OBUS<0 ]
11m0031                               	 LBJUMP [ HLSZ ] CYLEN[FIXM+1] $
11m0031 03272 651110025571044000200000	        D[MA] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[AC AR] COND[ OBUS<0 ]
11m0031                               	 LBJUMP [ HLSZ ] NORM $
11m0031 03273 000700000571000440000000	        NOP $
11m0031 03274 533150010161044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ -OBUS18 ]
11m0031                               	 JUMP[HRLEM1] CYLEN[ C550 ] $
11m0031 03275 662104200571044440002032	        D[AR] ROT[22] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0031 03276 640706200550400440030000	        FIXM2 $
11m0031 03277 651110004171044440000000	        D[MEM] ROT[ 22 ] DEST[Q AR] COND[ OBUS<0 ] LBJUMP[ HLLES1] CYLEN[FIXM+1] $
11m0032                               	];HRR
11m0032                               	        MH3[11m0032 03300 640706000550400440020000	FIXM1 $
11m0032 03301 640150005171000220000000	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[O_AC AR] JUMP[ HLAR ]
11m0032                               	 CYLEN[FIXM+1] $
11m0032 03302 640150025171000220000000	        D[MA] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[O_AC AR] JUMP[ HLAR ] NORM $
11m0032 03303 000700000571000440000000	        NOP $
11m0032 03304 640706200550400440030000	        FIXM2 $
11m0032 03305 640150010221000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ HRRM1 ] CYLEN[FIXM+1] $
11m0032                               	
11m0032 03306 663100000550400440030000	        ACSEL[MA] ALU[AC] DEST[ 0 ] MAPF[3] COND[-AC=0] LBJUMP[HMV] CYLEN[FIXM] $
11m0032 03307 663110004171000220000000	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS]
11m0032                               	 CYLEN[FIXM+1] $
11m0033                               	];HLR
11m0033                               	        MH3[11m0033 03310 640706000550400440020000	FIXM1 $
11m0033 03311 640150005171044220000000	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[O_AC AR] JUMP[ HLAR ]
11m0033                               	 CYLEN[FIXM+1] $
11m0033 03312 640150025171044220000000	        D[MA] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[O_AC AR] JUMP[ HLAR ] NORM $
11m0033                               	
11m0033 03313 000700000571000440000000	        NOP $
11m0033 03314 640706200550400440030000	        FIXM2 $
11m0033 03315 640150010221044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ HLRM1 ] CYLEN[FIXM+1] $
11m0033                               	
11m0033 03316 663706200550400440030000	        ACSEL[MA] ALU[AC] DEST[ FIXMAC-MAPF-WRT ] MAPF[3] COND[-AC=0] CONTA[0]
11m0033                               	 CYLEN[FIXM] $
11m0033 03317 663110004171044220000000	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS]
11m0033                               	 CYLEN[FIXM+1] $
11m0034                               	];HRRZ
11m0034                               	        MH1[11m0034 03320 640706000550400440020000	FIXM1 $
11m0034 03321 640160005571000220602027	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1]
11m0034                               	 CYLEN[FIXM+1] $
11m0034 03322 640160025571000220602027	        D[MA] ROT[0] MASK[ 22 ] SPEC[ MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM $
11m0034 03323 000700000571000440000000	        NOP $
11m0034 03324 662104210621000220002032	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[D&AC] DEST[ MEMSTO ] COND[-MA-AC] LBJUMP [
11m0034                               	 MSMAIN ]  CYLEN[ NORM ] $
11m0034 03325 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0034 03326 642146200550400440030000	        ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ HRRZS1 ] DEST[FIXMAC-MAPF-WRT] MAPF[3]
11m0034                               	 CYLEN[FIXM] $
11m0034 03327 663104204571000220000000	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1]
11m0034                               	 CYLEN[FIXM+1] $
11m0035                               	];HLRZ
11m0035                               	        MH1[11m0035 03330 640706000550400440020000	FIXM1 $
11m0035 03331 640160005571044220602027	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1]
11m0035                               	 CYLEN[FIXM+1] $
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

11m0035 03332 640160025571044220602027	        D[MA] ROT[22] MASK[ 22 ] SPEC[ MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM $
11m0035 03333 000700000571000440000000	        NOP $
11m0035 03334 662710010621044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[D&AC] DEST[ AR ] COND[-MA-AC] CONTA [ 0 ] 
11m0035                               	 CYLEN[ NORM ] $
11m0035 03335 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0035 03336 642146200550400440030000	        ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ HLRZS1 ] DEST[FIXMAC-MAPF-WRT] MAPF[3]
11m0035                               	 CYLEN[FIXM] $
11m0035 03337 663104204571044220000000	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1]
11m0035                               	 CYLEN[FIXM+1] $
11m0036                               	];HRRO
11m0036                               	        MH2[11m0036 03340 640706000550400440020000	FIXM1 $
11m0036 03341 640150005571000440000000	        D[MEM] ROT[ 0 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOL ]
11m0036                               	 CYLEN[FIXM+1] $
11m0036 03342 640150025571000440000000	        D[MA] ROT[ 0 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOL ]
11m0036                               	 NORM $
11m0036 03343 000700000571000440000000	        NOP $
11m0036 03344 662104210161044220002032	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[DORAC] DEST[Q MEMSTO ] COND[ -MA-AC ]
11m0036                               	 LBJUMP[MSMAIN] CYLEN[ NORM ] $
11m0036 03345 662104200571000440002032	        D[AR] ROT[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0036 03346 640706200550400440030000	        FIXM2 $
11m0036 03347 663110004171000440000000	        D[MEM] ROT[ 0 ] DEST[Q AR] COND[ -AC=0 ] LBJUMP[ HRROS1] CYLEN[FIXM+1] $
11m0037                               	];HLRO
11m0037                               	        MH2[11m0037 03350 640706000550400440020000	FIXM1 $
11m0037 03351 640150005571044440000000	        D[MEM] ROT[ 22 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOL
11m0037                               	 ] CYLEN[FIXM+1] $
11m0037 03352 640150025571044440000000	        D[MA] ROT[ 22 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOL ]
11m0037                               	 NORM $
11m0037 03353 000700000571000440000000	        NOP $
11m0037 03354 640710010161000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ 0 ] CONTA[0] CYLEN[
11m0037                               	 NORM ] $
11m0037 03355 662104200571044440002032	        D[AR] ROT[22] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0037 03356 640706200550400440030000	        FIXM2 $
11m0037 03357 663110004171044440000000	        D[MEM] ROT[ 22 ] DEST[Q AR] COND[ -AC=0 ] LBJUMP[ HRROS1] CYLEN[FIXM+1] $
11m0038                               	];HRRE
11m0038                               	        MH2[11m0038 03360 640706000550400440020000	FIXM1 $
11m0038 03361 653110005571000220000000	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ OBUS18 ] LBJUMP
11m0038                               	 [ HRSZ ] CYLEN[FIXM+1] $
11m0038 03362 653110025571000220000000	        D[MA] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ OBUS18 ] LBJUMP [
11m0038                               	 HRSZ ] NORM $
11m0038 03363 000700000571000440000000	        NOP $
11m0038 03364 533150010161044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ -OBUS18 ]
11m0038                               	 JUMP[HRREM1] CYLEN[ C550 ] $
11m0038 03365 662104200571000440002032	        D[AR] ROT[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0038 03366 640706200550400440030000	        FIXM2 $
11m0038 03367 653110004171000440000000	        D[MEM] ROT[ 0 ] DEST[Q AR] COND[ OBUS18 ] LBJUMP[ HRRES1] CYLEN[FIXM+1] $
11m0039                               	];HLRE
11m0039                               	        MH2[11m0039 03370 640706000550400440020000	FIXM1 $
11m0039 03371 653110005571044220000000	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ OBUS18 ] LBJUMP
11m0039                               	 [ HRSZ ] CYLEN[FIXM+1] $
11m0039 03372 653110025571044220000000	        D[MA] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ OBUS18 ] LBJUMP
11m0039                               	 [ HRSZ ] NORM $
11m0039 03373 000700000571000440000000	        NOP $
11m0039 03374 531150010161000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ -OBUS<0 ] JUMP[HLREM1]
11m0039                               	 CYLEN[ C550 ] $
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

11m0039 03375 662104200571044440002032	        D[AR] ROT[22] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0039 03376 640706200550400440030000	        FIXM2 $
11m0039 03377 653110004171044440000000	        D[MEM] ROT[ 22 ] DEST[Q AR] COND[ OBUS18 ] LBJUMP[ HRRES1] CYLEN[FIXM+1] $
11m0040                               	]
11m0040                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

12m0040                               	;------------------------------------------------------------------------------
12m0040                               	;
12m0040                               	;       Bit Test Instructions
12m0040                               	;
12m0040                               	;  Caution:     Instruction dispatch for these instructions is peculiar.
12m0040                               	;
12m0040                               	;------------------------------------------------------------------------------
12m0040                               	
12m0040                               	        .OPCODE[LIST 
12m0040                               	 LIST            ];TRN GROUP
12m0040                               	          D[IR] MASK[18.] ACSEL[AC] ALU[D&AC]
12m0040 03400 532160034621000220602027	            SPEC[MA_PC] DEST[MA] COND[-JCOND] JUMP[MAIN1] C550 $
12m0040 03401 640164620433000440002027	        DOSKIP $
12m0040                               	
12m0040                               	        .OPCODE[LIST 
12m0040                               	 LIST            ];TLN GROUP
12m0040                               	          D[IR] ROT[18.] ACSEL[AC] ALU[D&AC]
12m0040 03402 532160034621044000402027	            SPEC[LEFT&MA_PC] DEST[MA] COND[-JCOND] JUMP[MAIN1] C550 $
12m0040 03403 640164620433000440002027	        DOSKIP $
12m0040                               	
12m0040                               	   .DEFINE T2GRP 12m0040                               	
12m0040                               	;Following code is NOT dispatched to, it is JUMPed to.
12m0040                               	TRZ1:   T2GRP 12m0040 03404 640700035661000220000000	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[-D&AC] DEST[AC] NORM $
12m0040 03405 640164620433000440002027	        DOSKIP $
12m0041                               	]TLZ1:  T2GRP 12m0041 03406 640700035661044000200000	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[-D&AC] DEST[AC] NORM $
12m0041 03407 640164620433000440002027	        DOSKIP $
12m0042                               	]TRO1:  T2GRP 12m0042 03410 640700035561000220000000	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[DORAC] DEST[AC] NORM $
12m0042 03411 640164620433000440002027	        DOSKIP $
12m0043                               	]TLO1:  T2GRP 12m0043 03412 640700035561044000200000	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[DORAC] DEST[AC] NORM $
12m0043 03413 640164620433000440002027	        DOSKIP $
12m0044                               	]TRC1:  T2GRP 12m0044 03414 640700035721000220000000	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[D#AC] DEST[AC] NORM $
12m0044 03415 640164620433000440002027	        DOSKIP $
12m0045                               	]TLC1:  T2GRP 12m0045 03416 640700035721044000200000	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[D#AC] DEST[AC] NORM $
12m0045 03417 640164620433000440002027	        DOSKIP $
12m0046                               	]
12m0046                               	;(No space left before dispatch entry)
12m0046                               	
12m0046                               	        .OPCODE[LIST 
12m0046                               	 LIST            ];TDN GROUP
12m0046 03420 640706000550400440020000	        FIXM1 $
12m0046 03421 452100004621000440000000	        D[MEM] ACSEL[AC] ALU[D&AC] COND[JCOND] LBJUMP[SKMAIN] C600 $
12m0046                               	        .OPCODE[LIST 
12m0046                               	 LIST            ];TSN GROUP
12m0046 03422 640706000550400440020000	        FIXM1 $
12m0046 03423 452100004621044440000000	        D[MEM] ACSEL[AC] ROT[18.] ALU[D&AC] COND[JCOND] LBJUMP[SKMAIN] C600 $
12m0046                               	
12m0046                               	;(Following is not dispatched to.  It probably belongs with MSMAIN, etc.)
12m0046                               	        .PAIR
12m0046                               	. \ 2 + .
12m0047 03424 640160000571000440602027	]SKMAIN:        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

12m0047 03425 640164620433000440002027	        DOSKIP $
12m0047                               	
12m0047                               	AREA342:        ;Recover space from hole in instruction dispatch
12m0047                               	
12m0047                               	  .DEFINE T1GRP 12m0047                               	        .OPCODE[LIST 
12m0047                               	 LIST            ];TRZ GROUP
12m0047                               	        T1GRP 12m0047 03440 512140034621000220003404	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[D&AC] COND[JCOND] JUMP[TRZ1] C550 $
12m0047 03441 640160035661000220602027	        ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[MA_PC] ALU[-D&AC] DEST[AC MA] JUMP[MAIN1]
12m0047                               	 NORM $
12m0048                               	]
12m0048                               	        .OPCODE[LIST 
12m0048                               	 LIST            ];TLZ GROUP
12m0048                               	        T1GRP 12m0048 03442 512140034621044000203406	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[D&AC] COND[JCOND] JUMP[TLZ1] C550 $
12m0048 03443 640160035661044000402027	        ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT&MA_PC] ALU[-D&AC] DEST[AC MA]
12m0048                               	 JUMP[MAIN1] NORM $
12m0049                               	]
12m0049                               	AREA344:        ;Recover space from hole in instruction dispatch
12m0049                               	
12m0049                               	        .OPCODE[LIST 
12m0049                               	 LIST            ];TDZ
12m0049 03460 640706000550400440020000	        FIXM1 $
12m0049 03461 640140000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDZ1] NORM $
12m0049                               	
12m0049                               	        .OPCODE[LIST 
12m0049                               	 LIST            ];TSZ
12m0049 03462 640706000550400440020000	        FIXM1 $
12m0049 03463 640700000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] NORM $
12m0049                               	;       \ /
12m0049                               	;Following is not in instruction dispatch
12m0049 03464 640700005661044440000000	        ACSEL[AC] D[MEM] ROT[18.] ALU[-D&AC] DEST[AC] SHORT $
12m0049 03465 452100004635044440003424	TSZ2:   D[MEM] ROT[18.] ALU[D&Q] COND[JCOND] LBJUMP[SKMAIN] C600 $
12m0049 03466 640700005661000440000000	TDZ1:   ACSEL[AC] D[MEM] ALU[-D&AC] DEST[AC] SHORT $
12m0049 03467 452100004635000440003424	TDZ2:   D[MEM] ALU[D&Q] COND[JCOND] LBJUMP[SKMAIN] C600 $
12m0049                               	
12m0049                               	AREA346:        ;Recover space from hole in instruction dispatch
12m0049                               	
12m0049                               	        .OPCODE[LIST 
12m0049                               	 LIST            ];TRC GROUP
12m0049                               	        T1GRP 12m0049 03500 512140034621000220003414	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[D&AC] COND[JCOND] JUMP[TRC1] C550 $
12m0049 03501 640160035721000220602027	        ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[MA_PC] ALU[D#AC] DEST[AC MA] JUMP[MAIN1]
12m0049                               	 NORM $
12m0050                               	]
12m0050                               	        .OPCODE[LIST 
12m0050                               	 LIST            ];TLC GROUP
12m0050                               	        T1GRP 12m0050 03502 512140034621044000203416	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[D&AC] COND[JCOND] JUMP[TLC1] C550 $
12m0050 03503 640160035721044000402027	        ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT&MA_PC] ALU[D#AC] DEST[AC MA]
12m0050                               	 JUMP[MAIN1] NORM $
12m0051                               	]
12m0051                               	AREA350:        ;Recover space from hole in instruction dispatch
12m0051                               	
12m0051                               	        .OPCODE[LIST 
12m0051                               	 LIST            ];TDC
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

12m0051 03520 640706000550400440020000	        FIXM1 $
12m0051 03521 640140000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDC1] NORM $
12m0051                               	
12m0051                               	        .OPCODE[LIST 
12m0051                               	 LIST            ];TSC
12m0051 03522 640706000550400440020000	        FIXM1 $
12m0051 03523 640700000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] NORM $
12m0051 03524 640140005721044440003465	        ACSEL[AC] D[MEM] ROT[18.] ALU[AC#D] DEST[AC] JUMP[TSZ2] NORM $
12m0051 03525 640140005721000440003467	TDC1:   ACSEL[AC] D[MEM] ALU[AC#D] DEST[AC] JUMP[TDZ2] NORM $
12m0051                               	
12m0051                               	AREA352:        ;Recover space from hole in instruction dispatch
12m0051                               	
12m0051                               	        .OPCODE[LIST 
12m0051                               	 LIST            ];TRO GROUP
12m0051                               	        T1GRP 12m0051 03540 512140034621000220003410	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[D&AC] COND[JCOND] JUMP[TRO1] C550 $
12m0051 03541 640160035561000220602027	        ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[MA_PC] ALU[DORAC] DEST[AC MA] JUMP[MAIN1]
12m0051                               	 NORM $
12m0052                               	]
12m0052                               	        .OPCODE[LIST 
12m0052                               	 LIST            ];TLO GROUP
12m0052                               	        T1GRP 12m0052 03542 512140034621044000203412	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[D&AC] COND[JCOND] JUMP[TLO1] C550 $
12m0052 03543 640160035561044000402027	        ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT&MA_PC] ALU[DORAC] DEST[AC MA]
12m0052                               	 JUMP[MAIN1] NORM $
12m0053                               	]
12m0053                               	AREA354:        ;Recover space from hole in instruction dispatch
12m0053                               	
12m0053                               	        .OPCODE[LIST 
12m0053                               	 LIST            ];TDO GROUP
12m0053 03560 640706000550400440020000	        FIXM1 $
12m0053 03561 640140000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDO1] NORM $
12m0053                               	
12m0053                               	        .OPCODE[LIST 
12m0053                               	 LIST            ];TSO GROUP
12m0053 03562 640706000550400440020000	        FIXM1 $
12m0053 03563 640700000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] NORM $
12m0053 03564 640140005561044440003465	        ACSEL[AC] D[MEM] ROT[18.] ALU[DORAC] DEST[AC] JUMP[TSZ2] NORM $
12m0053 03565 640140005561000440003467	TDO1:   ACSEL[AC] D[MEM] ALU[DORAC] DEST[AC] JUMP[TDZ2] NORM $
12m0053                               	
12m0053                               	AREA356:        ;Recover space from hole in instruction dispatch
12m0053                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

13m0053                               	; IOT GROUP -- FOR NOW
13m0053                               	
13m0053                               	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
13m0053                               	;;;;                                                                    ;;;;
13m0053                               	;;;;    CAUTION: Hardware currently does not check for User when doing  ;;;;
13m0053                               	;;;;    IOTs.  Most, but not all, now check it in micro code.  The      ;;;;
13m0053                               	;;;;    instruction dispatch hardware is probably the right place to    ;;;;
13m0053                               	;;;;    check for this, but try to convince Poole of that...            ;;;;
13m0053                               	;;;;                                                                    ;;;;
13m0053                               	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
13m0053                               	
13m0053                               	
13m0053                               	.repeat 0[
13m0053                               	repeat 0
13m0053                               	
13m0053                               	.DEFINE IOTDIS 13m0053                               	.DEFINE IOTDIS
13m0053                               	        ;Bit 14 is guaranteed zero by instruction decode process and therefore
13m0053                               	        ;doubling can be obtained by extraction.   TVR-Apr80
13m0053                               	
13m0053                               	        .OPCODE[LIST 
13m0053                               	 LIST            ];APR & PI
13m0053 03600 665101614571000060020000	        MAPF[2] D[CONST 6] DEST[DEV-ADR] COND[-USER] LBJUMP[APIOT] NORM $
13m0053 03601 000700000571000440000000	        NOP $
13m0053                               	
13m0053                               	        .OPCODE[13m0053                               	LIST 
13m0054                               	 LIST            ]      ILGIOT 13m0054 03602 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03603 000700000571000440000000	        NOP $
13m0054                               	
13m0054                               	        .OPCODE[LIST 
13m0054                               	 LIST            ];UNUSED & MAP
13m0054 03604 640701614571000010020000	        MAPF[2] D[CONST 1] DEST[DEV-ADR] NORM $
13m0054 03605 665100034171032040000000	        D[IR] ROT[15] MASK[4] DEST[Q] COND[-USER] LBJUMP[MAPIOT] NORM $
13m0054                               	
13m0054                               	.REPEAT 7 [I13m0054                               	LGIOT 13m0054 03606 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03607 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03610 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03611 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03612 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03613 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03614 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03615 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03616 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03617 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03620 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03621 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03622 000140000571000440002026	 JUMP [MAIN] ]$
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

13m0054 03623 000700000571000440000000	        NOP $
13m0054                               	         ]
13m0054                               	        .OPCODE[LIST 
13m0054                               	 LIST            ];CTY & LPT
13m0054 03624 665101614571000040020000	        MAPF[2] D[CONST 4] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[CTYIOT] $
13m0054 03625 000700000571000440000000	        NOP $
13m0054                               	
13m0054                               	        ILGIOT 13m0054 03626 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03627 000700000571000440000000	         NOP $
13m0054                               	        ILGIOT 13m0054 03630 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03631 000700000571000440000000	         NOP $
13m0054                               	
13m0054                               	;DISK CTRL IOTS-- 140 - 174
13m0054                               	
13m0054                               	        .OPCODE[LIST 
13m0054                               	 LIST            ];DISK CTRL IOTS-- OPCODES 715 TO 724
13m0054 03632 005141614571000103400000	        D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
13m0054                               	         MAPF[0] D[IOD] DEST[MEMSTO] 
13m0054 03633 022104230571000440002024	                COND[-MA-AC] LBJUMP[SMAIN] $
13m0054 03634 005141614571000103400000	        D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
13m0054                               	         MAPF[1] D[IOD] DEST[MEMSTO] 
13m0054 03635 022104230571000440012024	                COND[-MA-AC] LBJUMP[SMAIN] $
13m0054 03636 005141614571000103400000	        D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
13m0054                               	         MAPF[2] D[IOD] DEST[MEMSTO] 
13m0054 03637 022104230571000440022024	                COND[-MA-AC] LBJUMP[SMAIN] $
13m0054 03640 005141614571000103400000	        D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
13m0054                               	         MAPF[3] D[IOD] DEST[MEMSTO] 
13m0054 03641 022104230571000440032024	                COND[-MA-AC] LBJUMP[SMAIN] $
13m0054 03642 000046000550400440020000	        FIXML PUSHJ[SET-DSK-OUT] $ ;ld cmd -- opcode 721
13m0054 03643 000140400571000443042026	         MAPF[4] d[ar] DEST[2]  DEST-A-MEM JUMP[MAIN] $
13m0054 03644 000046000550400440020000	        FIXML PUSHJ[SET-DSK-OUT] $
13m0054 03645 000160000571000440652027	         MAPF[5] DEST[MA]  SPEC[MA_PC]  JUMP[MAIN1] $
13m0054 03646 000046000550400440020000	        FIXML PUSHJ[SET-DSK-OUT] $
13m0054 03647 000160000571000440662027	         MAPF[6] DEST[MA]  SPEC[MA_PC]  JUMP[MAIN1] $
13m0054 03650 000046000550400440020000	        FIXML PUSHJ[SET-DSK-OUT] $
13m0054 03651 000160000571000440672027	         MAPF[7] DEST[MA]  SPEC[MA_PC]  JUMP[MAIN1] $
13m0054                               	        
13m0054                               	;TAPE IOTS - OPCODES 725 - 732 --Dispatch entries on page headed ";TAPE DISP"
13m0054                               	
13m0054                               	
13m0054                               	.OPCODE[13m0054                               	LIST 
13m0055                               	 LIST            ]
13m0055                               	  .REPEAT  4 [I13m0055                               	LGIOT 13m0055 03666 000140000571000440002026	 JUMP [MAIN] ]$ ;SKIP OPCODES 733 - 736
13m0055 03667 000700000571000440000000	        NOP $
13m0055                               	  ]LGIOT 13m0055 03670 000140000571000440002026	 JUMP [MAIN] ]$ ;SKIP OPCODES 733 - 736
13m0055 03671 000700000571000440000000	        NOP $
13m0055                               	  ]LGIOT 13m0055 03672 000140000571000440002026	 JUMP [MAIN] ]$ ;SKIP OPCODES 733 - 736
13m0055 03673 000700000571000440000000	        NOP $
13m0055                               	  ]LGIOT 13m0055 03674 000140000571000440002026	 JUMP [MAIN] ]$ ;SKIP OPCODES 733 - 736
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

13m0055 03675 000700000571000440000000	        NOP $
13m0055                               	  ]     .OPCODE[LIST 
13m0055                               	 LIST            ];DLS iot's (DLS is device 370)
13m0055                               	 .REPEAT 1 - DLS [ 13m0055                               	;1 - DLS
13m0055                               	
13m0055                               	   ;skip space for disk cono,coni, etc. OPS 740 - 743
13m0055                               	   ;locs 3700 to 3707
13m0055                               	          ; these dispatch entries are on dsk page.
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Tymnet opcodes (or undefined)
13m0055                               	 .repeat 1 - TYMNET - DR11P [
13m0055                               	
13m0055                               	.repeat tymnet [
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ] ;READ ECC INFO
13m0055 03720 662104244571000442402032	        D[11] A-MEM-APR DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
13m0055                               	         ;Get info on last ECC error from A-MEM(1), store in eff. adr.
13m0055 03721 000700000571000440000000	        NOP $
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Undefined
13m0055                               	        ILGIOT 13m0055 03722 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03723 000700000571000440000000	        NOP $
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];
13m0055                               	.REPEAT 1 - VC [
13m0055                               	        ILGIOT 13m0055 03724 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03725 000700000571000440000000	        NOP $
13m0055                               	].REPEAT 1 - VC
13m0055                               	.REPEAT VC [    13m0055                               	.REPEAT VC
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Undefined
13m0055                               	        ILGIOT 13m0055 03726 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03727 000700000571000440000000	        NOP $
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Undefined
13m0055                               	        ILGIOT 13m0055 03730 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03731 000700000571000440000000	        NOP $
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];IMP (BBN), device code 550
13m0055                               	.REPEAT 1 - IMP [I13m0055                               	LGIOT 13m0055 03732 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03733 000700000571000440000000	        NOP $
13m0055                               	]1 - IMP
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

13m0055                               	
13m0055                               	.REPEAT IMP [   13m0055                               	IMP
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Undefined
13m0055                               	.REPEAT (757 - 756 + 1) [I13m0055                               	LGIOT 13m0055 03734 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03735 000700000571000440000000	        NOP $
13m0055                               	 ]LGIOT 13m0055 03736 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03737 000700000571000440000000	        NOP $
13m0055                               	 ]
13m0055                               	TIMER-IOTS:
13m0055                               	  
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];760:765
13m0055                               	.REPEAT 0 * (1 - TIMER) * (765 - 760 + 1) [I13m0055                               	;;; : TIMER-IOTS + 12.  ;LEAVE SPACE FOR OPCODES 760-765
13m0055                               	;*** This is an unreasonably large waste of opcode space.  It should dispatch
13m0055                               	;*** on the AC field at least if normal PDP-10 I/O opcodes aren't suitable.
13m0055                               	;*** Furthermore, this kind of opcode has no chance of being properly
13m0055                               	;*** disassembled by DDT.                                       TVR-Apr80
13m0055                               	
13m0055                               	        .OPCODE[13m0055                               	LIST 
13m0056                               	 LIST            ].REPEAT STANSW [      13m0056                               	.REPEAT 1 - STANSW [C13m0056 03770 000140100571000440002026	URRENTLY-UNUSED[1]  JUMP[MAIN] $
13m0056                               	
13m0056 03771 000700000571000440000000	        NOP $
13m0056                               	]
13m0056                               	        .OPCODE[13m0056                               	LIST 
13m0057                               	 LIST            ]
13m0057                               	 .REPEAT 1 [
13m0057                               	        
13m0057                               	;CAM -- A COPY OF CAM WHICH HALTS IF IT DOESN'T SKIP.  WOW !
13m0057 03772 640706000550400440020000	        FIXM1 $
13m0057 03773 452140004463000440002622	        D[MEM] ACSEL[AC] ALU[AC-D] COND[JCOND] JUMP[DOSKP1] C600 $
13m0057 03774 000140104571000440003774	        D[MEM] CURRENTLY-UNUSED[1] JUMP[.] $
13m0057                               	
13m0057                               	;;DSKWT  -- DELAY UNTIL DISK NOT BUSY
13m0057                               	;       JUMP[DSKWT1] $          ;OPCODE 775
13m0057                               	;       NOP $
13m0057                               	;       NOP $
13m0057                               	;       NOP $
13m0057                               	
13m0057                               	]
13m0057                               	.REPEAT 0 [ 13m0057                               	
13m0057                               	        .OPCODE[LIST 
13m0057                               	 LIST            ];OPCODE 777 --- MAKE IT A UUO
13m0057                               	;;;     JUMP[MUUO] $
13m0057 03776 640150020171000440002125	        UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$             ;Illegal instruction
13m0057                               	 rather than an IOT.  It's an
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

13m0057                               	                        ;easy thing to stumble upon in buggy programs (or
13m0057                               	                        ;hardware), being it is most common negative integers
13m0057                               	
13m0057                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

14m0057                               	;MSTART MSTRT1 BADPC ILDB1 ILDB2 IDPB1 IDPB2 ILDB3 LDB1 LDB5 LDB2 LDB4 DPB1 DPB5 DPB7
14m0057                               	 IDPB3 DPB2 DPB4 BIIH1 BIIH BII IBP1 IBT1
14m0057                               	;NON DISPATCH STUFF HERE
14m0057                               	
14m0057                               	        .ORG[14m0057                               	XLIST
14m0058                               	 LIST ]; INIT THINGS -- INITIALIZE MACHINE, POWER-UP COMES HERE.
14m0058                               	
14m0058                               	MSTART:
14m0058 04000 000140000571000440000000	JUMP[MSTRT1] $  ;to help operator start from switches (KEEP THIS SIMPLE -- MLB)
14m0058                               	
14m0058                               	        .USE[14m0058                               	XLIST
14m0059                               	 LIST ]MSTRT1:
14m0059                               	
14m0059                               	;******* This code to be made a subroutine to allow machine resetting *******
14m0059                               	;******* to be done by auto-loading and via CONO APR,20000  TVR-Mar80 *******
14m0059                               	
14m0059                               	.REPEAT 1 - CROCK [     14m0059                               	1 - CROCK
14m0059                               	
14m0059                               	
14m0059                               	;The following code sets up the AMEM zero vectors for various random devices.
14m0059                               	;this is a complete CROCK!  The device reset subroutines should do this!!
14m0059                               	;I plan to fix this soon (when I have time, ha ha)      -- MLB 23JAN80
14m0059                               	;$*$*$ Fix this soon.   TVR-Apr80
14m0059                               	
14m0059 04001 640702414171014200000000	        D[CONST 20] ROT[6] DEST[Q CLR-DEV-FROM-INTR] NORM $
14m0059                               	
14m0059                               	        .DEFINE AMLD2 14m0059                               	        AMLD2 14m0059 04002 640701614571000010000000	D[CONST 1] DEST[DEV-ADR] NORM $
14m0059 04003 640700014575000623000000	        D[CONST 62] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTERRUPTS FROM DEV 1 (SWITCHES) GO TO 2062
14m0059 04004 640700014171014210000000	        D[CONST 21] ROT[6] DEST[Q] NORM $
14m0059                               	;;;     AMLD2 [ 4 0 30 ] ; INTERRUPTS FROM DEV 4 GO TO 2130 [Now set at CTYRST]
14m0059                               	        AMLD2 14m0059 04005 640701614571000050000000	D[CONST 5] DEST[DEV-ADR] NORM $
14m0059 04006 640700014575000343000000	        D[CONST 34] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTRS FROM DEV 5 GO TO 2134
14m0059                               	        AMLD2 14m0059 04007 640701614571000060000000	D[CONST 6] DEST[DEV-ADR] NORM $
14m0059 04010 640700014575000413000000	        D[CONST 41] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTS FROM DEV 6 GO TO 2141
14m0059                               	        AMLD2 14m0059 04011 640701614571000070000000	D[CONST 7] DEST[DEV-ADR] NORM $
14m0059 04012 640700014575000503000000	        D[CONST 50] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTS FROM DEV 7 GO TO 2150
14m0059                               	        AMLD2 14m0059 04013 640701614571000100000000	D[CONST 10] DEST[DEV-ADR] NORM $
14m0059 04014 640700014575000563000000	        D[CONST 56] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTS FROM DEV 10 GO TO 2156
14m0059                               	.REPEAT DLS [
14m0059                               	        AMLD2 14m0059 04015 640701614571000200000000	D[CONST DLSDEV] DEST[DEV-ADR] NORM $
14m0059 04016 640700014575000373000000	        D[CONST 37] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; DLS GOES TO 2137
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

14m0059                               	]DLS
14m0059                               	;;      the IMP reset code takes care of this for itself!!
14m0059                               	
14m0059                               	;;; Moved code to set MAP-DISP to MAPRST (due to lack of space between
14m0059                               	;;; 4000:4777).                                           TVR-Apr80
14m0059 04017 640705400615000440000000	        ALU[0] DEST[CRYOV] NORM $
14m0059 04020 640703600615000440000000	        ALU[0] DEST[CLR-MI-ERR] NORM $
14m0059 04021 640700614571000002600000	        D[CONST 0] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
14m0059 04022 640140000571000440000000	        JUMP[RESLOP] NORM $
14m0059                               	
14m0059 04023 000140000571000440002026	BADPC:  BADLOC $
14m0059                               	
14m0059                               	;------------------------------------------------------------------------------
14m0059                               	;$*$*$* THIS JUNK HAS GOT TO MOVE! TVR-Apr80
14m0059                               	;
14m0059                               	;Some of it also needs commenting but this must be postponed until after CCRMA
14m0059                               	;merge.
14m0059                               	;------------------------------------------------------------------------------
14m0059                               	
14m0059                               	        .USE[14m0059                               	XLIST
14m0060                               	 LIST ] .PAIR   . \ 2 + .
14m0060                               	];Goes to second if HALF is not set
14m0060 02602 640141400571030060000000	ILDB1:  D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[ILDB2] NORM $
14m0060                               	                ;Extract S field.  Being HALF was set, don't increment
14m0060 02603 657051400571030060000000	        D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $
14m0060                               	                ;Extract S field.  Increment word if byte overflow will happen
14m0060 02604 662154200077074440002606	        D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] -MA-AC JUMP[. + 2] NORM $
14m0060                               	                ;SUB S FROM P
14m0060                               	                ;Increment byte pointer, no overflow possible now
14m0060                               	                ;Store into memory, check for store into AC
14m0060 02605 640700005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] $
14m0060                               	                ;Store is into an AC, write it there.
14m0060 02606 664120000555000440000000	ILDB2:  ALU[Q] DEST[MA] COND[-MEM-IDX-IND] LBJUMP[ILDB3] NORM $
14m0060                               	                ;Fetch data, perhaps.  Maybe also do indexing or indirection
14m0060                               	        .PAIR
14m0060                               	. \ 2 + .
14m0061 02610 640141400571030060000000	]IDPB1: D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[IDPB2] NORM $
14m0061 02611 657051400571030060000000	        D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $;GET S FLD,
14m0061                               	 OVFL?
14m0061 02612 662154200077074440002614	        D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $;SUB S
14m0061                               	 FROM P
14m0061 02613 640700005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] $
14m0061 02614 664120000555000440000000	IDPB2:  ALU[Q] DEST[MA] COND[-MEM-IDX-IND] LBJUMP[IDPB3] NORM $
14m0061                               	
14m0061                               	        .PAIR   . \ 2 + .
14m0061                               	];Goes to second if not indexing or indirecting
14m0061 02616 640040000571000440020000	ILDB3:  MAPF[NORM-RD] PUSHJ[BIIH] NORM $;HANDLE IDX-IND
14m0061                               	        MAPF[BYTE-ILD] ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD]
14m0061 02617 640146000550400440110000	                        JUMP[LDB2] CYLEN[FIXM] $
14m0061                               	                ;Finish read of data word, then go extract byte
14m0061                               	
14m0061                               	        .USE[14m0061                               	XLIST
14m0062                               	 LIST ] .PAIR   . \ 2 + .
14m0062                               	];Goes to second if not indexing or indirecting
14m0062 02624 640040000571000440020000	LDB1:   MAPF[2] PUSHJ[BII] NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

14m0062 02625 640706000550400440020000	LDB5:   FIXM1 $ ;Also gets here from XBY13
14m0062 02626 640701400571030060000000	        D[AR] ROT[14] MASK[6] DEST[MASKR] SHORT $
14m0062                               	                ;GET S FLD
14m0062 02627 640700014171000442200000	        SPEC[CLR-HALF] D[CONST 44] DEST[Q] SHORT $
14m0062 02630 640701200077014060000000	        D[AR] ROT[6] MASK[6] ALU[Q-D] DEST[Q ROTR] SHORT $
14m0062                               	                ;SUB P FLD FROM 44
14m0062 02631 531140000477030060000000	        D[AR] ROT[12.] MASK[6] ALU[Q-D] COND[-OBUS<0] JUMP[LDB4] C550 $
14m0062                               	                ;Also, subtract S field.  If result is positive, then byte
14m0062                               	                ;of size S fits with at least P bits remaining in the right
14m0062                               	                ;side of the word
14m0062 02632 640141400555000440000000	        ALU[Q] DEST[MASKR] JUMP[LDB4] NORM $
14m0062                               	                ;Byte does not fit!!!  We want only the stuff to the left
14m0062                               	                ;of postion P, which is 36.-P bits, coincidentally, the same
14m0062                               	                ;size as the rotation
14m0062                               	;S field is already set up.  Set up P field and extract data from word.
14m0062 02633 640700014171000442200000	LDB2:   SPEC[CLR-HALF] D[CONST 44] DEST[Q] SHORT $
14m0062 02634 640701200477014060000000	        D[AR] ROT[6] MASK[6] ALU[Q-D] DEST[ROTR] SHORT $
14m0062                               	                ;SUB P FLD FROM 44
14m0062 02635 640160005571201000602027	LDB4:   D[MEM] ACSEL[AC] ROT[R] MASK[R] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $; DO
14m0062                               	 THE LDB
14m0062                               	
14m0062                               	
14m0062                               	        .PAIR
14m0062                               	. \ 2 + .
14m0063 02636 640040000571000440020000	]DPB1:  MAPF[2] PUSHJ[BII] NORM $
14m0063                               	DPB5:           ;Also gets here from XBY13
14m0063                               	;;;     FIXM2 $ ;Wrong thing for WAITS.
14m0063                               	          MAPF[BYTE-IDP] CYLEN[FIXM]
14m0063 02637 640146200550400440120000	                        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] JUMP[DPB7] $
14m0063                               	                ;KA/KL set half flag even on DPB.  They would also set read
14m0063                               	                ;failure, not write, in the case of not in map; but we don't
14m0063                               	                ;have time to be particular.                    TVR-Apr80
14m0063                               	
14m0063                               	        .USE[14m0063                               	XLIST
14m0064 04024 640701400571030060000000	 LIST ]DPB7:    D[AR] ROT[12.] MASK[6] DEST[MASKR] SHORT $
14m0064                               	                ;Fetch S field.
14m0064 04025 640701200171014062200000	        SPEC[CLR-HALF] D[AR] ROT[6] MASK[6] DEST[Q ROTR] SHORT $
14m0064                               	                ;Fetch P field.
14m0064 04026 640700014137000440000000	        D[CONST 44] ALU[D-Q] DEST[Q] SHORT $
14m0064                               	                ;Calculate 36-P, which is maximum number of bits in this byte
14m0064 04027 531140000477030060000000	        D[AR] ROT[12.] MASK[6] ALU[Q-D] COND[-OBUS<0] JUMP[DPB4] C550 $
14m0064                               	                ;Does this byte fit?  I.e. 36-P-S is non-negative.  If so,
14m0064                               	                ;use this mask field
14m0064 04030 640141400555000440000000	        ALU[Q] DEST[MASKR] JUMP[DPB4] NORM $
14m0064                               	                ;Setup mask which is everything to the left of the position
14m0064                               	                ;designated by P.
14m0064                               	
14m0064                               	        .USE[14m0064                               	XLIST
14m0065                               	 LIST ] .PAIR
14m0065                               	. \ 2 + .
14m0066 02666 640040000571000440020000	]IDPB3: MAPF[2] PUSHJ[BIIH] NORM $;HANDLE IDX-IND
14m0066                               	        MAPF[BYTE-IDP] CYLEN[FIXM]
14m0066 02667 640706200550400440120000	                ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] $
14m0066 02670 640701400571030060000000	        D[AR] ROT[14] MASK[6] DEST[MASKR] SHORT $
14m0066 02671 640701200171014062200000	DPB2:   SPEC[CLR-HALF] D[AR] ROT[6] MASK[6] DEST[Q ROTR] SHORT $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

14m0066 02672 640710010621001000000000	DPB4:   D[2] MASK[R] ACSEL[AC] ALU[D&AC] DEST[AR] SHORT $;GET BYTE
14m0066 02673 640700004171000440000000	        D[MEM] DEST[Q] SHORT $; GET DEST WORD
14m0066 02674 640700010275201000000000	        D[2] MASK[R] ROT[R] ALU[-D&Q] DEST[Q] SHORT $;CLR DEST BYTE
14m0066 02675 662104200575200440002032	        D[AR] ROT[R] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$;DO
14m0066                               	 IT
14m0066                               	
14m0066                               	.DEFINE BIIMAC[14m0066                               	        .USE[14m0066                               	XLIST
14m0067                               	 LIST ]BIIH:    BIIMAC 14m0067 02642 510141000571044040000000	D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[BII1] C550 $
14m0067                               	                ;IDX FLD
14m0067 02643 640720024420000220000000	        D[MA] ACSEL[REG] MASK[18.] ALU[D+AC] DEST[MA] SHORT $
14m0067                               	                ;DO INDEXING
14m0067 02644 550300000571034010020000	        D[AR] ROT[16] MASK[1] MAPF[2] COND[OBUS=0] POPJ CYLEN[C500] $
14m0067                               	                ;LEAVEIF NO IND
14m0067 02645 640706000550400440130000	BII1:   ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BYTE-IND] CYLEN[FIXM] $
14m0067 02646 564320004171000270000000	        D[MEM] MASK[27] DEST[Q MA] COND[-MEM-IDX-IND] POPJ CYLEN[C500] $
14m0067                               	                ;GET INDIRECT WORD, LEAVE IF NO MORE IND OR IDX
14m0067 02647 640710000571030140020000	        D[AR] ROT[14] MASK[14] DEST[AR] MAPF[2] NORM $
14m0067 02650 661150000175060440002642	        D[AR] ROT[30] ALU[DORQ] DEST[Q AR] COND[-INTRPT] JUMP[BIIH] NORM $
14m0067                               	                ;Loop if no interrupt is waiting.
14m0067 02651 640040000571000440000000	        PUSHJ[SETHLF] NORM $
14m0067                               	                ;Intrpt. waiting.   Set HALF (BIS) flag in PC.
14m0067 02652 640344620531000440002026	        D[PC] ALU[D-1] DEST[PC] NORM JPOP[MAIN] $
14m0067                               	                ;Back up PC (so instr. will be re-executed) and take intrpt.
14m0068                               	]
14m0068                               	  .USE[14m0068                               	XLIST
14m0069                               	 LIST ]
14m0069                               	BII:    BIIMAC 14m0069 04031 510141000571044040000000	D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[BII2] C550 $
14m0069                               	                ;IDX FLD
14m0069 04032 640720024420000220000000	        D[MA] ACSEL[REG] MASK[18.] ALU[D+AC] DEST[MA] SHORT $
14m0069                               	                ;DO INDEXING
14m0069 04033 550300000571034010020000	        D[AR] ROT[16] MASK[1] MAPF[2] COND[OBUS=0] POPJ CYLEN[C500] $
14m0069                               	                ;LEAVEIF NO IND
14m0069 04034 640706000550400440020000	BII2:   ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-RD] CYLEN[FIXM] $
14m0069 04035 564320004171000270000000	        D[MEM] MASK[27] DEST[Q MA] COND[-MEM-IDX-IND] POPJ CYLEN[C500] $
14m0069                               	                ;GET INDIRECT WORD, LEAVE IF NO MORE IND OR IDX
14m0069 04036 640710000571030140020000	        D[AR] ROT[14] MASK[14] DEST[AR] MAPF[2] NORM $
14m0069 04037 661150000175060440004031	        D[AR] ROT[30] ALU[DORQ] DEST[Q AR] COND[-INTRPT] JUMP[BII] NORM $
14m0069                               	                ;Loop if no interrupt is waiting.
14m0069 04040 640040000571000440000000	        PUSHJ[SETHLF] NORM $
14m0069                               	                ;Intrpt. waiting.   Set HALF (BIS) flag in PC.
14m0069 04041 640344620531000440002026	        D[PC] ALU[D-1] DEST[PC] NORM JPOP[MAIN] $
14m0069                               	                ;Back up PC (so instr. will be re-executed) and take intrpt.
14m0070                               	]
14m0070                               	        .PAIR   . \ 2 + .
14m0070                               	];Skip if AC=0
14m0070 04042 640150020171000440002125	IBP1:   UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$     ;Non-zero AC implies ADJBP.  We
14m0070                               	 don't, yet.
14m0070 04043 657050000571030060000000	        D[AR] ROT[14] MASK[6] DEST[AR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $;GET S FLD, OVFL?
14m0070                               	
14m0070                               	                ;Zero AC.  Do ordinary increment byte pointer.
14m0070                               	                ;PUSHJ if we are about to overflow a word.
14m0070 04044 662104200077074440002032	        D[AR] ROT[36] ALU[Q-D] DEST[Q MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

14m0070                               	                ;Finish updating byte position part of pointer
14m0070                               	
14m0070                               	;Increment byte pointer which crosses a word boundary
14m0070 04045 640700010235000360000000	IBT1:   D[MASK 36] ALU[D&Q] DEST[Q] SHORT $
14m0070 04046 640300014037074440000000	        D[CONST 44] ROT[36] ALU[D+Q+1] DEST[Q] POPJ NORM $
14m0070                               	                ;NEW P FLD OF 44, ADD 1 TO ADR
14m0070                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

15m0070                               	;IMUL1 IMUL2 IMUL3 MUL1 MUL2 MUL3 DOIMUL MSETOV DOMMUL DOMUL DOMUL1 DOMUL4 IDIV1 IDIV2
15m0070                               	 IDIV3 DIV1 DIV2 DIV3 DODDIV DODIV DODIV1 DODIV3 DODIV2 STOVFQ DODIV4 DODIV6 DODIV5
15m0070                               	
15m0070 04047 640050001215000440000000	IMUL1:  ALU[0] DEST[AR O_AC] PUSHJ[DOIMUL] NORM $       ;0 TO AC,AC TO AR
15m0070 04050 640140001555000440002026	        ALU[Q] DEST[AC] JUMP[MAIN] NORM $
15m0070 04051 640050001215000440000000	IMUL2:  ALU[0] DEST[AR O_AC] PUSHJ[DOIMUL] NORM $       ;0 TO AC
15m0070 04052 640700001571000440000000	        D[AR] DEST[AC] NORM $
15m0070 04053 662104200555000440002032	        ALU[Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0070                               	
15m0070 04054 640050001215000440000000	IMUL3:  ALU[0] DEST[AR O_AC] PUSHJ[DOIMUL] NORM $
15m0070 04055 662104201555000440002032	        ALU[Q] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0070                               	
15m0070 04056 640050001215000440000000	MUL1:   ALU[0] DEST[AR O_AC] PUSHJ[DOMMUL] NORM $
15m0070 04057 640140001555400440002026	        ACSEL[AC+1] ALU[Q] DEST[AC] JUMP[MAIN] NORM $
15m0070                               	
15m0070 04060 640050001215000440000000	MUL2:   ALU[0] DEST[AR O_AC] PUSHJ[DOMMUL] NORM $
15m0070 04061 662104201171000440002032	        D[AR] DEST[O_AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0070 04062 640050001215000440000000	MUL3:   ALU[0] DEST[AR O_AC] PUSHJ[DOMMUL] NORM $
15m0070 04063 640700001555400440000000	        ACSEL[AC+1] ALU[Q] DEST[AC] NORM $
15m0070 04064 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0070                               	
15m0070 04065 640040000571000440000000	DOIMUL: PUSHJ[DOMUL] NORM $
15m0070 04066 550300000551000440000000	        ALU[AC] COND[OBUS=0] POPJ CYLEN[C500] $; NO OV IF 0
15m0070 04067 550300000751000440000000	        ALU[NOTAC] COND[OBUS=0] POPJ CYLEN[C500] $; NO OV IF -1
15m0070 04070 640700021571000440000000	MSETOV: D[PC] DEST[AC] SHORT $; GET FLAGS
15m0070 04071 640305414561106010000000	MSTOV1: D[CONST 1] ROT[43] ALU[DORAC] DEST[CRYOV] NORM POPJ $; SET OV
15m0070 04072 570140000735000440000000	DOMMUL: D[AR] ALU[D#Q] COND[-OBUS=0] JUMP[DOMUL] CYLEN[C500] $; NO OV IF DIFF OPERS
15m0070 04073 570140014735106010000000	        D[CONST 1] ROT[43] ALU[D#Q] COND[-OBUS=0] JUMP[DOMUL] CYLEN[C500] $; J IF NOT
15m0070                               	 -2**35
15m0070 04074 640040000571000440004070	        PUSHJ[MSETOV] NORM $;SET OV
15m0070 04075 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
15m0070 04076 640740014571000420000000	DOMUL:  D[CONST 42] LLOAD NORM $        ;LOOP 35 TIMES
15m0070                               	
15m0070                               	DOMUL1: D[AR] ALU[MULAC+D] DEST[D4] MASK[3]
15m0070 04077 640240002021000030004077	                        LOOP[DOMUL1] NORM $ ;SHIFT, END-COND MUL; SOJGE, SH RT
15m0070                               	                ;This shifts right, with the low order bit of the partial
15m0070                               	                ;product being saved in Q.  At the same time, shift out of Q
15m0070                               	                ;a bit of the multiplier (and somehow??? the hardware uses this
15m0070                               	                ;to decide whether to add or not???)
15m0070                               	                ;MASK field specifies what gets shifted into AC, in this case,
15m0070                               	                ;(ALU OV) XOR (-OUT<0)
15m0070                               	        D[AR] ALU[MULAC+D] DEST[D4] MASK[3]
15m0070 04100 634140002021000030004102	                        COND[-Q0-35] JUMP[. + 2] CYLEN[C450] $ ;J IF QUOT WAS +
15m0070                               	                ;Do last step of multiply. Jump on sign of multiplier(?)
15m0070                               	        D[AR] ALU[MULAC-D] DEST[D7]
15m0070 04101 640140003443000440004103	                        JUMP[. + 2] NORM $ ; DEST AC SH LFT, ALU=1, ALU S=0
15m0070                               	                ;Multiplier was positive... ???: Shift left to make properly
15m0070                               	                ;signed result, with low order bit coming from Q0 (i think???)
15m0070 04102 640700003545000440000000	        ALU[SH-AC] DEST[D7] NORM $ ;DEST AC SH LFT
15m0070                               	                ;SINCE DEST IS >3, ALU[QORAC] IS ALU[AC]
15m0070                               	                ;Multiplier was negative... ???
15m0070 04103 551100000551000440000000	        ALU[AC] COND[OBUS<0] LBJUMP[DOMUL4] CYLEN[C500] $
15m0070                               	                ;Decide what sign should be in the low order result.
15m0070                               	
15m0070                               	        .PAIR
15m0070                               	. \ 2 + .
15m0071 04104 640300010235000430000000	]DOMUL4:        D[MASK 35.] ALU[D&Q] DEST[Q] POPJ NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

15m0071                               	                ;Positive.  Turn off Q0, which was copied into AC35.
15m0071 04105 640300014175106010000000	        D[CONST 1] ROT[35.] ALU[DORQ] DEST[Q] POPJ NORM $
15m0071                               	                ;Negative.  Set Q0 so the number is negative (Q0 was copied into
15m0071                               	                ;AC35).
15m0071                               	
15m0071       740000000000000000000000	  CCC1  = SHORT $       ;Apparently used as a NO-OP for macros below. TVR-Apr80
15m0071       777740000000000000007777	  MEMST1 = MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$     ;Store to memory. (Cause macro
15m0071                               	 expansion now, rather
15m0071                               	                        ;than in macro call.)
15m0071                               	
15m0071                               	.DEFINE DMACFN 15m0071                               	.DEFINE DMAC2 15m0071                               	.DEFINE DMAC1 15m0071                               	
15m0071                               	IDIV1:  DMAC1
15m0071                               	.PAIR
15m0071                               	. \ 2 + .
15m0072 04106 640140001741000440004110	]       ALU[-1] DEST[AC] JUMP[. + 2] NORM $
15m0072 04107 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
15m0072 04110 640710004721000440000000	        D[MEM] ALU[D#AC] DEST[AR] SHORT $
15m0072 04111 640700200571002010000000	        D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
15m0072 04112 640050000555000440000000	        ALU[Q] DEST[AR] PUSHJ[DODIV] NORM $
15m0072                               	]       DMACFN[15m0072 04113 640710001155000440000000	ALU[Q] D[AR] DEST[O_AC AR] SHORT $
15m0072 04114 640160001571400440602027	        ACSEL[AC+1] D[AR] ALU[D] DEST[AC MA] DOM1 $
15m0072 04115 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0073                               	]IDIV2: DMAC1
15m0073                               	.PAIR
15m0073                               	. \ 2 + .
15m0074 04116 640140001741000440004120	]       ALU[-1] DEST[AC] JUMP[. + 2] NORM $
15m0074 04117 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
15m0074 04120 640710004721000440000000	        D[MEM] ALU[D#AC] DEST[AR] SHORT $
15m0074 04121 640700200571002010000000	        D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
15m0074 04122 640050000555000440000000	        ALU[Q] DEST[AR] PUSHJ[DODIV] NORM $
15m0074                               	]       DMACFN[15m0074 04123 640710001171000440000000	ALU[D] D[AR] DEST[O_AC AR] SHORT $
15m0074 04124 662114200555400440002032	        ACSEL[AC+1] D[AR] ALU[Q] DEST[MEMSTO AR] MEMST1 $
15m0074 04125 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0075                               	]IDIV3: DMAC1
15m0075                               	.PAIR
15m0075                               	. \ 2 + .
15m0076 04126 640140001741000440004130	]       ALU[-1] DEST[AC] JUMP[. + 2] NORM $
15m0076 04127 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
15m0076 04130 640710004721000440000000	        D[MEM] ALU[D#AC] DEST[AR] SHORT $
15m0076 04131 640700200571002010000000	        D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
15m0076 04132 640050000555000440000000	        ALU[Q] DEST[AR] PUSHJ[DODIV] NORM $
15m0076                               	]       DMACFN[15m0076 04133 640710001155000440000000	ALU[Q] D[AR] DEST[O_AC AR] SHORT $
15m0076 04134 640700001571400440000000	        ACSEL[AC+1] D[AR] ALU[D] DEST[AC 0] CCC1 $
15m0076 04135 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0077                               	]DIV1:  DMAC2
15m0077 04136 640050004721000440000000	D[MEM] ALU[D#AC] DEST[AR] PUSHJ[DODDIV] NORM $
15m0078                               	]       DMACFN[15m0078 04137 640710001155000440000000	ALU[Q] D[AR] DEST[O_AC AR] SHORT $
15m0078 04140 640160001571400440602027	        ACSEL[AC+1] D[AR] ALU[D] DEST[AC MA] DOM1 $
15m0078 04141 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0079                               	]DIV2:  DMAC2
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

15m0079 04142 640050004721000440000000	D[MEM] ALU[D#AC] DEST[AR] PUSHJ[DODDIV] NORM $
15m0080                               	]       DMACFN[15m0080 04143 640710001171000440000000	ALU[D] D[AR] DEST[O_AC AR] SHORT $
15m0080 04144 662114200555400440002032	        ACSEL[AC+1] D[AR] ALU[Q] DEST[MEMSTO AR] MEMST1 $
15m0080 04145 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0081                               	]DIV3:  DMAC2
15m0081 04146 640050004721000440000000	D[MEM] ALU[D#AC] DEST[AR] PUSHJ[DODDIV] NORM $
15m0082                               	]       DMACFN[15m0082 04147 640710001155000440000000	ALU[Q] D[AR] DEST[O_AC AR] SHORT $
15m0082 04150 640700001571400440000000	        ACSEL[AC+1] D[AR] ALU[D] DEST[AC 0] CCC1 $
15m0082 04151 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0083                               	]
15m0083 04152 640700200571002010000000	DODDIV: D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
15m0083 04153 640710002545000010000000	        ALU[SH-AC] DEST[AR D5] MASK[1] NORM $
15m0083 04154 510140000571000010004156	        D[AR] MASK[1] COND[OBUS=0] JUMP[. + 2] C550 $
15m0083 04155 640140014175106010004157	        D[CONST 1] ROT[43] ALU[DORQ] DEST[Q] JUMP[. + 2] NORM $
15m0083 04156 640700010235000430000000	        D[MASK 43] ALU[D&Q] DEST[Q] NORM $
15m0083                               	;------------------------------------------------------------------------------
15m0083                               	;
15m0083                               	;       Single Precision Divide (and continuation of double precision)
15m0083                               	;
15m0083                               	;       (Reminder: Quotient, Remainder = Dividend / Divisor)
15m0083                               	;
15m0083                               	;Where we get here:
15m0083                               	;    MEM        36 bit signed divisor
15m0083                               	;    AC         High order dividend (0 or -1 for single precision)
15m0083                               	;    Q          Low order dividend
15m0083                               	;    IR<35>     Sign of dividend XOR sign of divisor
15m0083                               	;    AR         Sign of dividend and original contents of AC
15m0083                               	;  
15m0083                               	;------------------------------------------------------------------------------
15m0083 04157 531140004571000440000000	DODIV:  D[MEM] COND[-OBUS<0] JUMP[DODIV1] C550 $
15m0083                               	                ;Jump if divide by positive number
15m0083 04160 640704404473000440000000	        D[MEM] ALU[0-D] DEST[HOLD] SHORT $
15m0083                               	                ;Take absolute value
15m0083 04161 631140000551000440000000	DODIV1: ALU[AC] COND[-OBUS<0] JUMP[DODIV2] CYLEN[C450] $
15m0083                               	                ;Check sign of high order word.  If positive, we're ready to go
15m0083 04162 550140000117000440000000	        ALU[0-Q] DEST[Q] COND[OBUS=0] JUMP[DODIV3] CYLEN[C500] $
15m0083                               	                ;Double precision negate, low order word
15m0083 04163 640140001751000440000000	        ALU[NOTAC] DEST[AC] JUMP[DODIV2] NORM $
15m0083                               	                ;High order word, no carry
15m0083 04164 640700001513000440000000	DODIV3: ALU[0-AC] DEST[AC] NORM $
15m0083                               	                ;High order word, with carry
15m0083 04165 640740014571000440000000	DODIV2: D[CONST 44] LLOAD NORM $
15m0083                               	                ;LOOP 37 TIMES
15m0083                               	;Now have:
15m0083                               	;   MEM         Absolute value of divisor
15m0083                               	;   AC          Absolute value of high order dividend
15m0083                               	;   Q           Absolute value of low order dividend
15m0083                               	;   R           Repeat count for division
15m0083 04166 511140004463000440000000	        D[MEM] ALU[AC-D] COND[OBUS<0] JUMP[DODIV7] C550 $
15m0083                               	                ;Jump if not no divide case
15m0083 04167 640700021571000440000000	        D[PC] DEST[AC] SHORT $
15m0083                               	                ;Get ready to set flags
15m0083 04170 640040015561056010004071	        D[CONST 1] ROT[23.] ALU[DORAC] DEST[AC] PUSHJ[MSTOV1] NORM $
15m0083                               	                ;Set no divide
15m0083 04171 640300001571000440000000	        D[AR] DEST[AC] POPJ NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

15m0083                               	                ;Fix clobbered AC
15m0083                               	
15m0083                               	        ;$*$*$* NORMAL area runs of space for now.  TVR-Apr80
15m0083                               	        .USE[15m0083                               	XLIST
15m0084 02161 640040000571000440000000	 LIST ]DODIV7:  NORM PUSHJ[DODIV4] $
15m0084 02162 531140000571000440002164	        D[AR] COND[-OBUS<0] JUMP[. + 2] C550 $; J IF DIVIDEND WAS +
15m0084 02163 640700001513000440000000	        ALU[0-AC] DEST[AC] SHORT $
15m0084 02164 510300034571000010000000	        D[IR] MASK[1] COND[OBUS=0] POPJ C550 $ ;LEAVE IF RESULT SHOULD BE +
15m0084 02165 640300000117000440000000	        ALU[0-Q] DEST[Q] POPJ NORM $
15m0084                               	;On completion:
15m0084                               	;   MEM         Absolute value of divisor
15m0084                               	;   AC          Remainder
15m0084                               	;   Q           Quotient
15m0084                               	;   AR<0>       Sign of dividend
15m0084                               	;   IR<35>      Sign of dividend
15m0084                               	
15m0084                               	        .QUAD
15m0084                               	. + 3 - (. + 3) \ 4 
15m0085 02170 451640007043000030002170	]DODIV4:        D[MEM] ALU[DIVAC-D] DEST[D6] MASK[3] COND[OBUS<0] SLOOP[DODIV4] C600 $
15m0085 02171 640140002545000000000000	        ALU[SH-AC] DEST[D5] MASK[0] JUMP[DODIV6] NORM $ ; RE-SHIFT REMAINDER
15m0085 02172 451640007001000030002170	        D[MEM] ALU[DIVAC+D] DEST[D6] MASK[3] COND[OBUS<0] SLOOP[DODIV4] C600 $
15m0085 02173 640700002545000000000000	        ALU[SH-AC] DEST[D5] MASK[0] NORM $
15m0085                               	    ;end of .QUAD
15m0085 02174 531300015721106010000000	DODIV6: D[CONST 1] ROT[43] ALU[D#AC] DEST[AC] COND[-OBUS<0] C550 POPJ $ 
15m0085                               	                ;ADJUST REM SIGN, CHECK IT
15m0085 02175 640300005421000440000000	        D[MEM] ALU[D+AC] DEST[AC] NORM POPJ $ 
15m0085                               	                ;ADJUST REM.
15m0085                               	
15m0085                               	        .USE[15m0085                               	XLIST
15m0086                               	 LIST ]
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

16m0086                               	;JFFO1 JFFO2 JFFO3 JFFO5 JFFO4 ROTDO BIGLSH LSHPDO LSHDO LSHDO1 ASHDO1 BIGASH SETOV1
16m0086                               	 ASHDO ASHDOP BIGAS2 ASHC1 ASHC8 ASHC6 ASHC9 ASHC4 ASHC2 ASHC7 ROTC1 ROTC2 LSHC1 LSHC2
16m0086                               	 SJMAIN PUSH1 POP1 POPJ1 PUSHJ1
16m0086                               	
16m0086 04172 640140001615400440002026	JFFO1:  ACSEL[AC+1] ALU[0] DEST[AC] JUMP[MAIN] NORM $
16m0086 04173 530140000571014060000000	JFFO2:  D[AR] ROT[6] MASK[6] COND[-OBUS=0] JUMP[JFFO3] C550 $
16m0086 04174 640710000571014440000000	        D[AR] ROT[6] DEST[AR] NORM $
16m0086 04175 640140015421400060004173	        D[CONST 6] ACSEL[AC+1] ALU[AC+D] DEST[AC] JUMP[JFFO2] NORM $
16m0086 04176 511140000571000440000000	JFFO3:  D[AR] COND[OBUS<0] JUMP[JFFO4] C550 $
16m0086 04177 640700001413400440000000	JFFO5:  ACSEL[AC+1] ALU[AC+1] DEST[AC] NORM $
16m0086 04200 531150000571002440004177	        D[AR] ROT[1] DEST[AR] COND[-OBUS<0] JUMP[JFFO5] C550 $
16m0086 04201 640164634571000440002027	JFFO4:  D[IR] DEST[PC MA] JUMP[MAIN1] NORM $; JUMP
16m0086                               	.DEFINE SH2ND 16m0086                               	
16m0086                               	        .USE[16m0086                               	XLIST
16m0087                               	 LIST ] SH2ND 16m0087 02702 453140014477000440000000	OTPLS:  D[CONST 44] ALU[Q-D] COND[OBUS18] JUMP[ROTDO] C600 $
16m0087 02703 640141214077000440002702	        D[CONST 44] ALU[Q-D] DEST[Q ROTR] JUMP[ROTPLS] NORM $
16m0087 02704 640701210175020220000000	ROTNEG: D[MASK 22] ROT[10] ALU[DORQ] DEST[Q ROTR] NORM $
16m0087 02705 473141214035000440000000	ROTNN1: D[CONST 44] ALU[D+Q] DEST[Q ROTR] COND[-OBUS18] JUMP[ROTDO] C600 $
16m0087 02706 640140000571000440002705	        JUMP[ROTNN1] NORM $
16m0088 02707 640710000551000440000000	]ROTDO: ACSEL[AC] ALU[AC] DEST[AR] SHORT $
16m0088 02710 640160001571200440602027	        D[AR] ROT[R] ACSEL[AC] SPEC[MA_PC] DEST[AC MA] JUMP[MAIN1] NORM $
16m0088                               	        SH2ND 16m0088 02711 453140014477000440000000	SHPLS:  D[CONST 44] ALU[Q-D] COND[OBUS18] JUMP[LSHPDO] C600 $
16m0088 02712 640141214077000440000000	        D[CONST 44] ALU[Q-D] DEST[Q ROTR] JUMP[BIGLSH] NORM $
16m0088 02713 640701210175020220000000	LSHNEG: D[MASK 22] ROT[10] ALU[DORQ] DEST[Q ROTR] NORM $
16m0088 02714 473141214035000440000000	LSHNN1: D[CONST 44] ALU[D+Q] DEST[Q ROTR] COND[-OBUS18] JUMP[LSHDO] C600 $
16m0088 02715 640140000571000440000000	        JUMP[BIGLSH] NORM $
16m0089                               	]
16m0089                               	        .USE[16m0089                               	XLIST
16m0090 02725 640160001615000440602027	 LIST ]BIGLSH:  ACSEL[AC] ALU[0] SPEC[MA_PC] DEST[AC MA] JUMP[MAIN1] NORM $
16m0090                               	
16m0090 02726 640701414537000440000000	LSHPDO: D[CONST 44] ALU[D-Q] DEST[MASKR] SHORT $
16m0090 02727 640710010621001000000000	        D[2] MASK[R] ALU[D&AC] ACSEL[AC] DEST[AR] SHORT $
16m0090 02730 640160001571200440602027	        D[AR] ROT[R] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
16m0090                               	
16m0090 02731 640701400555000440000000	LSHDO:  ALU[Q] DEST[MASKR] SHORT $
16m0090 02732 640710000551000440000000	        ALU[AC] ACSEL[AC] DEST[AR] SHORT $
16m0090 02733 640160001571201000602027	LSHDO1: D[AR] MASK[R] ROT[R] SPEC[MA_PC] DEST[AC MA] ACSEL[AC] JUMP[MAIN1] NORM $
16m0090 02734 640141400555000440002733	ASHDO1: ALU[Q] DEST[MASKR] JUMP[LSHDO1] NORM $
16m0090                               	
16m0090                               	        .USE[16m0090                               	XLIST
16m0091                               	 LIST ] SH2ND 16m0091 04202 453140014477000440000000	SHPLS:  D[CONST 44] ALU[Q-D] COND[OBUS18] JUMP[ASHDOP] C600 $
16m0091 04203 640141214077000440000000	        D[CONST 44] ALU[Q-D] DEST[Q ROTR] JUMP[BIGASH] NORM $
16m0091 04204 640701210175020220000000	ASHNEG: D[MASK 22] ROT[10] ALU[DORQ] DEST[Q ROTR] NORM $
16m0091 04205 473141214035000440000000	ASHNN1: D[CONST 44] ALU[D+Q] DEST[Q ROTR] COND[-OBUS18] JUMP[ASHDO] C600 $
16m0091 04206 640140000571000440000000	        JUMP[BIGAS2] NORM $
16m0092 04207 610140000551000440002026	]BIGASH:        ALU[AC] ACSEL[AC] COND[OBUS=0] JUMP[MAIN] CYLEN[C450] $
16m0092 04210 640700015621106010000000	        D[CONST 1] ROT[43] ACSEL[AC] ALU[D&AC] DEST[AC] SHORT $
16m0092 04211 640700020171000440000000	        D[PC] DEST[Q] SHORT $
16m0092 04212 640165414575106010602027	SETOV1: D[CONST 1] ROT[43] ALU[DORQ] DEST[MA CRYOV] SPEC[MA_PC] NORM JUMP[MAIN1] $
16m0092 04213 571150000551000440002734	ASHDO:  ACSEL[AC] ALU[AC] DEST[AR] COND[-OBUS<0] JUMP[ASHDO1] CYLEN[C500] $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

16m0092 04214 640701414537000440000000	        D[CONST 44] ALU[D-Q] DEST[MASKR] SHORT $
16m0092 04215 640700010171201000000000	        D[2] MASK[R] ROT[R] DEST[Q] SHORT $
16m0092 04216 640160001575200440602027	        D[AR] ROT[R] ALU[DORQ] SPEC[MA_PC] DEST[AC MA] ACSEL[AC] JUMP[MAIN1] NORM $
16m0092 04217 640701414537000430000000	ASHDOP: D[CONST 43] ALU[D-Q] DEST[MASKR] SHORT $
16m0092 04220 640700200555000440000000	        ALU[Q] DEST[IR-ADR] SHORT $; SAVE SH AMT
16m0092 04221 640700014221106010000000	        D[CONST 1] ROT[43] ACSEL[AC] ALU[D&AC] DEST[Q] SHORT $ ;GET SIGN BIT
16m0092 04222 640710010621001000000000	        D[2] MASK[R] ACSEL[AC] ALU[D&AC] DEST[AR] SHORT $
16m0092 04223 640710001175200440000000	        D[AR] ROT[R] ACSEL[AC] ALU[DORQ] DEST[O_AC AR] SHORT $
16m0092 04224 640701434433000440000000	        D[IR] ALU[D+1] DEST[MASKR] SHORT $
16m0092 04225 640700000171200440000000	        D[AR] ROT[R] DEST[Q] SHORT $
16m0092 04226 510140010235107000002026	        D[2] MASK[R] ROT[43] ALU[D&Q] DEST[Q] COND[OBUS=0] JUMP[MAIN] C550 $
16m0092 04227 510140010735107000002026	        D[2] MASK[R] ROT[43] ALU[D#Q] COND[OBUS=0] JUMP[MAIN] C550 $
16m0092 04230 640140020171000440004212	        D[PC] DEST[Q] JUMP[SETOV1] NORM $
16m0092 04231 631140000551000440002725	BIGAS2: ACSEL[AC] ALU[AC] COND[-OBUS<0] JUMP[BIGLSH] CYLEN[C450] $
16m0092 04232 640160001741000440602027	        ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
16m0092                               	
16m0092 04233 640704414621106010000000	ASHC1:  D[CONST 1] ROT[43] ALU[D&AC] ACSEL[AC] DEST[HOLD] NORM $ ; SAVE SIGN BIT
16m0092 04234 513140034571000220000000	        D[IR] MASK[18.] COND[OBUS18] JUMP[ASHC2] C550 $
16m0092 04235 510140034571000100002026	        D[IR] MASK[10] COND[OBUS=0] JUMP[MAIN] C550 $
16m0092 04236 640700001615400440000000	        ALU[0] ACSEL[AC+1] DEST[AC] SHORT $
16m0092 04237 640740034531000100000000	        D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0092 04240 640700003145000010000000	ASHC8:  ALU[SH-AC] DEST[D6] MASK[1] ACSEL[AC] NORM $
16m0092 04241 511140004721000440000000	        ACSEL[AC] D[MEM] ALU[D#AC] COND[OBUS<0] JUMP[ASHC9] C550 $
16m0092 04242 640240000571000440004240	ASHC6:  LOOP[ASHC8] NORM $
16m0092 04243 640145420561400440000000	        D[PC] ACSEL[AC+1] ALU[DORAC] DEST[CRYOV] JUMP[ASHC7] NORM $
16m0092 04244 640140015571506010004242	ASHC9:  D[CONST 1] ROT[43] ACSEL[AC+1] DEST[AC] JUMP[ASHC6] NORM $
16m0092                               	
16m0092                               	.DEFINE SHLOOP 16m0092                               	
16m0092 04245 640700004171000440000000	ASHC4:  D[MEM] DEST[Q] SHORT $
16m0092 04246 640700001575506430000000	        D[AR] ROT[43] MASK[43] ALU[DORQ] ACSEL[AC+1] DEST[AC] NORM $
16m0092 04247 640700011621000430000000	        D[MASK 43] ACSEL[AC] ALU[D&AC] DEST[AC] SHORT $
16m0092 04250 640140001545000440002026	        ACSEL[AC] ALU[QORAC] DEST[AC] JUMP[MAIN] NORM $
16m0092 04251 640700234473000440000000	ASHC2:  D[IR] ALU[0-D] DEST[IR-ADR] NORM $
16m0092                               	        SHLOOP 16m0092 04252 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0092 04253 640240002145000010004253	        ALU[SH-AC] DEST[D4] MASK[1] ACSEL[AC] LOOP[.] NORM $
16m0093 04254 640150000555000440004245	]ASHC7: ALU[Q] DEST[AR] JUMP[ASHC4] NORM $
16m0093                               	
16m0093                               	        .USE[16m0093                               	XLIST
16m0094 02742 640140234473000440000000	 LIST ]ROTC1:   D[IR] ALU[0-D] DEST[IR-ADR] JUMP[ROTC2] NORM $
16m0094 02743 510140034571000100002026	        D[IR] COND[OBUS=0] MASK[10] JUMP[MAIN] C550 $
16m0094                               	        SHLOOP[16m0094 02744 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0094 02745 640240003145000000002745	        ALU[SH-AC] DEST[D6] MASK[0] ACSEL[AC] LOOP[.] NORM $
16m0095 02746 640140001555400440002026	]       ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
16m0095                               	ROTC2:  SHLOOP[16m0095 02747 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0095 02750 640240002145000000002750	        ALU[SH-AC] DEST[D4] MASK[0] ACSEL[AC] LOOP[.] NORM $
16m0096 02751 640140001555400440002026	]       ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
16m0096                               	
16m0096                               	        .PAIR
16m0096                               	. \ 2 + .
16m0097 02752 640140234473000220000000	]LSHC1: D[IR] MASK[18.] ALU[0-D] DEST[IR-ADR] JUMP[LSHC2] NORM $
16m0097 02753 510140034571000100002026	        D[IR] MASK[10] COND[OBUS=0] JUMP[MAIN] C550 $
16m0097                               	        SHLOOP SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

16m0097 02754 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0097 02755 640240003145000020002755	        ALU[SH-AC] DEST[D6] MASK[2] ACSEL[AC] LOOP[.] NORM $
16m0098 02756 640140001555400440002026	]       ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
16m0098                               	        .USE[16m0098                               	XLIST
16m0099       2735	 LIST ] debuguse = .            ;See if it is still losing
16m0099                               	: 2735  ;%$@#&@# SLOEXP didn't redefine AREA272 properly!!! $*$*$*
16m0099                               	LSHC2:  SHLOOP[16m0099 02735 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0099 02736 640240002145000020002736	        ALU[SH-AC] DEST[D4] MASK[2] ACSEL[AC] LOOP[.] NORM $
16m0100 02737 640140001555400440002026	]       ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
16m0100                               	
16m0100                               	        .USE[16m0100                               	XLIST
16m0101 02034 000700005570400440000000	 LIST ]SJMAIN:  ACSEL[MA] D[MEM] DEST[AC] $
16m0101 02035 000164634571000440002027	        D[IR] DEST[MA PC] JUMP[MAIN1] $
16m0101                               	
16m0101                               	        .USE[16m0101                               	XLIST
16m0102 04255 455160015421001000000000	 LIST ]PUSH1:   D[CONST 1,,1] ALU[D+AC] DEST[AC MA] COND[CRY0] JUMP[PDLO2] C600 $
16m0102 04256 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
16m0102                               	
16m0102 04257 640710004571000440000000	POP1:   D[MEM] DEST[AR] SHORT $
16m0102 04260 640720034571000220000000	        D[IR] MASK[18.] DEST[MA] SHORT $
16m0102 04261 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
16m0102                               	
16m0102 04262 640164604571000220002027	POPJ1:  D[MEM] MASK[18.] DEST[PC MA] JUMP[MAIN1] NORM $
16m0102                               	
16m0102 04263 662104634571000222372032	PUSHJ1: MAPF[MASTO] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] MEMST OND[-MA-AC]
16m0102                               	 LBJUMP[MSMAIN] NORM ]$
16m0102                               	
16m0102                               	
16m0102                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

17m0102                               	;BLTA2 BLT1 BLT7 BLT5 BLT3 BLT2 BLT9 BLT4 BLT6 BLT8 BLTA3 BLTL1 BLTA4 BLTA1 BLTAL2 BLTA10
17m0102                               	 BLTL2 BLTA12 ANDCA1 ANDCA2 ANDCA3 LOG2 LOG3 ORCM2 ORCM3
17m0102                               	        .PAIR
17m0102                               	. \ 2 + .
17m0103 04264 640170000551000440000000	]BLTA2: ACSEL[AC] ALU[AC] DEST[AR MA] JUMP[BLTA3] NORM $ ;SRC IS AC GET DEST ADR
17m0103 04265 640710021171000440000000	BLT1:   D[PC] DEST[O_AC AR] ACSEL[AC] SHORT $
17m0103 04266 640704600171000220000000	        D[AR] MASK[18.] DEST[Q PC] SHORT $
17m0103 04267 640740034137000220000000	        D[IR] MASK[18.] ALU[D-Q] DEST[Q] LLOAD NORM $;GET COUNT
17m0103 04270 611140000555000440000000	        ALU[Q] COND[OBUS<0] JUMP[BLT4] CYLEN[C450] $ ; J IF END PRECEDES STRT
17m0103 04271 640730000171044220000000	BLT7:   D[AR] MASK[18.] ROT[18.] DEST[Q MA AR] SHORT $; FETCH FIRST WORD
17m0103 04272 640146000571000440050000	BLT5:   DEST[FIXMAC-MAPF-RD] MAPF[BLT-RD] JUMP[BLT2] CYLEN[FIXM] $
17m0103 04273 640706000571000442050000	BLT3:   DEST[FIXMAC-MAPF-RD] MAPF[BLT-RD] SPEC[PC+1] CYLEN[FIXM] $
17m0103 04274 641164204571000440600000	BLT2:   D[MEM] SPEC[MA_PC] DEST[MEMSTO MA] COND[INTRPT] JUMP[BLT6] NORM $
17m0103 04275 640270000017000440064273	        ALU[Q+1] DEST[Q AR MA] LOOP[BLT3] MAPF[BLT-WRT] CYLEN[MEMSTO] $
17m0103 04276 640704621171000220000000	BLT9:   D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC] NORM $
17m0103 04277 531140034463000220002026	        ACSEL[AC] D[IR] MASK[18.] ALU[AC-D] COND[-OBUS<0] JUMP[MAIN] C550 $ ;J IF DONE
17m0103 04300 640700001413000440000000	        ACSEL[AC] ALU[AC+1] DEST[AC] SHORT $
17m0103 04301 640740034523000440000000	        D[IR] ACSEL[AC] ALU[D-AC] LLOAD NORM $ ;GET COUNT
17m0103 04302 640704621171000440000000	        D[PC] ACSEL[AC] DEST[O_AC PC] SHORT $
17m0103 04303 640160000555000440004272	        ALU[Q] DEST[MA] JUMP[BLT5] NORM $
17m0103 04304 640740000615000440000000	BLT4:   ALU[0] LLOAD NORM $
17m0103 04305 640140000571000440004271	        JUMP[BLT7] NORM $
17m0103 04306 640250000017000440060000	BLT6:   ALU[Q+1] DEST[Q AR] LOOP[BLT8] MAPF[BLT-WRT] CYLEN[MEMSTO] $
17m0103 04307 000140000571000440004276	        JUMP[BLT9] $
17m0103 04310 640700001451000442000000	BLT8:   ACSEL[AC] ALU[AC-1] DEST[AC] SPEC[PC+1] NORM $
17m0103 04311 640704621171000220000000	        ACSEL[AC] D[PC] MASK[18.] DEST[O_AC PC] SHORT $
17m0103 04312 640700001561044000200000	        D[AR] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC] SHORT $
17m0103 04313 540500000571000441602320	        DISP[2320] SPEC[PC+1-IF&] CYLEN[DISP] $
17m0103 04314 640701000571044440000000	BLTA3:  D[AR] ROT[18.] DEST[AC-SEL] SHORT $ ;GET SRC ADR
17m0103 04315 640700034171000220000000	        D[IR] MASK[18.] DEST[Q] SHORT $
17m0103 04316 640740024077000220000000	        D[MA] MASK[18.] ALU[Q-D] DEST[Q] LLOAD NORM $
17m0103 04317 611040000555000440000000	        ALU[Q] COND[OBUS<0] PUSHJ[BLTA4] CYLEN[C450] $
17m0103 04320 640700000035044220000000	        D[AR] ROT[18.] MASK[18.] ALU[D+Q] DEST[Q] SHORT $
17m0103 04321 530140010635010300000000	        D[MASK 30] ROT[4] ALU[D&Q] COND[-OBUS=0] JUMP[BLTA10] C550  $;J IF SRC LEAVES
17m0103                               	 AC'S
17m0103 04322 640704200550000440000000	BLTL1:  ACSEL[REG] ALU[AC] DEST[MEMSTO] NORM $
17m0103 04323 640267024433000440104322	        D[MA] ALU[D+1] DEST[MA A-MEM-CNTR&INC] MAPF[BLT-WRTA] LOOP[BLTL1] CYLEN[MEMSTO] $
17m0103                               	
17m0103 04324 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
17m0103 04325 640740000215000440000000	BLTA4:  ALU[0] DEST[Q] LLOAD NORM $
17m0103 04326 640300000571000440000000	        POPJ NORM $
17m0103 04327 510140010621054160000000	BLTA1:  D[MASK 16] ROT[26] ACSEL[AC] ALU[D&AC] COND[OBUS=0] JUMP[BLTA10] C550 $; DEST IS
17m0103                               	 AC, J IF SRC AC?
17m0103 04330 530140034571100160000000	        D[IR] ROT[40] MASK[16] COND[-OBUS=0] JUMP[BLTA10] C550 $;J IF FINAL DEST NOT AC
17m0103 04331 640711000551000440000000	        ACSEL[AC] ALU[AC] DEST[AR AC-SEL] SHORT $;GET DEST ADR
17m0103 04332 640700034171000220000000	        D[IR] MASK[18.] DEST[Q] SHORT $
17m0103 04333 640740000077000220000000	        D[AR] MASK[18.] ALU[Q-D] DEST[Q] LLOAD NORM $;GET COUNT
17m0103 04334 611040000555000440004325	        ALU[Q] COND[OBUS<0] PUSHJ[BLTA4] CYLEN[C450] $;ADJUST IF CNT NEG.
17m0103 04335 640720000571044220000000	        D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $;GET SRC ADR
17m0103 04336 640706025432000440070000	BLTAL2: DEST[FIXMAC-MAPF-RD AC] MAPF[BLT-RDA] D[MA] ALU[D+1] ACSEL[REG] CYLEN[FIXM] $
17m0103 04337 640267005170000440004336	        ACSEL[REG] D[MEM] DEST[O_AC MA A-MEM-CNTR&INC] LOOP[BLTAL2] NORM $
17m0103 04340 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
17m0103 04341 640710000551000440000000	BLTA10: ACSEL[AC] ALU[AC] DEST[AR] SHORT $
17m0103 04342 640720000571044220000000	BLTL2:  D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $;GET WORD
17m0103 04343 640706000550400440070000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BLT-RDA] CYLEN[FIXM] $
17m0103 04344 640704404171000440000000	        D[MEM] DEST[HOLD Q] SHORT $
17m0103 04345 640724000571000220000000	        D[AR] MASK[18.] DEST[MA STRT-WRT] SHORT $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

17m0103 04346 562140000571000440104350	        MAPF[BLT-WRTA] COND[-MA-AC] JUMP[. + 2] C500 $
17m0103 04347 640700001554400440000000	        ALU[Q] ACSEL[MA] DEST[AC] SHORT $
17m0103 04350 640700000171000220000000	        D[AR] MASK[18.] DEST[Q] NORM $
17m0103 04351 471140034477000220102026	        D[IR] MASK[18.] ALU[Q-D] MAPF[BLT-WRTA] COND[-OBUS<0] JUMP[MAIN] C600 $
17m0103 04352 640700014171001000000000	        D[CONST 1,,1] DEST[Q]  NORM $
17m0103 04353 640150000435000440004342	        D[AR] ALU[D+Q] DEST[AR] JUMP[BLTL2] NORM $;*** TEST FOR INTERRUPT HERE?
17m0103 04354 662100000571000440002032	BLTA12: MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0103                               	
17m0103                               	        .USE[17m0103                               	XLIST
17m0104                               	 LIST ]
17m0104 02763 640160005635000440602027	ANDCA1: D[MEM] ACSEL[AC] ALU[D&Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
17m0104                               	
17m0104 02764 662104204635000440002032	ANDCA2: D[MEM] ALU[D&Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104 02765 662104205635000440002032	ANDCA3: D[MEM] ACSEL[AC] ALU[D&Q] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM
17m0104                               	 ]$
17m0104                               	
17m0104 02766 662104200755000440002032	LOG2:   ALU[NOTQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104 02767 662104201755000440002032	LOG3:   ACSEL[AC] ALU[NOTQ] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104 02770 662104200545000440002032	ORCM2:  ACSEL[AC] ALU[QORAC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104 02771 662104201545000440002032	ORCM3:  ACSEL[AC] ALU[QORAC] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104                               	        .USE[17m0104                               	XLIST
17m0105                               	 LIST ]
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

18m0105                               	;SWINT NORSW NOSW RESW1 RESET RESET RESLOP DOHALT STPLOP STPLP1 NORSW2 RESW2 STRTSW CONSW
18m0105                               	 DEPTSW DEPNSW DEPSW1 EXMTSW EXMNSW SETLTS EXMSW1 BRPNT MOVSS1 MOVNS1 HLLZS1 HRLZS1
18m0105                               	 HRRZS1 HLRZS1 HRAR HLAR HLLEM1 HRLEM1 HLREM1 HRREM1 HSMAIN HSMN1 HLLOS1 HRROS1 HLLES1
18m0105                               	 HRRES1 HLLES2 HMV HHS HLSZ HOR HRSZ HOL HRLM1 HLLM1 HLRM1 HRRM1 JRST1 JRST4 JRST5 JRST9
18m0105                               	 JRST8 JRST2 JRST3 JFCL1 JSR2 JSA1 JRA1 MUJSR MUJSP
18m0105                               	;  MUJSA MUJSYS MUJSM1
18m0105                               	;;;RESW1:
18m0105                               	        .ORG[XLIST
18m0105                               	 LIST ];*$*$* No REAL reason for this
18m0105                               	: 2062  ;SWITCH, AR & ECC INTERRUPTS COME HERE
18m0105 02062 640702400571000440000000	SWINT:  DEST[CLR-DEV-FROM-INTR] SHORT $
18m0105 02063 640701600615000443400000	        ALU[0] DEST[DEV-ADR] SPEC[IOB-IN] SHORT $
18m0105 02064 140710030571000440040000	        D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $                 ;GET SW BITS
18m0105 02065 530140000571016010000000	        D[AR] ROT[7] MASK[1] COND[-OBUS=0] JUMP[APDINT] C550 $  ;JUMP IF OVFL OR ECC INT
18m0105                               	
18m0105 02066 640700014171002153600000	        D[CONST 15] ROT[1] DEST[Q] SPEC[IOB-OUT] SHORT $
18m0105 02067 510140000635030440040000	        D[AR] ROT[14] ALU[D&Q] MAPF[4] COND[OBUS=0] JUMP[NOSW] C550 $   ;CHECK FOR
18m0105                               	 RELEVANT SW, & CLR FF.
18m0105 02070 530140000571020010000000	        D[AR] ROT[10] MASK[1] COND[-OBUS=0] JUMP[RESW1] C550 $  ;J IF RESET SW
18m0105 02071 530040000571026010000000	NORSW:  D[AR] ROT[13] MASK[1] COND[-OBUS=0] PUSHJ[EXMTSW] C550 $        ;PUSHJ IF EXAM
18m0105                               	 THIS
18m0105 02072 530040000571022010000000	        D[AR] ROT[11] MASK[1] COND[-OBUS=0] PUSHJ[DEPTSW] C550 $        ;PUSHJ IF DEPO
18m0105                               	 THIS
18m0105 02073 640160000571000440602027	NOSW:   SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
18m0105                               	
18m0105       2074	area206 = .     ;Sigh...
18m0105                               	
18m0105                               	        .RELOC
18m0105                               	USE[18m0105                               	XLIST
18m0106                               	 LIST ]]
18m0106 04355 640700000571000443400000	RESW1:  SPEC[IOB-IN] SHORT $
18m0106 04356 140710030571000440000000	        D[IOD] DEST[AR]  CYLEN[IOB-IN] $        ;DOUBLE CHECK RESET SW
18m0106 04357 410140000571020010002071	        D[AR] ROT[10] MASK[1] COND[OBUS=0] JUMP[NORSW] CYLEN[C650] $    ;DOUBLE CHECK
18m0106                               	 RESET SW
18m0106                               	
18m0106                               	;******* This code to be made a subroutine to allow machine resetting *******
18m0106                               	;******* to be done by auto-loading and via CONO APR,20000  TVR-Mar80 *******
18m0106                               	
18m0106                               	.REPEAT F2SW [
18m0106 04360 640702214571000003600000	RESET:  D[CONST 0] DEST[IOD] SPEC[IOB-OUT] NORM $
18m0106                               	  ] ;END F2SW
18m0106                               	
18m0106                               	.REPEAT 1 - F2SW [
18m0106                               	 ;END 1 - F2SW
18m0106                               	;*** Disable ECC interrupts on F3's?????
18m0106                               	
18m0106 04361 440705400615000440100000	        MAPF[10] ALU[0] DEST[CRYOV] CYLEN[IOB-OUT] $    ;CLR MAP-IN-USE & PC FLAGS & AR
18m0106                               	 INT ENBL, ETC.
18m0106 04362 640143600571000440000000	        DEST[CLR-MI-ERR] JUMP[RESLOP] NORM $
18m0106 04363 640702600615000440000000	RESLOP: ALU[0] DEST[HI-ABS-MA] NORM $
18m0106 04364 000702400571000440000000	        DEST[CLR-DEV-FROM-INTR] $
18m0106 04365 640041614571000000000000	        D[CONST 0] DEST[DEV-ADR] PUSHJ[APRRST] NORM $
18m0106 04366 640041614571000010000000	        D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPRST] NORM $
18m0106 04367 640041614571000040000000	        D[CONST 4] DEST[DEV-ADR] PUSHJ[CTYRST] NORM $
18m0106 04370 640041614571000100000000	        D[CONST 10] DEST[DEV-ADR] PUSHJ[DSKRST] NORM $
18m0106                               	 .REPEAT WK [
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

18m0106 04371 640041614571000070000000	        D[CONST 7] DEST[DEV-ADR] PUSHJ[TAPRST] NORM $
18m0106                               	.REPEAT DLS [;18m0106                               	 9 JAN 80  BO
18m0106 04372 640041614571000200000000	        D[CONST DLSDEV] DEST[DEV-ADR] PUSHJ[DLSRST] NORM $
18m0106                               	]DLS
18m0106                               	.REPEAT VC [ 18m0106                               	; VC
18m0106                               	.REPEAT IMP [;18m0106                               	IMP
18m0106                               	.REPEAT LPT [
18m0106                               	LPT
18m0106                               	.REPEAT STANSW [;18m0106                               	REPEAT STANSW
18m0106 04373 640041614571000060000000	        D[CONST 6] DEST[DEV-ADR] PUSHJ[CLKRST] NORM $
18m0106 04374 640041614571000060000000	        D[CONST 6] DEST[DEV-ADR] PUSHJ[TYMRST] NORM $
18m0106 04375 640041614571000060000000	        D[CONST 6] DEST[DEV-ADR] PUSHJ[PI-RESET] NORM $
18m0106 04376 640702400571000440000000	DOHALT: DEST[CLR-DEV-FROM-INTR] NORM $
18m0106 04377 640701614571000013400000	STPLOP: D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
18m0106 04400 140700030171000440040000	        MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
18m0106 04401 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
18m0106 04402 640702214575000103600000	        D[CONST 10] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $
18m0106 04403 440700000571000440100000	        MAPF[10] CYLEN[IOB-OUT] $; SET PROG HALT LIGHT
18m0106 04404 640721600615000440600000	        ALU[0] DEST[DEV-ADR MA] SPEC[MA_PC] NORM $
18m0106 04405 640706000550400443620000	        FIXM1 SPEC[IOB-OUT] $
18m0106 04406 000700004571000440060000	        D[MEM] MAPF[6] CYLEN[LONG] $
18m0106 04407 640700000571000443400000	        SPEC[IOB-IN] NORM $
18m0106 04410 140710030571000440040000	        D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $
18m0106 04411 451140000571000440000000	        D[AR] COND[OBUS<0] JUMP[BRPNT] C600 $; J IF BRK POINT SW
18m0106 04412 640700000571000443400000	        SPEC[IOB-IN] NORM $
18m0106 04413 140710030571000440040000	STPLP1: D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $ ;GET SW BITS
18m0106 04414 530140000571020010000000	        D[AR] ROT[10] MASK[1] COND[-OBUS=0] JUMP[RESW2] C550 $  ;J IF RESET SW
18m0106 04415 640700000171030110000000	        D[AR] ROT[14] MASK[11] DEST[Q] NORM $
18m0106 04416 450140014675010073404413	        D[CONST 7] ROT[4] ALU[-D&Q] COND[OBUS=0] SPEC[IOB-IN] JUMP[STPLP1] C600 $; LOOP
18m0106                               	 IF NO SW
18m0106 04417 640700000571000443600000	        SPEC[IOB-OUT] NORM $
18m0106 04420 440700000571000440040000	        MAPF[4] CYLEN[IOB-OUT] $        ;CLR SW FF'S
18m0106                               	        .DEFINE SWTEST 18m0106                               	NORSW2: SWTEST[18m0106 04421 530140000571010010000000	D[AR] ROT[4] MASK[1] COND[-OBUS=0] JUMP [ CONSW ] C550 $
18m0107                               	]       SWTEST[18m0107 04422 530140000571012010000000	D[AR] ROT[5] MASK[1] COND[-OBUS=0] JUMP [ STRTSW ] C550 $
18m0108                               	]       SWTEST[18m0108 04423 530040000571022010000000	D[AR] ROT[11] MASK[1] COND[-OBUS=0] PUSHJ [ DEPTSW ] C550 $
18m0109                               	]       SWTEST[18m0109 04424 530040000571024010000000	D[AR] ROT[12] MASK[1] COND[-OBUS=0] PUSHJ [ DEPNSW ] C550 $
18m0110                               	]       SWTEST[18m0110 04425 530040000571026010000000	D[AR] ROT[13] MASK[1] COND[-OBUS=0] PUSHJ [ EXMTSW ] C550 $
18m0111                               	]       SWTEST[18m0111 04426 530040000571030010000000	D[AR] ROT[14] MASK[1] COND[-OBUS=0] PUSHJ [ EXMNSW ] C550 $
18m0112 04427 640141614571000003404413	]       D[CONST 0] DEST[DEV-ADR] SPEC[IOB-IN] JUMP[STPLP1] NORM $       ;LOOP
18m0112                               	
18m0112 04430 640700000571000443400000	RESW2:  SPEC[IOB-IN] SHORT $
18m0112 04431 140710030571000440000000	        D[IOD] DEST[AR]  CYLEN[IOB-IN] $        ;DOUBLE CHECK RESET SW
18m0112 04432 150140000571020010004421	        D[AR] ROT[10] MASK[1] COND[OBUS=0] JUMP[NORSW2] CYLEN[IOB-IN] $ ;DOUBLE CHECK
18m0112                               	 RESET SW
18m0112 04433 640140000571000440004360	        JUMP[RESET] NORM $
18m0112 04434 640704600571000230000000	STRTSW: D[AR] MASK[23] DEST[PC] NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

18m0112 04435 640722600615000440600000	CONSW:  ALU[0] SPEC[MA_PC] DEST[MA HI-ABS-MA] NORM $
18m0112 04436 640701614571000013400000	        D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
18m0112 04437 140700030171000440040000	        MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
18m0112 04440 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
18m0112 04441 640702214635000073600000	        D[CONST 7] ALU[D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $
18m0112 04442 440700000571000440100000	        MAPF[10] CYLEN[IOB-OUT] $; CLEAR PROG HALT LIGHT
18m0112 04443 640706000550400440010000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
18m0112 04444 540530604571000441602074	        D[MEM] DEST[IR-ALL AR MA] DISP[2074] SPEC[PC+1-IF] CYLEN[DISP] $
18m0112                               	        ; IGNORE STOP SW AND INTERRUPTS
18m0112 04445 640162600571000233400000	DEPTSW: D[AR] MASK[23] DEST[MA HI-ABS-MA] SPEC[IOB-IN] JUMP[DEPSW1] NORM $
18m0112 04446 640720024433000443400000	DEPNSW: D[MA] ALU[D+1] DEST[MA] NORM SPEC[IOB-IN] $
18m0112 04447 140704230571000440020000	DEPSW1: D[IOD] DEST[MEMSTO] MAPF[2] CYLEN[IOB-IN] $
18m0112 04450 662300000571000440000000	        MAPF[TEMP] COND[-MA-AC] POPJ CYLEN[MEMSTO] $
18m0112 04451 640300005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] POPJ NORM $
18m0112                               	
18m0112 04452 640162600571000230000000	EXMTSW: D[AR] MASK[23] DEST[MA HI-ABS-MA] JUMP[EXMSW1] NORM $
18m0112 04453 640160024433000440000000	EXMNSW: D[MA] ALU[D+1] DEST[MA] JUMP[EXMSW1] NORM $
18m0112                               	;NOTE: This subroutine is called by DATAO PI, which displays in the lights
18m0112 04454 640706000550400440020000	SETLTS: FIXM1 $                 ;Take page faults, if any.
18m0112 04455 640706000550400440000000	EXMSW1: ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[TEMP] CYLEN[FIXM] $
18m0112 04456 640700000571000443600000	        SPEC[IOB-OUT] NORM $
18m0112 04457 000300004571000440020000	        D[MEM] MAPF[2] CYLEN[LONG] POPJ $
18m0112 04460 640700000171000270000000	BRPNT:  D[AR] MASK[27] DEST[Q] NORM $
18m0112 04461 470140020537000270004435	        D[PC] MASK[27] ALU[D-Q] COND[-OBUS=0] JUMP[CONSW] C600 $
18m0112 04462 640140000571000443404413	        SPEC[IOB-IN] JUMP[STPLP1] NORM $
18m0112                               	
18m0112                               	        .USE[18m0112                               	XLIST
18m0113 02772 662104205571044440002032	 LIST ]MOVSS1:  D[MEM] ROT[18.] ACSEL[AC] DEST[AC MEMSTO] MEMST OND[-MA-AC]
18m0113                               	 LBJUMP[MSMAIN] NORM ]$
18m0113                               	
18m0113 02773 662104205473000440002032	MOVNS1: D[MEM] ALU[0-D] ACSEL[AC] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM
18m0113                               	 ]$
18m0113                               	
18m0113 02774 643130005570400000400000	HLLZS1: ACSEL[MA] D[MEM] COND[AC=0] DEST[AC AR MA] SPEC[LEFT&MA_PC] LBJUMP[HSMAIN] NORM $
18m0113                               	
18m0113                               	
18m0113 02775 643130005570444000400000	HRLZS1: ACSEL[MA] D[MEM] ROT[18.] COND[AC=0] DEST[AC AR MA] SPEC[LEFT&MA_PC]
18m0113                               	 LBJUMP[HSMAIN] NORM $
18m0113                               	
18m0113 02776 643130005570400220600000	HRRZS1: ACSEL[MA] D[MEM] MASK[18.] COND[AC=0] DEST[AC AR MA] SPEC[MA_PC] LBJUMP[HSMAIN]
18m0113                               	 NORM $
18m0113                               	
18m0113 02777 643130005570444220600000	HLRZS1: ACSEL[MA] D[MEM] ROT[18.] MASK[18.] COND[AC=0] DEST[AC AR MA] SPEC[MA_PC]
18m0113                               	 LBJUMP[HSMAIN] NORM $
18m0113                               	
18m0113                               	        .USE[18m0113                               	XLIST
18m0114 03426 640160001561000220602027	 LIST ]HRAR:    D[AR] MASK[18.] ALU[DORAC] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1]
18m0114                               	 NORM $
18m0114                               	
18m0114 03427 640160001561000000402027	HLAR:   D[AR] SPEC[LEFT&MA_PC] MASK[0] ALU[DORAC] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM
18m0114                               	 $
18m0114                               	
18m0114 03430 662104200571000000202032	HLLEM1: D[AR] MASK[0] SPEC[LEFT] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0114                               	
18m0114 03431 662104200571044000202032	HRLEM1: D[AR] ROT[18.] MASK[0] SPEC[LEFT] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN]
18m0114                               	 NORM ]$
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

18m0114                               	
18m0114 03432 662104200571044220002032	HLREM1: D[AR] ROT[18.] MASK[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0114                               	
18m0114 03433 662104200571000220002032	HRREM1: D[AR] MASK[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0114                               	
18m0114                               	        .USE[18m0114                               	XLIST
18m0115                               	 LIST ] .PAIR
18m0115                               	. \ 2 + .
18m0116 03444 640700001571000440000000	]HSMAIN:        ACSEL[AC] D[AR] DEST[AC] NORM $
18m0116 03445 640346000550400440012030	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] JPOP[MAIN2] NORM $
18m0116                               	        .PAIR
18m0116                               	. \ 2 + .
18m0117 03446 640160000571000440602027	]HSMN1: SPEC[MA_PC] DEST[MA] JUMP[MAIN1] CYLEN[MEMSTO] $
18m0117 03447 640160005571000440602027	        D[MEM] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[MEMSTO] $
18m0117                               	        .PAIR
18m0117                               	. \ 2 + .
18m0118 03450 662104210575000220002032	]HLLOS1:        D[MASK 22] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM
18m0118                               	 ]$
18m0118 03451 662104211575000220002032	        D[MASK 22] ALU[DORQ] DEST[MEMSTO AC] ACSEL[AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN]
18m0118                               	 NORM ]$
18m0118                               	        .PAIR
18m0118                               	. \ 2 + .
18m0119 03452 662104210575044220002032	]HRROS1:        D[MASK 22] ROT[18.] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC]
18m0119                               	 LBJUMP[MSMAIN] NORM ]$
18m0119 03453 662104211575044220002032	        D[MASK 22] ROT[18.] ALU[DORQ] DEST[MEMSTO AC] ACSEL[AC] MEMST OND[-MA-AC]
18m0119                               	 LBJUMP[MSMAIN] NORM ]$
18m0119                               	        .PAIR
18m0119                               	. \ 2 + .
18m0120 03454 663100010235044220000000	]HLLES1:        D[MASK 22] ROT[18.] ALU[D&Q] DEST[Q] COND[-AC=0] LBJUMP[HLLES2] NORM $
18m0120 03455 663100000571000440003450	        COND[-AC=0] LBJUMP[HLLOS1] NORM $
18m0120                               	        .PAIR
18m0120                               	. \ 2 + .
18m0121 03456 663100010235000220000000	]HRRES1:        D[MASK 22] ALU[D&Q] DEST[Q] COND[-AC=0] LBJUMP[HLLES2] NORM $
18m0121 03457 663100000571000440003452	        COND[-AC=0] LBJUMP[HRROS1] NORM $
18m0121                               	        .USE[18m0121                               	XLIST
18m0122                               	 LIST ] .PAIR
18m0122                               	. \ 2 + .
18m0123 03470 662104200555000440002032	]HLLES2:        ALU[Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0123 03471 662104201555000440002032	        ALU[Q] ACSEL[AC] DEST[MEMSTO AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0123                               	        .PAIR
18m0123                               	. \ 2 + .
18m0124 03472 640140000571000440002026	]HMV:   JUMP[MAIN] NORM $
18m0124 03473 640140000571000440002400	        JUMP[MOVE] NORM $
18m0124                               	        .PAIR
18m0124                               	. \ 2 + .
18m0125 03474 662104200575044440002032	]HHS:   D[AR] ROT[18.] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0125 03475 662104201575044440002032	        D[AR] ROT[18.] ALU[DORQ] ACSEL[AC] DEST[MEMSTO AC] MEMST OND[-MA-AC]
18m0125                               	 LBJUMP[MSMAIN] NORM ]$
18m0125                               	        .USE[18m0125                               	XLIST
18m0126                               	 LIST ] .PAIR
18m0126                               	. \ 2 + .
18m0127 03526 640160000571000440602027	]HLSZ:  SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
18m0127 03527 640160011561000220602027	HOR:    D[MASK 22] ACSEL[AC] ALU[DORAC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $
18m0127                               	        .PAIR
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

18m0127                               	. \ 2 + .
18m0128 03530 640160000571000440602027	]HRSZ:  SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
18m0128 03531 640160011561044220602027	HOL:    D[MASK 22] ACSEL[AC] ROT[18.] ALU[DORAC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM
18m0128                               	 $
18m0128                               	        .PAIR
18m0128                               	. \ 2 + .
18m0129 03532 640700000171044440000000	]HRLM1: D[AR] ROT[18.] DEST[Q] NORM $
18m0129 03533 662104204575000220002032	HLLM1:  D[MEM] MASK[18.] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0129                               	
18m0129                               	        .PAIR   . \ 2 + .
18m0129                               	];(??) Added TVR-Apr80
18m0129 03534 640700000171044440000000	HLRM1:  D[AR] ROT[18.] DEST[Q] NORM $
18m0129 03535 662104204575000000202032	HRRM1:  D[MEM] MASK[0] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN]
18m0129                               	 NORM ]$
18m0129                               	
18m0129                               	        .USE[18m0129                               	XLIST
18m0130                               	 LIST ] .PAIR
18m0130                               	. \ 2 + .
18m0131                               	]JRST1: ;10 bit on in AC field
18m0131 03504 645140000571000440002100	        COND[USER] JUMP[MUUO] NORM $; ILLEGAL IF USER MODE
18m0131                               	        ;10 bit off, or exec mode.  Check 2 bit.
18m0131 03505 530140034571030010000000	        D[IR] ROT[14] MASK[1] COND[-OBUS=0] JUMP[JRST2] C550 $
18m0131                               	JRST4:  ;If 1 bit on in AC field, set user mode
18m0131 03506 530140034571032010000000	        D[IR] ROT[15] MASK[1] COND[-OBUS=0] JUMP[JRST3] C550 $
18m0131                               	JRST5:  ;If 4 bit on in AC field, act like stop switch
18m0131 03507 530140034571026010000000	        D[IR] ROT[13] MASK[1] COND[-OBUS=0] JUMP[JRST9] C550 $
18m0131                               	        ;If 10 bit on in AC field, dismiss
18m0131 03510 530140034571024010000000	        D[IR] ROT[12] MASK[1] COND[-OBUS=0] JUMP[PI-DISMISS] C550 $
18m0131 03511 640160000571000440602027	        JUMP[MAIN1] NORM SPEC[MA_PC] DEST[MA] $
18m0131                               	
18m0131                               	        ;4 bit on in AC field
18m0131 03512 665140000571000440004376	JRST9:  COND[EXEC] JUMP[DOHALT] NORM $; HALT IF EXEC MODE
18m0131 03513 640150020171000440002101	        MUUO1 D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
18m0131                               	]$              ;Halting in user mode is illegal
18m0131                               	
18m0131                               	        ;2 bit on in AC field
18m0131 03514 640700020171000440000000	JRST2:  D[PC] DEST[Q] SHORT $
18m0131                               	         ;Flag restore.
18m0131 03515 640700014235074010000000	        D[CONST 1] ROT[36] ALU[D&Q] DEST[Q] SHORT $
18m0131                               	         ;Don't let USER be cleared.
18m0131 03516 640700000175000440000000	        D[AR] ALU[DORQ] DEST[Q] NORM $
18m0131                               	         ;Put in the new bits (but OR in the old USER)
18m0131 03517 640145414675064010003506	        D[CONST 1] ROT[35. - 9.] ALU[-D&Q] DEST[CRYOV] JUMP[JRST4] NORM $
18m0131                               	         ;Don't let bit 9 be set (it is a sort of trap flag for PDL OV)
18m0131                               	
18m0131                               	  .USE[18m0131                               	XLIST
18m0132                               	 LIST ]
18m0132                               	        ;1 bit on in AC field, set user mode
18m0132 03544 640700014171074010000000	JRST3:  D[CONST 1] ROT[36] DEST[Q] SHORT $
18m0132 03545 640145420575000440003507	        D[PC] ALU[DORQ] DEST[CRYOV] JUMP[JRST5] NORM $
18m0132                               	
18m0132 03546 510140000635100440002026	JFCL1:  D[AR] ROT[40] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $;TEST SELECTED FLAGS
18m0132 03547 640705400675100440000000	        D[AR] ROT[40] ALU[-D&Q] DEST[CRYOV] SHORT $;CLEAR FLAGS
18m0132 03550 640164634571000440002027	        DOJUMP $
18m0132 03551 640704624433000442240000	JSR2:   D[MA] ALU[D+1] DEST[PC] SPEC[CLR-HALF] MAPF[STO] NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

18m0132 03552 640160005570400440602027	        ACSEL[MA] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
18m0132 03553 640704624433000440000000	JSA1:   D[MA] ALU[D+1] DEST[PC] SHORT $
18m0132 03554 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0132 03555 640706000550400440020000	JRA1:   FIXM1 $
18m0132 03556 640700005571000440000000	        ACSEL[AC] D[MEM] DEST[AC] CYLEN[FIXM+1] $
18m0132 03557 640164634571000220002027	        D[IR] MASK[18.] DEST[PC MA] JUMP[MAIN1] NORM $
18m0132                               	
18m0132                               	        .USE[18m0132                               	XLIST
18m0133 04463 640720604571000440000000	 LIST ]MUJSR:   D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
18m0133 04464 642144200571000440003551	        D[AR] DEST[MEMSTO] COND[MA-AC] JUMP[JSR2] NORM $
18m0133 04465 640164624433000442242027	        D[MA] ALU[D+1] DEST[MA PC] MAPF[STO] SPEC[CLR-HALF] JUMP[MAIN1] CYLEN[MEMSTO] $
18m0133 04466 640720604571000440000000	MUJSP:  D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
18m0133 04467 640140001571000440002553	        D[AR] ACSEL[AC] DEST[AC] JUMP[JSP1] NORM $
18m0133 04470 640720604571000440000000	MUJSA:  D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
18m0133 04471 640150001171000440003553	        D[AR] ACSEL[AC] DEST[O_AC AR] JUMP[JSA1] NORM $
18m0133 04472 640720604571000440000000	MUJSYS: D[MEM] DEST[IR-ALL MA] SHORT $
18m0133 04473 510140034571066110002211	        D[IR] ROT[33] MASK[11] COND[OBUS=0] JUMP[JSYS3] C550 $; J IF EX JSYS
18m0133 04474 640706000550400440150000	MUJSM1: ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[MAPFTR] CYLEN[FIXM] $
18m0133 04475 640704604571000220000000	        D[MEM] MASK[18.] DEST[PC] NORM $; JUMP TO RIGHT HALF
18m0133 04476 640720004571044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $; GET READY TO STORE
18m0133 04477 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0133                               	
18m0133                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

19m0133                               	;CTYDSP AREA51 CTYINT CTYIOT CTYDI CTYDO CTYCO CTYCI CTYCI2 CTYCI1 CTYCI9 CTYCI8 CTYCI3
19m0133                               	 CTYCO1 CTYCO3 CTYCO4 CTYCO5 CTYRST ctyrs1 AREA52 CTYCZ CTYCS
19m0133                               	;------------------------------------------------------------------------------
19m0133                               	;
19m0133                               	;       CTY - Console Teletype                          Device 120
19m0133                               	;
19m0133                               	;------------------------------------------------------------------------------
19m0133                               	
19m0133                               	;
19m0133                               	;A-MEM Usage
19m0133                               	;
19m0133       0	CTY-DISP = 0            ;Instruction and interrupt dispatch
19m0133       1	CTY-CONT = 1            ;Control bits for UART, etc.
19m0133       2	CTY-STATUS = 2          ;Firmware status
19m0133                               	
19m0133                               	;
19m0133                               	;*** Meanings of hardware bits should be documented here.
19m0133                               	;
19m0133                               	;MAPF values
19m0133                               	
19m0133                               	.REPEAT NTP [
19m0133       0	TTY.DI = 0      ;read data
19m0133       12	TTY.WD = 12     ;write data
19m0133       14	TTY.WC = 14     ;write control
19m0133                               	  ];NTP
19m0133                               	
19m0133                               	.REPEAT OTP [
19m0133                               	;OTP
19m0133                               	
19m0133                               	;*$*$*  This ORG is ready to be flushed.  It only remains to test the code
19m0133                               	;       and merge the AREAs
19m0133                               	
19m0133                               	        .ORG[XLIST
19m0133                               	 LIST ];CTY IOT DISPATCH TABLE
19m0133                               	
19m0133                               	CTYDSP: ILGIOT 19m0133 05100 000140000571000440002026	 JUMP [MAIN] ]$ ;BLKI
19m0133 05101 000700000571000440000000	        NOP $
19m0133 05102 640700050171000443400000	        D[CTY-STATUS + 10] DEST[Q] SPEC[IOB-IN] NORM $ ;DATAI
19m0133 05103 140150030571000440000000	        MAPF[TTY.DI] D[IOD] DEST[AR] JUMP[CTYDI] CYLEN[IOB-IN] $
19m0133                               	        ILGIOT 19m0133 05104 000140000571000440002026	 JUMP [MAIN] ]$ ;BLKO
19m0133 05105 000700000571000440000000	        NOP $
19m0133 05106 640706000550400440020000	        FIXM1 $         ;DATAO
19m0133 05107 640140050171000440000000	        D[CTY-STATUS + 10] DEST[Q] JUMP[CTYDO] NORM $ ; GET CONI BITS
19m0133 05110 640700050171000070000000	        D[CTY-STATUS + 10] MASK[7] DEST[Q] NORM $ ;CONO, GET CONI BITS
19m0133 05111 640140034275100070000000	        D[IR] MASK[7] ROT[40] ALU[-D&Q] DEST[Q] JUMP[CTYCO] NORM $ ;CLR THE CLR BITS
19m0133 05112 640040050171000443400000	        D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
19m0133                               	                ; CONI, GET BITS
19m0133 05113 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
19m0133 05114 640040050171000443400000	        D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
19m0133                               	                ;CONSZ, GET BITS
19m0133 05115 640140034171000220000000	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
19m0133 05116 640040050171000443400000	        D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
19m0133                               	                ;CONSO, GET CONI BITS
19m0133 05117 640140034171000220000000	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
19m0133                               	;$*$*$ We may not be able to afford this in the future...  TVR-Apr80
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

19m0133                               	LPTDSP:
19m0133                               	.REPEAT 1 - LPT [
19m0133                               	     .REPEAT 10 [I19m0133                               	LGIOT 19m0133 05120 000140000571000440002026	 JUMP [MAIN] ]$
19m0133 05121 000700000571000440000000	        NOP $
19m0133                               	]LGIOT 19m0133 05122 000140000571000440002026	 JUMP [MAIN] ]$
19m0133 05123 000700000571000440000000	        NOP $
19m0133                               	]LGIOT 19m0133 05124 000140000571000440002026	 JUMP [MAIN] ]$
19m0133 05125 000700000571000440000000	        NOP $
19m0133                               	]LGIOT 19m0133 05126 000140000571000440002026	 JUMP [MAIN] ]$
19m0133 05127 000700000571000440000000	        NOP $
19m0133                               	]LGIOT 19m0133 05130 000140000571000440002026	 JUMP [MAIN] ]$
19m0133 05131 000700000571000440000000	        NOP $
19m0133                               	]LGIOT 19m0133 05132 000140000571000440002026	 JUMP [MAIN] ]$
19m0133 05133 000700000571000440000000	        NOP $
19m0133                               	]LGIOT 19m0133 05134 000140000571000440002026	 JUMP [MAIN] ]$
19m0133 05135 000700000571000440000000	        NOP $
19m0133                               	]LGIOT 19m0133 05136 000140000571000440002026	 JUMP [MAIN] ]$
19m0133 05137 000700000571000440000000	        NOP $
19m0133                               	].REPEAT 10
19m0133                               	].REPEAT 1 - LPT
19m0133                               	
19m0133                               	.REPEAT LPT [   19m0133                               	.REPEAT LPT
19m0133                               	
19m0133                               	AREA51: ;$*$*$ Start code from here for now.  This should go away
19m0133                               	
19m0133                               	
19m0133                               	: 2130 ;CTY and 60 HZ CLOCK INTS COME HERE
19m0133                               	
19m0133                               	CTYINT:
19m0133                               	  .REPEAT NTP [;19m0133                               	With new tape controller, 60HZ clk shares DEV 4 w/ CTY.
19m0133 02130 640700000571000443400000	        START-IN SHORT $
19m0133 02131 440710030771000440050000	        MAPF[5] D[IOD] ALU[NOTD] DEST[AR] C600 $
19m0133                               	                ;Read the NET interface status...
19m0133 02132 530140000571000010000000	        D[AR] MASK[1] C550 -OBUS=0 JUMP[CLKINT] $
19m0133                               	                ;Is 60HZ clk requesting an int. ? Jump if so.
19m0133 02133 640140000571000440000000	        NORM JUMP[CTYIN1] $
19m0133                               	                ;Else it is the CTY's turn.
19m0133                               	: 2144
19m0133                               	      ];NTP
19m0133                               	
19m0133 02144 640040050171000443400000	CTYIN1: D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
19m0133                               	                ; DO A CONI, GET BITS
19m0133 02145 640702244571000113600000	        D[CTY-CONT + 10] MASK[11] DEST[IOD] SPEC[IOB-OUT] NORM $; DISABLE INTS
19m0133 02146 440710050171000030140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] D[CTY-STATUS + 10] MASK[3] DEST[Q AR] $
19m0133                               	                ; GET PI CHAN
19m0133 02147 640142400571000440000000	        NORM  DEST[CLR-DEV-FROM-INTR] JUMP[PIGEN] $;CAUSE INTR.
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

19m0133                               	
19m0133                               	;$*$*$ This one is referenced off the MAP dispatch
19m0133       5210	AREA52 = 5210
19m0133                               	
19m0133                               	.USE[19m0133                               	XLIST
19m0134                               	 LIST ]
19m0134                               	        .PAIR
19m0134                               	. \ 2 + .
19m0135                               	]       UIOTRP[19m0135 05210 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
19m0135                               	]$
19m0135                               	CTYIOT: IOTDIS 19m0135 05211 640700034171034050000000	D[IR] ROT[16] MASK[5] DEST[Q] NORM $
19m0135 05212 540540014575014510000000	        D[CONST 51] ROT[6] ALU[DORQ] SDISP CYLEN[C500] $
19m0136                               	]
19m0136 05213 640700414675000403000000	CTYDI:  D[CONST 40] ALU[-D&Q] DEST-A-MEM DEST[CTY-STATUS] NORM $; CLR TTI FLAG
19m0136 05214 640700014171006100000000	        D[CONST 10] ROT[3] DEST[Q] SHORT $
19m0136 05215 640702244575000443600000	        D[CTY-CONT + 10] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] SHORT $;CLR RCV. CHR
19m0136 05216 440700000571000440140000	        MAPF[TTY.WC]  CYLEN[IOB-OUT] $
19m0136 05217 640702244571000443600000	        D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] SHORT $
19m0136 05220 440700000571000440140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] $
19m0136 05221 662104200571000100002032	        D[AR] MASK[10] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
19m0136 05222 640702204571000443600000	CTYDO:  D[MEM] DEST[IOD] SPEC[IOB-OUT] NORM $;SEND CHR.
19m0136 05223 440700014275000100120000	        MAPF[TTY.WD] CYLEN[IOB-OUT] D[CONST 10] ALU[-D&Q] DEST[Q] $;CLR TTO FLAG
19m0136 05224 640702244433000443600000	        D[CTY-CONT + 10] ALU[D+1] DEST[IOD] SPEC[IOB-OUT] NORM $
19m0136                               	                ;ENABLE UART STB
19m0136                               	        MAPF[TTY.WC] CYLEN[IOB-OUT]
19m0136 05225 440700414575000203140000	                        D[CONST 20] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM $
19m0136                               	                ;SET TTO BUSY
19m0136 05226 640702244571000443600000	        D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] NORM $;CLR UART STB
19m0136 05227 450140014635000070142026	        MAPF[TTY.WC] CYLEN[IOB-OUT] D[CONST 7] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] $ ; DONE
19m0136                               	 IF NO PI CHAN
19m0136 05230 640700044171000440000000	        D[CTY-CONT + 10] DEST[Q] SHORT $; GET IOB-OUT BITS
19m0136 05231 640702214175022043600000	        D[CONST 4] ROT[11] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] NORM $ ;ENABLE XMT INT
19m0136 05232 440140200555000443142026	        MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[Q] DEST[CTY-CONT] DEST-A-MEM JUMP[MAIN] $
19m0136 05233 640700014235006170000000	CTYCO:  D[CONST 17] ROT[3] ALU[D&Q] DEST[Q] NORM $;CLR PI BITS
19m0136 05234 640140434575000073000000	        D[IR] MASK[7] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM JUMP[CTYCO1] NORM $
19m0136                               	                ;OR IN NEW PI BITS
19m0136 05235 140704430571000440000000	CTYCI:  MAPF[TTY.DI] D[IOD] DEST[HOLD] CYLEN[IOB-IN] $;GET UART BITS
19m0136 05236 640702244571000443600000	        D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] NORM $
19m0136 05237 170140004571054010140000	        MAPF[TTY.WC] D[MEM] ROT[26] MASK[1] COND[-OBUS=0] JUMP[CTYCI1]
19m0136                               	 CYLEN[MAX,IOB-OUT,C550] $; J IF RCV RDY
19m0136 05240 640150014275006100000000	CTYCI2: D[CONST 10] ROT[3] ALU[-D&Q] DEST[Q AR] JUMP[CTYCI9] NORM $;CLR TTI BUSY
19m0136 05241 530140014635000400005240	CTYCI1: D[CONST 40] ALU[D&Q] COND[-OBUS=0] JUMP[CTYCI2] C550 $;J IF TTI FLAG ON
19m0136 05242 640710014335006100000000	        D[CONST 10] ROT[3] ALU[D#Q] DEST[Q AR] NORM $;COMPL BUSY.
19m0136 05243 530140014635006100000000	        D[CONST 10] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[CTYCI9] C550 $;J IF BUSY NOW ON
19m0136 05244 640710014175000400000000	        D[CONST 40] ALU[DORQ] DEST[Q AR] NORM $; SET TTI FLAG
19m0136 05245 530140004571052010000000	CTYCI9: D[MEM] ROT[25] MASK[1] COND[-OBUS=0] JUMP[CTYCI8] C550 $;J IF XMT RDY
19m0136 05246 640300414575000203000000	        D[CONST 20] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM POPJ NORM $
19m0136                               	                ;SET BUSY -- NOTE, NO "AR DEST" IS CORRECT
19m0136 05247 510140014635000200000000	CTYCI8: D[CONST 20] ALU[D&Q] COND[OBUS=0] JUMP[CTYCI3] C550 $; J IF BUSY OFF
19m0136 05250 640700014175000100000000	        D[CONST 10] ALU[DORQ] DEST[Q] NORM $; SET FLAG
19m0136 05251 640300414675000203000000	CTYCI3: D[CONST 20] ALU[-D&Q] DEST[CTY-STATUS] DEST-A-MEM POPJ NORM $ ;CLR BUSY
19m0136 05252 640700034171102100000000	CTYCO1: D[IR] ROT[41] MASK[10] DEST[Q] NORM $; GET SET&CLR BITS
19m0136 05253 010140014635006100000000	        D[CONST 10] ROT[3] ALU[D&Q] COND[OBUS=0] JUMP[CTYCO4] $
19m0136                               	                ; J IF CLR TTI FLAG OFF
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

19m0136 05254 640700044171000110000000	        D[CTY-CONT + 10] MASK[11] DEST[Q] NORM $;GET IOB-OUT BITS
19m0136 05255 640702214575006103600000	        D[CONST 10] ROT[3] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $
19m0136                               	                ;GET CLR RCV RDY BIT
19m0136 05256 440700000571000440140000	CTYCO3: MAPF[TTY.WC] CYLEN[IOB-OUT] $
19m0136 05257 640702200555000443600000	        ALU[Q] DEST[IOD] SPEC[IOB-OUT] NORM $;CLR IT
19m0136 05260 440700000571000440140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] $
19m0136 05261 640700044171000110000000	CTYCO4: D[CTY-CONT + 10] MASK[11] DEST[Q] NORM $; GET IOB-OUT BITS
19m0136 05262 510140050571000030000000	        D[CTY-STATUS + 10] MASK[3] COND[OBUS=0] JUMP[CTYCO5] C550 $
19m0136                               	                ; J IF NO PI CHAN
19m0136 05263 640700014175022020000000	        D[CONST 2] ROT[11] ALU[DORQ] DEST[Q] SHORT $; ENBL RCV INT
19m0136 05264 510140050571102020000000	        D[CTY-STATUS + 10] ROT[41] MASK[2] COND[OBUS=0] JUMP[CTYCO5] C550 $
19m0136                               	                ; J IF NO OUT FLAG OR BUSY
19m0136 05265 640700014175022040000000	        D[CONST 4] ROT[11] ALU[DORQ] DEST[Q] SHORT $;ENBL XMT INT
19m0136 05266 640702200555000443600000	CTYCO5: ALU[Q] DEST[IOD] SPEC[IOB-OUT] SHORT $; FIX INT ENBLS
19m0136 05267 440140200555000443142026	        MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[Q] DEST[CTY-CONT] DEST-A-MEM JUMP[MAIN] $
19m0136                               	; **** HERE IS DEFN. OF CTY UART CONSTANTS ****
19m0136                               	
19m0136 05270 640701614571000040000000	CTYRST: D[CONST 4] DEST[DEV-ADR] NORM $
19m0136 05271 640702414171014040000000	        D[CONST 4] ROT[6] DEST[Q CLR-DEV-FROM-INTR] NORM $
19m0136 05272 640700214175000743000000	        D[CONST 74] ALU[DORQ] DEST[Q CTY-CONT] DEST-A-MEM NORM $
19m0136 05273 640702214575014033600000	        D[CONST 3] ROT[6] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $; RESET UART
19m0136 05274 440700400615000443140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[0] DEST[CTY-STATUS] DEST-A-MEM $
19m0136 05275 640142200555000443600000	        ALU[Q] DEST[IOD] SPEC[IOB-OUT] NORM JUMP[CTYRS1] $
19m0136                               	
19m0136                               	    .USE[XLIST
19m0136                               	 LIST ] ;$*$*$*$ Temporary ****
19m0136                               	
19m0136                               	CTYRS1:
19m0136                               	;Setup entry vectors: IOT vector in left half, interrupt vector in right half   
19m0136 03566 240700014171060510140000	        MAPF[TTY.WC] C800 D[CONST (CTYDSP / 100)] ROT[18. + 6.] DEST[Q] $
19m0136                               	                ;High order 6 IOT bits
19m0136 03567 640700014175044000000000	        D[CONST (CTYDSP \ 100)] ROT[18.] ALU[DORQ] DEST[Q] NORM $
19m0136                               	                ;Low order 6 IOT bits
19m0136 03570 640700014175014210000000	        D[CONST (CTYINT / 100)] ROT[6.] ALU[DORQ] DEST[Q] NORM $
19m0136                               	                ;High order 6 interrupt bits
19m0136                               	        D[CONST (CTYINT \ 100)] ROT[0] ALU[DORQ]
19m0136 03571 640300014575000303000000	                        SPEC[DEST-A-MEM] DEST[CTY-DISP] POPJ NORM $
19m0136                               	                ;Low order 6 interrupt bits
19m0136                               	                ;Finish setting up vectors and return.
19m0136                               	
19m0136                               	
19m0136                               	;;;     .USE[AREA206]
19m0136                               	;;;     debuguse = .
19m0136                               	
19m0136                               	;;;:2074        ;%$#@#$% SLOEXP didn't redefine AREA206 properly??? $*$*$*$
19m0136                               	
19m0136                               	        .USE[19m0136                               	XLIST
19m0137                               	 LIST ]
19m0137                               	        .PAIR
19m0137                               	. \ 2 + .
19m0138 04500 530140000635000440002026	]CTYCZ: D[AR] ALU[D&Q] COND[-OBUS=0] JUMP[MAIN] C550 $
19m0138 04501 640164620433000440002027	        DOSKIP $
19m0138 04502 510140000635000440002026	CTYCS:  D[AR] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $
19m0138 04503 640164620433000440002027	        DOSKIP $
19m0138                               	
19m0138                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

20m0138                               	;$*$*$ This code should set up dispatch and interrupt vectors.  It will have to
20m0138                               	;      be moved to the end of regular disk stuff.  TVR-Apr80
20m0138 04504 640702200615000443600000	DSKRST: ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $
20m0138                               	          ;SET DSK CTRL COMMAND REGISTER TO 0 (DISABLES INTS).
20m0138                               	        MAPF[4] D[CONST 2] DEST[IOD] SPEC[IOB-OUT]
20m0138 04505 440702214571000023640000	                                CYLEN[IOB-OUT] $
20m0138                               	          ;NOW RESET THE CONTROLLER.
20m0138 04506 440300200615000443070000	        MAPF[7] ALU[0] DEST[1] DEST-A-MEM  CYLEN[IOB-OUT]  POPJ $
20m0138                               	          ;ALSO CLEAR THE PI CHANNEL ASSIGNMENT.
20m0138                               	
20m0138                               	SET-DSK-OUT:
20m0138 04507 665141614571000100000000	        D[CONST 10] DEST[DEV-ADR] NORM COND[-USER] JUMP[SDSKO2] $
20m0138                               	        UIOTRP[20m0138 04510 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
20m0138                               	]$
20m0138                               	                ;Watch for IOT-USER mode.
20m0138 04511 640312204571000443600000	SDSKO2: D[MEM] DEST[IOD AR] SPEC[IOB-OUT] NORM POPJ $
20m0138                               	
20m0138                               	;Kludge to allow disk controller status IOTs from IOT-USER Mode.  This is
20m0138                               	;so a wizard can look at the state of the disk controller from MDDT (or UEDDT).
20m0138                               	UDSKST: UIOTRP[20m0138 04512 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
20m0138                               	]$
20m0138                               	                ;Ignore SPEC[IOB-IN] we just did and trap if in user mode.
20m0138 04513 000700034171024120000000	        D[IR] ROT[8 + 1 + 1] MASK[10.] DEST[Q] $
20m0138                               	                ;Extract opcode
20m0138 04514 000700014175000010000000	        D[CONST 1] ALU[DORQ] DEST[Q] $
20m0138                               	                ;Skip first micro instruction that got us here
20m0138 04515 540540014575022023400000	        D[CONST 2] ROT[9.] ALU[DORQ] SDISP CYLEN[DISP] SPEC[IOB-IN] $
20m0138                               	                ;Dispatch again to finish instruction
20m0138                               	
20m0138                               	;$*$*$ This code should set up dispatch and interrupt vectors.  It will have to
20m0138                               	;      be moved to the end of regular disk stuff.  TVR-Apr80
20m0138                               	TYMRST:         ;RESET TYMNET INTERFACE
20m0138 04516 640040014171000010000000	        D[CONST 1] DEST[Q] PUSHJ[DEV6CL] NORM $
20m0138                               	.REPEAT TYMNET [
20m0138                               	TYMNET
20m0138                               	.REPEAT 1 - tymnet [
20m0138 04517 640300000571000440000000	        POPJ NORM $
20m0138                               	] 1 - tymnet
20m0138                               	
20m0138                               	;$*$*$ This code should set up dispatch and interrupt vectors.  TVR-Apr80
20m0138                               	
20m0138                               	 .REPEAT OTP [
20m0138                               	;OTP
20m0138                               	
20m0138                               	 .REPEAT NTP [
20m0138                               	
20m0138                               	CLKRST:         ;Fall in to CLKCLR
20m0138 04520 640701614571000043600000	CLKCLR: START-OUT D[CONST 4] DEST[DEV-ADR] NORM $
20m0138                               	                ;Clear clk flag.
20m0138 04521 440702250571064442470000	CLKENB: MAPF[7] D[12] SPEC[A-MEM-APR] ROT[26.] DEST[IOD] C600 $
20m0138                               	                ;Get the APR conditions wd, put CLK INT ENB bit in bit 35.
20m0138 04522 640700000571000443600000	        START-OUT NORM $
20m0138 04523 440300000571000440060000	        MAPF[6] C600 POPJ $
20m0138                               	                ;SET OR CLEAR THE HARDWARE INTRPT. ENB. ACCORDING TO
20m0138                               	                ; STATE OF CLK INT ENB BIT IN APR 
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

20m0138                               	  ];NTP
20m0138                               	
20m0138                               	.REPEAT OTP [ 20m0138                               	;OTP
20m0138                               	
20m0138                               	;$*$*$*$* This should be moved to CFKNYD.SLO   TVR-Sep80
20m0138                               	  .REPEAT NTP [
20m0138                               	
20m0138                               	TAPRST:  ;RESET THE TAPE CONTROLLER.
20m0138 04524 640701614571000070000000	        D[CONST 7] DEST[DEV-ADR] NORM $ ;SELECT DEVICE.
20m0138 04525 000702200615000443600000	        START-OUT ALU[0]  DEST[IOD] $
20m0138                               	         ;Turn off "FORMATTER ENABLE"
20m0138 04526 000700000571000440020000	        MAPF[2] LONG $
20m0138                               	          ;Fall in to TIMRST.
20m0138                               	
20m0138 04527 640701614571000050000000	TIMRST: D[CONST 5] DEST[DEV-ADR] NORM $
20m0138 04530 640702214571000013600000	        START-OUT D[CONST TIMER] DEST[IOD] NORM $
20m0138                               	                ;Enable timer interrupts if TIMER is 1, else disable them.
20m0138 04531 440700200615000443100000	        MAPF[10] ALU[0] DEST[1] DEST-A-MEM C600 $
20m0138                               	                ;Clear pi channel
20m0138 04532 640300600615000443000000	        ALU[0] DEST[3] DEST-A-MEM NORM POPJ $
20m0138                               	                ;Clear timer reg.
20m0138                               	   ];NTP
20m0138                               	
20m0138                               	APRRST:
20m0138                               	.REPEAT F2SW [
20m0138 04533 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $   ;Clear Addr. Break
20m0138                               	]REPEAT F2SW
20m0138 04534 440300400615000442610000	        MAPF[1] ALU[0] DEST[APRSTS] SPEC[A-MEM-APR&DEST-A-MEM] CYLEN[IOB-OUT] POPJ $
20m0138                               	;$*$*$ This code should set up dispatch and interrupt vectors.  TVR-Apr80
20m0138                               	
20m0138 04535 640302400571000440000000	CLRDEVINT:         DEST[CLR-DEV-FROM-INTR] POPJ NORM $
20m0138                               	                ;CLEAR FLAG WHICH CAUSES DEV-ADR TO BE
20m0138                               	                ; ADR OF LAST INTERRUPTING DEVICE,
20m0138                               	                ; SO THE DEV-ADR REGISTER WILL WORK AGAIN.
20m0138                               	
20m0138                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

21m0138                               	;------------------------------------------------------------------------------
21m0138                               	;
21m0138                               	;       PI - Priority Interrupt Service                 Device 4
21m0138                               	;
21m0138                               	;------------------------------------------------------------------------------
21m0138                               	
21m0138                               	;PI SYSTEM USE OF APR AMEM---
21m0138                               	; 4     MEM PAR ERR(BIT 19), MEM PAR ERR INTRPT ENB(BIT 20),
21m0138                               	;        PI SYSTEM ON(BIT 28) CHN1-7 ON (BITS 29-35)
21m0138                               	; 5     WAITING RQ 1-7 (11-18)  IN PROG 1-7 (29-35)
21m0138                               	; 6     RQ COUNTS - 4-BIT FIELDS, CHN. 7 AT RIGHT END OF WORD.
21m0138                               	;
21m0138                               	;Other uses of APR AMEM are documented at the beginning 
21m0138                               	
21m0138                               	PI-GET-CHN:     ;MAKE BINARY CHN. NO. FROM MASK IN AR.
21m0138 04536 640710000571070440000000	        D[AR] ROT[34] DEST[AR] NORM $
21m0138                               	                ;PUT RQ 1 INTO BIT 1
21m0138 04537 640720014571000060000000	        D[CONST 6] DEST[MA] NORM $
21m0138                               	                ;MA WILL GET 7-CHN (FOR USE IN SHIFTING)
21m0138                               	PIL1:   D[AR] ROT[1] DEST[AR] C550
21m0138 04540 511150000571002440000000	           COND[OBUS<0] JUMP[PIGETMASK] $ ;FOUND FIRST BIT ?
21m0138 04541 640160024531000440004540	        D[MA] ALU[D-1] DEST[MA] NORM JUMP[PIL1] $
21m0138                               	                ;NO. DECREMENT COUNT AND LOOP.
21m0138 04542 640701224571000440000000	PIGETMASK:      D[MA] DEST[ROTR] NORM $ ;LOAD ROTATE AMT.
21m0138                               	        D[CONST 1] ROT[R] DEST[AR] NORM 
21m0138 04543 640310014571200010000000	          POPJ $        ;MAKE MASK OF FIRST BIT ONLY IN AR.
21m0138                               	
21m0138                               	
21m0138                               	PI-CHECK-RQS:    ;SEE IF IT IS TIME TO TAKE AN INTRPT.
21m0138                               	.REPEAT STANSW [        21m0138                               	.REPEAT STANSW
21m0138                               	.REPEAT 1 - STANSW [
21m0138                               	        D[15] SPEC[A-MEM-APR] ROT[18.] MASK[7] DEST[AR]
21m0138 04544 510150064571044072402026	          C550 COND[OBUS=0] JUMP[MAIN] $ ;ANY RQ'S ?
21m0138                               	].REPEAT 1 -STANSW
21m0138 04545 640041600615000440004536	        ALU[0] DEST[DEV-ADR] NORM PUSHJ[PI-GET-CHN] $
21m0138                               	                ;GET UNARY CHN NO. IN AR, SHIFT AMT. IN MA, ROTR
21m0138 04546 531140060571070440002026	        D[14] ROT[34] C550 COND[-OBUS<0] JUMP[MAIN] $
21m0138                               	                ;EXIT IF PI SYS NOT ON.
21m0138 04547 640700010171200070000000	        D[MASK 7] ROT[R] DEST[Q] NORM $
21m0138                               	                ;MASK OF CHN AND ALL HIGHER CHNS.
21m0138 04550 530140064635000440002026	        D[15] ALU[D&Q] C550 COND[-OBUS=0] JUMP[MAIN] $
21m0138                               	                ;EXIT IF THIS OR HIGHER CHN IN PROGRESS.
21m0138 04551 640700000171000440000000	        D[AR] DEST[Q] NORM $ ;MOVE UNARY CHN # TO Q.
21m0138 04552 510140060635000440002026	        D[14] ALU[D&Q] C550 COND[OBUS=0] JUMP[MAIN] $
21m0138                               	                ;EXIT IF CHN NOT ON.
21m0138 04553 640701224571004440000000	        D[MA] ROT[2] DEST[ROTR] NORM $
21m0138                               	                ;GET SHIFT AMT 4 TIMES LARGER, TO ACCESS CNT FIELD
21m0138 04554 640700014171200010000000	        D[CONST 1] ROT[R] DEST[Q] NORM $
21m0138                               	                ;A ONE ALIGNED WITH RQ CNT FIELD FOR THIS CHN.
21m0138 04555 640704470137000440000000	        D[16] ALU[D-Q] DEST[Q HOLD] NORM $
21m0138                               	                ;DECREMENT OUR WAITING RQ COUNT.
21m0138 04556 640700070335000440000000	        D[16] ALU[D#Q] DEST[Q] NORM $ ;DID WE OVERFLOW ?
21m0138 04557 530140014635200200004557	        D[CONST 20] ROT[R] ALU[D&Q] COND[-OBUS=0] C550 JUMP[.] $
21m0138                               	          ;LOOP HERE FOREVER IF WE OVERFLOWED 4-BIT CNT FIELD
21m0138 04560 640701404171000443000000	        D[MEM] DEST[6 Q] DEST-A-MEM NORM $
21m0138                               	                ;PUT BACK WORD OF RQ COUNTS.
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

21m0138                               	        D[CONST 17] ROT[R] ALU[D&Q] C550
21m0138 04561 530140014635200170000000	          COND[-OBUS=0] JUMP[PIINTGO] $ ;JUMP IF OUR COUNT NEQ 0
21m0138 04562 640140000371044440000000	        D[AR] ROT[18.] ALU[NOTD] DEST[Q] NORM JUMP[PIL11] $
21m0138                               	                ;MASK FOR CLEARING THE WAITING RQ BIT.
21m0138 04563 640700014371000000000000	PIINTGO:        D[CONST 0] ALU[NOTD] DEST[Q] NORM $
21m0138                               	                ;DON'T CLEAR THE BIT, RQ'S STILL WAITING
21m0138 04564 640700064235000440000000	PIL11:  D[15] ALU[D&Q] DEST[Q] NORM $
21m0138                               	                ;GET STATUS B, EITHER DO OR DO NOT CLEAR RQ BIT
21m0138 04565 640701200575000443000000	        D[AR] ALU[DORQ] DEST[5] DEST-A-MEM NORM $
21m0138                               	                ;SET IN PROGRESS BIT, STORE STATUS B.
21m0138 04566 640710020171000440000000	        D[PC] DEST[Q AR] NORM $ ;GET PC INTO Q, AR.
21m0138 04567 640705410635076430000000	        D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $ ;CLR USR MODE
21m0138                               	
21m0138                               	;;;     D[MA] ROT[18.] ALU[DORQ] DEST[1] DEST-A-MEM NORM $
21m0138                               	;;; This is an obsolete bug trap -- DWP 9/80
21m0138                               	
21m0138                               	 ;; FOLLOWING INSTR. IS DEBUGGING AID
21m0138 04570 640700014171000560000000	        D[CONST 56] DEST[Q] NORM $
21m0138                               	                ;PREPARE TO CALC. INTRPT. ADDRESS.
21m0138 04571 640160024477002440002105	        D[MA] ROT[1] ALU[Q-D] DEST[MA] NORM JUMP[PIMUUO] $
21m0138                               	                ;FETCH INTRPT. INSTR AND GO INTERPRET IT.
21m0138                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

22m0138                               	PIGEN:   ;ENTER WITH CHN IN AR TO REQUEST INTRPT.
22m0138 04572 640041600615000440004535	        ALU[0] DEST[DEV-ADR] NORM PUSHJ[CLRDEVINT] $
22m0138 04573 640700060171000440000000	        D[14] DEST[Q] NORM $
22m0138                               	        D[CONST 1] ROT[18.] ALU[D+Q] DEST[4] DEST-A-MEM
22m0138 04574 640701014435044013000000	                NORM $
22m0138 04575 640700014171000070000000	        D[CONST 7] DEST[Q] NORM $
22m0138                               	                ;7-CHN IS AMT TO SHIFT BY FOR MASK BIT.
22m0138                               	        D[AR] MASK[3] ALU[Q-D] DEST[MA] NORM
22m0138 04576 640060000477000030004542	          PUSHJ[PIGETMASK] $ ;LOAD ROTR, FORM MASK IN AR
22m0138 04577 531140060571070440000000	PIGEN1: D[14] ROT[34] C550 COND[-OBUS<0] JUMP[PIGENWT] $
22m0138                               	                ;BRANCH IF PI SYS NOT ON.
22m0138 04600 640700010171200070000000	        MASK[7] D[2] ROT[R] DEST[Q] NORM $
22m0138                               	                ;MASK OF CHN AND ALL HIGHER CHNS.
22m0138 04601 530140064635000440000000	        D[15] ALU[D&Q] C550 COND[-OBUS=0] JUMP[PIGENWT] $
22m0138                               	                ;BRANCH IF THIS OR HIGHER CHN IN PROGRESS.
22m0138 04602 640700000171000440000000	        D[AR] DEST[Q] NORM $ ;MOVE UNARY CHN # TO Q.
22m0138 04603 530140060635000440004563	        D[14] ALU[D&Q] C550 COND[-OBUS=0] JUMP[PIINTGO] $
22m0138                               	                ;IF CHN ON, GO TAKE INTRPT.
22m0138                               	PIGENWT:          ;INTRPT CANNOT HAPPEN NOW, SO SET A WAITING RQ.
22m0138 04604 640701224571004440000000	        D[MA] ROT[2] DEST[ROTR] NORM $
22m0138                               	                ;GET SHIFT AMT 4 TIMES LARGER, TO GET CNT FIELD
22m0138 04605 640700014171200010000000	        D[CONST 1] ROT[R] DEST[Q] NORM $
22m0138                               	                ;A ONE ALIGNED WITH RQ CNT FIELD FOR THIS CHN.
22m0138 04606 640704470035000440000000	        D[16] ALU[D+Q] DEST[Q HOLD] NORM $
22m0138                               	                ;INCREMENT OUR WAITING RQ COUNT.
22m0138 04607 530140014635200100004611	        D[CONST 10] ROT[R] ALU[D&Q] COND[-OBUS=0] C550 JUMP[. + 2] $
22m0138                               	          ;DON'T LET COUNT GET HIGHER THAN 7.
22m0138 04610 640701404571000443000000	        D[MEM] DEST[6] DEST-A-MEM NORM $
22m0138                               	                ;PUT BACK WORD OF RQ COUNTS.
22m0138 04611 640700064171000440000000	        D[15] DEST[Q] NORM $
22m0138                               	                ;GET STATUS B.
22m0138                               	        D[AR] ROT[18.] ALU[DORQ] DEST[5] DEST-A-MEM
22m0138 04612 640141200575044443002026	           NORM JUMP[MAIN] $ ;SET WAITING RQ BIT.
22m0138                               	
22m0138                               	PI-DISMISS:
22m0138                               	        D[15] SPEC[A-MEM-APR] MASK[7] DEST[AR]
22m0138 04613 530050064571000072404536	          C550 COND[-OBUS=0] PUSHJ[PI-GET-CHN] $
22m0138 04614 640700064171000442400000	        D[15] SPEC[A-MEM-APR] DEST[Q] NORM $
22m0138                               	        D[AR] ALU[-D&Q] DEST[5] SPEC[A-MEM-APR&DEST-A-MEM]
22m0138 04615 640141200675000442604544	                NORM JUMP[PI-CHECK-RQS] $
22m0138                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

23m0138                               	PICONO:  ;Here from any CONO PI,
23m0138 04616 640710024571000070000000	        D[MA] MASK[7]  DEST[AR] NORM $
23m0138 04617 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
23m0138 04620 640700060171000440000000	        D[14]  DEST[Q] NORM $ ;GET STATUS A
23m0138 04621 531140024571052440000000	        D[MA] ROT[21.]  C550 COND[-OBUS<0] JUMP[PIL7] $
23m0138 04622 640700014175036010000000	        D[CONST 1] ROT[35. - 20.] ALU[DORQ] DEST[Q] NORM $ 
23m0138                               	         ; TURN ON PAR ERR INTRPT ENB.
23m0138 04623 531140024571050440000000	PIL7:   D[MA] ROT[20.]  C550 COND[-OBUS<0] JUMP[PIL8] $
23m0138 04624 640700014275036010000000	        D[CONST 1] ROT[35. - 20.] ALU[-D&Q] DEST[Q] NORM $ 
23m0138                               	         ;TURN OFF PAR ERR INT ENB
23m0138 04625 531140024571046440000000	PIL8:   D[MA] ROT[19.] C550 COND[-OBUS<0] JUMP[PIL9] $
23m0138 04626 640700014275040010000000	        D[CONST 1] ROT[35. - 19.] ALU[-D&Q] DEST[Q] NORM $ 
23m0138                               	         ;CLEAR MEM PAR ERR FLAG
23m0138 04627 513040024571012440000000	PIL9:   D[MA] ROT[5]  C550 COND[OBUS18] PUSHJ[PI-RESET] $
23m0138 04630 533140024571024440000000	        D[MA] ROT[12]  C550 COND[-OBUS18] JUMP[PIL3] $
23m0138 04631 640700014175016010000000	        D[CONST 1] ROT[7] ALU[DORQ] DEST[Q] NORM $ ; PI ON
23m0138 04632 533140024571022440000000	PIL3:   D[MA] ROT[11]  C550 COND[-OBUS18] JUMP[PIL4] $
23m0138 04633 640700014275016010000000	        D[CONST 1] ROT[7] ALU[-D&Q] DEST[Q] NORM $ ; PI OFF
23m0138 04634 533140024571016440000000	PIL4:   D[MA] ROT[7]  C550 COND[-OBUS18] JUMP[PIL5] $
23m0138 04635 640700000175000440000000	        D[AR] ALU[DORQ] DEST[Q] NORM $ ; CHNS ON
23m0138 04636 533140024571020440000000	PIL5:   D[MA] ROT[10]  C550 COND[-OBUS18] JUMP[PIL6] $
23m0138 04637 640700000275000440000000	        D[AR] ALU[-D&Q] DEST[Q] NORM $ ; CHNS OFF
23m0138 04640 640701000555000443000000	PIL6:   ALU[Q] DEST[4] DEST-A-MEM NORM $
23m0138 04641 533140024571014440004544	        D[MA] ROT[6]  C550 COND[-OBUS18] JUMP[PI-CHECK-RQS] $
23m0138 04642 640700000073000070000000	        D[AR] MASK[7] ALU[0-D] DEST[Q] NORM $
23m0138                               	                ;GENERATED INTRPTS REQUESTED. CHECK TO
23m0138                               	                ; MAKE SURE ONLY ONE CHN IS SPECIFIED.
23m0138 04643 640700000235000070000000	        D[AR] MASK[7] ALU[D&Q] DEST[Q] NORM $
23m0138                               	        D[AR] MASK[7] ALU[D-Q] C600
23m0138 04644 470140000537000070004644	          COND[-OBUS=0] JUMP[.] $ ;HANG HERE IF MORE THAN ONE.
23m0138 04645 640050000571000070004536	        D[AR] MASK[7]  DEST[AR] NORM PUSHJ[PI-GET-CHN] $
23m0138                               	                ;GET BINARY CHN. NUMBER AND UNARY MASK.
23m0138 04646 640140000571000440004577	        NORM JUMP[PIGEN1] $ ;GO GENERATE REQUEST.
23m0138                               	
23m0138                               	
23m0138                               	PICONISUB:
23m0138 04647 640700060171000222400000	        D[14] SPEC[A-MEM-APR] MASK[18.] DEST[Q] NORM $
23m0138                               	          ;GET SYS ON AND CHN ON BITS.
23m0138 04650 640710064571000102400000	        D[15] SPEC[A-MEM-APR] MASK[10] DEST[AR] NORM $
23m0138                               	          ;GET PI IN PROG BITS
23m0138 04651 640710000175020440000000	        D[AR] ROT[10] ALU[DORQ] DEST[AR Q] NORM $
23m0138 04652 640710064571044102400000	        D[15] SPEC[A-MEM-APR] ROT[18.] MASK[10] DEST[AR] NORM $
23m0138                               	          ;GET WAITING RQ BITS, AND RETURN IN LEFT HALF.
23m0138 04653 640310000175044440000000	        D[AR] ROT[18.] ALU[DORQ] DEST[AR Q] NORM POPJ $
23m0138                               	
23m0138                               	PI-RESET:
23m0138 04654 640701000615000442600000	        ALU[0] DEST[4] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
23m0138 04655 640701200615000442600000	        ALU[0] DEST[5] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
23m0138 04656 640301400215000442600000	        ALU[0] DEST[6 Q] SPEC[A-MEM-APR&DEST-A-MEM] NORM POPJ $
23m0138                               	
23m0138                               	;;;     ALU[0] DEST[1] SPEC[A-MEM-APR&DEST-A-MEM] NORM POPJ $
23m0138                               	;;; This is an obsolete bug trap -- DWP 9/80
23m0138                               	
23m0138                               	END-OF-PI-CODE:
23m0138                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

24m0138                               	;; MBOOT MOVED TO PAGE WITH REST OF TAPE STUFF
24m0138                               	
24m0138                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

25m0138                               	;MAPIOT MAPIO1 MAPCO0 MAPCOB MAPCOC MFT1 MFT1A MFT1D MFRD MFOTH MBLT3 SETHLF QORCRY
25m0138                               	 SETHFU BWRTA1 MBLT2 MAPCWT MAPCW1 MAPCW2
25m0138                               	;------------------------------------------------------------------------------
25m0138                               	;
25m0138                               	;       BBN Pager - Map CONO Dispatch Table
25m0138                               	;
25m0138                               	;*** What these things do should documented here.  It's hard enough to find it
25m0138                               	;*** elsewhere!  TVR-Apr80
25m0138                               	;
25m0138                               	;       This code is all BBN dependent.  It will be replaced for other pagers.
25m0138                               	;
25m0138                               	;------------------------------------------------------------------------------
25m0138                               	
25m0138                               	        .ORG[XLIST
25m0138                               	 LIST ];$*$*$ This should be fixed
25m0138                               	
25m0138 05200 640140000571000440000000	        JUMP[MAPCO0] NORM $               ;CONO 0
25m0138 05201 640145000571000440000000	        DEST[CLR-MAP] JUMP[MAPCO1] NORM $ ;CONO 1 -- START MAP CLEARING
25m0138 05202 640150020171000440002125	        UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$                               ;CONO 2
25m0138                               	 -- Ill. Instruction
25m0138 05203 640145000571000440000000	        DEST[CLR-MAP] JUMP[MAPCO1] NORM $ ;CONO 3 -- START MAP CLR
25m0138 05204 640141614571000010000000	        D[CONST 1] DEST[DEV-ADR] JUMP[MAPCO4] NORM $; CONO 4
25m0138 05205 640141614571000010000000	        D[CONST 1] DEST[DEV-ADR] JUMP[MAPCO4] NORM $; CONO 5
25m0138 05206 640140000571000440000000	        JUMP[MAPCO6] NORM $               ;CONO 6
25m0138 05207 640145000571000440000000	        DEST[CLR-MAP] JUMP[MAPCO7] NORM $ ;CONO 7
25m0138                               	
25m0138                               	        .USE[25m0138                               	XLIST
25m0139                               	 LIST ]                 ;$*$*$  This is truely silly.  The CTY code appears
25m0139                               	                        ;       after the map dispatch and the map code
25m0139                               	                        ;       after the CTY dispatch!
25m0139                               	        .PAIR
25m0139                               	. \ 2 + .
25m0140                               	]       UIOTRP[25m0140 05140 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
25m0140                               	]$
25m0140 05141 531140034571022440002026	MAPIOT: D[IR] ROT[9.] COND[-OBUS<0] JUMP[MAIN] C550 $ ;NOP IF DEV. 20
25m0140 05142 510140014735000140000000	        D[CONST 14] ALU[D#Q] COND[OBUS=0] JUMP[MAPIO1] C550 $; IS IT CONO ?
25m0140 05143 510140014735000130000000	        D[CONST 13] ALU[D#Q] COND[OBUS=0] JUMP[MAPDO] C550 $; NO IS IT DATAO?
25m0140                               	        ILGIOT 25m0140 05144 000140000571000440002026	 JUMP [MAIN] ]$   ;ELSE ILLEGAL
25m0140 05145 640700034171000030000000	MAPIO1: D[IR] MASK[3] DEST[Q] NORM $
25m0140 05146 440540014575014520000000	        D[CONST 52] ROT[6] ALU[DORQ] SDISP C600 $
25m0140 05147 640041614571000010000000	MAPCO0: D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $
25m0140 05150 640700050171000440000000	        D[12] DEST[Q] NORM $
25m0140                               	                ; GET SIGN BIT = ENBL FOR EXEC 0-77777
25m0140 05151 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
25m0140 05152 640702234571000023600000	        D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] SHORT $
25m0140 05153 440745014571000200100000	        MAPF[10] CYLEN[IOB-OUT] DEST[CLR-MAP] D[CONST 20] LLOAD $
25m0140                               	                ; TURN OFF MAPPING & START CLEARING MAP
25m0140 05154 500240000571000440005154	        LOOP [.] C550 $  ;WAIT FOR MAP CLR TO FINISH -- OTHERWISE THE
25m0140                               	                ; READS OF 71 AND 72 BELOW DON'T HAPPEN (ON F2 #1).
25m0140                               	.REPEAT 1 - WAITS [
25m0140                               	   ;Now add 1 to abs. loc. 31 of main mem (for statistics keeping)
25m0140                               	;;;;    D[CONST 32] DEST[MA] NORM PUSHJ[MPINC1] $
25m0140                               	    ].REPEAT 1 - WAITS
25m0140 05155 640720014571000710000000	        D[CONST 71] DEST[MA] SHORT $; FETCH MAGIC LOC
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

25m0140 05156 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] CYLEN[FIXM]  $; WAIT FOR DATA
25m0140 05157 640710004571000130000000	        D[MEM] MASK[13] DEST[AR] SHORT $
25m0140 05160 640701000571022443000000	        D[AR] ROT[11] DEST-A-MEM DEST[4] NORM $; MBR
25m0140 05161 640710004571044130000000	        D[MEM] ROT[18.] MASK[13] DEST[AR] SHORT $
25m0140 05162 640700200571022443000000	        D[AR] ROT[11] DEST-A-MEM DEST[1] NORM $; UBR
25m0140                               	.REPEAT 1 - WAITS [
25m0140 05163 640710004571056050000000	        D[MEM] ROT[27] MASK[5] DEST[AR] SHORT $
25m0140 05164 640700600571010443000000	        D[AR] ROT[4] DEST-A-MEM DEST[3] NORM $; AC BASE REG
25m0140                               	].REPEAT 1 - WAITS
25m0140                               	        D[MEM] ROT[7] MASK[3] ALU[0-D] DEST[AR] 
25m0140 05165 450150004473016030000000	                COND[OBUS=0] JUMP[MAPCOB] C600 $; ADDRS LIMIT, J IF 0
25m0140 05166 640710000571000030000000	        D[AR] MASK[3] DEST[AR] SHORT $
25m0140 05167 640150000571034440000000	        D[AR] ROT[16] DEST[AR] JUMP[MAPCOC] NORM $
25m0140                               	                ; FORM SMALLEST ILLEGAL ADDRESS
25m0140 05170 640710014571034200000000	MAPCOB: D[CONST 20] ROT[16] DEST[AR] SHORT $
25m0140 05171 640700014235106010000000	MAPCOC: D[CONST 1] ROT[43] ALU[D&Q] DEST[Q] SHORT $
25m0140                               	                ; GET SIGN BIT = ENBL FOR EXEC 0-77777
25m0140 05172 640710400575000443000000	        D[AR] ALU[DORQ] DEST-A-MEM DEST[AR 2] NORM $; ADDRS LIMIT
25m0140                               	.REPEAT WAITS [
25m0140                               	.REPEAT WAITS
25m0140 05173 640720014571000720000000	        D[CONST 72] DEST[MA] SHORT $; GET NEXT WORD
25m0140 05174 000700004171000440000000	        D[MEM] DEST[Q] LONG $   ;LONG to wait for data to arrive.
25m0140 05175 640141214675064013000000	        D[CONST 1] ROT[32] ALU[-D&Q] DEST-A-MEM DEST[5] JUMP[MAPCOE] NORM $
25m0140                               	                ; AGE & PROCESS BITS
25m0140                               	
25m0140                               	;------------------------------------------------------------------------------
25m0140                               	;
25m0140                               	;       MAP FAULT DISPATCHES COME HERE (6100 + MAPF*4 )
25m0140                               	;
25m0140                               	;       MAP traps happen on next micro instruction after a MEMSTO or STRT-WRT.
25m0140                               	;       They also happen after micro instruction containing a DEST[FIXMAC...],
25m0140                               	;       as in FIXM1 for example.  The trap happens by forcing an unconditional
25m0140                               	;       jump to an address determined by MAP-DISP register and the MAPF of
25m0140                               	;       field of the failing micro instruction.  Otherwise, that micro
25m0140                               	;       instruction is executed normally.
25m0140                               	;       
25m0140                               	;       This code should be the same for all kinds of maps.  However, it will
25m0140                               	;       be necessary to define symbolically the trap code, i.e. the thing that
25m0140                               	;       is usually being loaded left half of Q.  After doing that, and updating
25m0140                               	;       necessary state of PC and flags, the code leave by jumping to MFT1B,
25m0140                               	;       the map dependent page fault/page fill code, with fault code in Q and
25m0140                               	;       failing address in the MA.
25m0140                               	;
25m0140                               	; ***   As you will notice, there are NO spare trap codes.  If you need one,
25m0140                               	; ***   talk to me about a scheme for fixing this and improving page fault
25m0140                               	; ***   recovery.  TVR-Apr80
25m0140                               	;
25m0140                               	;------------------------------------------------------------------------------
25m0140                               	        .ORG[XLIST
25m0140                               	 LIST ];Fixed by hardware to xx100
25m0140 06100 000140000571000440006100	        JUMP[.] $   ;ILLEGAL MAP FAULT -- MICROCODE BUG IF YOU GET HERE
25m0140                               	.REPEAT XUCODE [
25m0140                               	:16100  ;copy for high mem
25m0140 16100 000140000571000440006100	        JUMP[6100] $
25m0140                               	]XUCODE
25m0140                               	        ;**** Consider looking at STOP switch in the future.    TVR - Mar80
25m0140                               	        ;
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

25m0140                               	        ;To find out non-destructively how you lost, start at 2003 (on an F2)
25m0140                               	        ;you will be stopped at PC+1, assuming you lose trying to display
25m0140                               	        ;that instruction in the lights (i.e. (PC) not mapped in)
25m0140                               	        ;
25m0140                               	        ;You can get here by examining/depositing a location in the
25m0140                               	        ;hardware map (i.e. it may only be asking for a page-fill cycle).
25m0140                               	: 6104  ;EXECUTE (&INDIRECT) FAULTS HERE
25m0140 06104 640700014171044020000000	MFT1:   D[CONST 2] ROT[18.] DEST[Q] NORM $; CODE FOR EXECUTE
25m0140 06105 640701614571000010000000	MFT1A:  D[CONST 1] DEST[DEV-ADR] NORM $
25m0140 06106 640702400571000443400000	MFT1D:  DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
25m0140 06107 140150230571000030040000	        D[IOD] MASK[3] DEST[AR IR-ADR] JUMP[MFT1B] MAPF[4] CYLEN[IOB-IN] $
25m0140                               	: 6110  ;NORMAL READ FAULT
25m0140 06110 640700014171044100000000	MFRD:   D[CONST 10] ROT[18.] DEST[Q] NORM $;CODE FOR RD
25m0140 06111 640144620531000440006105	MFOTH:  D[PC] ALU[D-1] DEST[PC] JUMP[MFT1A] NORM $
25m0140                               	.REPEAT XUCODE [
25m0140                               	:16110  ;NORMAL READ FAULT -High mem duplicate instr.
25m0140 16110 640700014171044100000000	        D[CONST 10] ROT[18.] DEST[Q] NORM $;CODE FOR RD
25m0140                               	]XUCODE
25m0140                               	: 6114  ;RMW HERE, DECREMENTS PC
25m0140 06114 640140014171044140006111	        D[CONST 14] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $
25m0140                               	.REPEAT XUCODE [
25m0140                               	:16114  ;RMW -High mem duplicate instr.
25m0140 16114 640140014171044140006111	        D[CONST 14] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $
25m0140                               	]XUCODE
25m0140                               	: 6120  ;WRITES (NORMAL) HERE (NO DECREMENT PC)
25m0140 06120 640702414171044040000000	        D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $
25m0140 06121 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
25m0140 06122 640701600571000443000000	        D[AR] DEST-A-MEM DEST[7] NORM $;SAVE STORE DATA
25m0140 06123 640160034571000220006106	        D[IR] MASK[18.] DEST[MA] NORM JUMP[MFT1D] $; RESTORE MA
25m0140                               	.REPEAT XUCODE * VID [
25m0140                               	XUCODE * VID
25m0140                               	: 6124 ; 5-- BLT-RD
25m0140 06124 640704621171000220000000	        D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC] NORM $; RESTORE PC & DEST ADR
25m0140 06125 640700014171044100000000	        D[CONST 10] ROT[18.] DEST[Q] SHORT $; CODE FOR RD
25m0140 06126 640140001561044000206111	MBLT3:  D[AR] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC] JUMP[MFOTH] NORM $; GET
25m0140                               	 SRC ADR
25m0140                               	.REPEAT XUCODE * VID [
25m0140                               	XUCODE * VID
25m0140                               	: 6130 ;6-- BLT-WRT
25m0140 06130 640724621171000220600000	        D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC MA] SPEC[MA_PC] NORM $; RESTORE PC, GET
25m0140                               	 DEST ADR
25m0140 06131 640710000455000440000000	        ALU[Q-1] DEST[AR] NORM $;  ADJUST SRC ADR
25m0140 06132 640140014171044040006126	        D[CONST 4] ROT[18.] DEST[Q] JUMP[MBLT3] NORM $; CODE FOR WRT
25m0140                               	: 6134 ;7-- BLT-RDA
25m0140 06134 640700001571000440000000	        ACSEL[AC] D[AR] DEST[AC] NORM $; NEW DEST ADR
25m0140 06135 640140014171044100006111	        D[CONST 10] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $; CODE FOR RD
25m0140                               	: 6140 ; 10-- BLT-WRTA
25m0140 06140 640702414171044040000000	        D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; CODE FOR WRT
25m0140 06141 640040024171000220000000	        D[MA] MASK[18.] DEST[Q] PUSHJ[BWRTA1] NORM $; GET MA, SAVE STORE DAT
25m0140 06142 510140000735000220000000	        D[AR] MASK[18.] ALU[D#Q] COND[OBUS=0] JUMP[MBLT2] C550 $
25m0140 06143 640160000055000440000000	        ALU[Q-1] DEST[Q MA] JUMP[MBLT2] NORM $; CORRECT MA
25m0140                               	: 6144 ;11-- BYTE-ILD
25m0140 06144 640040000571000440000000	        PUSHJ[SETHLF] NORM $; SET HALF
25m0140 06145 640140000571000440006110	        JUMP[6110] NORM $; NORMAL READ
25m0140                               	;Page fault in the middle of a interruptable instruction.  Set HALF (BIS)
25m0140                               	;flag as part of page fault processing so that instruction gets restarts in
25m0140                               	;the proper way.
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

25m0140 06146 645140014171074020000000	SETHLF: D[CONST 2] ROT[36] DEST[Q] COND[USER] JUMP[SETHFU] NORM $;BIT 4--HALF
25m0140                               	                ;Get ready to set HALF (BIS) flag.
25m0140                               	                ;Watch for special case of User page fault from Exec. TVR-May80
25m0140 06147 640305420575000440000000	QORCRY: D[PC] ALU[DORQ] DEST[CRYOV] POPJ NORM $;SET HALF
25m0140                               	: 6150 ;12 -- BYTE-IDP
25m0140 06150 640040000571000440006146	        PUSHJ[SETHLF] NORM $; SET HALF
25m0140 06151 640140000571000440006114	        JUMP[6114] NORM $;NORMAL RMW
25m0140                               	;When a DEST[CRYOV] is done, the EXEC shift register is cleared (set) to
25m0140                               	;whatever the user bit in the new CRYOV is.  This destroys the information
25m0140                               	;about which space a page fault came from on XCTR (XCT mapped) instruction.
25m0140                               	;We turn it on explicitly here.  Note that since a user cannot do a XCTR,
25m0140                               	;we only have to worry about the case of being in EXEC mode and getting a
25m0140                               	;user mode page fault.  TVR-May80
25m0140 06152 640705420575000440000000	SETHFU: D[PC] ALU[DORQ] DEST[CRYOV] NORM $
25m0140                               	                ;Set the half flag.
25m0140                               	                ;Don't return yet, we need to reset EXEC-SR
25m0140 06153 640305614571022170000000	        SET-TEMP-USER POPJ $
25m0140                               	                ;Remember that the page fault was from a user page!!
25m0140                               	: 6154 ;13 -- BYTE-IND
25m0140 06154 640040000571000440006146	        PUSHJ[SETHLF] NORM $; SET HALF
25m0140 06155 640140000571000440006104	        JUMP[6104] NORM $; NORMAL INDIRECT
25m0140                               	: 6160 ;BLT-WRTB -- XCT MAPPED BLT STORES
25m0140 06160 640702414171044040000000	        D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; CODE FOR WRT
25m0140 06161 640040024171000220000000	        D[MA] MASK[18.] DEST[Q] PUSHJ[BWRTA1] NORM $; GET MA, SAVE STORE DAT
25m0140 06162 640700014171044040000000	        D[CONST 4] ROT[18.] DEST[Q] NORM $
25m0140 06163 640140001571000440006111	        D[AR] ACSEL[AC] DEST[AC] JUMP[MFOTH] NORM $; RESTORE AC
25m0140                               	: 6164 ;-- MAPFTR -- TRAP WHIILE FETCHING JSYS TARGET
25m0140 06164 640702414171044500000000	        D[CONST 50] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; PI CODE
25m0140 06165 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
25m0140 06166 640141600571000443006111	        D[AR] DEST-A-MEM DEST[7] JUMP[MFOTH] NORM $
25m0140                               	: 6170 ;PPOP-- 16 -- POP & POPJ FETCH- RE-INCR PDL PNTR -- THEN LIKE READ FAULT
25m0140 06170 640140015421001000006110	        D[CONST 1,,1] ACSEL[AC] ALU[D+AC] DEST[AC] JUMP[MFRD] NORM $
25m0140                               	
25m0140                               	: 16174  ;UPPER MEM COPY OF 6174
25m0140 16174 640702414171044040000000	        D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $
25m0140                               	: 6174 ;17-- WRITES WITH RELEVANT ADRS IN MA (NO DECR PC)
25m0140 06174 640702414171044040000000	        D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $
25m0140 06175 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $
25m0140 06176 640141604571000443006106	        D[MEM] DEST-A-MEM DEST[7] JUMP[MFT1D] NORM $;SAVE STORE DATA
25m0140 06177 640701614571000010000000	BWRTA1: D[CONST 1] DEST[DEV-ADR] NORM $
25m0140 06200 640301604571000443000000	        D[MEM] DEST-A-MEM DEST[7] POPJ NORM $
25m0140 06201 640700000077000220000000	MBLT2:  D[AR] MASK[18.] ALU[Q-D] DEST[Q] SHORT $; COUNT HOW MANY WORDS MOVED
25m0140 06202 640710000435044440000000	        D[AR] ROT[18.] ALU[Q+D] DEST[AR] SHORT $;FORM NEW SRC
25m0140 06203 640700025571000220000000	        ACSEL[AC] D[MA] MASK[18.] DEST[AC] SHORT $;NEW DEST
25m0140 06204 640700014171044040000000	        D[CONST 4] ROT[18.] DEST[Q] NORM $
25m0140 06205 640140001561044000206111	        D[AR] ACSEL[AC] ROT[18.] SPEC[LEFT] ALU[DORAC] DEST[AC] JUMP[MFOTH] NORM $; OR IN
25m0140                               	 NEW SRC
25m0140                               	
25m0140       6206	OTHER = .       ;$*$*$ This is the end of the fix areas, In'Sh'Allah  TVR-Apr80
25m0140                               	
25m0140                               	: 5340  ;$*$*$ The APR dispatch ends at 5340.
25m0140                               	
25m0140                               	;*$*$* Fudge area accounting
25m0140       5340	AREA53 = .
25m0140                               	
25m0140                               	.USE[25m0140                               	XLIST
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

25m0141                               	 LIST ]
25m0141 05340 640740000555000440000000	MAPCWT: ALU[Q] LLOAD NORM $
25m0141 05341 000240000571000440005341	        LOOP[.] CYLEN[LONG] $; WAIT FOR MAP TO CLEAR
25m0141 05342 640702214571000043600000	        D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $;TURN ON MAP
25m0141 05343 151140000571000440100000	        MAPF[10] D[AR] COND[OBUS<0] JUMP[MAPCW9] CYLEN[MAX,IOB-OUT,C550] $
25m0141                               	                ; JUMP IF WHOLE MAP ON (INCLUDING EXEC 0-77777)- DONE
25m0141 05344 640740014571000770100000	MAPCW1: D[CONST 77]  MAPF[10] LLOAD NORM $
25m0141 05345 640710020571000440000000	MAPCW2: D[PC]  DEST[AR] SHORT $;SAVE FLAGS
25m0141 05346 640725400615000440000000	        ALU[0] DEST[MA CRYOV] SHORT $;INIT MA, SET EXEC
25m0141 05347 640700014171014100000000	        D[CONST 10] ROT[6]  DEST[Q] SHORT $
25m0141                               	
25m0141                               	 .REPEAT NEWMAP [
25m0141 05350 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $ ; -- FOR WRITING MAP
25m0141 05351 640700000571000443600000	        SPEC[IOB-OUT] SHORT $  ;SET FIRST PART OF 
25m0141                               	           ; EXEC MAP TO POINT TO "NULL MAP" LOCS(UNMAPPED)
25m0141 05352 240700024571000220020000	        MAPF[2] D[MA] MASK[18.] C800 $ ;MAP DATA COMES FROM OBUS.
25m0141 05353 640260024435000440005351	        D[MA] ALU[D+Q] DEST[MA] LOOP[. - 2] NORM $;LOOP
25m0141                               	   ]; NEWMAP
25m0141                               	
25m0141                               	 .REPEAT 1 - NEWMAP [
25m0141                               	; 1 - NEWMAP
25m0141                               	
25m0141 05354 640702234571000033600000	        D[IR] MASK[3]  DEST[IOD] SPEC[IOB-OUT] SHORT $; RESTORE MAP
25m0141 05355 440145400571000440102026	        D[AR]  DEST[CRYOV] JUMP[MAIN] MAPF[10] CYLEN[IOB-OUT] $; RESTORE FLAGS, DONE
25m0141                               	;------------------------------------------------------------------------------
25m0141                               	;       End map trap code which is common to all maps.
25m0141                               	;------------------------------------------------------------------------------
25m0141                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

26m0141                               	;MAPCOA MAPCOE MAPCO1 MAPCOG MAPCO4 MPOFF1 MAPOFF MAPCO6 MAPCO7 MAPCW9 MAPDO MFUS MFA3
26m0141                               	 MFA7 MFA6 MFA4 MFT1B MFHIEX MFA1 MFA2 MFB3 MFTYP1 MFTYP0
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	;       BBN MAP CONO, continued
26m0141                               	;
26m0141                               	;       This code will need to be rewritten for another kind of map.
26m0141                               	;
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	MAPCOA:
26m0141 05356 640702400571000443400000	        DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
26m0141 05357 140300230571000030040000	        D[IOD]  MASK[3] DEST[IR-ADR] MAPF[4] POPJ CYLEN[IOB-IN] $
26m0141                               	                ;GET MAP, ECC & OV ENBL BITS
26m0141 05360 640701600615000440000000	MAPCOE: ALU[0] DEST[DEV-ADR] SHORT $
26m0141 05361 640702234571000033600000	        D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] NORM $
26m0141                               	                ; RESTORE MAP STATE
26m0141 05362 440140014171000010105340	        MAPF[10] D[CONST 1] DEST[Q] JUMP[MAPCWT] CYLEN[IOB-OUT] $
26m0141                               	
26m0141 05363 640041614571000010005356	MAPCO1: D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $
26m0141                               	                ;GET ENABLE BITS IN IR
26m0141 05364 640710050571000440000000	        D[12] DEST[AR] NORM $
26m0141                               	                ; GET SIGN BIT = ENBL EXEC 0-77777
26m0141                               	 .REPEAT NEWMAP [
26m0141                               	   .REPEAT 1 - WAITS [
26m0141                               	   ;Now add 1 to abs. loc. 32 of main mem (for statistics keeping)
26m0141                               	;;;;    ALU[-1] DEST[MAP-DISABLE] NORM $
26m0141                               	;;;;    D[CONST 32] DEST[MA] NORM PUSHJ[MPINC1] $
26m0141                               	    ].REPEAT 1 - WAITS
26m0141                               	  ];NEWMAP
26m0141 05365 640701600615000440000000	ALU[0] DEST[DEV-ADR] SHORT $
26m0141 05366 640140014171000050005340	        D[CONST 5] DEST[Q] JUMP[MAPCWT] NORM $
26m0141                               	
26m0141 05367 640701614571000010000000	MAPCOG: D[CONST 1] DEST[DEV-ADR] NORM $
26m0141 05370 640700050171000430000000	        D[12] MASK[43] DEST[Q] NORM $
26m0141 05371 640710034571000010000000	        D[IR] MASK[1] DEST[AR] SHORT $
26m0141                               	                ;GET LOW BIT OF CONO
26m0141 05372 640700400575106443000000	        D[AR] ROT[43] ALU[DORQ] DEST-A-MEM DEST[2] NORM $
26m0141                               	                ;GET SIGN BIT = EXEC 0-77777 MAP ENBL
26m0141 05373 640700000571000443400000	        SPEC[IOB-IN] SHORT $
26m0141 05374 140700030171000030040000	        MAPF[4] D[IOD] MASK[3] DEST[Q] CYLEN[IOB-IN] $
26m0141 05375 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
26m0141 05376 640702214575000043600000	        D[CONST 4] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] SHORT $
26m0141 05377 440300214575000040100000	        D[CONST 4] ALU[DORQ] DEST[IR-ADR] MAPF[10] POPJ CYLEN[IOB-OUT] $
26m0141                               	                ;TURN ON MAP
26m0141 05400 640042400571000443400000	MAPCO4: DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] NORM PUSHJ[MAPOFF] $
26m0141                               	
26m0141 05401 440140000571000440102026	MPOFF1: MAPF[10] CYLEN[IOB-OUT] JUMP[MAIN] $
26m0141                               	                ; DONE
26m0141 05402 140700230571000030040000	MAPOFF: D[IOD] MASK[3] DEST[IR-ADR] MAPF[4] CYLEN[IOB-IN] $
26m0141 05403 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
26m0141 05404 640302234571000023600000	        D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM POPJ $
26m0141                               	
26m0141 05405 640042400571000440005367	MAPCO6: DEST[CLR-DEV-FROM-INTR] PUSHJ[MAPCOG] NORM $
26m0141 05406 640140000571000440005344	        JUMP[MAPCW1] NORM $
26m0141 05407 000042400571000440005367	MAPCO7: DEST[CLR-DEV-FROM-INTR] PUSHJ[MAPCOG] CYLEN[LONG] $
26m0141 05410 000700000571000440000000	        CYLEN[LONG] $; WAIT FOR MAP TO CLEAR
26m0141 05411 000700000571000440000000	        CYLEN[LONG] $
26m0141 05412 640740000615000440000000	MAPCW9: ALU[0] LLOAD NORM $; SET UP ONLY PAGE 0
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

26m0141 05413 640140000571000440005345	        JUMP[MAPCW2] NORM $
26m0141                               	
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	;DATAO CLEARS THE "ASSOCIATIVE" REGISTER MAPPING THE ADDRESS OF THE DATAO
26m0141                               	; THIS REPLACES CONO 2.
26m0141                               	;------------------------------------------------------------------------------
26m0141 05414 640041614571000010005356	MAPDO:  D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $;GET MAP BITS
26m0141                               	 .REPEAT 1 - NEWMAP [ 26m0141 05415 640702214571000043600000	        D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $;TURN ON MAP
26m0141 05416 440700000571000440100000	        MAPF[10] CYLEN[IOB-OUT] $
26m0141                               	 .REPEAT NEWMAP [
26m0141 05417 640700000571000443600000	        SPEC[IOB-OUT] SHORT $  ;REQUEST MAP WRITE CYCLE.
26m0141 05420 240700014571064010020000	        MAPF[2] D[CONST 1] ROT[32] C800 $ ]
26m0141                               	 .REPEAT 1 - NEWMAP [
26m0141                               	          ;CLR MAP ENTRY ASSOCIATED WITH MA
26m0141 05421 240702234571000033600000	        D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] C800 $; RESTORE ENABLES
26m0141 05422 440140000571000440102026	        MAPF[10] CYLEN[IOB-OUT] JUMP[MAIN] $
26m0141                               	
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	;
26m0141                               	;       BBN MAP - Handle map trap and page fill cycles.
26m0141                               	;
26m0141                               	;       This code will need to be rewritten for another kind of map.
26m0141                               	;
26m0141                               	;------------------------------------------------------------------------------
26m0141 05423 640700050171000400000000	MFUS:   D[12] MASK[40] DEST[Q] NORM $;GET LIMIT REG
26m0141 05424 471140024537000440000000	        D[MA] ALU[D-Q] COND[-OBUS<0] JUMP[MTRPAL] C600 $;J IF MA PAST ADDRS LIMIT
26m0141 05425 640140044171000440000000	        D[11] DEST[Q] JUMP[MFA1] NORM $;GET USER BASE REG.
26m0141                               	
26m0141 05426 530140004571024010000000	MFA3:   D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFA4] C550 $ ;J IF MODIF. BIT ON
26m0141 05427 640700600571000440000000	MFA7:   D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
26m0141 05430 640701400571000443000000	        D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
26m0141 05431 640710014575056010000000	        D[CONST 1] ROT[27] ALU[DORQ] DEST[AR] SHORT $; TURN ON WRT-PREVENT, SAVE NEW MAP
26m0141                               	 WORD
26m0141 05432 640140004171000330000000	MFA6:   D[MEM] MASK[33] DEST[Q] JUMP[MFA5] NORM $; GET CST ENTRY, GO DO
26m0141 05433 510140034571054010005427	MFA4:   D[IR] ROT[26] MASK[1] COND[OBUS=0] JUMP[MFA7] C550 $; J IF NO WRT-PERMIT
26m0141 05434 640700600571000440000000	        D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
26m0141 05435 640701400571000443000000	        D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
26m0141 05436 640150010635060430005432	        D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] JUMP[MFA6] NORM $; CLEAR WRT-PREVENT
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	; Enter here with fault code in Q and address in MA to handle page fault or
26m0141                               	; page fill cycle.  MAP-EXEC-SR (i.e. USER condition) is still undisturbed.
26m0141                               	;------------------------------------------------------------------------------
26m0141 05437 645150024575000220005423	MFT1B:  D[MA] MASK[18.] ALU[DORQ] DEST[AR] COND[USER] JUMP[MFUS] NORM $;GET FAILED ADDRS,
26m0141                               	 J IF USER
26m0141 05440 640700024171050020000000	        D[MA] ROT[24] MASK[2] DEST[Q] NORM $; HIGH ORDER 2 BITS
26m0141 05441 450140014537000030000000	        D[CONST 3] ALU[D-Q] COND[OBUS=0] JUMP[MFHIEX] C600 $; J IF PRIVATELY MAPPED PART
26m0141                               	
26m0141 05442 640140014171014300000000	        D[CONST 30] ROT[6] DEST[Q] JUMP[MFA1] NORM $; PAGE TAB @ 3000
26m0141 05443 640700060171000440000000	MFHIEX: D[14] DEST[Q] NORM $
26m0141 05444 640701600615000440000000	MFA1:   ALU[0] DEST[DEV-ADR] NORM $
26m0141 05445 640702234571000023600000	        D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM $ ;CLEAR MAPPING
26m0141 05446 440701634571000033100000	        D[IR] MASK[3] DEST-A-MEM DEST[APRENB] MAPF[10] CYLEN[IOB-OUT] $
26m0141                               	                ;SAVE AR, ECC INT
26m0141 05447 640722624435066110000000	        D[MA] ROT[33] MASK[11] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE ENTRY
26m0141                               	
26m0141 05450 640700214571030160000000	        D[CONST 16] ROT[14] DEST[IR-ADR] NORM $; PREPARE INITIAL PERMIT BITS
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

26m0141 05451 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
26m0141 05452 640700014171000030000000	MFA2:   D[CONST 3] DEST[Q] CYLEN[FIXM] $; DON'T CLEAR IND PNTR. COUNT, WAIT FOR FETCH
26m0141 05453 640700004175044440000000	        D[MEM] ROT[18.] ALU[DORQ] DEST[Q] CYLEN[FIXM+1] $;GET PERMIT BITS
26m0141 05454 640700234635000440000000	        D[IR] ALU[D&Q] DEST[IR-ADR] SHORT $; AND THEM IN
26m0141 05455 530140004571026030000000	        D[MEM] ROT[13] MASK[3] COND[-OBUS=0] JUMP[MFTR1] C550 $; CHECK FOR TRAP BITS
26m0141 05456 510140004571032010000000	MFB3:   D[MEM] ROT[15] MASK[1] COND[OBUS=0] JUMP[MFTR2] C550 $; J IF NO ACCESS PERMIT
26m0141 05457 510140004171004020000000	        D[MEM] ROT[2] MASK[2] DEST[Q] COND[OBUS=0] JUMP[MFTYP0] C550 $; GET TYPE CODE, J
26m0141                               	 IF 0
26m0141 05460 510140000055000440000000	        ALU[Q-1] DEST[Q] COND[OBUS=0] JUMP[MFTYP1] C550 $; J IF 1
26m0141 05461 530140000055000440000000	        ALU[Q-1] DEST[Q] COND[-OBUS=0] JUMP[MFTR3] C550 $; J IF NOT 2
26m0141 05462 530140034571106010000000	        D[IR] ROT[43] MASK[1] COND[-OBUS=0] JUMP[MFTR41] C550 $; TYPE 2, J IF >2 INDR.
26m0141                               	 PNTRS
26m0141 05463 640700234433000440000000	        D[IR] ALU[D+1] DEST[IR-ADR] SHORT $; COUNT IND. PNTRS
26m0141 05464 640700004171066150000000	        D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET PAGE TABLE #
26m0141 05465 640701404571000443000000	        D[MEM] DEST-A-MEM DEST[6] NORM $; SAVE PNTR
26m0141 05466 640722614435030020000000	        D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE PNTR
26m0141 05467 640700070171000110000000	        D[16] MASK[11] DEST[Q] CYLEN[FIXM] $; GET PAGE #, WAIT FOR MEM
26m0141 05470 530140004571044040000000	        D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR4] C550 $; PAGE OUT-OF-CORE?
26m0141 05471 640704404571000130000000	        D[MEM] MASK[13] DEST[HOLD] NORM $
26m0141 05472 640162604575022440005452	        D[MEM] ROT[11] ALU[DORQ] DEST[MA HI-ABS-MA] JUMP[MFA2] NORM $; LOOP
26m0141 05473 640700004171066150000000	MFTYP1: D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET SHARED PAGE #
26m0141 05474 640722614435030020000000	        D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH SHARED PNTR
26m0141 05475 640700014171030120000000	MFTYP0: D[CONST 12] ROT[14] DEST[Q] CYLEN[FIXM] $; GET R-X MASK
26m0141 05476 450140034635000440005500	        D[IR] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C600 $; J IF NEITHER R NOR X
26m0141 05477 640700234575000440000000	        D[IR] ALU[DORQ] DEST[IR-ADR] NORM $; TURN ON R AND X
26m0141 05500 640700034371056030000000	        D[IR] ROT[27] MASK[3] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX ENBL BITS,
26m0141                               	 INVERTED
26m0141 05501 530140004571044040000000	        D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR5] CYLEN [C550] $; J IF
26m0141                               	 OUT-OF-CORE
26m0141 05502 530140000235042030000000	        D[AR] ROT[21] MASK[3] ALU[D&Q] DEST[Q] COND[-OBUS=0] JUMP[MFTR6] C550 $; J IF
26m0141                               	 ILLEGAL ACCESS TYPE (RWX)
26m0141                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

27m0141                               	;MFA5 JSMFR MFTR1 MFTR10 MFB5 MFB4 MFC1 MFTR2 MTRPAL MFTR3 MFTR4 MFTR5 MFTR6 MFTR7 MFTR9
27m0141                               	 MFTR41 MAPRST MAPRSS MAPRSL
27m0141 05503 640700004171000130000000	        D[MEM] MASK[13] DEST[Q] SHORT $; GET ABS PAGE #
27m0141 05504 640722614575014400000000	        D[CONST 40] ROT[6] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; GET CORE STATUS ENTRY
27m0141 05505 640700034371024440000000	        D[IR] ROT[12] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX DISABLES
27m0141 05506 640700014235052240000000	        D[CONST 24] ROT[25] ALU[D&Q] DEST[Q] SHORT $; GET ONLY R & X
27m0141 05507 640700014035052040000000	        D[CONST 4] ROT[25] ALU[D+Q] DEST[Q] SHORT $; MOVE X BIT LEFT 1
27m0141 05510 640700024175022240000000	        D[MA] ROT[11] MASK[24] ALU[DORQ] DEST[Q] SHORT $; OR IN PAGE ADDRS
27m0141 05511 510140004571006030000000	        D[MEM] ROT[3] MASK[3] COND[OBUS=0] JUMP[MFTR7] C550 $; J IF CST AGE SAYS TRAP
27m0141 05512 510140000571040010005426	        D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFA3] C550 $;J IF NO WRT RQ
27m0141 05513 640700200571000440000000	        D[AR] DEST[IR-ADR] SHORT $; SAVE ORRIGINAL MA
27m0141 05514 640701400571000443000000	        D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
27m0141 05515 640710010635060430000000	        D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] SHORT $; TURN OFF WRT PREVENT, SAVE NEW MAP
27m0141                               	 WORD
27m0141 05516 640700014171064010000000	        D[CONST 1] ROT[32] DEST[Q] SHORT $; GET MODIFICATION BIT
27m0141 05517 640700004175000320000000	        D[MEM] MASK[32] ALU[DORQ] DEST[Q] SHORT $; OR INTO CST WORD
27m0141 05520 640704464575000440000000	MFA5:   D[15] ALU[DORQ] DEST[HOLD] NORM $;OR IN AGE, ETC
27m0141 05521 640700024171000440000000	        D[MA] DEST[Q] SHORT $; SAVE CST ADDRS
27m0141                               	
27m0141 05522 640722634571000220000000	        D[IR] MASK[18.] DEST[MA HI-ABS-MA] NORM $; GET ORIGINAL MA
27m0141                               	
27m0141                               	 .REPEAT NEWMAP [
27m0141 05523 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $ ;NOW TURN MAP ON.
27m0141 05524 640702214571000043600000	        D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $
27m0141 05525 440700000571000443700000	        MAPF[10] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
27m0141 05526 240700000571000440020000	        MAPF[2] D[AR] C800$; LOAD MAP
27m0141 05527 000700000571000440000000	  NOP $ ;%%%%%%% FOR DEBUGGING $$$$$$$$
27m0141                               	  ]; NEWMAP
27m0141                               	
27m0141                               	 .REPEAT 1 - NEWMAP [
27m0141                               	; 1-NEWMAP
27m0141                               	
27m0141 05530 240702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] C800 $ ;MAP OFF
27m0141 05531 465140000571000440105533	        MAPF[10] CYLEN[IOB-OUT] COND[-USER] JUMP[. + 2] $
27m0141                               	
27m0141 05532 640705614571022170000000	        D[CONST 17] ROT[11] DEST[MAP-EXEC-SR] NORM $
27m0141 05533 640724000555000440000000	        ALU[Q] DEST[MA STRT-WRT] NORM $; STORE CST
27m0141                               	
27m0141                               	.REPEAT 1 - WAITS [
27m0141                               	   ;Now add 1 to abs. loc. 30 of main mem (for statistics keeping)
27m0141                               	;;;;    D[CONST 30] DEST[MA] NORM PUSHJ[MPINC1] $
27m0141                               	].REPEAT 1 - WAITS
27m0141                               	
27m0141 05534 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
27m0141 05535 640710070571000440000000	        D[16] DEST[AR] NORM $
27m0141 05536 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
27m0141 05537 640702274571000443600000	        D[10 + APRENB] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN MAP BACK ON, ETC.
27m0141                               	        MAPF[10] CYLEN[MAX,IOB-OUT,C550]
27m0141 05540 170140000571032010100000	                        D[AR] ROT[15] MASK[1] COND[-OBUS=0] JUMP[JSMFR] $
27m0141                               	                ; DO SPECIAL JSYS STUFF IF APPROPRIATE
27m0141 05541 510140000571040010002026	        D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MAIN]  C550 $; DONE IF NO WRT
27m0141 05542 530140000571036010002026	        D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MAIN] C550 $; DONE IF READ
27m0141 05543 640720000571000220000000	        D[AR] MASK[18.] DEST[MA] SHORT $;GET ORRIG. MA
27m0141 05544 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $
27m0141 05545 640144274571000440002033	        D[17] DEST[MEMSTO] JUMP[MSMAIN1] NORM $; STORE THE STORE DATA, & PROCEDE
27m0141                               	
27m0141 05546 640700000571000440000000	MPINC1: NORM $  ;Wait for mem fetch to finish.
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

27m0141 05547 640704204433000440000000	        D[MEM] ALU[D+1] DEST[MEMSTO] NORM $
27m0141                               	         ;Add one to data and store back in same mem loc.
27m0141                               	 .REPEAT NEWMAP [
27m0141 05550 640305200615000440000000	        ALU[0] DEST[MAP-DISABLE] NORM POPJ $
27m0141                               	     ] .REPEAT 1 - NEWMAP [
27m0141                               	
27m0141 05551 640720000571000220000000	JSMFR:  D[AR] MASK[18.] DEST[MA] NORM $
27m0141 05552 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
27m0141 05553 640150074571000440004474	        D[17] DEST[AR] JUMP[MUJSM1] NORM $; RESTORE STORE DATA
27m0141                               	
27m0141 05554 530140004571022010000000	MFTR1:  D[MEM] ROT[11] MASK[1] COND[-OBUS=0] JUMP[MFTR9] C550 $; J IF TRAP TO USER
27m0141 05555 530140004571024010000000	        D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFTR10] C550 $;J IF WRT TRAP
27m0141 05556 640140004571000440000000	        D[MEM] JUMP[MFTR2] NORM $; TREAT BOTH "TRAP-TO-MON" CODES AS IMMEDIATE
27m0141 05557 510140000571040010005456	MFTR10: D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFB3] C550 $; WRT RQ? J IF NO
27m0141 05560 640700014171074440000000	        D[CONST 44] ROT[36] DEST[Q] SHORT $; GET ERROR CODE BITS -- WRT TRAP
27m0141                               	MFB5:
27m0141 05561 645150000175000440005563	MFB4:   D[AR] ALU[DORQ] DEST[AR Q] COND[USER] JUMP[. + 2] NORM $; OR ERROR BITS IN, J IF
27m0141                               	 USER MODE
27m0141 05562 640710014575044010000000	        D[CONST 1] ROT[18.] ALU[DORQ] DEST[AR] NORM $; TURN ON EXEC BIT
27m0141 05563 640700014171014050000000	        D[CONST 5] ROT[6] DEST[Q] SHORT $
27m0141 05564 640700014175000710000000	        D[CONST 71] ALU[DORQ] DEST[Q] SHORT $; FORM 571
27m0141 05565 640722660575000440000000	        D[14] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; ADD PSB (MON BASE TAB)
27m0141 05566 640704200571000440000000	        D[AR] DEST[MEMSTO] CYLEN[FIXM] $; STORE ERROR BITS THERE
27m0141 05567 510140000571040010000000	        D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFC1] C550 $; J IF NO WRT RQ
27m0141 05570 530140000571036010000000	        D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MFC1] C550 $; J IF RD RQ
27m0141 05571 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] SHORT $; GO TO 572
27m0141 05572 640704274571000440000000	        D[17] DEST[MEMSTO] NORM $; SAVE STORE DATA
27m0141 05573 640701600615000440000000	MFC1:   ALU[0] DEST[DEV-ADR] CYLEN[MEMSTO] $
27m0141 05574 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN OFF MAP
27m0141 05575 440702600615000440100000	        MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $
27m0141 05576 640720014571000700000000	        D[CONST 70] DEST[MA] SHORT $; FETCH TRAP INSTR
27m0141 05577 640701600615000440000000	        ALU[0] DEST[DEV-ADR] CYLEN[FIXM] $
27m0141 05600 640702274571000443600000	        D[10 + APRENB] DEST[IOD] SPEC[IOB-OUT] SHORT $; TURN ON MAP
27m0141 05601 440710020171000440100000	        D[PC] DEST[Q AR] MAPF[10] CYLEN[IOB-OUT] $
27m0141 05602 640705410635076430000000	        D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $;CLR USER
27m0141 05603 640140014171004550002106	        D[CONST 55] ROT[2] DEST[Q] JUMP[MUUO44] NORM $
27m0141 05604 640140014171074410005561	MFTR2:  D[CONST 41] ROT[36] DEST[Q] JUMP[MFB5] NORM $; ASCCESS PERMISSION TRAP
27m0141                               	MTRPAL:
27m0141 05605 640700014171074400000000	MFTR3:  D[CONST 40] ROT[36] DEST[Q] SHORT $
27m0141 05606 640140014175066010005561	        D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB5] NORM $; ILLEGAL PT ENTRY TYPE,
27m0141                               	 ADDRESS LIMIT
27m0141                               	MFTR4:  ;ALL THESE ARE NOT-IN-CORE
27m0141 05607 640140014171074220005561	MFTR5:  D[CONST 22] ROT[36] DEST[Q] JUMP[MFB5] NORM $; NOT-IN-CORE
27m0141 05610 510140014635000050005613	MFTR6:  D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[. + 3] C550 $; J IF NO R OR X ERROR
27m0141 05611 640700014175066040000000	        D[CONST 4] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN "R OR X ERROR" BIT
27m0141 05612 510140014635000020005614	        D[CONST 2] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C550 $; J IF NO W ERROR
27m0141 05613 640700014175066020000000	        D[CONST 2] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN W ERROR BIT
27m0141 05614 640700014275000070000000	        D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
27m0141 05615 640140014175074400005561	        D[CONST 40] ROT[36] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; GROUP 2
27m0141 05616 640140014171074100005561	MFTR7:  D[CONST 10] ROT[36] DEST[Q] JUMP[MFB4] NORM $; AGE ERR -- GROUP 0
27m0141 05617 640140014171074420005561	MFTR9:  D[CONST 42] ROT[36] DEST[Q] JUMP[MFB4] NORM $; USER TRAP
27m0141 05620 640700014171074200000000	MFTR41: D[CONST 20] ROT[36] DEST[Q] NORM $; GROUP 1
27m0141 05621 640140014175066010005561	        D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; TOO MANY INDR. PNTRS
27m0141                               	;------------------------------------------------------------------------------
27m0141                               	;Reset map.  Clear entire map to zero.  This is because even though the map
27m0141                               	;will stop stores from happening, fetches still happen irregardless of state
27m0141                               	;of map and if map points at non-existent memory (on for example, an immediate
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

27m0141                               	;mode instruction), the machine will get a spurious ECC interrupt.
27m0141                               	;
27m0141                               	;It is assumed that the device address is set to 1 when this thing is called.
27m0141                               	;------------------------------------------------------------------------------
27m0141 05622 640705614571022000000000	MAPRST: SET-TEMP-EXEC $
27m0141                               	                ;Begin at the beginning of EXEC space.
27m0141 05623 640700014171022010000000	        D[CONST 1] ROT[9.] DEST[Q] SHORT $
27m0141                               	                ;Increment for MA
27m0141 05624 640720014537044010000000	MAPRSS: D[CONST 1] ROT[18.] ALU[D-Q] DEST[MA] NORM $
27m0141                               	                ;Start at the top and work down.
27m0141                               	MAPRSL:
27m0141                               	.REPEAT 1 - NEWMAP [
27m0141                               	.REPEAT 1 - NEWMAP
27m0141                               	.REPEAT NEWMAP [
27m0141 05625 640700000571000443600000	        START-OUT SHORT $
27m0141 05626 640700014571064010020000	        MAPF[2] D[CONST 1] ROT[35. - 9.] NORM $
27m0141                               	                ;Set mapping to zero, Invalid
27m0141 05627 262160024537000440005625	        D[MA] ALU[D-Q] DEST[MA] COND[-MA-AC] JUMP[. - 2] C800 $
27m0141                               	                ;Repeat for each page in this space
27m0141                               	].REPEAT NEWMAP
27m0141 05630 665145614571022170005624	        SET-TEMP-USER COND[-USER] JUMP[MAPRSS] $
27m0141                               	                ;Repeat once more if currently doing EXEC space. This
27m0141                               	                ;time for USER space.  We can do this because EXEC-SR is
27m0141                               	                ;latched at the end of the cycle.
27m0141 05631 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
27m0141 05632 640702214571000013600000	        D[CONST 1] DEST[IOD] SPEC[IOB-OUT] NORM $
27m0141 05633 440702014571000030140000	        MAPF[14] CYLEN[IOB-OUT] D[CONST 3] DEST[MAP-DISP] $
27m0141 05634 000303600571000440000000	        DEST[CLR-MI-ERR] POPJ $ ;Done
27m0141                               	
27m0141                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

28m0141                               	;JSYS1 JSYS2 UMOVX XCT1 XCTUMV XCT5 XCT4 XCT6 XCT3 XCT13 XCT18 XCT12 XCT11 XDISP XCT2
28m0141                               	 XFIXMA XCTAC XCTSTK XCTS1 XCTS2 XCT10 XCTBLG XCTBYT XBY1 XBY4 XBY15 XBY14 XBY13 XBY3
28m0141                               	;------------------------------------------------------------------------------
28m0141                               	;
28m0141                               	;       BBN added instructions.  Sometimes used by other than TENEX
28m0141                               	;
28m0141                               	;------------------------------------------------------------------------------
28m0141 05635 640706000550400440020000	JSYS1:  FIXM1 $
28m0141 05636 640710020571000440000000	        D[PC] DEST[AR] NORM $   ;SAVE PC & FLAGS
28m0141 05637 640704604571000220000000	        D[MEM] MASK[18.] DEST[PC] NORM $; JUMP TO RIGHT HALF
28m0141 05640 640720004571044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $
28m0141 05641 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
28m0141 05642 510140014635074010005644	JSYS2:  C550 D[CONST 1] ROT[36] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] $; J IF EXEC MODE
28m0141 05643 640705600615000440000000	        ALU[0] DEST[MAP-EXEC-SR]  NORM $; TEMP TURN OFF USER
28m0141 05644 640700014171014100000000	        D[CONST 10] ROT[6] DEST[Q] SHORT $
28m0141 05645 640720024575000440000000	        D[MA] ALU[DORQ] DEST[MA] SHORT $; FETCH POINTER WORD
28m0141 05646 640706000550400440020000	        FIXM1  $
28m0141 05647 640704604571000220000000	        D[MEM] MASK[18.] DEST[PC] NORM $; J TO RIGHT HALF
28m0141 05650 640700020171000440000000	        D[PC] DEST[Q] SHORT $
28m0141 05651 511140000571012440005653	        D[AR] ROT[5] C550 COND[OBUS<0] JUMP[. + 2] $
28m0141                               	                ;If we came from exec mode, then we...
28m0141 05652 640700014175070010000000	        D[CONST 1] ROT[34] ALU[DORQ] DEST[Q] SHORT $
28m0141                               	                ; ...TURN ON FLAG BIT 7
28m0141 05653 640705414675074010000000	        D[CONST 1] ROT[36] ALU[-D&Q] DEST[CRYOV] SHORT $; TURN OFF USER
28m0141 05654 640720004571044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $; LEFT HALF
28m0141 05655 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$; STORE PC
28m0141                               	
28m0141                               	  .DEFINE JCFM 28m0141                               	
28m0141 05656 645140000571000440002100	UMOVX:  COND[USER] JUMP[MUUO] NORM $
28m0141 05657 640700004171000440000000	        D[MEM] DEST[Q] NORM $
28m0141 05660 640704414435102010000000	        D[CONST 1] ROT[41] ALU[D+Q] DEST[HOLD] NORM $
28m0141 05661 640140014171000050000000	        D[CONST 5] DEST[Q] JUMP[XCTUMV] NORM $
28m0141                               	
28m0141                               	;------------------------------------------------------------------------------
28m0141                               	;
28m0141                               	;       XCTR - Execute Relocated
28m0141                               	;
28m0141                               	;       If in Exec mode and the AC field of the XCT instruction is non-zero,
28m0141                               	;       it means do some of the references from User mode if PC bit (?),
28m0141                               	;       meaning JSYS from Moniter, is not set.
28m0141                               	;
28m0141                               	;       This code is not map dependent, although other maps (like ITS) may code
28m0141                               	;       the bits in the AC field differently, requiring some rewriting.
28m0141                               	;
28m0141                               	;       Warning:  This code is complex and prone to bugs.  Many probably lurk
28m0141                               	;                 in the cracks.  If you find one, please document it even if
28m0141                               	;                 no solution seems to appear.
28m0141                               	;------------------------------------------------------------------------------
28m0141 05662 640704620531000440000000	XCT1:   D[PC] ALU[D-1] DEST[PC] NORM $
28m0141 05663 645140000571000440000000	        COND[USER] JUMP[XCT2] NORM $
28m0141 05664 640700034171032040000000	        D[IR] ROT[15] MASK[4] DEST[Q] SHORT $; SAVE XCT AC FLD
28m0141 05665 664170604571000440000000	XCTUMV: D[MEM] DEST[AR IR-ALL MA] COND[-MEM-IDX-IND] JUMP[XCT3] NORM $
28m0141 05666 510140034571044040020000	XCT5:   D[IR] ROT[18.] MASK[4] COND[OBUS=0] JUMP[XCT4] C550 MAPF[2] $; J IF NO IDX FLD
28m0141 05667 000730234420400220000000	        D[IR] MASK[18.] ALU[IX+D] DEST[MA IR-ADR AR] $; DO INDEX
28m0141 05670 510140034571034010020000	XCT4:   D[IR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XCT3] C550 MAPF[2] $; J IF NO INDR
28m0141 05671 530040014635000100000000	        D[CONST 10] ALU[D&Q] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF ADDR CALC USER
28m0141                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

28m0141                               	XCT6:
28m0141 05672 640706000550400440010000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-IND] CYLEN[FIXM] $
28m0141                               	;;;     FIXM1 $
28m0141                               	;;;             ;It was overdecrementing PC  TVR-Mar80
28m0141 05673 640705614571022000000000	        SET-TEMP-EXEC $
28m0141 05674 644170404571000440005666	        D[MEM] DEST[AR IR-23 MA] COND[MEM-IDX-IND] JUMP[XCT5] NORM $
28m0141 05675 640700200555000440020000	XCT3:   ALU[Q] DEST[IR-ADR] SHORT  MAPF[2] $; SAVE XCT AC FLD
28m0141 05676 640700034171016070000000	        D[IR] ROT[7] MASK[7] DEST[Q] SHORT $; GET HO 7 BITS OF OPCODE
28m0141 05677 510140014735000540000000	        D[CONST 54] ALU[D#Q] COND[OBUS=0] JUMP[XCTSTK] C550 $; J IF STACK GROUP
28m0141 05700 510140014735000270000000	        D[CONST 27] ALU[D#Q] COND[OBUS=0] JUMP[XCTBYT] C550 $; J IF BYTE GROUP
28m0141 05701 510140014735000520000000	        D[CONST 52] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLG] C550 $; J IF GROUP WITH BLT IN IT
28m0141                               	
28m0141 05702 640700034171000040000000	XCT13:  D[IR] MASK[4] DEST[Q] SHORT $; GET XCT AC FLD
28m0141 05703 510140014635000050000000	XCT18:  D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[XDISP] C550 $; J IF NEITHER RELEVANT BIT
28m0141 05704 642140000571000440000000	        COND[MA-AC] JUMP[XCT10] NORM $; J IF EF ADR IS AC
28m0141                               	        JCFM[28m0141 05705 530140020571020010000000	D[PC] ROT[10] MASK[1] COND[-OBUS=0] JUMP[XDISP] C550 $;J IF CALL FM MON];J IF CALL FM MON
28m0141                               	
28m0141 05706 510140014635000010000000	        D[CONST 1] ALU[D&Q] COND[OBUS=0] JUMP[XCT11] C550 $;J IF BIT OFF
28m0141 05707 510140014635000040000000	        D[CONST 4] ALU[D&Q] COND[OBUS=0] JUMP[XCT12] C550 $; J IF OTHER BIT OFF
28m0141 05710 640145614571022030000000	        D[CONST 03] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET SRC & DEST TO USER
28m0141                               	
28m0141 05711 640145614571022020000000	XCT12:  D[CONST 02] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET DEST TO USER
28m0141 05712 640705614571022010000000	XCT11:  D[CONST 01] ROT[11] DEST[MAP-EXEC-SR] NORM $; SET SRC TO USER
28m0141 05713 540520224571000441602000	XDISP:  D[MA] DEST[MA IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
28m0141                               	
28m0141                               	;This is the dispatch for normal non-relocated XCT
28m0141 05714 540530604571000441602174	XCT2:   D[MEM] DEST[IR-ALL AR MA] DISP[2174] SPEC[PC+1-IF] CYLEN[DISP] $
28m0141                               	
28m0141                               	;Call here after setting MA if this memory cycle is supposed to
28m0141                               	;be relocated to the previous address space.
28m0141                               	;This must preserve Q and AR, some callers depend on it.
28m0141 05715 642140000571000440000000	XFIXMA: COND[MA-AC] JUMP[XCTAC] NORM $; J IF ADDRS IS AC
28m0141 05716 530300020571020010020000	        D[PC] ROT[10] MASK[1] COND[-OBUS=0] POPJ C550 MAPF[2] $; LEAVE IF CALL FM MON
28m0141 05717 640705614571022170000000	        SET-TEMP-USER $
28m0141 05720 640320024571000440000000	        D[MA] DEST[MA] POPJ NORM $
28m0141                               	
28m0141                               	;MA is reference to AC of previous address space.
28m0141                               	XCTAC:
28m0141                               	.REPEAT 1 - WAITS [
28m0141 05721 640704400551000440000000	        ACSEL[AC] ALU[AC] DEST[HOLD]  SHORT $; SAVE AC
28m0141 05722 640702425571000440000000	        ACSEL[AC] DEST[CLR-DEV-FROM-INTR AC] D[MA] SHORT $; GET AC ADDRS
28m0141 05723 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $
28m0141 05724 640700055421000440000000	        ACSEL[AC] D[13] ALU[D+AC] DEST[AC] SHORT $; ADD IN AC BASE REG.
28m0141 05725 640700015421022750000000	        ACSEL[AC] D[CONST 75] ROT[11] ALU[D+AC] DEST[AC] SHORT $
28m0141 05726 640700015421036070000000	        ACSEL[AC] D[CONST 7] ROT[17] ALU[D+AC] DEST[AC] NORM $
28m0141 05727 640320005171000440000000	        D[MEM] ACSEL[AC] DEST[O_AC MA] POPJ NORM $
28m0141                               	].REPEAT 1 - WAITS
28m0141                               	.REPEAT WAITS [
28m0141                               	.REPEAT WAITS
28m0141                               	
28m0141                               	XCTSTK:
28m0141                               	;;;     COND[-MA-AC] JUMP[XCT13] NORM $; J IF EF ADR NOT AC (TREAT NORMALLY)
28m0141 05730 510140034171022020005702	        D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LOW ORDER
28m0141                               	 BITS OF OP CODE, J IF PUSHJ
28m0141 05731 510140014735000030005702	        D[CONST 3] ALU[D#Q] COND[OBUS=0] JUMP[XCT13] C550 $; J IF POPJ
28m0141                               	.repeat 0[
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

28m0141                               	.repeat 0
28m0141 05732 510140014735000020000000	        D[CONST 2] ALU[D#Q] COND[OBUS=0] JUMP[XPOP1] C550 $; J IF POP
28m0141 05733 640140000571000440000000	        JUMP[XPUSH1] NORM $
28m0141                               	                ;Someday, move code over here (when we have space)
28m0141                               	
28m0141 05734 640040000571000440005721	XCT10:  PUSHJ[XCTAC] NORM $; FIX EF ADR
28m0141 05735 540500224571000041622000	        MAPF[2] D[MA] MASK[4] DEST[IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
28m0141 05736 510140034171022020005702	XCTBLG: D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LO BITS OF
28m0141                               	 OPCODE, J IF EXCH
28m0141 05737 510140014735000010000000	        D[CONST 1] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLT] C550 $; J IF BLT
28m0141 05740 640140034171000040005703	        D[IR] MASK[4] DEST[Q] JUMP[XCT18] NORM $; GET XCT AC FLD, PROCEDE
28m0141                               	
28m0141                               	;XCTR of byte instruction.  AC field bits:
28m0141                               	;       4 - byte pointer in previous address space
28m0141                               	;       2 - byte pointer address calculation in previous address space
28m0141                               	;       1 - byte in previous address space
28m0141 05741 530040034571104012005715	XCTBYT: D[IR] ROT[42] MASK[1] SPEC[PC+1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF
28m0141                               	 B.P. FETCH IS NOT EXEC
28m0141 05742 510140034571022010020000	XBY1:   D[IR] ROT[11] MASK[1] COND[OBUS=0] JUMP[XBY3] C550 MAPF[2] $;J IF BP WILL BE INCR
28m0141                               	
28m0141 05743 640706000550400440020000	        FIXM1 $
28m0141 05744 640710004171000440000000	        D[MEM] DEST[AR Q] NORM $; GET BP
28m0141 05745 640705614571022000000000	XBY4:   SET-TEMP-EXEC $
28m0141 05746 664160000571000220000000	        D[AR] MASK[18.] DEST[MA] COND[-MEM-IDX-IND] JUMP[XBY13] NORM $; J IF BP HAS NO
28m0141                               	 IDX OR INDR
28m0141 05747 510141000571044040020000	XBY15:  D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[XBY14] C550 MAPF[2] $; J IF
28m0141                               	 NO IX FLD
28m0141 05750 510140034571106010000000	        D[IR] ROT[43] MASK[1] COND[OBUS=0] JUMP[XBY16] C550 $;J IF BP ADR CALC NOT USER
28m0141 05751 640060000571044040005721	        D[AR] ROT[18.] MASK[4] DEST[MA] PUSHJ[XCTAC] NORM $;FETCH IDX REG
28m0141 05752 640706000550400440020000	        FIXM1 $
28m0141 05753 640700010275044040000000	        D[MASK 4] ROT[18.] ALU[-D&Q] DEST[Q] NORM $;CLEAR INDEX FIELD OF Q
28m0141 05754 640170004035000220000000	        D[MEM] MASK[18.] ALU[D+Q] DEST[Q AR MA] JUMP[XBY14] NORM $
28m0141                               	                ;Above instruction makes the indexed byte pointer, with
28m0141                               	                ;garbage in bits 14-17 that doesn't hurt anything.
28m0141                               	                ;There will be no carry into PPSS.
28m0141                               	
28m0141 05755 640700010235044220000000	XBY16:  D[MASK 18.] ROT[18.] ALU[D&Q] DEST[Q] NORM $    ;HLLZS BP IN Q
28m0141 05756 640710000420000220000000	        D[AR] MASK[18.] ACSEL[REG] ALU[D+AC] DEST[AR] SHORT $
28m0141 05757 640730000175000220000000	        D[AR] MASK[18.] ALU[DORQ] DEST[Q AR MA] SHORT $
28m0141 05760 510140000571034010020000	XBY14:  D[AR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XBY13] C550 MAPF[2] $; J IF NO INDR
28m0141 05761 530040034571106010005715	        D[IR] ROT[43] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF BP ADR CALC IS
28m0141                               	 USER
28m0141 05762 640706000550400440020000	        FIXM1 $
28m0141 05763 640705614571022000000000	        SET-TEMP-EXEC $
28m0141 05764 640710000571030140000000	        D[AR] ROT[14] MASK[14] DEST[AR] SHORT $
28m0141 05765 640700000171060440000000	        D[AR] ROT[30] DEST[Q] SHORT $
28m0141 05766 644170004175000270005747	        D[MEM] MASK[27] ALU[DORQ] DEST[Q AR MA] COND[MEM-IDX-IND] JUMP[XBY15] NORM $
28m0141 05767 030040034571000010025715	XBY13:  D[IR] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] MAPF[2] $; MAKE MA OK
28m0141 05770 510140034571020010022625	        D[IR] ROT[10] MASK[1] COND[OBUS=0] JUMP[LDB5] C550 MAPF[2] $; DISTINGUISH LOADS
28m0141                               	 FROM DEPOSITS, J IF LOAD
28m0141 05771 640140000571000440002637	        JUMP[DPB5] NORM $
28m0141                               	
28m0141 05772 640706200550400440030000	XBY3:   FIXM2 $
28m0141 05773 656150004171000440005745	        D[MEM] DEST[AR Q] COND[HALF] JUMP[XBY4] NORM $;GET BP, J IF NO INCR
28m0141 05774 657051400571030060004045	        D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $; GET S
28m0141                               	 FLD, HANDLE OVERFLOW
28m0141 05775 662154200077074440005777	        D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $; SUB S
28m0141                               	 FROM P
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

28m0141 05776 640700005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] NORM $
28m0141 05777 640040000571000440006146	        PUSHJ[SETHLF] NORM $; SET HALF
28m0141 06000 640140000571000440005745	        JUMP[XBY4] NORM $; (IN CASE OF MAP FAULTS)
28m0141                               	
28m0141                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

29m0141                               	;XCTBLT XBLTL XPUSH1 XPDLO2 XPOP1 XPOP2 XPOP3
29m0141                               	
29m0141                               	;;;;;.USE[OTHER]  DWP 9-19-80
29m0141                               	
29m0141 06001 640710025171000442000000	XCTBLT: D[MA] SPEC[PC+1] DEST[O_AC AR] NORM $; END ADR IN AC, AC IN AR
29m0141 06002 640720000571044220000000	XBLTL:  D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $; GET WORD
29m0141 06003 530040034571104010005715	        D[IR] ROT[42] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; FIX IF USER ADDRS
29m0141 06004 640706000550400440070000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BLT-RDA] CYLEN[FIXM] $
29m0141 06005 640700004171000440000000	        D[MEM] DEST[Q] SHORT $; GET DATA WORD
29m0141 06006 640720000571000220000000	        D[AR] MASK[18.] DEST[MA] SHORT $; GET DEST ADR
29m0141 06007 530045634571000010005715	        D[IR] MASK[1] DEST[MAP-EXEC-SR] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $;FIX MA ADDRS
29m0141 06010 640704200555000440000000	        ALU[Q] DEST[MEMSTO] SHORT $
29m0141 06011 471140000523000220144354	        D[AR] MASK[18.] ALU[D-AC] MAPF[BLT-WRTB] COND[-OBUS<0] JUMP[BLTA12] C600 $
29m0141 06012 662145614171001000006014	        D[CONST 1,,1] DEST[Q MAP-EXEC-SR] COND[-MA-AC] JUMP[. + 2] NORM $
29m0141 06013 640700005570400440000000	        D[MEM] ACSEL[MA] DEST[AC] SHORT $
29m0141 06014 640150000435000440006002	        D[AR] ALU[D+Q] DEST[AR] JUMP[XBLTL] NORM $; TEST FOR INTERPT HERE ? *****
29m0141                               	
29m0141                               	;Special case for PUSH.  Check for AC reference from stack pointer
29m0141 06015 510140034571000010005702	XPUSH1: D[IR] MASK[1] COND[OBUS=0] JUMP[XCT13] C550 $
29m0141                               	                ;If not mapping stack references, it's simple
29m0141 06016 530040034571104012005715	        D[IR] ROT[36. - 2] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] SPEC[PC+1] C550$
29m0141                               	                ;Make sure we're referring to the right place here.
29m0141                               	                ;Also, we're now executing the instruction (PC+1)
29m0141 06017 640706000550400440020000	        FIXM1 $ ;Check page faults for effective address part.
29m0141 06020 640710004571000440000000	        D[MEM] DEST[AR] NORM $
29m0141                               	                ;Copy away the thing that we want to push
29m0141 06021 515160015421001000000000	        D[CONST 1,,1] ALU[D+AC] DEST[AC MA] COND[CRY0] JUMP[XPDLO2] C550 $
29m0141                               	                ;Advance frame pointer and check for overflow
29m0141 06022 640040000571000440005715	        PUSHJ[XFIXMA] NORM $
29m0141                               	                ;Decide whether to map destination.
29m0141 06023 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
29m0141                               	                ;Finish instruction. We're done
29m0141 06024 640040000571000440005715	XPDLO2: PUSHJ[XFIXMA] NORM $
29m0141                               	                ;Fixup AC references
29m0141 06025 640140000571000440000000	        JUMP[PDLO2] NORM $
29m0141                               	                ;Done.  Take stack overflow trap
29m0141                               	
29m0141                               	;Special case for POP.  Check for AC reference from stack pointer
29m0141 06026 640700034171022442000000	XPOP1:  D[IR] ROT[11] DEST[Q] NORM SPEC[PC+1] $
29m0141                               	                ;Save bit meaning 'source from user' in format that can
29m0141                               	                ;be fed easily to EXEC-SR
29m0141                               	                ;Now we're executing the PUSH (implied by PC+1)
29m0141 06027 640700224571000440000000	        D[MA] DEST[IR-ADR] NORM $
29m0141                               	                ;Restore normal effective address 
29m0141 06030 640720015063001000000000	        ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC] NORM $
29m0141                               	                ;Update AC and MA for stack reference
29m0141 06031 530040014635022040005715	        D[CONST 4] ROT[11] ALU[D&Q] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $
29m0141                               	                ;Fixup stack addressing if user AC
29m0141 06032 640706000550400440160000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
29m0141                               	                ;Check for page faults
29m0141 06033 640710004571000440000000	        D[MEM] DEST[AR] NORM $
29m0141                               	                ;Find somewhere safer for thing to push
29m0141                               	        D[CONST 1] ROT[11] ALU[D&Q] DEST[MAP-EXEC-SR]
29m0141 06034 510145614635022010000000	                        COND[OBUS=0] JUMP[XPOP3] C550 $
29m0141                               	                ;Set appropriate mode to do store in
29m0141 06035 640720034571000220000000	        D[IR] MASK[22] DEST[MA] NORM $
29m0141                               	                ;Extract address and fetch it from the appropriate page.
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

29m0141 06036 642040000571000440005721	        COND[MA-AC] PUSHJ[XCTAC] NORM $
29m0141                               	                ;Fixup AC addressing if needed.  (We can't combine this and
29m0141                               	                ;previous instruction because MA is strobed at end of cycle.
29m0141                               	                ;We can't call XFIXMA because it uses SET-TEMP-USER which
29m0141                               	                ;would affect the next instruction fetch. Sigh...)
29m0141 06037 515140014421001000000000	XPOP2:  D[CONST 1,,1] ALU[D+AC] COND[CRY0] JUMP[PDLO5] C550 $
29m0141                               	                ;Try for overflow again.  Take it if you need it.
29m0141 06040 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
29m0141                               	                ;Write out thing we POP'ped
29m0141 06041 640160034571000220006037	XPOP3:  D[IR] MASK[22] DEST[MA] NORM JUMP[XPOP2] $
29m0141                               	                ;Extract address and don't do anything special about it
29m0141                               	
29m0141                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

30m0141                               	;APRDSP PIDSP AREA53 APRCO APRCO2 APRCO3 APRIEN APRC1 APRC2 APRCHK APRCK1 APDINT APRCI
30m0141                               	 APRCII APRDI APIOT
30m0141                               	;------------------------------------------------------------------------------
30m0141                               	;
30m0141                               	;       APR and PI instructions
30m0141                               	;
30m0141                               	;------------------------------------------------------------------------------
30m0141                               	        .ORG[XLIST
30m0141                               	 LIST ] ;APR & PI IOT DISP TABLE
30m0141                               	APRDSP: ILGIOT 30m0141 05300 000140000571000440002026	 JUMP [MAIN] ]$; BLKI APR
30m0141 05301 000700000571000440000000	        NOP $
30m0141 05302 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $; DATAI -- RD SW
30m0141 05303 640142400571000443400000	        DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] JUMP[APRDI] NORM $
30m0141                               	        ILGIOT 30m0141 05304 000140000571000440002026	 JUMP [MAIN] ]$ ;BLKO APR
30m0141 05305 000700000571000440000000	        NOP $
30m0141 05306 000140000571000440002026	        JUMP[MAIN] $; DATAO
30m0141 05307 000700000571000440000000	        NOP $
30m0141 05310 640700034171000130000000	        D[IR] MASK[13] DEST[Q] NORM $; GET CONO BITS
30m0141 05311 640140014275012330000000	        D[CONST 33] ROT[5] ALU[-D&Q] DEST[Q] JUMP[APRCO] NORM $
30m0141 05312 640040000571000440000000	        PUSHJ[APRCI] NORM $; CONI -- GET BITS IN AR & Q
30m0141 05313 662104200571000220002032	        D[AR] MASK[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
30m0141 05314 640040000571000440000000	        PUSHJ[APRCI] NORM $; CONSZ -- GET BITS IN AR & Q
30m0141 05315 640140034171000220004500	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
30m0141 05316 640040000571000440000000	        PUSHJ[APRCI] NORM $; CONSO -- GET BITS IN AR & Q
30m0141 05317 640140034171000220004502	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
30m0141                               	PIDSP:  .REPEAT 3[ 30m0141                               	ILGIOT 30m0141 05320 000140000571000440002026	 JUMP [MAIN] ]$
30m0141 05321 000700000571000440000000	        NOP $
30m0141                               	]ILGIOT 30m0141 05322 000140000571000440002026	 JUMP [MAIN] ]$
30m0141 05323 000700000571000440000000	        NOP $
30m0141                               	]ILGIOT 30m0141 05324 000140000571000440002026	 JUMP [MAIN] ]$
30m0141 05325 000700000571000440000000	        NOP $
30m0141                               	]       ;DATAO PI -- Set lights
30m0141 05326 640041614571000000004454	        D[CONST 0] DEST[DEV-ADR] PUSHJ[SETLTS] NORM $   ;Just like examine...?
30m0141 05327 640140000571000440002026	        JUMP[MAIN] SHORT $
30m0141 05330 640140000571000440004616	        JUMP[PICONO] NORM $; PI CONO
30m0141 05331 000700000571000440000000	        NOP $
30m0141 05332 640040000571000440004647	        PUSHJ[PICONISUB] NORM $; CONI -- GET BITS IN AR & Q
30m0141 05333 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
30m0141 05334 640040000571000440004647	        PUSHJ[PICONISUB] NORM $; CONSZ -- GET BITS IN AR & Q
30m0141 05335 640140034171000220004500	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
30m0141 05336 640040000571000440004647	        PUSHJ[PICONISUB] NORM $; CONSO -- GET BITS IN AR & Q
30m0141 05337 640140034171000220004502	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
30m0141                               	
30m0141                               	
30m0141                               	   .USE[30m0141                               	XLIST
30m0142                               	 LIST ]
30m0142 04657 640710014675006010000000	APRCO:  D[CONST 1] ROT[3] ALU[-D&Q] DEST[AR] SHORT $
30m0142 04660 640700034371106210000000	        D[IR] ROT[43] MASK[21] ALU[NOTD] DEST[Q] SHORT $
30m0142                               	                ; GET CLR BITS
30m0142 04661 640700014275000070000000	        D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

30m0142                               	                ; Remove PI assignment
30m0142 04662 640702450235000442400000	        D[10 + APRSTS] SPEC[A-MEM-APR] ALU[D&Q] DEST[Q CLR-DEV-FROM-INTR] SHORT $
30m0142                               	                ; CLEAR INDICATED BITS
30m0142 04663 640710400575000442600000	        D[AR] ALU[DORQ] SPEC[A-MEM-APR&DEST-A-MEM] DEST[APRSTS AR] NORM $
30m0142                               	                ; SET INDICATED BITS & CHAN
30m0142 04664 510140034571102010000000	        D[IR] ROT[41] MASK[1] COND[OBUS=0] JUMP[APRCO2] C550 $
30m0142                               	                ; J IF NO CLR OVERFLOW BIT
30m0142 04665 640705420571000430000000	        D[PC] MASK[43] DEST[CRYOV] SHORT $; CLR OV
30m0142                               	                ; Remove overflow bit from current PC flags
30m0142 04666 510140034571074010000000	APRCO2: D[IR] ROT[36] MASK[1] COND[OBUS=0] JUMP[APRCO3] C550 $
30m0142                               	                ; J IF NO CLR FLT OV
30m0142 04667 640700010171102430000000	        D[MASK 43] ROT[41] DEST[Q] SHORT $
30m0142                               	                ; Remove bit from current PC flags
30m0142 04670 640705420635000440000000	        D[PC] ALU[D&Q] DEST[CRYOV] SHORT $
30m0142                               	                ; CLR FLT OV
30m0142 04671 530040034571066010004520	APRCO3: D[IR] ROT[33] MASK[1] COND[-OBUS=0] PUSHJ[CLKCLR] C550 $
30m0142                               	                ; CLR CLOCK FLAG IF INDICATED
30m0142                               	;       ---
30m0142                               	
30m0142                               	; TEMP **** APRCI:
30m0142 04672 640042400571000440000000	APRIEN: PUSHJ[APRCII] DEST[CLR-DEV-FROM-INTR] NORM $
30m0142                               	                ; GET APR CONI BITS
30m0142 04673 640701614571000013400000	        D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
30m0142                               	                ; Select and read MAP and ECC enablings
30m0142 04674 140700030171000030040000	        D[IOD] MAPF[4] MASK[3] DEST[Q] CYLEN[IOB-IN] $
30m0142 04675 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
30m0142                               	                ; For some pecular reason, the thing we read from device 1 is
30m0142                               	                ; written in device 0???
30m0142 04676 510140000571000030000000	        D[AR] MASK[3] COND[OBUS=0] JUMP[APRC1] C550 $
30m0142                               	                ; Jump if no PI channel.  We don't want to enable arithmetic
30m0142                               	                ; micro-interrupts in that case.
30m0142 04677 510140000571100010000000	        D[AR] ROT[40] MASK[1] COND[OBUS=0] JUMP[APRC1] C550 $
30m0142                               	                ; J IF NO OV INT ENBL
30m0142                               	                ; *** Don't both enables need to be checked???
30m0142 04700 640142214575000023600000	        D[CONST 2] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] JUMP[APRC2] NORM $; ENABLE OV INT
30m0142                               	                ; Turn on arithmetic interrupts
30m0142 04701 640702214675000023600000	APRC1:  D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
30m0142                               	                ; Turn off arithmetic interrupts
30m0142 04702 440140000171000440100000	APRC2:  MAPF[10] CYLEN[IOB-OUT] D[AR] DEST[Q] JUMP[APRCK1] $
30m0142                               	                ; Finish turning arithmetic interrupts off or on, and we're done
30m0142                               	
30m0142                               	;Check for clock interrupts (and other things)
30m0142 04703 640040000571000440000000	APRCHK: PUSHJ[APRCI] NORM $; GET CONI BITS IN AR & Q
30m0142                               	
30m0142                               	APRCK1:
30m0142                               	.REPEAT 1 - WAITS [
30m0142 04704 510140000571000030002026	        D[AR] MASK[3] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF PI=0
30m0142 04705 530140000571050010000000	        D[AR] ROT[24] MASK[1] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF PDLOV INT
30m0142 04706 640700000235106440000000	        D[AR] ROT[43] ALU[D&Q] DEST[Q] SHORT $; AND MASK WITH FLAG
30m0142 04707 530140014635006110000000	        D[CONST 11] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF OV INT
30m0142 04710 510140014635014100002026	        D[CONST 10] ROT[6] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF NO CLOCK INT
30m0142                               	
30m0142                               	;       \ /
30m0142                               	].REPEAT 1 - WAITS
30m0142                               	.REPEAT WAITS [
30m0142                               	.REPEAT WAITS
30m0142                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

30m0142                               	;       \ /     (Falls thru from APRCK1)
30m0142 04711 640150000171000030004572	APDINT: D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; GET CHAN #, CAUSE INTERRUPT
30m0142                               	
30m0142                               	APRCI:  ;TEMP -- LATER WE FIX OV
30m0142 04712 640040000571000440000000	APRCII: PUSHJ[CLKRDFLG] NORM $
30m0142                               	         ;Get CLOCK FLAG in AR 35, rest of AR = 0
30m0142                               	        .DEFINE APRGBT 30m0142                               	        APRGBT[30m0142 04713 640700020171002010000000	D[PC] ROT[1] MASK[1] DEST[Q] SHORT $
30m0142 04714 640710000575014440000000	        D[AR] ROT[6] ALU[DORQ] DEST[AR] SHORT $
30m0143                               	]       APRGBT[30m0143 04715 640700020171010010000000	D[PC] ROT[4] MASK[1] DEST[Q] SHORT $
30m0143 04716 640710000575102440000000	        D[AR] ROT[41] ALU[DORQ] DEST[AR] SHORT $
30m0144                               	]       APRGBT[30m0144 04717 640700020171016010000000	D[PC] ROT[7] MASK[1] DEST[Q] SHORT $
30m0144 04720 640710000575066440000000	        D[AR] ROT[33] ALU[DORQ] DEST[AR] SHORT $
30m0145 04721 640700000171036440000000	]       D[AR] ROT[17] DEST[Q] SHORT $; SET FLAGS
30m0145                               	.REPEAT 1 - WAITS [
30m0145 04722 640310050175000442400000	        D[10 + APRSTS] SPEC[A-MEM-APR] ALU[DORQ] DEST[Q AR] NORM POPJ $
30m0145                               	].REPEAT 1 - WAITS
30m0145                               	
30m0145                               	.REPEAT WAITS [
30m0145                               	.REPEAT WAITS
30m0145                               	
30m0145 04723 162104230571000440022032	APRDI:  MAPF[2] D[IOD] DEST[MEMSTO] COND[-MA-AC] LBJUMP[MSMAIN] CYLEN[IOB-IN] $
30m0145                               	
30m0145                               	        .PAIR
30m0145                               	. \ 2 + .
30m0146                               	]       UIOTRP[30m0146 04724 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
30m0146                               	]$                      ;Trap if not IOT-USER Mode
30m0146                               	APIOT:  IOTDIS[30m0146 04725 640700034171034050000000	D[IR] ROT[16] MASK[5] DEST[Q] NORM $
30m0146 04726 540540014575014530000000	        D[CONST 53] ROT[6] ALU[DORQ] SDISP CYLEN[C500] $
30m0147                               	]
30m0147                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

31m0147                               	;PDLO1 PDLO2 PDLO5 PDLO3 PDLO4 PDLO6  PDLO SOED STOPS SOVRS SECCS SOEDOV
31m0147                               	
31m0147 04727 640040000571000440000000	PDLO1:  PUSHJ[PDLO] NORM $ ;SET PDLO BIT
31m0147 04730 640714220571000440000000	        D[PC] DEST[AR MEMSTO] NORM $
31m0147 04731 662104634571000222372032	        MAPF[MASTO] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] COND[-MA-AC] LBJUMP[MSMAIN]
31m0147                               	 NORM $
31m0147 04732 640040000571000440000000	PDLO2:  PUSHJ[PDLO] NORM $; SET FLAG
31m0147 04733 662104200571000440002032	PDLO5:  D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[MSMAIN] NORM $
31m0147 04734 640706000550400440160000	PDLO3:  ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
31m0147 04735 640050004571000440000000	        D[MEM] DEST[AR] PUSHJ[PDLO] NORM $
31m0147 04736 640160034571000220004733	        D[IR] MASK[18.] DEST[MA] JUMP[PDLO5] NORM $
31m0147 04737 640706000550400440160000	PDLO4:  ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
31m0147 04740 640040000571000440000000	        PUSHJ[PDLO] NORM $
31m0147 04741 640144604571000220002026	        D[MEM] MASK[18.] DEST[PC] JUMP[MAIN] NORM $
31m0147                               	;PDLOV from ADJSP
31m0147 04742 640040000571000440000000	PDLO6:  PUSHJ[PDLO] NORM $
31m0147 04743 640140000571000440002026	        JUMP[MAIN] NORM $ 
31m0147                               	
31m0147                               	
31m0147                               	
31m0147 04744 640700020171000440000000	PDLO:   D[PC] DEST[Q] SHORT $
31m0147                               	          ;Set bit 9 of PC to indicate that a PDL OV has happened...
31m0147 04745 640305414575064010000000	        D[CONST 1] ROT[35. - 9.] ALU[DORQ] DEST[CRYOV] NORM POPJ $
31m0147                               	          ;...MAIN will notice this bit and go to PDLTRP below.
31m0147                               	
31m0147                               	PDLTRP:   ;Here from MAIN when PC bit 9 is on.
31m0147 04746 640710050171000442400000	        D[10 + APRSTS] A-MEM-APR DEST[Q AR] NORM $
31m0147                               	         ;APR CONI word to Q (leave also in AR to give PIGEN the APR PI chn)
31m0147 04747 640700414575040012600000	        D[CONST 1] ROT[20] ALU[DORQ] A-MEM-APR&DEST-A-MEM DEST[APRSTS] NORM $
31m0147                               	                ;set PDLOV bit
31m0147 04750 640700020171000440000000	        D[PC] DEST[Q] SHORT $
31m0147                               	           ;Now clear the pseudo-trap flag in bit 9 of PC.
31m0147 04751 640705414675064010000000	        D[CONST 1] ROT[35. - 9.] ALU[-D&Q] DEST[CRYOV] NORM $
31m0147 04752 530150000571000030004572	        D[AR] MASK[3] DEST[AR] C550 -OBUS=0 JUMP[PIGEN] $
31m0147                               	           ;...and request interrupt (AR already has APR PI chn.)
31m0147 04753 000140000571000440002026	        JUMP[MAIN] $
31m0147                               	
31m0147                               	  .USE[31m0147                               	XLIST
31m0148                               	 LIST ]
31m0148                               	.REPEAT F3SW [
31m0148                               	 ;; END OF .REPEAT F3SW
31m0148                               	
31m0148                               	;(ECC-UNC moved to bottom of page)
31m0148                               	
31m0148                               	 .REPEAT F2SW [ 31m0148                               	
31m0148                               	
31m0148 04754 640141614571000010004376	STOPS:  D[CONST 1] DEST[DEV-ADR] JUMP[DOHALT] NORM $
31m0148                               	
31m0148 04755 531142420571000443404760	SOVRS:  D[PC] COND[-OBUS<0] SPEC[IOB-IN] JUMP[. + 3] DEST[CLR-DEV-FROM-INTR] C550 $
31m0148                               	                ; J IF NO OV
31m0148 04756 140702430171000440040000	        D[IOD] MAPF[4] DEST[Q CLR-DEV-FROM-INTR] CYLEN[IOB-IN] $
31m0148 04757 530140014635000020000000	        D[CONST 2] ALU[D&Q] COND[-OBUS=0] JUMP[SOEDOV] C550 $ ;J IF OV INT EN
31m0148 04760 000140000571000440004760	        JUMP[.] $ ; HOW COULD WE GET HERE?
31m0148                               	
31m0148                               	 .USE[SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

31m0148                               	XLIST
31m0149                               	 LIST ]
31m0149 06042 640701614571000013400000	SECCS:  D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
31m0149 06043 140704430171000440020000	        D[IOD] MAPF[2] DEST[Q HOLD] CYLEN[IOB-IN] $
31m0149 06044 640700054171000042400000	        D[10 + ECCSVP] SPEC[A-MEM-APR] MASK[4] DEST[Q] NORM $
31m0149                               	.REPEAT 1 - XUCODE [
31m0149                               	.REPEAT 1 - XUCODE
31m0149                               	.REPEAT XUCODE [
31m0149                               	        D[MASK 9.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
31m0149 06045 640712410575010113400000	          NORM SPEC[IOB-IN] $  ;;17760 IS NEW LOC. OF ERROR LOG.
31m0149                               	].REPEAT XUCODE
31m0149 06046 140700030171000440040000	        MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
31m0149                               	 ;;;;;  D[CONST 1] ROT[7] ALU[D&Q] COND[-OBUS=0] JUMP[.] C550 $
31m0149                               	
31m0149 06047 140707400615000440000000	        ALU[0] DEST[MUCODE-HI] CYLEN[MUSTO] $
31m0149 06050 640700004171000440000000	        D[MEM] DEST[Q] NORM $
31m0149 06051 140707610635052420000000	        D[MASK 42] ROT[25] ALU[D&Q] DEST[MUCODE-LO] CYLEN[MUSTO] $
31m0149 06052 640700600433000442600000	        D[AR] ALU[D+1] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
31m0149 06053 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
31m0149 06054 640702400571000443400000	        DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
31m0149 06055 140700230571000440040000	        D[IOD] DEST[IR-ADR]  MAPF[4] CYLEN[IOB-IN] $
31m0149 06056 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
31m0149                               	;NOTE:  This conflicts with the use of the lights by diagnostics.
31m0149 06057 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;PUT JUNK IN LIGHTS
31m0149 06060 440700000555000443620000	        MAPF[2] ALU[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ;LTS_OBUS
31m0149 06061 440703600571000440100000	        MAPF[10] DEST[CLR-MI-ERR] CYLEN[IOB-OUT] $; TURN OFF MAP
31m0149 06062 640700200555000443000000	        ALU[Q] DEST[A-MEM-ECC-DATA] DEST-A-MEM NORM $
31m0149                               	          ;Save info for reading via opcode 750.  
31m0149 06063 640722604571000440000000	        D[MEM] DEST[MA HI-ABS-MA] NORM $; GET DATA
31m0149 06064 540700000571000440000000	        CYLEN[C500] $;WAIT
31m0149 06065 640704204571000440000000	        D[MEM] DEST[MEMSTO] NORM $; RE-STORE IT
31m0149 06066 640700000571000440000000	        NORM $; WAIT -- FOR LUCK
31m0149 06067 640702234571000443600000	        D[IR] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE STATE OF MAP, ETC.
31m0149 06070 440702600615000440100000	         MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $;
31m0149 06071 640143600571000440002026	        DEST[CLR-MI-ERR] JUMP[MAIN] NORM $
31m0149                               	
31m0148                               	  ];; END OF .REPEAT F2SW
31m0148                               	
31m0148 06072 640701600615000440000000	SOEDOV: ALU[0] DEST[DEV-ADR] NORM $
31m0148 06073 640702214675000023600000	        D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
31m0148 06074 440040000571000440104712	        MAPF[10] CYLEN[IOB-OUT] PUSHJ[APRCII] $; GET CONI BITS
31m0148 06075 640150000171000030004572	        D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; DO INTR.
31m0148                               	
31m0148                               	;$*$*$*$ No space left in NORMAL by now...
31m0148                               	        .USE[31m0148                               	XLIST
31m0149                               	 LIST ]
31m0149                               	ECC-UNC:  ;SEE IF WE SHOULD GIVE INTERRUPT FOR HARD ECC ERR
31m0149                               	          ;RETURN TO CALLER IF NOT, BUT STILL SET PAR ERR FLAG.
31m0149 06206 640700060171000440000000	        D[14] DEST[Q] NORM $
31m0149                               	         ;FIRST, SET PAR ERR FLAG IN PI CONI BITS.
31m0149                               	        D[CONST 1] ROT[35. - 19.] ALU[DORQ] 
31m0149 06207 640711014575040013000000	                DEST[AR 4] DEST-A-MEM NORM $
31m0149 06210 531300000571036440000000	        D[AR] ROT[35. - 20.] C550 COND[-OBUS<0] POPJ $
31m0149                               	         ;IF PAR ERR INTRPT ENABLE OFF, DO NO MORE.
31m0149 06211 510310050171000030000000	        D[10 + APRSTS] MASK[3] DEST[Q AR] C550 COND[OBUS=0] POPJ $
31m0149                               	         ;IF APR PI CHAN IS 0, DON'T GIVE INTRPT.
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

31m0149 06212 640343600571000440004572	        DEST[CLR-MI-ERR] NORM JPOP[PIGEN] $ 
31m0149                               	         ;CLEAR ERR FF AND GIVE INTERRUPT ON APR CHANNEL.
31m0149                               	
31m0149                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

32m0149                               	;; 60 HZ CLOCK READING AND INTERRUPT ROUTINES
32m0149                               	
32m0149                               	 .REPEAT OTP [
32m0149                               	 ;OTP
32m0149                               	
32m0149                               	
32m0149                               	 .REPEAT NTP [ 32m0149                               	;We branch here from CTYINT if intrpt. is really 60HZ CLK.
32m0149                               	
32m0149 06213 640702200615000443600000	CLKINT: START-OUT ALU[0] DEST[IOD] NORM $
32m0149                               	          ;Clear hardware int. enb. for 60HZ CLK.
32m0149 06214 440700000571000440060000	        MAPF[6] C600 $
32m0149                               	  ];NTP
32m0149                               	
32m0149                               	.REPEAT TYMNET [
32m0149                               	TYMNET
32m0149 06215 440142400571000440004703	        DEST[CLR-DEV-FROM-INTR] JUMP[APRCHK] C600 $     
32m0149                               	          ;Cause PI on APR channel if enabled, and exit.
32m0149                               	
32m0149                               	CLKRDFLG:  ;Put hardware 60HZ CLK FLAG into AR35.
32m0149 06216 640701614571000063400000	        START-IN D[CONST 6] DEST[DEV-ADR] NORM $
32m0149                               	          ;Select device 6.
32m0149 06217 140310030571106010050000	        MAPF[5] D[IOD] ROT[34. + 1] MASK[1] DEST[AR] CYLEN[IOB-IN] POPJ $
32m0149                               	          ;Get bit and return.
32m0149                               	
32m0149                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

33m0149                               	.REPEAT NTP [ 33m0149                               	;Ucode for KENNEDY or PERTEC formatter and DMA tape controller.
33m0149                               	
33m0149                               	  .REPEAT 1 - TAPE [
33m0149                               	
33m0149                               	  .REPEAT TAPE [ 33m0149                               	 ;New (DMA tape controller, Pertec compatible fmtr )
33m0149                               	.INSERT TAPE.SLO

SLOE   Oct  30, 2543 00:00:00  file DSK:TAPE.SLO  --  of -- f2sym

01m0001                               	;-------------------------------------------------------------------------------
01m0001                               	;
01m0001                               	;       Ucode for KENNEDY or PERTEC formatter and DMA tape controller.
01m0001                               	;
01m0001                               	;-------------------------------------------------------------------------------
01m0001                               	.REPEAT XUCODE [
01m0001                               	        .USE[XLIST
01m0001                               	 LIST ];If 8K u-mem present, put tape code there.
01m0001                               	   ]
01m0001                               	;TAPE READING AND WRITING CODE
01m0001                               	; A-MEM USEAGE:
01m0001                               	;               0       DISPATCH ADDR.
01m0001       0	TPMODE =        0       ;DATA PACKING MODE 
01m0001                               	;                        BIT 0: 0=PDP-10 CORE-DUMP, 1=INDUSTRY (32-bit mode)
01m0001                               	;                        BIT 1: NRZI Kluge Mode (to read old CCRMA & SCI tapes)
01m0001                               	;               1       Used by FMNBWT and TRCHECK for NRZI Kluge Mode info.
01m0001                               	;               2       Used by KNYGOA and TRCHECK for NRZI Kluge Mode info.
01m0001                               	;               3       DON'T USE... Storing into it clobbers IR left !
01m0001                               	;               4       Next mem adr of xfer (STRTDC) -- 0 during non-data ops
01m0001                               	;               5       Remaining word count in current WCMA (STRTDC)
01m0001                               	;               6       Not currently used-- will be  Data Channel PC
01m0001                               	;               7       RETRY COUNT (WRITE); 400000,,STARTING-MA (READ)
01m0001                               	
01m0001                               	;MAPF values
01m0001                               	
01m0001       4	TP.RS = 4       ;read status (from formatter)
01m0001       2	TP.RC = 2       ;read control (controller status and un-fifo'd read data)
01m0001                               	
01m0001       2	TP.WF = 2       ;write formatter (send ctrl bits to formatter)
01m0001       4	TP.WM = 4       ;write mode control reg.
01m0001       1	TP.WC = 1       ;write control reg.
01m0001       5	TP.MR = 5       ;give Master Reset
01m0001       3	TP.WMA = 3      ;write (load) the CNTMA reg. (count and MA)
01m0001                               	
01m0001                               	KNYCLR:  ;RESET the formatter and drive.
01m0001                               	
01m0001 10001 000702200615000443600000	KNYRS1: START-OUT ALU[0]  DEST[IOD] $
01m0001                               	                ;Turn off "FORMATTER ENABLE"
01m0001 10002 000300000571000440020000	        MAPF[TP.WF] LONG POPJ $
01m0001                               	
01m0001                               	   ;725 - OBSOLETE VERSION OF READ
01m0001                               	
01m0001                               	  .PAIR
01m0001                               	. \ 2 + .
01m0002                               	]  UIOTRP[01m0002 10004 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0002                               	]$
01m0002                               	
01m0002 10005 640040214571014140000000	TAPERD: D[CONST 14] ROT[6] DEST[IR-ADR] NORM PUSHJ[KNYRGO] $
01m0002                               	                ;Fake a word count of 1400
01m0002 10006 640041024571000443000000	        D[MA] DEST[4] DEST-A-MEM NORM PUSHJ[TRP2] $
01m0002 10007 640140001555000440000000	        ALU[Q] DEST[AC] ACSEL[AC] NORM JUMP[GOMAIN] $
01m0002                               	                ;Move status into AC.
01m0002                               	
01m0002                               	; KNYRGO -- Called to start tape motion on reads.
01m0002 10010 640040000571000440000000	KNYRGO: NORM PUSHJ[DCINIT] $
01m0002                               	                ;Init the data channel.
SLOE   Oct  30, 2543 00:00:00  file DSK:TAPE.SLO  --  of -- f2sym

01m0002 10011 640710040571002010000000	        D[10 + TPMODE]  ROT[1] MASK[1] DEST[AR] NORM $
01m0002                               	                ;Get the 32-bit mode flag.
01m0002 10012 640702200571014443600000	        START-OUT D[AR] ROT[35. - 29.] DEST[IOD] NORM $
01m0002                               	                ;Position it for the hardware.
01m0002 10013 440140014171000000040000	        MAPF[TP.WM] D[CONST 0] DEST[Q]   C-OUT JUMP[KNYGOA] $
01m0002                               	                ;Send command to formatter.
01m0002                               	
01m0002                               	  ;Send a tape-motion command to the formatter.  Call with command bits
01m0002                               	  ;  (except for FMTR ENABLE and GO) in Q.  Clobbers Q, HOLD, AR
01m0002 10014 000040014175022013400000	KNYGOA: START-IN D[CONST 1] ROT[35. - 26.] ALU[DORQ] DEST[Q] PUSHJ[FMNBWT] $
01m0002                               	          ;Add the FMTR ENBL bit to the command word.
01m0002                               	          ;Wait for FORMATTER NOT BUSY.
01m0002 10015 640700404571000443000000	        D[MEM] DEST[2] DEST-A-MEM NORM $
01m0002                               	          ;Save status bits returned by FMNBWT for use by TRCHECK
01m0002 10016 440702214735004013600000	        START-OUT D[CONST 1] ROT[35. - 33.] ALU[D#Q] DEST[IOD] C-OUT $
01m0002                               	          ;Set the GO bit to fmtr (except: on RWD, CLEAR the bit !)
01m0002 10017 000702214675004013620000	        MAPF[TP.WF] START-OUT D[CONST 1] ROT[35. - 33.] ALU[-D&Q] DEST[IOD] $
01m0002                               	          ;Send command word again, without GO bit.
01m0002 10020 000300000571000440020000	        MAPF[TP.WF] LONG POPJ $
01m0002                               	
01m0002                               	
01m0002                               	FMNBWT:   ;Wait for formatter to be not busy.
01m0002                               	          ;Return tape status in MEM;  timeout in 164 msec.
01m0002                               	          ;Duration of loop should be 10 usec. (for TRCHECK).
01m0002 10021 640710014571034013400000	        START-IN D[CONST 1] ROT[14.] DEST[AR] NORM $
01m0002 10022 240704430571000440040000	FMNBW1: MAPF[TP.RS] D[IOD] DEST[HOLD] C800 $ ;GET STATUS BITS.
01m0002 10023 511350000531000440000000	        D[AR] ALU[D-1] DEST[AR] C550 OBUS<0 JPOP[FMTHNG] $
01m0002 10024 440740014571000160000000	        D[CONST 14.] LLOAD C600 $
01m0002 10025 540240000571000440000025	        C500 LOOP[.] $
01m0002                               	          ;We execute this instr. 15. times, for a 7.5 usec delay.
01m0002 10026 531140004571016443400022	        START-IN D[MEM] ROT[7] C550 -OBUS<0 JUMP[FMNBW1] $
01m0002                               	          ;check for 'BUSY'
01m0002 10027 640300200571000443000000	        D[AR] DEST[1] DEST-A-MEM NORM POPJ $
01m0002                               	          ;Save ending timeout count (for TRCHECK)
01m0002 10030 640040000571000440000001	FMTHNG: NORM PUSHJ[KNYRS1] $
01m0002                               	                ;Blast the formatter.
01m0002 10031 000340015571074420000000	        D[CONST 42] ROT[30.] DEST[AC] JPOP[GOMAIN] $
01m0002                               	                ;Return error code for 'hung fmtr' and abort.
01m0002                               	
01m0002                               	NCNTWT:   ;Wait for TP CNT GO to be off.
01m0002                               	          ;Return tape status in MEM;  timeout in 164 msec.
01m0002                               	          ;Duration of loop should be 10 usec. (for TRCHECK).
01m0002 10032 240704430571000440020000	NCNTW1: MAPF[TP.RC] D[IOD] DEST[HOLD] C800 $ ;GET STATUS BITS.
01m0002 10033 511310000531000440000000	        D[AR] ALU[D-1] DEST[AR] C550 OBUS<0 POPJ $
01m0002                               	          ;Exit if we time out-- probably just a short record.
01m0002 10034 440740014571000160000000	        D[CONST 14.] LLOAD C600 $
01m0002 10035 540240000571000440000035	        C500 LOOP[.] $
01m0002                               	          ;We execute this instr. 15. times, for a 7.5 usec delay.
01m0002 10036 511140004571046443400032	        START-IN D[MEM] ROT[19.] C550 OBUS<0 JUMP[NCNTW1] $
01m0002                               	          ;check for not TP CNT GO
01m0002 10037 640300200571000443000000	        D[AR] DEST[1] DEST-A-MEM NORM POPJ $
01m0002                               	          ;Save ending timeout count (for TRCHECK)
01m0002                               	
01m0002                               	
01m0002                               	;INITIALIZE DATA CHANNEL
01m0002                               	
01m0002 10040 640740014571000103600000	DCINIT: START-OUT D[CONST 8.] LLOAD NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:TAPE.SLO  --  of -- f2sym

01m0002                               	                ;Give TP MR
01m0002 10041 440702200615000443650000	        MAPF[TP.MR] START-OUT ALU[0] DEST[IOD] C600 $
01m0002                               	                ;Load 0 into cntma (the COUNT and MA registers)
01m0002 10042 440702210571054143630000	        MAPF[TP.WMA] START-OUT D[MASK 12.] ROT[35. - 13.] DEST[IOD] C600 $
01m0002                               	                ;Load cntma again-- since COUNT is currently  0, this will 
01m0002                               	                ; force BUF CNT to be 0.  But, we put -1 into COUNT this
01m0002                               	                ; time, which, with BUF CNT = 0, will make BUF CNT load
01m0002                               	                ; properly when STARTDC loads cntma.
01m0002 10043 440702214571000023630000	        MAPF[TP.WMA] START-OUT D[CONST 2] DEST[IOD] C600 $
01m0002                               	                ;Set MBUSY
01m0002 10044 500240000571000440010044	        MAPF[TP.WC] C550 LOOP[.] $
01m0002                               	                ;Wait for a few usec.  This clears mem rq.
01m0002 10045 640702200615000443600000	        START-OUT ALU[0] DEST[IOD] NORM $
01m0002                               	                ;Clr MBUSY
01m0002 10046 440300000571000440010000	        MAPF[TP.WC] C600 POPJ $
01m0002                               	
01m0002                               	;START DATA CHANNEL to write or read a record.  Transfer up to C(IR-ADR) words;
01m0002                               	;  starting address is in A-MEM[4].
01m0002                               	
01m0002 10047 640701234571000223000000	STRTDC: D[IR] MASK[18.] NORM DEST[5] DEST-A-MEM $
01m0002                               	                ;Initialize word count
01m0002 10050 640700214571034013000000	        D[CONST 1] ROT[14.] DEST[1] DEST-A-MEM NORM $
01m0002                               	                ;Initialize timeout count (for NCNTWT and FMNBWT)
01m0002 10051 440040000571000440000000	STDC1:  MAPF[0] C600 PUSHJ[DCGO] $
01m0002                               	          ;start xfer -- MAPF is relevant if we looped back here on READ
01m0002 10052 440050044571000443400032	        MAPF[0] START-IN D[11] DEST[AR] C600 PUSHJ[NCNTW1] $
01m0002                               	          ;Wait for TP CNT GO to be off (continue with current timeout count)
01m0002                               	          ;MAPF is relevant if we came from DCGWR below.
01m0002 10053 531140074571000440000051	        D[17] C550 -OBUS<0 JUMP[STDC1] $
01m0002                               	          ;Jump if this is a WRITE operation.
01m0002 10054 531140000571000443600051	        START-OUT D[AR] C550 -OBUS<0 JUMP[STDC1] $
01m0002                               	          ;READ op, so set MEM RQ to store last word.
01m0002                               	          ;Jump unless we timed out waiting for end of last COUNT.
01m0002 10055 440150044571000443400022	WCDONE: MAPF[0] START-IN D[11] DEST[AR] C600 JUMP[FMNBW1] $
01m0002                               	          ;Enter FMNBWT with the timeout count left from NCNTWT.
01m0002                               	          ;The MAPF sets MEM RQ if we have fallen in from previous instr.
01m0002 10056 510354464171000440000055	DCGO:   D[15] DEST[Q AR HOLD] C550 OBUS=0 JPOP[WCDONE] $
01m0002                               	                ;Get remaining word count. If =0, we are done.
01m0002 10057 511140014477014140000000	        D[CONST 14] ROT[6] ALU[Q-D] C550 OBUS<0 JUMP[DCG1] $
01m0002                               	                ;Jump if it is less than 1400
01m0002 10060 640710014171014140000000	         D[CONST 14] ROT[6] DEST[Q AR] NORM $   
01m0002                               	                ;It is not. Use 1400 instead.
01m0002 10061 640701204537000443000000	DCG1:   D[MEM] ALU[D-Q] DEST[5] DEST-A-MEM NORM $
01m0002                               	                ;Decrement remaining WC by amount of current WC.
01m0002 10062 640704460571000440000000	        D[14] DEST[HOLD] SHORT $
01m0002                               	                ;Get current starting adr
01m0002 10063 640701004435000443000000	        D[MEM] ALU[D+Q] DEST[4] DEST-A-MEM NORM $
01m0002                               	                ;Increment it by current WC.
01m0002 10064 511140040571000440000066	        D[10 + TPMODE] C550 OBUS<0 JUMP[. + 2] $
01m0002                               	                ;Are we in 32-bit mode ?  Jump if so.
01m0002 10065 640150000435004440000067	         D[AR] ROT[2] ALU[D+Q] DEST[AR] NORM JUMP[. + 2] $
01m0002                               	                ;Form byte count (=5*word count).
01m0002 10066 640710000571004440000000	         D[AR] ROT[2] ALU[D] DEST[AR] NORM $
01m0002                               	                ;Form byte count (=4*word count).
01m0002 10067 640710000531000440000000	        D[AR] ALU[D-1] DEST[AR] NORM $
01m0002                               	                ;Adjust count to be right for hdwr.
01m0002 10070 640700000171054440000000	        D[AR] ROT[35. - 13.] DEST[Q] NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:TAPE.SLO  --  of -- f2sym

01m0002                               	                ;Align count at bit 13.
01m0002 10071 640702204575000243600000	        START-OUT D[MEM] MASK[20.] ALU[DORQ] DEST[IOD] NORM $
01m0002                               	                ;Include mem addr and load into COUNT, MA
01m0002                               	                ;Also sets BUF CNT to 0 (if IN) or 5 (if OUT)-- this
01m0002                               	                ; depends on COUNT not =0 and BUF CNT not = 4 or 5
01m0002 10072 440702214571000023630000	        MAPF[TP.WMA] START-OUT D[CONST 2] DEST[IOD] C600 $
01m0002                               	                ;Set M BUSY
01m0002 10073 440700000571000443610000	        MAPF[TP.WC] START-OUT C600 $
01m0002                               	                ;Set CNT GO
01m0002 10074 451300074571000440130000	        MAPF[13] D[17] C600 OBUS<0 POPJ $
01m0002                               	                ;Return if this is a READ op.
01m0002 10075 530300064571000443600000	DCGWR:  START-OUT D[15] C550 -OBUS=0 POPJ $
01m0002                               	                ;Set MEM RQ to fetch first word.
01m0002                               	                ;Return unless this is the last WCMA in the record.
01m0002 10076 440702214571000123600000	        MAPF[0] START-OUT D[CONST 12] DEST[IOD] C600  $
01m0002                               	                ;Last one.  Set TP ENB LAST BYTE as well as M BUSY
01m0002 10077 440300000571000440010000	        MAPF[TP.WC] C600 POPJ $
01m0002                               	
01m0002                               	
01m0002                               	  ;Here to do the data xfer for a read operation.
01m0002 10100 640700060171000440000000	TRP2:   D[14] DEST[Q] SHORT $
01m0002                               	          ;We must save initial mem. adr. for NRZI KLUGE stuff..
01m0002 10101 640041614575106013000047	        D[CONST 1] ROT[35.] ALU[DORQ] DEST[7] DEST-A-MEM NORM PUSHJ[STRTDC] $
01m0002                               	          ;Flag op. as a READ, start the data channel
01m0002 10102 000140000571000440000000	        JUMP[TRCHKB] $
01m0002                               	
01m0002                               	TRCHECK:        
01m0002 10103 000040000571000440000021	        PUSHJ[FMNBWT] $
01m0002                               	          ;wait for formatter not busy.
01m0002 10104 531140004571100440000000	TRCHKB: D[MEM] ROT[32.] C550 -OBUS<0 JUMP[TRERR] $
01m0002                               	          ;check for hard error status.
01m0002 10105 531140004571102440000000	TRCHA:  D[MEM] ROT[33.] C550 -OBUS<0 JUMP[TREOF] $
01m0002                               	          ;Jump if EOF seen by formatter
01m0002 10106 640700000215000440000000	        ALU[0] DEST[Q] NORM $
01m0002                               	                ;Flag no errors.
01m0002 10107 640700000571000443400000	TRDONE: START-IN NORM $
01m0002 10110 440710030571000443420000	        MAPF[TP.RC] START-IN D[IOD] DEST[AR] C600  $  
01m0002                               	          ;Get data channel status bits.
01m0002 10111 240701230175000253030000	        MAPF[3] D[IOD] MASK[21.] ALU[DORQ] DEST[Q 5] DEST-A-MEM C800 $
01m0002                               	          ;Include ending MA value in status info.
01m0002 10112 531140000571046440000000	        D[AR] ROT[19.] C550 -OBUS<0 JUMP[TPMAOK] $
01m0002                               	          ;If TP CNT GO is off,
01m0002 10113 530140000531060033400000	        START-IN D[AR] ROT[24.] MASK[3] ALU[D-1] C550 -OBUS=0 JUMP[TPMAOK] $
01m0002                               	          ;  or if BUF CNT is not =1, then right no. of words were stored.
01m0002 10114 640701200055000443000000	         ALU[Q-1] DEST[Q 5] DEST-A-MEM NORM $
01m0002                               	           ;Otherwise, 1 extra word was stored, so decrement ending MA.
01m0002 10115 511140004571014440000000	TPMAOK: D[MEM] ROT[6] C550 OBUS<0 JUMP[TRCRET] $        
01m0002                               	          ;Done if not in NRZI mode.
01m0002 10116 531140040571002440000000	        D[10 + TPMODE] ROT[1] C550 -OBUS<0 JUMP[TRCRET] $
01m0002                               	          ;Also done if not in NRZI Kluge Mode,
01m0002 10117 510140060571000440000000	        D[14] C550 OBUS=0 JUMP[TRCRET] $
01m0002                               	          ; or if this was not a data-xfer operation.
01m0002 10120 531140050571030440000000	        D[12] ROT[12.] C550 -OBUS<0 JUMP[TRCRET] $
01m0002                               	          ;Neither do we check for EOF if we started at BOT (see KNYGOA)
01m0002                               	
01m0002                               	    ;In NRZI Kluge Mode, detect EOF by timing.
01m0002 10121 640704474077000240000000	        D[17] MASK[20.] ALU[Q-D] DEST[Q HOLD] NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:TAPE.SLO  --  of -- f2sym

01m0002                               	          ;Get number of words xferred (= ending MA minus starting MA )
01m0002 10122 640700004035004440000000	        D[MEM] ROT[2] ALU[D+Q] DEST[Q] NORM $
01m0002                               	          ;Get no. of bytes (=5* no. of words)
01m0002 10123 640700044035000240000000	        D[11] MASK[20.] ALU[D+Q] DEST[Q] NORM $
01m0002                               	          ;Add remaining timeout count from FMNBWT
01m0002 10124 640700014137034010000000	        D[CONST 1] ROT[14.] ALU[D-Q] DEST[Q] NORM $
01m0002                               	          ;Get no. of byte-times not accounted for by bytes xfrd.
01m0002                               	  .REPEAT 1 - 75IPS [
01m0002                               	  .REPEAT 75IPS [
01m0002 10125 533140014537014150000000	        D[CONST 15] ROT[6.] ALU[D-Q] C550 COND[-OBUS18] JUMP[TRCRET] $
01m0002                               	       ]          ;Jump if it is not more than appropriate for a record gap.
01m0002 10126 640040000571000440000000	        NORM PUSHJ[TAPEBR] $
01m0002                               	          ;Too long.  Assume an EOF was passed.  Back up over record read.
01m0002 10127 000040000571000440000021	        PUSHJ[FMNBWT] $
01m0002 10130 640300014171074600000000	        D[CONST 60] ROT[30.] DEST[Q] NORM POPJ $
01m0002                               	          ;Return EOF status.
01m0002                               	
01m0002 10131 511140060131000220000000	TRCRET: D[14] MASK[18.] ALU[D-1] DEST[Q] C550 OBUS<0 JUMP[TRCX] $
01m0002                               	          ;Get last loc. of input buffer (<0 iff non-data xfer operation)
01m0002 10132 640704400615000440000000	        ALU[0] DEST[HOLD] NORM $
01m0002                               	          ;Prepare to clear the part of the input buffer we didn't use.
01m0002                               	  .REPEAT NEWMAP [
01m0002 10133 640705200741000440000000	        ALU[-1] DEST[MAP-DISABLE] NORM $
01m0002                               	          ;Disable mapping.
01m0002                               	           ]  .REPEAT 1 - NEWMAP [
01m0002 10134 640720064531000440000000	        D[15] ALU[D-1] DEST[MA] NORM $
01m0002 10135 511140024475000440000137	        D[MA] ALU[Q-D-1] C550 OBUS<0 JUMP[. + 2] $
01m0002 10136 640164024433000440000135	        D[MA] ALU[D+1] DEST[MA STRT-WRT] NORM JUMP[. - 1] $
01m0002                               	  .REPEAT NEWMAP [
01m0002 10137 640705200615000440000000	        ALU[0] DEST[MAP-DISABLE] NORM $
01m0002                               	          ;Enable mapping.
01m0002                               	         ]  .REPEAT 1 - NEWMAP [
01m0002 10140 640300064171000440000000	TRCX:   D[15] DEST[Q] NORM POPJ $       
01m0002                               	          ;Recover ending status and return.
01m0002                               	
01m0002 10141 640140014171074600000107	TREOF:  D[CONST 60] ROT[30.] DEST[Q]  NORM JUMP[TRDONE] $
01m0002 10142 511140004571014440000144	TRERR:  D[MEM] ROT[6] C550 OBUS<0 JUMP[. + 2] $ 
01m0002                               	          ;Always check hard error if not in NRZI mode.
01m0002 10143 511140040571002440000105	        D[10 + TPMODE] ROT[1] C550 OBUS<0 JUMP[TRCHA] $
01m0002                               	          ;If NRZI, don't check if in kluge mode.
01m0002 10144 640140014171074500000107	        D[CONST 50] ROT[30.] DEST[Q] NORM JUMP[TRDONE] $
01m0002                               	          ;Flag hard read error to progm.
01m0002                               	
01m0002                               	        .PAIR
01m0002                               	. \ 2 + .
01m0003                               	]       UIOTRP[01m0003 10146 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0003                               	]$
01m0003                               	TAPEMT: ;OPCODE 726 -- MTAPE FUNCTIONS.
01m0003 10147 640040000571000440000151	        NORM PUSHJ[. + 2] $
01m0003 10150 640140000571000440000000	        NORM JUMP[GOMAIN] $
01m0003                               	
01m0003 10151 510140024171000440000000	        D[MA] DEST[Q] COND[OBUS=0] JUMP[TAPERW] C550 $
01m0003 10152 510040014537000010000000	        D[CONST 1] ALU[D-Q] COND[OBUS=0] PUSHJ[TWREOF] C550 $
01m0003 10153 510040014537000130000000	        D[CONST 13] ALU[D-Q] COND[OBUS=0] PUSHJ[TERASE] C550 $
01m0003 10154 510140014537000500000000	        D[CONST 50] ALU[D-Q] COND[OBUS=0] JUMP[TPSETIND] C550 $
01m0003                               	          ;Code ?, set industry compatable mode.
SLOE   Oct  30, 2543 00:00:00  file DSK:TAPE.SLO  --  of -- f2sym

01m0003 10155 510140014537000510000000	        D[CONST 51] ALU[D-Q] COND[OBUS=0] JUMP[TPSETDMP] C550 $
01m0003                               	          ;Code ?, set PDP-10 dump mode.
01m0003 10156 510140014537000600000000	        D[CONST 60] ALU[D-Q] COND[OBUS=0] JUMP[TPSETNK] C550 $
01m0003                               	          ;Code ?, set NRZI KLUGE mode.
01m0003 10157 510140014537000610000000	        D[CONST 61] ALU[D-Q] COND[OBUS=0] JUMP[TPCLRNK] C550 $
01m0003                               	          ;Code ?, clear NRZI KLUGE mode.
01m0003 10160 510040014537000050000000	        D[CONST 5] ALU[D-Q] COND[OBUS=0] PUSHJ[TAPEFR] C550 $
01m0003 10161 510040014537000060000000	        D[CONST 6] ALU[D-Q] COND[OBUS=0] PUSHJ[TAPEBR] C550 $
01m0003 10162 640041000615000443000103	        ALU[0] DEST[4] DEST-A-MEM NORM PUSHJ[TRCHECK] $
01m0003                               	            ;Wait for op. to finish and get ending status in Q.
01m0003                               	            ; The 0 in A-MEM[4] prevents TRCHECK from clearing read buf !
01m0003 10163 640340001555000440000000	        ALU[Q] DEST[AC] NORM JPOP[GOMAIN] $
01m0003                               	            ;Return status to caller in his AC (same as READ)
01m0003                               	
01m0003                               	
01m0003                               	TWREOF:  ;WRITE AN END OF FILE (TAPE MARK)
01m0003 10164 640700014171016010000000	        D[CONST 1] ROT[35. - 28.] DEST[Q] NORM $ 
01m0003                               	          ;Get WFM (WRITE EOF) cmd bit for formatter
01m0003 10165 640144414575032010000000	TERAS1: D[CONST 1] ROT[35. - 22.] ALU[DORQ] DEST[HOLD] NORM JUMP[KNYMTP] $  
01m0003                               	          ;Add WRT CMD bit and start command.
01m0003                               	
01m0003 10166 640140014171014030000165	TERASE: D[CONST 3] ROT[35. - 29.] DEST[Q] NORM JUMP[TERAS1] $
01m0003                               	          ;ERASE A 3.75" GAP ON THE TAPE (get WFM and ERASE bits for formatter)
01m0003                               	
01m0003 10167 640700000571000443600000	KNYMTP: START-OUT NORM $
01m0003                               	          ;Give TP MR to clear mode, error status
01m0003 10170 440040004171000440050014	        MAPF[TP.MR] D[MEM] DEST[Q] C-OUT PUSHJ[KNYGOA] $
01m0003                               	          ;Put command bits in Q and start formatter.
01m0003 10171 640702214571022013600000	        START-OUT D[CONST 1] ROT[35. - 26.] DEST[IOD] NORM $
01m0003                               	                ;Clear all command bits except FORMATTER ENABLE.
01m0003 10172 000300000341000440020000	        MAPF[TP.WF] ALU[-1] DEST[Q] LONG POPJ $
01m0003                               	                ;Put -1 in Q in case we are returning to TAPEMT.
01m0003                               	
01m0003                               	TAPERW: ;REWIND
01m0003 10173 640144414571000240000167	        D[CONST 24] DEST[HOLD] NORM JUMP[KNYMTP] $
01m0003                               	          ;RWD AND GO BITS -- KNYGOA WILL DELETE THE GO BIT !
01m0003                               	
01m0003                               	TAPEFR: ;SKIP FORWARD ONE RECORD.
01m0003 10174 640144414571000000000167	        D[CONST 0] DEST[HOLD] NORM JUMP[KNYMTP] $
01m0003                               	          ;START A READ, BUT IGNORE THE DATA.
01m0003                               	
01m0003                               	TAPEBR: ;SKIP BACKWARD ONE RECORD.
01m0003 10175 640144414571020010000167	        D[CONST 1] ROT[35. - 27.] DEST[HOLD] NORM JUMP[KNYMTP] $
01m0003                               	          ;JUST A READ BACKWARD, WITH THE DATA IGNORED.
01m0003                               	
01m0003                               	TPSETIND:       ;Set industry compatable mode
01m0003 10176 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10177 000140014575106013000000	        D[CONST 1] ROT[35.] ALU[DORQ] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	          ;Set appropriate bit and done
01m0003                               	TPSETDMP:       ;Set PDP-10 Dump Mode
01m0003 10200 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10201 000140014675106013000000	        D[CONST 1] ROT[35.] ALU[-D&Q] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	          ;Clear industry compatable mode and done.
01m0003                               	
01m0003                               	TPSETNK:        ;Enter NRZI KLUGE mode.
01m0003 10202 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10203 000140014575104013000000	        D[CONST 1] ROT[34.] ALU[DORQ] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
SLOE   Oct  30, 2543 00:00:00  file DSK:TAPE.SLO  --  of -- f2sym

01m0003                               	          ;Set appropriate bit and done
01m0003                               	TPCLRNK:          ;Leave NRZI KLUGE mode.
01m0003 10204 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10205 000140014675104013000000	        D[CONST 1] ROT[34.] ALU[-D&Q] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	
01m0003                               	TAPERS: ;OPCODE 727 -- READ STATUS BITS FROM TAPE DRIVE.
01m0003                               	
01m0003                               	.DEFINE TSS[01m0003                               	
01m0003 10206 640702200615000443600000	        START-OUT ALU[0] DEST[IOD] NORM $
01m0003                               	          ;CLEAR THE MODE CTRL REGISTER.
01m0003                               	        MAPF[TP.WM] START-OUT 
01m0003 10207 440702214571022013640000	         D[CONST 1] ROT[35. - 26.] DEST[IOD] C-OUT $
01m0003                               	          ;ENABLE THE FORMATTER.
01m0003 10210 240700000215000443420000	        MAPF[TP.WF] START-IN ALU[0] DEST[Q] C800 $
01m0003                               	          ;READ STATUS BITS.
01m0003 10211 240710030771000440040000	        MAPF[TP.RS] D[IOD] ALU[NOTD] DEST[AR] C800 $
01m0003                               	          ;NOW RE-ARRANGE THE BITS
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 3 OF AR TO BIT 30. OF Q.
01m0003 10212 640704400571010010000000	        D[AR] ROT[1 + 3] MASK[1] DEST[HOLD] NORM $
01m0003 10213 640700004175012440000000	        D[MEM] ROT[35. - 30.] ALU[DORQ] DEST[Q] NORM $ ];ON LINE
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 11. OF AR TO BIT 31. OF Q.
01m0003 10214 640704400571030010000000	        D[AR] ROT[1 + 11.] MASK[1] DEST[HOLD] NORM $
01m0003 10215 640700004175010440000000	        D[MEM] ROT[35. - 31.] ALU[DORQ] DEST[Q] NORM $ ];REWINDING
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 4 OF AR TO BIT 32. OF Q.
01m0003 10216 640704400571012010000000	        D[AR] ROT[1 + 4] MASK[1] DEST[HOLD] NORM $
01m0003 10217 640700004175006440000000	        D[MEM] ROT[35. - 32.] ALU[DORQ] DEST[Q] NORM $ ];FILE PROTECT
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 12. OF AR TO BIT 33. OF Q.
01m0003 10220 640704400571032010000000	        D[AR] ROT[1 + 12.] MASK[1] DEST[HOLD] NORM $
01m0003 10221 640700004175004440000000	        D[MEM] ROT[35. - 33.] ALU[DORQ] DEST[Q] NORM $ ];LOAD POINT
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 10. OF AR TO BIT 34. OF Q.
01m0003 10222 640704400571026010000000	        D[AR] ROT[1 + 10.] MASK[1] DEST[HOLD] NORM $
01m0003 10223 640700004175002440000000	        D[MEM] ROT[35. - 34.] ALU[DORQ] DEST[Q] NORM $ ];READY
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 34. OF AR TO BIT 35. OF Q.
01m0003 10224 640704400571106010000000	        D[AR] ROT[1 + 34.] MASK[1] DEST[HOLD] NORM $
01m0003 10225 640700004175000440000000	        D[MEM] ROT[35. - 35.] ALU[DORQ] DEST[Q] NORM $ ];END OF TAPE
01m0003                               	        ALU[Q] DEST[MEMSTO] NORM
01m0003 10226 662104200555000440000000	                COND[-MA-AC] LBJUMP[HIGHSMAIN] $
01m0003                               	
01m0003                               	
01m0003                               	        .PAIR
01m0003                               	. \ 2 + .
01m0004                               	]       UIOTRP[01m0004 10230 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0004                               	]$
01m0004                               	TAPENR: ;730, AC/COUNT.  READ WHOLE RECORD, STORING UP TO COUNT WORDS STARTING AT EFF
01m0004                               	 ADR.
01m0004                               	         ;SWAP AC AND IR, THEN DO TAPERX.
01m0004 10231 640140235171000440000000	        D[IR] DEST[O_AC IR-ADR] ACSEL[AC]  NORM JUMP[TAPERX] $ 
01m0004                               	
01m0004                               	        .PAIR
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

01m0004                               	. \ 2 + .
01m0005                               	]       UIOTRP[01m0005 10232 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0005                               	]$
01m0005                               	TAPERX: ;732 - (AC) IS START ADDR., E IS # OF WORDS TO READ.
01m0005 10233 640040000571000440000010	        NORM PUSHJ[KNYRGO] $ ;GET TAPE STARTED.
01m0005 10234 640041000551000443000100	        ALU[AC] ACSEL[AC] DEST[4] DEST-A-MEM PUSHJ[TRP2] NORM $ ;READ REC.
01m0005 10235 031140000571040440000000	        D[AR] ROT[16.] -OBUS<0 JUMP[TNRP3] $
01m0005                               	                ;Was record longer than word count ?
01m0005                               	                ;Jump unless FIFO RDY FOR BUF is on, indicating
01m0005                               	                ;  that tape supplied more bytes after count ran out.
01m0005 10236 640700014175074440000000	        D[CONST 44] ROT[30.] ALU[DORQ] DEST[Q] NORM $ ;YES, SET BIT 3.
01m0005 10237 640340001555000440000000	TNRP3:  ALU[Q] DEST[AC] ACSEL[AC] JPOP[GOMAIN] NORM $  ;NO, NOT TOO LONG.
01m0005                               	                ;MOVE STATUS INTO AC.
01m0005                               	
01m0005                               	
01m0005                               	UTAPWR: UIOTRP[01m0005 10240 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0005                               	]$
01m0005                               	
01m0005                               	TAPEWR: ;731, AC/ADR, E/+COUNT.  WRITE RECORD OF +COUNT
01m0005                               	        ; WORDS, DATA FROM ADR.
01m0005                               	        ;SET AC:=0 IF OPERATION COMPLETED SUCCESSFULLY.
01m0005                               	        ; SET AC:=<SETZ> + HIGHEST ADR READ IF REACHED
01m0005                               	        ; EOT DURING OPERATION (CURRENTLY THIS IS THE ONLY
01m0005                               	        ; ERROR CONDITION.)  OPERATION IS COMPLETED EVEN
01m0005                               	        ; IF EOT IS PASSED.
01m0005                               	
01m0005 10241 640701614571000123000000	        D[CONST 10.] DEST[7] DEST-A-MEM NORM $
01m0005                               	          ;SET UP ERROR RETRY COUNT.
01m0005 10242 640040000571000440000040	TWRTRY: NORM PUSHJ[DCINIT] $
01m0005                               	                ;Init. the data channel
01m0005 10243 640710040571002010000000	        D[10 + TPMODE]  ROT[1] MASK[1] DEST[AR] NORM $
01m0005                               	                ;Get the 32-bit mode flag.
01m0005 10244 640700000171014440000000	        D[AR] ROT[35. - 29.] DEST[Q] NORM $
01m0005                               	                ;Position it for the hardware.
01m0005 10245 640702214575016013600000	        START-OUT D[CONST 1] ROT[35. - 28.] ALU[DORQ] DEST[IOD] NORM $
01m0005                               	                ;Set the OUT bit.
01m0005 10246 000040014171032010040014	        MAPF[TP.WM] D[CONST 1] ROT[35. - 22.] DEST[Q] PUSHJ[KNYGOA] $
01m0005                               	                ;Issue WRITE command to formatter.
01m0005 10247 640041000551000443000047	        ALU[AC] DEST[4] DEST-A-MEM NORM PUSHJ[STRTDC] $
01m0005                               	                ;Get word count and start the channel.
01m0005 10250 031140004571100440000000	        D[MEM] ROT[32.] -OBUS<0 JUMP[TWERR] $ ;Test HARD ERR.
01m0005 10251 640700001615000440000000	        ALU[0] DEST[AC] NORM $ ;We return 0 in AC if no EOT.
01m0005 10252 511140004571104440000000	        D[MEM] ROT[34.] C550 OBUS<0 JUMP[GOMAIN] $
01m0005                               	         ;If no EOT seen, all done.
01m0005 10253 640140015561074600000000	        D[CONST 60] ROT[35. - 5] ALU[DORAC] DEST[AC] NORM JUMP[GOMAIN] $
01m0005                               	         ;Turn on bit 0 to indicate EOT seen during operation.
01m0005                               	
01m0005                               	TWERR:  ;;Error occurred during write. Backspace, erase gap, and retry.
01m0005 10254 640040000571000440000001	        NORM PUSHJ[KNYRS1] $ 
01m0005                               	          ;Blast the tape formatter and drive 
01m0005 10255 531140074131000440000000	        D[17] ALU[D-1] DEST[Q] C550 -OBUS<0 JUMP[TWER1] $
01m0005                               	          ;See if we have had to many retry's already...
01m0005 10256 000140015571074500000000	        D[CONST 50] ROT[30.] DEST[AC] JUMP[GOMAIN] $
01m0005                               	           ;Hopeless. Give error return to prgm.
01m0005 10257 640041600555000443000175	TWER1:  ALU[Q] DEST[7] DEST-A-MEM NORM PUSHJ[TAPEBR] $
SLOE   Oct  30, 2543 00:00:00  file DSK:TAPE.SLO  --  of -- f2sym

01m0005                               	         ;Start a BACKSPACE RECORD command.
01m0005 10260 640040000571000443400021	        START-IN NORM PUSHJ[FMNBWT] $ 
01m0005                               	         ;Wait for completion.
01m0005 10261 000040000571000440000166	        PUSHJ[TERASE] $
01m0005                               	         ;Start erasing a 3.75" gap.
01m0005 10262 640040000571000443400021	        START-IN NORM PUSHJ[FMNBWT] $ 
01m0005                               	         ;Wait for completion.
01m0005 10263 640140000571000440000242	        NORM JUMP[TWRTRY] $
01m0005                               	          ;Start write op again.
01m0005                               	
01m0005                               	
01m0005                               	;BOOTSTRAP LOADER FOR MACROCODE.
01m0005                               	
01m0005                               	 .ORG[01m0005                               	XLIST
01m0006                               	 LIST ]
01m0006 05000 000340000571000440005001	MBOOT:  JPOP[. + 1] $
01m0006                               	         ;The . + 1 is to make the lights look familiar for the operator...
01m0006 05001 000140000571000440000000	        JUMP[MBOOTA] $
01m0006                               	         ;MBOOTA takes us to MBOOTH, whether or not that is in high u-mem.
01m0006                               	
01m0006                               	.REPEAT XUCODE [ 01m0006                               	;If 8K u-mem, put this code in upper 4K
01m0006       5002	AREA50 = .
01m0006                               	 .USE[01m0006                               	XLIST
01m0006                               	 LIST ] ];XUCODE
01m0006                               	
01m0006 10264 000041614571000070000001	MBOOTH: D[CONST 7] DEST[DEV-ADR] PUSHJ[KNYCLR] $ ;RESET TAPE CTRL
01m0006 10265 640042600615000440000000	        ALU[0] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
01m0006 10266 640042614571044010000000	        D[CONST 1] ROT[18.] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
01m0006 10267 000041614571000070000010	        D[CONST 7] DEST[DEV-ADR] CYLEN[LONG] PUSHJ[KNYRGO] $
01m0006                               	                ;SELECT DEVICE 7, START READ.
01m0006 10270 640040000571000440000000	        NORM PUSHJ[KNYWAIT] $
01m0006 10271 240044430771000443420000	        MAPF[TP.RC] START-IN D[IOD] ALU[NOTD] DEST[HOLD] C800 PUSHJ[MBTBYX] $ 
01m0006                               	                ;Read 1st byte of new record.
01m0006 10272 640162600615000440000000	        ALU[0] DEST[MA HI-ABS-MA] NORM JUMP[P2A] $
01m0006                               	                ;Clear high-order MA and enter reading loop.
01m0006                               	
01m0006 10273 640060024433000440000000	P2:     D[MA] ALU[D+1] DEST[MA] PUSHJ[MBTBYTE] NORM $
01m0006 10274 640040004171070440000000	P2A:    D[MEM] ROT[34] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10275 640040004175050440000000	        D[MEM] ROT[24] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10276 640040004175030440000000	        D[MEM] ROT[14] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10277 640040004175010440000000	        D[MEM] ROT[4] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10300 640144204575000040000273	        D[MEM] MASK[4]  ALU[DORQ] DEST[MEMSTO] NORM JUMP[P2] $
01m0006                               	
01m0006 10301 640720000615000440000000	CCLR:   ALU[0] DEST[MA] NORM $
01m0006 10302 640704200615000440000000	        ALU[0] DEST[MEMSTO] NORM $
01m0006 10303 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
01m0006 10304 470140024571000220000302	        D[MA] MASK[18.] COND[-OBUS=0] JUMP[. - 2] C600 $
01m0006 10305 640300000571000440000000	        POPJ NORM $
01m0006                               	
01m0006                               	MBTBYTE:
01m0006 10306 640740014571002353400000	        START-IN D[CONST 35] ROT[1] LLOAD NORM $
01m0006                               	                ;Ask tape for a byte and status thereof
01m0006                               	                ;Set loop counter to do timeout
01m0006                               	                ;(TIMEOUT ABOUT 78 USEC)
SLOE   Oct  30, 2543 00:00:00  file DSK:TAPE.SLO  --  of -- f2sym

01m0006 10307 240244430571000440020000	MBTBY1: MAPF[TP.RC] D[IOD] DEST[HOLD] C800 LOOP[MBTBY2] $
01m0006                               	                ;Read byte and status.  Byte comes complemented.
01m0006                               	                ;Result is put in HOLD to avoid synchronizer problems
01m0006                               	                ;Do timeout check and branch if still waiting
01m0006 10310 640040000571000443400000	        START-IN NORM PUSHJ[MBTCHECK] $
01m0006                               	                ;Byte wasn't ready in time.  Go find out why
01m0006 10311 000040000571000440000010	        PUSHJ[KNYRGO] $ ;START NEXT RECORD.
01m0006 10312 640040000571000440000000	        NORM PUSHJ[KNYWAIT] $
01m0006 10313 240044430771000443420000	        MAPF[TP.RC] START-IN D[IOD] ALU[NOTD] DEST[HOLD] C800 PUSHJ[MBTBYX] $ 
01m0006                               	                ;Read 1st byte of new record.
01m0006 10314 640340000571000440000274	        NORM JPOP[P2A] $
01m0006                               	                ;Go for another record
01m0006                               	;       ---
01m0006                               	MBTBY2:
01m0006 10315 531140004571064443400307	        START-IN D[MEM] ROT[26.] -OBUS<0 C550 JUMP[MBTBY1] $
01m0006                               	                ;Check for byte ready (this is a two instruction loop)
01m0006                               	                ;Start getting byte and status again in case we have
01m0006                               	                ;  to loop
01m0006 10316 240704430771000443420000	        START-IN MAPF[TP.RC] D[IOD] ALU[NOTD] DEST[HOLD] C800 $
01m0006                               	                ;READ THE DATA AGAIN (NOW THAT IT'S STABLE !)
01m0006 10317 500304404571000100010000	MBTBYX: MAPF[1] D[MEM] MASK[10] DEST[HOLD] C550 POPJ $
01m0006                               	                ;MAPF[1] clears byte ready
01m0006                               	                ;Extract data byte from other status information
01m0006                               	
01m0006                               	;       ---
01m0006                               	
01m0006                               	KNYWAIT: ;Wait for first byte of read data (BOOTSTRAP mode only)
01m0006 10320 640700000571000443400000	        START-IN SHORT $
01m0006 10321 640710014571030773410000	        MAPF[1] START-IN D[CONST 77] ROT[12.] DEST[AR] NORM $
01m0006                               	                ;Clear read data ready flag
01m0006 10322 440704430571000440020000	KNYW1:  MAPF[TP.RC] D[IOD] DEST[HOLD] C600 $
01m0006 10323 511300004571064443400000	        START-IN D[MEM] ROT[26.] OBUS<0 POPJ C550 $
01m0006                               	                ;Return if READ DATA RDY is now on.
01m0006 10324 530150000531000443400322	        START-IN D[AR] ALU[D-1] DEST[AR] C550 -OBUS=0 JUMP[KNYW1] $
01m0006 10325 640300000571000440000000	        NORM POPJ $
01m0006                               	
01m0006 10326 640040000571000443400021	MBTCHECK:       START-IN NORM PUSHJ[FMNBWT] $
01m0006                               	          ;WAIT FOR FORMATTER IDLE.
01m0006 10327 531140004571100440000000	        D[MEM] ROT[32.] C550 -OBUS<0 JUMP[MBTERR] $
01m0006                               	          ;CHECK FOR ERROR STATUS.
01m0006 10330 511300004571102440000000	        D[MEM] ROT[33.] C550 OBUS<0 POPJ $
01m0006                               	          ;IF END OF FILE NOT SEEN, RETURN FOR MORE, ELSE DONE.
01m0006 10331 640700000215000440000000	        ALU[0] DEST[Q] NORM $ ;CLEAR LIGHTS TO INDICATE NO ERRORS.
01m0006 10332 000341600615000443600333	MBTDNX: START-OUT ALU[0] DEST[DEV-ADR] JPOP[. + 1] $
01m0006                               	                ;Setup to display code in lights
01m0006 10333 000340000555000443620334	        START-OUT MAPF[2] ALU[Q] JPOP[. + 1] $  ;LOAD LIGHTS FROM Q, CLR SW FF'S
01m0006 10334 000700000571000443440000	D1:     MAPF[4] START-IN $
01m0006                               	           ;CHECK START AND CONT SWITCHES.  RD NEXT FILE ON CONT
01m0006 10335 000710030571000440040000	        MAPF[4] D[IOD] DEST[AR] $
01m0006                               	        D[AR]  ROT[5] MASK[2] DEST[AR]
01m0006 10336 010150000571012020000334	                COND[OBUS=0] JUMP[D1] CYLEN[LONG] $
01m0006                               	                ;WAIT FOR A SWITCH.
01m0006 10337 530140000571000010000000	        D[AR] MASK[1] COND[-OBUS=0] JUMP[GOMSTART] C550 $
01m0006                               	           ;  ... START MAIN MICROCODE ON START SWITCH.
01m0006 10340 640700000571000443600000	        START-OUT NORM $  ;CLEAR SWITCH FF'S
01m0006 10341 000340000571000440040264	        MAPF[4] JPOP[MBOOTH] CYLEN[LONG] $
01m0006                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:TAPE.SLO  --  of -- f2sym

01m0006                               	GOMSTART: ;Branch to MSTART
01m0006                               	        GETADR[ ;Place the 12-bit value of MSTART in Q.
01m0006 10342 640700014171014400000000	        D[CONST (77 & (MSTART / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
01m0006 10343 440140014175000000000000	        D[CONST (MSTART \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOLOW] $
01m0006                               	
01m0006 10344 000140014371000000000332	MBTERR: D[CONST 0] ALU[NOTD] DEST[Q] JUMP[MBTDNX] $
01m0006                               	;       ---
01m0006                               	
01m0006                               	  .ORG[01m0006                               	XLIST
01m0007                               	 LIST ]
01m0007 02150 000140000571000440002150	        JUMP[.] $       ;Hang if any interrupts from device 7 occur.
01m0007                               	
01m0007                               	    .USE[XLIST
01m0007                               	 LIST ] ;RETURN TO OLD LOC. CTR.
01m0007                               	
01m0007                               	MBOOTA: GETADR[ ;Place the 12-bit value of MBOOTH in Q.
01m0007 06220 640700014171014020000000	        D[CONST (77 & (MBOOTH / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
01m0007 06221 440140014175000640000000	        D[CONST (MBOOTH \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOHIGH] $
01m0007                               	        

SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

33m0149                               	  ]
33m0149                               	  ];NTP
33m0149                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

34m0149                               	.REPEAT KNYTAPE [ 34m0149                               	;ENDX OF KENNEDY TAPE CODE
34m0149                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

35m0149                               	.REPEAT TLXTAPE [ 35m0149                               	;ENDX OF TELEX TAPE CODE
35m0149                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

36m0149                               	.REPEAT SLOWTAPE [ 36m0149                               	;END OF SLOW TAPE CODE
36m0149                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

37m0149                               	.REPEAT 125TAPE [ 37m0149                               	;END OF SLOW 125 IPS TAPE CODE
37m0149                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

38m0149                               	;TAPE DISPATCH
38m0149                               	
38m0149                               	 .REPEAT 1 - XUCODE [ 38m0149                               	;1 - XUCODE
38m0149                               	
38m0149                               	
38m0149                               	 .REPEAT XUCODE [ 38m0149                               	;If we don't have extended ucode memory, these are different.
38m0149                               	
38m0149                               	.OPCODE[LIST 
38m0149                               	 LIST            ];TAPE IOTS
38m0149                               	
38m0149                               	;725 - Obsolete version of read (no word count, E = core address.)
38m0149                               	        GETADR[ ;Place the 12-bit value of TAPERD in Q.
38m0149 03652 640700014171014000000000	        D[CONST (77 & (TAPERD / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0149 03653 440140014175000050000000	        D[CONST (TAPERD \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0149                               	;726 - MTAPE
38m0149                               	        GETADR[ ;Place the 12-bit value of TAPEMT in Q.
38m0149 03654 640700014171014010000000	        D[CONST (77 & (TAPEMT / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0149 03655 440140014175000470000000	        D[CONST (TAPEMT \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0149                               	;727 - READ STATUS
38m0149                               	        GETADR[ ;Place the 12-bit value of TAPERS in Q.
38m0149 03656 640700014171014020000000	        D[CONST (77 & (TAPERS / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0149 03657 440140014175000060000000	        D[CONST (TAPERS \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0149                               	;730 - OBSOLETE ! --read 1 record, store up to (AC) words starting at E.
38m0149                               	        GETADR[ ;Place the 12-bit value of TAPENR in Q.
38m0149 03660 640700014171014020000000	        D[CONST (77 & (TAPENR / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0149 03661 440140014175000310000000	        D[CONST (TAPENR \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0149                               	;731 - WRITE 1 record of E words starting from CORE LOC IN AC.
38m0149                               	        GETADR[ ;Place the 12-bit value of TAPEWR in Q.
38m0149 03662 640700014171014020000000	        D[CONST (77 & (TAPEWR / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0149 03663 440140014175000410000000	        D[CONST (TAPEWR \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0149                               	;732 - READ 1 record, store up to E words starting at (AC).
38m0149                               	        GETADR[ ;Place the 12-bit value of TAPERX in Q.
38m0149 03664 640700014171014020000000	        D[CONST (77 & (TAPERX / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0149 03665 440140014175000330000000	        D[CONST (TAPERX \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0149                               	
38m0149                               	  ];XUCODE
38m0149                               	
38m0149                               	.RELOC
38m0149                               	USE[38m0149                               	XLIST
38m0150                               	 LIST ]]
38m0150 06222 025141614571000070000000	TAPDSP: D[CONST 7] DEST[DEV-ADR] COND[-USER] JUMP[GOHIGH] $
38m0150                               	         ;Load device code for tape, test for user mode.
38m0150                               	        UIOTRP[38m0150 06223 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
38m0150                               	]$
38m0150                               	         ;In user mode-- trap unless IOT USER
38m0150                               	
38m0150                               	GOHIGH:  ;Jump into high part of umemory, using 12-bit addr. in Q
38m0150 06224 440540014433022120000000	        D[CONST (XUCODE * 10) + 2] ROT[9.] ALU[D+1] C600 SDISP $
38m0150                               	          ;This takes us to loc. 2001 and pre-sets the 10000 bit.
38m0150                               	 .ORG[38m0150                               	XLIST
38m0151 02001 000540014575030010000000	 LIST ] D[CONST XUCODE] ROT[12.] ALU[DORQ] SDISP $
38m0151                               	          ;This finally takes us to loc. 10000+[Q] 
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

38m0151                               	
38m0151                               	 .RELOC
38m0151                               	USE[38m0151                               	XLIST
38m0152                               	 LIST ]]
38m0152                               	  .REPEAT XUCODE [
38m0152                               	.USE[XLIST
38m0152                               	 LIST ]$
38m0152                               	     ]
38m0152                               	 .PAIR
38m0152                               	. \ 2 + .
38m0153                               	]HIGHSMAIN:
38m0153 10346 640140005570400440000000	        D[MEM] ACSEL[MA] DEST[AC] NORM JUMP[GOMAIN] $
38m0153 10347 640140000571000440000000	        NORM JUMP[GOMAIN] $
38m0153                               	
38m0153                               	GOMAIN: GETADR[ ;Place the 12-bit value of MAIN in Q.
38m0153 10350 640700014171014200000000	        D[CONST (77 & (MAIN / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0153 10351 440700014175000260000000	        D[CONST (MAIN \ 100)] ALU[DORQ] DEST[Q] C600 ] $        ;Do extended mode jump to
38m0153                               	 MAIN.
38m0153                               	
38m0153                               	GOLOW:   ;Jump to loc. in lower 4K indicated by contents of Q.
38m0153                               	
38m0153                               	   .REPEAT XUCODE [
38m0153 10352 440540000615000440000000	        ALU[0] C600 SDISP $
38m0153                               	         ;This goes to loc. 10000 and pre-clears the 10000 bit.
38m0153                               	 .ORG[38m0153                               	XLIST
38m0153                               	 LIST ]   ];XUCODE
38m0153                               	
38m0153 10000 440540000555000440000000	        C600 ALU[Q] SDISP $
38m0153                               	         ;Now we actually go to low u-mem.
38m0153                               	
38m0153                               	.USE[38m0153                               	XLIST
38m0154                               	 LIST ]
38m0154                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

39m0154                               	
39m0154                               	
39m0154                               	;------------------------------------------------------------------------------
39m0154                               	;
39m0154                               	;       FooVision
39m0154                               	;
39m0154                               	;------------------------------------------------------------------------------
39m0154                               	.REPEAT VID [
39m0154                               	VID
39m0154                               	        .OPCODE[39m0154                               	LIST 
39m0155                               	 LIST            ].REPEAT ((1 - VID) * (773 - 766 + 1)) [
39m0155                               	        ILGIOT 39m0155 03754 000140000571000440002026	 JUMP [MAIN] ]$                 ;OPS 766:773
39m0155 03755 000700000571000440000000	        NOP $
39m0155                               	]39m0155                               	        ILGIOT 39m0155 03756 000140000571000440002026	 JUMP [MAIN] ]$                 ;OPS 766:773
39m0155 03757 000700000571000440000000	        NOP $
39m0155                               	]39m0155                               	        ILGIOT 39m0155 03760 000140000571000440002026	 JUMP [MAIN] ]$                 ;OPS 766:773
39m0155 03761 000700000571000440000000	        NOP $
39m0155                               	]39m0155                               	        ILGIOT 39m0155 03762 000140000571000440002026	 JUMP [MAIN] ]$                 ;OPS 766:773
39m0155 03763 000700000571000440000000	        NOP $
39m0155                               	]39m0155                               	        ILGIOT 39m0155 03764 000140000571000440002026	 JUMP [MAIN] ]$                 ;OPS 766:773
39m0155 03765 000700000571000440000000	        NOP $
39m0155                               	]39m0155                               	        ILGIOT 39m0155 03766 000140000571000440002026	 JUMP [MAIN] ]$                 ;OPS 766:773
39m0155 03767 000700000571000440000000	        NOP $
39m0155                               	]1-VID
39m0155                               	.REPEAT VID [
39m0155                               	VID
39m0155                               	        .RELOC
39m0155                               	USE[39m0155                               	XLIST
39m0156                               	 LIST ]]
39m0156                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

40m0156                               	
40m0156                               	;FLOATING POINT, KA10 STYLE.
40m0156                               	;NONDISPATCH CODE.
40m0156                               	.DEFINE CFPLOW[40m0156                               	.DEFINE JINSEXP[40m0156                               	.DEFINE CINSEXP[40m0156                               	.DEFINE CFDS[40m0156                               	
40m0156                               	;***** DON'T USE A-MEM 0 FOR ANYTHING BESIDES DISPATCHES!!!     TVR-Sep80  *****
40m0156                               	;***** This must be fixed!!!!                                   TVR-Sep80  *****
40m0156 06225 640050000551000443000000	UFA1:   ALU[AC] DEST[0 AR] DEST-A-MEM PUSHJ[FADSUB] NORM $
40m0156 06226 640710041171000440000000	        D[10] DEST[AR O_AC] SHORT $
40m0156 06227 000160001571400440602027	        D[AR] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] $
40m0156                               	
40m0156                               	        .PAIR   . \ 2 + .
40m0156                               	];: 6460                ;.PAIR
40m0156 06230 640140001751000440006232	DFN1:   ALU[NOTAC] DEST[AC] JUMP[. + 2] NORM $
40m0156 06231 640700001513000440000000	        ALU[0-AC] DEST[AC] SHORT $
40m0156 06232 640700004171000440000000	        D[MEM] DEST[Q] SHORT $
40m0156 06233 640700010235066110000000	        D[MASK 9] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
40m0156 06234 662104200575000330002032	        D[AR] MASK[27.] ALU[DORQ] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0156                               	
40m0156                               	
40m0156 06235 640160001615000440602027	FSCZAP: ALU[0] DEST[MA AC] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0156 06236 640710000171022110000000	FSC1:   D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
40m0156 06237 531140011661066100000000	        D[MASK 8] ROT[27.] ALU[-D&AC] DEST[AC] COND[-OBUS<0] JUMP[FSC2] C550 $
40m0156 06240 640710010335000110000000	        D[MASK 9] ALU[D#Q] DEST[Q AR] SHORT $
40m0156 06241 640700011561066100000000	        D[MASK 8] ROT[27.] ALU[DORAC] DEST[AC] SHORT $
40m0156 06242 640700224435000220000000	FSC2:   D[MA] MASK[18.] ALU[D+Q] DEST[IR-ADR] SHORT $
40m0156 06243 640040000215000440000000	        ALU[0] DEST[Q] PUSHJ[NRMLIZ] NORM $
40m0156 06244 640040000171066440000000	        CINSEXP [AR] ROT[27.] DEST[Q] PUSHJ[INSEX1] NORM ]$
40m0156 06245 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0156                               	
40m0156                               	FAOS1:
40m0156                               	FAOS5:
40m0156 06246 640050000551000440000000	        ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
40m0156 06247 640160000571000440602027	        DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0156 06250 640050000551000440000000	FAOS2:  ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
40m0156 06251 640140001571400440000000	        CFPLOW [AR] ACSEL[AC+1] DEST[AC] JUMP[FPLOW] NORM ]$
40m0156 06252 640710000551000440000000	FAOS3:  ALU[AC] DEST[AR] NORM $
40m0156 06253 640701614571000110000000	        D[CONST 11] DEST[DEV-ADR] SHORT $
40m0156 06254 640040000551000443000000	        ALU[AC] DEST[0] DEST-A-MEM PUSHJ[FADSUB] NORM $
40m0156 06255 662104241171000440002032	        D[10] DEST[MEMSTO O_AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0156 06256 640050000551000440000000	FAOS4:  ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
40m0156 06257 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0156                               	
40m0156                               	FMP1:
40m0156                               	FMP5:
40m0156 06260 640050000551000440000000	        ALU[AC] DEST[AR] PUSHJ[FM] NORM $
40m0156 06261 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0156 06262 640050000551000440000000	FMP2:   ALU[AC] DEST[AR] PUSHJ[FM] NORM $
40m0156 06263 640140001571400440000000	        CFPLOW [AR] ACSEL[AC+1] DEST[AC] JUMP[FPLOW] NORM ]$
40m0156 06264 640710000551000440000000	FMP3:   ALU[AC] DEST[AR] NORM $
40m0156 06265 640701614571000110000000	        D[CONST 11] DEST[DEV-ADR] SHORT $
40m0156 06266 640040000551000443000000	        ALU[AC] DEST-A-MEM PUSHJ[FM] DEST[0] NORM $
40m0156 06267 662104241171000440002032	        D[10] DEST[MEMSTO O_AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0156 06270 640050000551000440000000	FMP4:   ALU[AC] DEST[AR] PUSHJ[FM] NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

40m0156 06271 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0156                               	
40m0156                               	;Macro to test for divide by zero
40m0156                               	.DEFINE DIVTST[40m0156                               	
40m0156                               	;;;FD5: D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] NORM $     ;Not needed.  TVR-Apr80
40m0156                               	
40m0156                               	;FDV,FDVR
40m0156 06272 510140004571000330000000	FD1:    DIVTST [MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$ ;Check for divide by zero
40m0156                               	
40m0156 06273 640050004721000440000000	        CFDS [MEM] ALU[D#AC] DEST[AR] PUSHJ[FDS1] NORM]$
40m0156 06274 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0156                               	
40m0156                               	;------------------------------------------------------------------------------
40m0156                               	;LONG MODE FLOATING DIVIDE.
40m0156                               	;------------------------------------------------------------------------------
40m0156 06275 510140004571000330000000	FD2:    DIVTST [MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$
40m0156                               	 ;AR.0,IR.35:=XOR(DIVIDEND SIGN,DIVISOR SIGN).
40m0156 06276 640710004721000440000000	        D[MEM] ALU[D#AC] DEST[AR] SHORT $
40m0156 06277 640700200571002010000000	        D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
40m0156                               	 ;Flush sign & exponent from Dividend Low
40m0156 06300 640710010621400330000000	        D[MASK 27.] ALU[D&AC] ACSEL[AC+1] DEST[AR] SHORT $
40m0156 06301 640700001571422440000000	        D[AR] ROT[9] DEST[AC] ACSEL[AC+1] SHORT $
40m0156                               	 ;Positive form of Dividend to AC, AR; original form to AMEM[1]
40m0156 06302 631150200551000443000000	        ALU[AC] DEST[AR 1] DEST-A-MEM COND[-OBUS<0] JUMP[FD2A] CYLEN[C450] $
40m0156 06303 510140001513400440006305	        ALU[0-AC] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[. + 2] C550 $
40m0156 06304 640150001751000440006306	        ALU[NOTAC] DEST[AC AR] JUMP[. + 2] SHORT $
40m0156 06305 640710001513000440000000	        ALU[0-AC] DEST[AC AR] NORM $
40m0156 06306 640710014421066010000000	FD2A:   D[CONST 1] ROT[27.] ALU[AC+D] DEST[AR] NORM $
40m0156                               	         ;Add 1 to exp. of dividend, since we will do only a 27-bit divide.
40m0156 06307 640701400551400443000000	        ALU[AC] ACSEL[AC+1] DEST[6] DEST-A-MEM NORM $
40m0156                               	         ;Put low-order mantissa in AMEM[6] for FD.
40m0156 06310 640740014571000330000000	        D[CONST 27.] LLOAD NORM $ 
40m0156                               	         ;Do only a 27-bit divide, so remainder will come out right.
40m0156 06311 640040000571000440000000	        PUSHJ[FD] NORM $        
40m0156                               	         ;Perform the divide (returns: AC=quotient, AMEM[6]=remainder)
40m0156                               	 ;AC+1 gets 0 if remainder = 0.
40m0156 06312 510140071571400440000000	        D[16] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[FD2D] C550 $
40m0156                               	 ;Calculate exponent of remainder.
40m0156 06313 531140044171000440006316	        D[11]  DEST[Q] C550 -OBUS<0 JUMP[. + 3] $
40m0156                               	         ;Check sign of dividend, jump if positive.
40m0156 06314 640700200517000443000000	         ALU[0-Q] DEST[1] DEST-A-MEM NORM $
40m0156                               	          ;Negate the dividend (so the exponent will be in pos. form)
40m0156 06315 640700001513400440000000	         ACSEL[AC+1] ALU[0-AC] DEST[AC] NORM $
40m0156                               	          ;Negate the remainder.
40m0156 06316 640700044171022100000000	        D[11] ROT[9.] MASK[8] DEST[Q] NORM $
40m0156                               	         ;Recover exp. of dividend.
40m0156                               	 ;A-MEM[7] has (dividend HOW)-(divisor).
40m0156 06317 531140074571000440006321	        D[17] COND[-OBUS<0] JUMP[. + 2] C550 $
40m0156 06320 640700014077000010000000	         D[CONST 1] ALU[Q-D] DEST[Q] SHORT $
40m0156 06321 453140014077000320000000	        D[CONST 26.] ALU[Q-D] DEST[Q] COND[OBUS18] JUMP[FD2C] C600 $
40m0156                               	         ;Jump if exponent underflow.
40m0156                               	.DEFINE SWAPAC[40m0156                               	
40m0156                               	 ;SWAP QUOTIENT (AC) AND REMAINDER (AC+1)
40m0156                               	        SWAPAC
40m0156                               	;Interchange (AC) and (AC+1)
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

40m0156 06322 640710000551400440000000	        ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
40m0156 06323 640710001171000440000000	        D[AR] DEST[AR O_AC] SHORT $
40m0156 06324 640700001571400440000000	        D[AR] ACSEL[AC+1] DEST[AC] SHORT $
40m0157                               	  ] ;INSERT EXPONENT INTO REMAINDER.
40m0157 06325 640050000555000440000000	        ALU[Q] DEST[AR] PUSHJ[INSEXP] NORM $
40m0157                               	        SWAPAC
40m0157                               	;Interchange (AC) and (AC+1)
40m0157 06326 640710000551400440000000	        ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
40m0157 06327 640710001171000440000000	        D[AR] DEST[AR O_AC] SHORT $
40m0157 06330 640700001571400440000000	        D[AR] ACSEL[AC+1] DEST[AC] SHORT $
40m0158 06331 640160000571000440602027	  ]FD2D:        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0158                               	
40m0158 06332 640160001615400440602027	FD2C:   ALU[0] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0158                               	
40m0158 06333 510140004571000330000000	FD3:    DIVTST [MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$
40m0158 06334 640040000551000443000000	        ALU[AC] DEST[0] DEST-A-MEM PUSHJ[FDS] NORM $
40m0158 06335 662104241171000440002032	        D[10] DEST[MEMSTO O_AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0158 06336 510140004571000330000000	FD4:    DIVTST [MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$
40m0158 06337 640050004721000440000000	        CFDS [MEM] ALU[D#AC] DEST[AR] PUSHJ[FDS1] NORM]$
40m0158 06340 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0158                               	
40m0158                               	;HERE ON DIVISOR=0.  SET NO DIVIDE, OVF,FLOV,RETURN.
40m0158 06341 640700020171000440000000	FPNDIV: D[PC] DEST[Q] SHORT $
40m0158 06342 640040014175056010000000	        D[CONST 1] ROT[23.] ALU[DORQ] DEST[Q] PUSHJ[SETFOV] NORM $
40m0158 06343 640160000571000440602027	        DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0158                               	
40m0158                               	;------------------------------------------------------------------------------
40m0158                               	;NORMALIZE DOUBLE PRECISION NUMBER IN AC,Q WHOSE EXPONENT
40m0158                               	; IS IN IR-ADR.  LEAVE EXPONENT IN AR, NORMALIZED NUMBER IN AC,Q.
40m0158                               	; IF NUMBER IS 0, LEAVE 0 IN AR,AC, AND Q.
40m0158                               	;------------------------------------------------------------------------------
40m0158                               	.DEFINE CNORM[40m0158                               	
40m0158                               	;A. Return immediately if 0.
40m0158 06344 510310000545000440000000	NRMLIZ: ALU[QORAC] DEST[AR] COND[OBUS=0] POPJ C550 $
40m0158                               	;B. Check for mantissa overflow, move exponent to AR.
40m0158 06345 640050000551000440000000	        ALU[AC] DEST[AR] PUSHJ[NORMOV] NORM $
40m0158                               	                ;Check mantissa and shift right if necessary
40m0158 06346 530300034571000220000000	        D[IR] MASK[18.] COND[-OBUS=0] POPJ C550 $
40m0158                               	                ;If we adjusted right, then we definitely don't have to
40m0158                               	                ;shift left.  We're done here.
40m0158                               	;C. Left shift until normalized.
40m0158 06347 611140000551000440000000	        ALU[AC] COND[OBUS<0] JUMP[NEGNOR] CYLEN[C450] $
40m0158                               	                ;Separate into two cases, positive and negative
40m0158 06350 530300014621064010000000	POSNOR: D[CONST 1] ROT[26.] ALU[D&AC] COND[-OBUS=0] POPJ C550 $
40m0158                               	                ;If high order bit of mantissa is one, we're done
40m0158 06351 640710000531000440000000	        D[AR] ALU[D-1] DEST[AR] SHORT $
40m0158                               	                ;Decrement the exponent
40m0158 06352 640140003145000020006350	        ALU[SH-AC] MASK[2] DEST[D6] JUMP[POSNOR] NORM $
40m0158                               	                ;Shift left and try again.
40m0158 06353 510140014621064010000000	NEGNOR: D[CONST 1] ROT[26.] ALU[D&AC] COND[OBUS=0] JUMP[NN1] C550 $
40m0158                               	                ;If high order bit of mantissa is zero, we're done
40m0158 06354 640710000531000440000000	        D[AR] ALU[D-1] DEST[AR] SHORT $
40m0158                               	                ;Decrement the exponent
40m0158 06355 640140003145000020006353	        ALU[SH-AC] MASK[2] DEST[D6] JUMP[NEGNOR] NORM $
40m0158                               	                ;Shift left and try again.
40m0158 06356 530300010621000330000000	NN1:    D[MASK 27.] ALU[D&AC] COND[-OBUS=0] POPJ C550 $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

40m0158                               	                ;Check for case of exactly -(2^n).  If it isn't, we're done
40m0158 06357 640700015561064010000000	        D[CONST 1] ROT[26.] ALU[DORAC] DEST[AC] SHORT $
40m0158                               	                ;We went one too far, backup by simply OR'ing in the relevant
40m0158                               	                ;bit in the same manner as shifting would. 
40m0158                               	                ;(*** What about Q??  TVR-Jul80)
40m0158 06360 640310000433000440000000	        D[AR] ALU[D+1] DEST[AR] POPJ NORM $
40m0158                               	                ;Increment exponent to account for simulated left shift.
40m0158                               	
40m0158                               	;------------------------------------------------------------------------------
40m0158                               	;CHECK FOR MANTISSA OVERFLOW INTO EXPONENT FIELD.  CALL WITH
40m0158                               	; AR&AC,Q: # TO NORMALIZE, IR-ADR: ITS EXPONENT.
40m0158                               	; LEAVE EXPONENT IN AR.  SET IR-ADR=0 IF NO OVERFLOW.  SET IR-ADR<>0
40m0158                               	; IF OVERFLOW, AND NORMALIZE.
40m0158                               	;
40m0158                               	;M.O. <=> [AR0<>AR8] OR [(AR8=1) AND (AR9-35=0)]
40m0158                               	;------------------------------------------------------------------------------
40m0158 06361 511140000721020440000000	NORMOV: D[AR] ROT[8] ALU[D#AC] COND[OBUS<0] JUMP[NOVYES] C550 $
40m0158                               	                ;Check to make sure AR<0>=AR<8>.  If they don't, the mantissa
40m0158                               	                ;clearly overlaps the exponent field.
40m0158 06362 530140010621000330000000	        D[MASK 27.] ALU[D&AC] COND[-OBUS=0] JUMP[NOVNO] C550 $
40m0158                               	                ;Check for AR<9:35> for zero.  If not zero, we're OK
40m0158 06363 510140014621066010000000	        D[CONST 1] ROT[27.] ALU[D&AC] COND[OBUS=0] JUMP[NOVNO] C550 $
40m0158                               	                ;Check AR<8>.  If zero, we're OK
40m0158                               	;       \ /
40m0158                               	;Mantissa has overflowed, adjust it.  Right by one should be enough.
40m0158 06364 640700002145000010000000	NOVYES: ALU[SH-AC] MASK[1] DEST[D4] SHORT $
40m0158                               	                ;Shift mantissa right (i think?)
40m0158 06365 640310234433000220000000	        D[IR] MASK[18.] ALU[D+1] DEST[AR IR-ADR] POPJ NORM $
40m0158                               	                ;Increment mantissa and flag that we changed it by setting
40m0158                               	                ;IR<18:35> to be non-zero.
40m0158                               	
40m0158                               	;Mantissa has not overflowed.
40m0158 06366 640710034571000220000000	NOVNO:  D[IR] MASK[18.] DEST[AR] SHORT $
40m0158                               	                ;Save exponent in AR
40m0158 06367 640300200615000440000000	        ALU[0] DEST[IR-ADR] POPJ NORM $
40m0158                               	                ;Zero IR<18:35> to signify success
40m0158                               	
40m0158                               	;------------------------------------------------------------------------------
40m0158                               	;INSERT EXPONENT IN AR INTO WORD IN AC.
40m0158                               	;SET FLOV,FLUN,OVF FLAGS AS REQUIRED.
40m0158                               	;PRESERVES AR, CLOBBERS Q.
40m0158                               	;------------------------------------------------------------------------------
40m0158 06370 640700000171066440000000	INSEXP: D[AR] ROT[27.] DEST[Q] NORM $
40m0158                               	                ;Move exponent into position
40m0158 06371 640700010235066100000000	INSEX1: D[MASK 8.] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
40m0158                               	                ;Flush stuff in mantissa area
40m0158 06372 640700001705000440000000	        ALU[Q#AC] DEST[AC] SHORT $
40m0158                               	                ;Fill in exponent (complementing it if (AC) is negative !)
40m0158 06373 513140000571000440000000	        D[AR] COND[OBUS18] JUMP[EXPUF] C550 $
40m0158                               	                ;Check for underflow (i.e. below range of exponent offset)
40m0158 06374 510300000571070120000000	        D[AR] MASK[10.] ROT[28.] COND[OBUS=0] POPJ C550 $
40m0158                               	                ;Check for overflow (i.e. above range of exponent offset)
40m0158 06375 640700020171000440000000	        D[PC] DEST[Q] SHORT $
40m0158                               	                ;Setup to set floating overflow
40m0158 06376 640305414575100110000000	SETFOV: D[CONST 11] ROT[32.] ALU[DORQ] DEST[CRYOV] POPJ NORM $
40m0158                               	                ;Turn on overflow and floating overflow
40m0158 06377 640700020171000440000000	EXPUF:  D[PC] DEST[Q] SHORT $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

40m0158                               	                ;Setup to set no divide and floating overflow
40m0158 06400 640140014175060010006376	        D[CONST 1] ROT[24.] ALU[DORQ] DEST[Q] JUMP[SETFOV] NORM$
40m0158                               	                ;Turn on no divide, then do overflows
40m0158                               	
40m0158                               	;------------------------------------------------------------------------------
40m0158                               	;FLOATING ADD AC&AR TO MEM.  RESULT, NORMALIZED AND ROUNDED
40m0158                               	; IF REQUIRED IN AC,Q.
40m0158                               	;------------------------------------------------------------------------------
40m0158                               	.DEFINE BLEXPS[40m0158                               	BLEXPS
40m0158                               	        ;A. + FORM EXPONENT OF AC,MEM RTO AR,Q RESP.
40m0158 06401 640710000171022110000000	FADSUB: D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
40m0158 06402 510140014635020010000000	FADSU1: D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS1] C550 $
40m0158 06403 640710010735000110000000	        D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
40m0158 06404 640700004171022110000000	FS1:    D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
40m0158 06405 510140014635020010000000	        D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS2] C550 $
40m0158 06406 640700010335000110000000	        D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
40m0158                               	        ;B. COMPUTE DIFFERENCE, SWAP OPRANDS IF AC HAS LARGER EXP.
40m0158                               	        ;   LEAVE + DIFFERENCE IN Q, DIFF -1 IN LOOP CTR.
40m0158                               	        ;   LEAVE LARGER EXPONENT IN IR-ADR.
40m0158 06407 640700200555000440000000	FS2:    ALU[Q] DEST[IR-ADR] SHORT $
40m0158 06410 471140000077000440000000	        D[AR] ALU[Q-D] DEST[Q] COND[-OBUS<0] JUMP[FS3] C600 $
40m0158 06411 640700200571000440000000	        D[AR] DEST[IR-ADR] SHORT $
40m0158 06412 640704405171000440000000	        D[MEM] DEST[HOLD O_AC] NORM $
40m0158 06413 640700000117000440000000	        ALU[0-Q] DEST[Q] NORM $
40m0158 06414 640750000455000440000000	FS3:    ALU[Q-1] DEST[AR] LLOAD NORM $
40m0158                               	        ;C. BLANK EXPONENTS.
40m0158                               	        BLEXPS[40m0158 06415 511140011561066100006417	        D[MASK 8] ROT[27.] ALU[DORAC] DEST[AC] COND[OBUS<0] JUMP[. + 2] C550 $
40m0158 06416 640700011661066100000000	        D[MASK 8] ROT[27.] ALU[-D&AC] DEST[AC] SHORT $
40m0158 06417 511140004171000440006421	        D[MEM] DEST[Q] COND[OBUS<0] JUMP[. + 2] C550 $
40m0158 06420 640144410675066100006422	        D[MASK 8] ROT[27.] ALU[-D&Q] DEST[HOLD] JUMP[. + 2] NORM $
40m0158 06421 640704410575066100000000	        D[MASK 8] ROT[27.] ALU[DORQ] DEST[HOLD] CYLEN[NORM] $
40m0159                               	]       ;D. IF DELTA EXPONENTS >62., AC GOES TO OBLIVION.
40m0159 06422 450140000033000440000000	        D[AR] ALU[D+1] DEST[Q] COND[OBUS=0] JUMP[FS5] C600 $
40m0159 06423 451140014477000770000000	        D[CONST 63.] ALU[Q-D] COND[OBUS<0] JUMP[FS4] C600 $
40m0159 06424 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
40m0159 06425 640140000215000440000000	        ALU[0] DEST[Q] JUMP[FS5] NORM $
40m0159 06426 640700000215000440000000	FS4:    ALU[0] DEST[Q] SHORT $
40m0159 06427 640240002145000010006427	        ALU[SH-AC] DEST[D4] MASK[1] LOOP [.] NORM $
40m0159                               	        ;E. ADD.
40m0159 06430 640710004421000440000000	FS5:    D[MEM] ALU[D+AC] DEST[AR] SHORT $
40m0159                               	        ;F. NORMALIZE RESULT.
40m0159 06431 640700035571000440000000	        D[IR] DEST[AC] SHORT $  ;CHECK FOR UFA
40m0159 06432 510140014621100010000000	        D[CONST 1] ROT[40] ALU[D&AC] COND[OBUS=0] JUMP[UFANOR] C550 $
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;ENTER HERE WITH RESULT IN AR,Q, EXP IN IR-ADR.
40m0159                               	;------------------------------------------------------------------------------
40m0159 06433 640040001571000440006344	FPNAR:  CNORM [AR] DEST[AC] PUSHJ[NRMLIZ] NORM]$                                ;NOPE,
40m0159                               	 NORMALIZE
40m0159                               	;(Calls NRMLIZ which changes register usage from above and adjusts various
40m0159                               	;things.  "LEAVE EXPONENT IN AR, NORMALIZED NUMBER IN AC,Q.")
40m0159                               	;G. ROUND IF NECESSARY, INSERT EXPONENT INTO HIGH ORDER WORD OF RESULT.
40m0159 06434 631144400555000440000000	        ALU[Q] COND[-OBUS<0] DEST[HOLD] JUMP[NORND] CYLEN[C450] $
40m0159                               	                ;Save Q in HOLD (i.e. MEM)
40m0159                               	                ;If Q<0> is zero, don't round
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

40m0159 06435 640700034171000440000000	        D[IR] DEST[Q] NORM $
40m0159                               	                ;Get Q so we check bit meaning rounding (??? Can't this be
40m0159                               	                ;done with D[IR] ROT[7] COND[OBUS<0]... ???)
40m0159 06436 510140014635072010000000	        D[CONST 1] ROT[35] ALU[D&Q] COND[OBUS=0] JUMP[NORND] C550 $
40m0159                               	                ;Check opcode to see if rounding is requested.
40m0159                               	                ;If not, we're done
40m0159 06437 640700004171000440000000	        D[MEM] DEST[Q] SHORT $
40m0159                               	                ;Restore Q
40m0159 06440 530140010635000430000000	        D[MASK 43] ALU[D&Q] COND[-OBUS=0] JUMP[YESRND] C550 $
40m0159                               	                ;Round if Q<1:35> is non-zero (? what does this signify???)
40m0159 06441 611140000551000440006370	        ALU[AC] COND[OBUS<0] JUMP[INSEXP] CYLEN[C450] $
40m0159                               	                ;If mantissa is negative, we don't round (???)
40m0159                               	;       \ /
40m0159 06442 640700200571000440000000	YESRND: D[AR] DEST[IR-ADR] SHORT $
40m0159                               	                ;Setup IR for NRMLIZ
40m0159 06443 640040001413000440006344	        ALU[AC+1] DEST[AC] PUSHJ[NRMLIZ] NORM $
40m0159                               	                ;Increment high order word and normalize once more (???)
40m0159 06444 640140000171066440006371	        JINSEXP [AR] ROT[27.] DEST[Q] JUMP[INSEX1] NORM ]$
40m0159                               	                ;Now stick in exponent
40m0159                               	;       ---
40m0159 06445 640140004171000440006370	NORND:  D[MEM] DEST[Q] JUMP[INSEXP] NORM $
40m0159                               	                ;Restore Q and insert exponent(?)
40m0159                               	
40m0159                               	;UFA NORMALIZATION -- ONLY ON MANTISSA OVERFLOW.
40m0159 06446 450300001575000440000000	UFANOR: D[AR] ALU[DORQ] DEST[AC] COND[OBUS=0] POPJ C600 $
40m0159 06447 640040001571000440006361	        D[AR] DEST[AC] PUSHJ[NORMOV] NORM $
40m0159 06450 640140000171066440006371	        JINSEXP [AR] ROT[27.] DEST[Q] JUMP[INSEX1] NORM ]$
40m0159                               	;       ---
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;SETUP LOW ORDER FP RESULT, STORE BOTH IN AC,AC+1
40m0159                               	;ENTER WITH LOW WORD IN MEM, HIGH WORD IN AC, HIGH
40m0159                               	;WORD'S EXPONENT IN AR&AC+1.
40m0159                               	;------------------------------------------------------------------------------
40m0159 06451 640710015463400330000000	FPLOW:  D[CONST 27.] ACSEL[AC+1] ALU[AC-D] DEST[AC AR] SHORT $
40m0159 06452 530140014621416010000000	        D[CONST 1] ROT[7] ACSEL[AC+1] ALU[D&AC] COND[-OBUS=0] JUMP[ZLOW] C550 $
40m0159 06453 510140004171066330000000	        D[MEM] ROT[27.] MASK[27.] DEST[Q] COND[OBUS=0] JUMP[ZLOW] C550 $
40m0159 06454 640700001571466440000000	        D[AR] ROT[27.] ACSEL[AC+1] DEST[AC] SHORT $
40m0159 06455 640700011621466100000000	        D[MASK 8] ROT[27.] ALU[D&AC] ACSEL[AC+1] DEST[AC] SHORT $
40m0159 06456 640160001545400440602027	        ACSEL[AC+1] ALU[QORAC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0159 06457 640160001615400440602027	ZLOW:   ACSEL[AC+1] ALU[0] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;
40m0159                               	;       FLOATING MULTIPLY.  AC&AR BY MEM.
40m0159                               	;
40m0159                               	;*** This code produces non-zero results if MEM=-1.0 and AC=0  !!!    TVR-Jun80
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;A. SUM OF + FORM EXPONENTS -128.+1 TO IR-ADR.  +1 BECAUSE 28
40m0159                               	; STEPS ARE USED TO PROVIDE ONE GUARD DIGIT.
40m0159 06460 640710000171022110000000	FM:     D[AR] MASK[9] ROT[9] DEST[Q AR] NORM$
40m0159                               	                ;Extract the exponent from AC (which was copied into AR)
40m0159 06461 510140014635020010000000	        D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM1] C550 $
40m0159                               	                ;Check sign bit of number.  Nothing special if positive
40m0159 06462 640710010735000110000000	        D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
40m0159                               	                ;Sign is negative, we want the one-complement of the exponent
40m0159                               	                ;field to get the actual exponent.
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

40m0159 06463 640700004171022110000000	FM1:    D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
40m0159                               	                ;Extract the exponent from MEM
40m0159 06464 510140014635020010000000	        D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM2] C550 $
40m0159                               	                ;Check sign bit of number.  Nothing special if positive
40m0159 06465 640700010335000110000000	        D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
40m0159                               	                ;Sign is negative, we want the one-complement of the exponent
40m0159                               	                ;field to get the actual exponent.
40m0159 06466 640700000037000440000000	FM2:    D[AR] ALU[D+Q] CARRY DEST[Q] SHORT $
40m0159                               	                ;Add the two exponents
40m0159                               	                ;+1. FOR GUARD DIGIT.
40m0159 06467 640700214477016010000000	        D[CONST 1] ROT[7] ALU[Q-D] DEST[IR-ADR] SHORT $
40m0159                               	                ;Account for exponent bias.  Put exponent in a safe place.
40m0159                               	;B. BLANK EXPONENTS.
40m0159                               	        BLEXPS[40m0159 06470 511150010561066100006472	        D[MASK 8] ROT[27.] ALU[DORAC] DEST[AR] COND[OBUS<0] JUMP[. + 2] C550 $
40m0159 06471 640710010661066100000000	        D[MASK 8] ROT[27.] ALU[-D&AC] DEST[AR] SHORT $
40m0159 06472 511140004171000440006474	        D[MEM] DEST[Q] COND[OBUS<0] JUMP[. + 2] C550 $
40m0159 06473 640140010275066100006475	        D[MASK 8] ROT[27.] ALU[-D&Q] DEST[Q] JUMP[. + 2] NORM $
40m0159 06474 640700010175066100000000	        D[MASK 8] ROT[27.] ALU[DORQ] DEST[Q] CYLEN[SHORT] $
40m0160                               	]               ;Extend the sign to blank out the exponent field.  We will
40m0160                               	                ;now have perfectly good integers here, of 27 bit magnitude
40m0160                               	                ;(assuming that the numbers were normalized to begin with).
40m0160 06475 640040001615000440000000	        ALU[0] DEST[AC] PUSHJ[TESMUL] NORM $ ;28. STEPS.
40m0160                               	;;;     ALU[Q] DEST[AR] SHORT $ ;FLUSH SIGN IN LO WD.
40m0160 06476 640710010275000070000000	        D[MASK 7] ALU[-D&Q] DEST[Q AR] SHORT $  ;FLUSH SIGN IN LO WD.
40m0160                               	                ;Flush remenants of multiplier in low order part of
40m0160                               	                ;word.  MASK field determined empirically (35-28???)
40m0160 06477 640700000035000440000000	        D[AR] ALU[D+Q] DEST[Q] SHORT $
40m0160                               	                ;Make low order word unsigned.
40m0160 06500 640150000551000440006433	        ALU[AC] DEST[AR] JUMP[FPNAR] NORM $
40m0160                               	
40m0160                               	;28. STEP INTEGER MULTIPLY FOR USE BY FM.
40m0160 06501 640740014571000330000000	TESMUL: D[CONST 27.] LLOAD NORM $       ;LOOP 28 TIMES
40m0160 06502 640140000571000440004077	        JUMP[DOMUL1] NORM $     ;TEST.
40m0160                               	
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;SHORT STYLE FLOATING DIVIDE AC BY MEM.
40m0160                               	; XOR OF DIVISOR&DIVIDEND SIGNS IN AR BIT 0.
40m0160                               	;------------------------------------------------------------------------------
40m0160 06503 640710004721000440000000	FDS:    D[MEM] ALU[D#AC] DEST[AR] SHORT $
40m0160 06504 640700200571002010000000	FDS1:   D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
40m0160 06505 531150000551000440006507	        ALU[AC] DEST[AR] COND[-OBUS<0] JUMP[. + 2] C550 $
40m0160 06506 640710001513000440000000	        ALU[0-AC] DEST[AC AR] SHORT $
40m0160 06507 640701400615000443000000	        ALU[0] DEST[6] DEST-A-MEM NORM $
40m0160 06510 640740014571000340000000	        D[CONST 28.] LLOAD NORM $ 
40m0160                               	                ;Do only a 28-bit divide.
40m0160                               	
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;       Floating Divide
40m0160                               	;
40m0160                               	; DIVIDEND HIGH ORDER WORD IN AR, LOW IN A-MEM[6]. DIVISOR IN MEM.
40m0160                               	; BOTH IN POSITIVE FORM.  IR.35=XOR(DIVIDEND SIGN,DIVISOR SIGN).
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	FD:
40m0160                               	;A. PUT DIVISOR IN + FORM, GET DIVISOR EXPONENT.
40m0160                               	;.1 Shuffle IR.35 into A-MEM[4].
40m0160 06511 640701034571000223000000	        D[IR] MASK[18.] DEST[4] DEST-A-MEM NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

40m0160                               	                ;Save IR-ADR in A-MEM
40m0160 06512 531140004171000440006514	        D[MEM] DEST[Q] COND[-OBUS<0] JUMP[. + 2] C550 $
40m0160                               	                ;Check for negative divisor
40m0160 06513 640704404073000440000000	        D[MEM] ALU[0-D] DEST[Q HOLD] NORM $
40m0160                               	                ;Negate divisor
40m0160 06514 640700204571022100000000	        D[MEM] ROT[9] MASK[8] DEST[IR-ADR] NORM $
40m0160                               	                ;Extract exponent from divisor, store in IR<18:35>
40m0160 06515 640704410675066100000000	        D[MASK 8] ROT[27.] ALU[-D&Q] DEST[HOLD] NORM $
40m0160                               	                ;Extract mantissa from divisor
40m0160                               	;B. Fetch and blank HOW Dividend exponent.
40m0160 06516 640700000171022100000000	        D[AR] ROT[9] MASK[8] DEST[Q] NORM $
40m0160                               	                ;Extract dividend exponent.
40m0160 06517 640700001571000330000000	        D[AR] MASK[27.] DEST[AC] SHORT $
40m0160                               	                ;Extract mantissa from dividend
40m0160                               	;C. Compute resultant exponent.
40m0160 06520 640700034077000220000000	        D[IR] MASK[18.] ALU[Q-D] DEST[Q] SHORT $
40m0160                               	                ;Subtract divisor exponent from dividend exponent
40m0160 06521 640700214435016010000000	        D[CONST 1] ROT[7] ALU[D+Q] DEST[IR-ADR] NORM $
40m0160                               	                ;Include exponent offset
40m0160                               	;D. Move LOW Dividend to Q.
40m0160 06522 640700070171000440000000	        D[16] DEST[Q] SHORT $
40m0160                               	;E. If divisor<=dividend,  shift dividend right, increment the
40m0160                               	        ; resultant exponent.  save diff. in A-MEM[7] for long mode.
40m0160 06523 471141604463000443000000	        D[MEM] ALU[AC-D] DEST[7] DEST-A-MEM COND[-OBUS<0] JUMP[FDAD] C600 $
40m0160                               	;F. Save exp in A-MEM[5]
40m0160 06524 640701234571000443000000	FDSHFT: D[IR] DEST[5] DEST-A-MEM NORM $
40m0160 06525 640040000571000440002170	        PUSHJ[DODIV4] NORM $    
40m0160                               	         ;Do the divide. Result DOES NOT have signs adjusted.
40m0160                               	;G. Save remainder in A-MEM[6], put quotient in AC, AR; put 0 in Q.
40m0160 06526 640701400551000443000000	        ALU[AC] DEST[6] DEST-A-MEM NORM $
40m0160 06527 640710001555000440000000	        ALU[Q] DEST[AC AR] SHORT $
40m0160 06530 640700000215000440000000	        ALU[0] DEST[Q] SHORT $
40m0160                               	;H. Prepare to round 28. bit result.
40m0160 06531 640700002145000010000000	        ALU[SH-AC] MASK[1] DEST[D4] SHORT $
40m0160                               	         ;Shift AC,Q rt 1 bit
40m0160 06532 640040264531000440006433	        D[15] ALU[D-1] DEST[IR-ADR] NORM PUSHJ[FPNAR] $ 
40m0160                               	         ;Move exp for FPNAR, normalize and insert exponent into quotient.
40m0160 06533 510300060571000010000000	        D[14] MASK[1] C550 OBUS=0 POPJ $
40m0160                               	         ;Done if positive result.
40m0160 06534 640300001513000440000000	        ALU[0-AC] DEST[AC] NORM POPJ $
40m0160                               	         ;Negate quotient.
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;HERE WHEN DIVIDEND IS >= DIVISOR.  SHIFT DIVIDEND RIGHT
40m0160                               	; AND INCREMENT RESULTANT AC.  THIS WILL ALLOW DIVIDE TO
40m0160                               	; SUCCEED IF BOTH DIVISOR & DIVIDEND WERE NORMALIZED
40m0160                               	; AND DIVISOR <> 0.
40m0160                               	;------------------------------------------------------------------------------
40m0160 06535 640700002145000020000000	FDAD:   ALU[SH-AC] MASK[2] DEST[D4] SHORT $
40m0160 06536 640140234433000220006524	        D[IR] MASK[18.] ALU[D+1] DEST[IR-ADR] JUMP[FDSHFT] NORM $
40m0160                               	
40m0160                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

41m0160                               	;ADJSP1 ADJSP2 DMOVE2 DMOVN2 DMOVM2 DMVNM2 DMVNM3 DMVNM4 DMVNM5 KAFIXP KAFIXN FIXR1
41m0160                               	 KIFIX1 FIXRN KIFIXN FIXER FIXER1 FIXER2 FIXER3
41m0160                               	;
41m0160                               	;Strays from KI instructions
41m0160                               	;
41m0160                               	
41m0160                               	.REPEAT XUCODE [
41m0160                               	 .USE[XLIST
41m0160                               	 LIST ] ;Squeeze this stuff into the space vacated by MBOOT.
41m0160                               	    ]
41m0160                               	;(ADJSP continued)
41m0160                               	;Left result is negative.  Check right side.
41m0160 05002 640710034421000220000000	ADJSP1: D[IR] MASK[22] ALU[D+AC] DEST[AR] NORM $
41m0160                               	                ;Add right half
41m0160 05003 640700010275000220000000	        D[MASK 22] ALU[-D&Q] DEST[Q] SHORT $
41m0160                               	                ;Isolate left half
41m0160 05004 640710001175000220000000	        D[AR] MASK[22] ALU[DORQ] DEST[O_AC AR] NORM $
41m0160                               	                ;Merge halves and store
41m0160 05005 533160034571000440602027	        D[IR] COND[-OBUS18] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] C550 $
41m0160                               	                ;If E was positive, it wasn't an overflow (just a bad idea)
41m0160                               	                ;Start fetching next instruction
41m0160 05006 511140000571000440002026	        D[AR] COND[OBUS<0] JUMP[MAIN] C550 $
41m0160                               	                ;If original was negative, we're OK.  Start doing next
41m0160                               	                ;instruction if no sign changed in left half
41m0160 05007 640140000571000440004742	        JUMP[PDLO6] NORM $
41m0160                               	                ;ADJSP got a PDLOV
41m0160                               	;ADJSP left result positive
41m0160 05010 640700010275000220000000	ADJSP2: D[MASK 22] ALU[-D&Q] DEST[Q] SHORT $
41m0160                               	                ;Isolate left half
41m0160 05011 000710001175000220000000	        D[AR] MASK[22] ALU[DORQ] DEST[O_AC AR] $
41m0160                               	                ;Merge halves and store
41m0160 05012 513720034571000440600000	        D[IR] COND[OBUS18] SPEC[MA_PC] DEST[MA] C550 $
41m0160                               	                ;If E was negative, it wasn't an overflow (just a bad idea)
41m0160                               	                ;Start fetching next instruction
41m0160 05013 531140000571000440002027	        D[AR] COND[-OBUS<0] JUMP[MAIN1] C550 $
41m0160                               	                ;If original was positive, we're OK.  Start doing next
41m0160                               	                ;instruction if no sign changed in left half
41m0160 05014 640140000571000440004742	        JUMP[PDLO6] NORM $
41m0160                               	                ;ADJSP got a PDLOV
41m0160                               	
41m0160                               	;(DMOVE continued)
41m0160 05015 640720024433000440000000	DMOVE2: D[MA] ALU[D+1] DEST[MA] NORM $  ;Fetch second word
41m0160 05016 640706000550400440020000	        FIXM1 $                 ;Complete fetch
41m0160 05017 640160005571400440602027	        ACSEL[AC+1] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
41m0160                               	                ;Put it in the second AC and start next instruction
41m0160                               	
41m0160                               	;(DMOVN continued)
41m0160 05020 640720024433000440000000	DMOVN2: D[MA] ALU[D+1] DEST[MA] NORM $  ;Fetch second word
41m0160 05021 640706000550400440020000	        FIXM1 $ ;Complete fetch
41m0160 05022 640720005473400440600000	        ACSEL[AC+1] D[MEM] ALU[0-D] DEST[AC MA] SPEC[MA_PC] CYLEN[FIXM+1] $
41m0160                               	                ;Negate low order word and put it in the second AC
41m0160                               	                ;Start next instruction fetch (Note that DEST[MA] is
41m0160                               	                ;really associated with SPEC[MA_PC])
41m0160                               	                ;*** Is FIXM+1 really the right thing???
41m0160                               	        ACSEL[AC+1] D[MASK 1] ROT[35.] ALU[-D&AC] DEST[AC]
41m0160 05023 670140011661506010002027	                        COND[-OBUS=0] JUMP[MAIN1] NORM $
41m0160                               	                ;Clear stupid bit 0.
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

41m0160                               	                ;If the low order part is non-zero, we're done
41m0160 05024 500140001413000441202027	        ACSEL[AC] ALU[AC+1] DEST[AC] SPEC[CRYOV] JUMP[MAIN1] C550 $
41m0160                               	                ;Increment high order word and we're finally done.
41m0160                               	
41m0160                               	;(DMOVEM continued)
41m0160                               	        .PAIR
41m0160                               	. \ 2 + .
41m0161 05026 640700005571000440000000	]DMOVM2:        CYLEN[MEMSTO] ACSEL[AC] D[MEM] DEST[AC] NORM $
41m0161                               	                ;Write it also in the AC
41m0161 05027 640720024433000440000000	        CYLEN[MEMSTO] D[MA] ALU[D+1] DEST[MA] $
41m0161                               	                ;Setup to write second word
41m0161 05030 662104200551400440002032	        ACSEL[AC+1] ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
41m0161                               	                ;Write secord word.
41m0161                               	
41m0161                               	;(DMOVNM continued)
41m0161 05031 640700000113400440000000	DMVNM2: ACSEL[AC+1] ALU[0-AC] DEST[Q] SHORT $
41m0161                               	                ;Negate low order word.
41m0161                               	        ACSEL[AC+1] D[MASK 1] ROT[35.] ALU[-D&Q] DEST[Q]
41m0161 05032 670140010275506010000000	                        COND[-OBUS=0] JUMP[DMVNM4] NORM $
41m0161                               	                ;Clear stupid bit 0.
41m0161                               	                ;If the low order part is non-zero, no change needed to
41m0161                               	                ;high order word.
41m0161                               	        D[AR] ALU[AC+1] DEST[AR STRT-WRT] SPEC[CRYOV]
41m0161 05033 662154000413000441200000	                COND[-MA-AC] JUMP[DMVNM5] NORM $
41m0161                               	                ;Increment high order word and start first store
41m0161 05034 000140005570400440000000	DMVNM3: ACSEL[MA] D[MEM] DEST[AC] JUMP[DMVNM5] $
41m0161                               	                ;Store is to an AC, write into 2901.
41m0161 05035 002144000571000440005034	DMVNM4: DEST[STRT-WRT] COND[MA-AC] JUMP[DMVNM3] $
41m0161                               	                ;Start first store.  Jump if to an AC
41m0161 05036 640720024433000440000000	DMVNM5: D[MA] ALU[D+1] DEST[MA] NORM $
41m0161                               	                ;Finish write.  Note that due to FIXM2, we don't have to
41m0161                               	                ;worry about map faults.
41m0161                               	                ;Prepare for secord write
41m0161 05037 662104200555000440002032	        ALU[Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
41m0161                               	                ;Do final write (low order word into (E+1))
41m0161                               	
41m0161                               	;KAFIX (Opcode 247) continued
41m0161                               	;Positive number to fix
41m0161 05040 030040034171066110000000	KAFIXP: D[IR] ROT[27.] MASK[9.] DEST[Q] COND[-OBUS=0] PUSHJ[FIXER] $
41m0161                               	                ;Extract exponent adjustment factor and do fixing
41m0161 05041 640160001555000440602027	        ACSEL[AC] ALU[Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0161                               	                ;Put result into AC and we're done
41m0161                               	;Negative number to fix
41m0161 05042 030040034171066110000000	KAFIXN: D[IR] ROT[27.] MASK[9.] DEST[Q] COND[-OBUS=0] PUSHJ[FIXER] $
41m0161                               	                ;Extract exponent adjustment factor and do fixing
41m0161                               	;;;     ACSEL[AC] D[MASK R] ALU[D/#Q] DEST[AC MA]       ;*** Assembler loses!
41m0161                               	        ACSEL[AC] D[2] MASK[R] ALU[D/#Q] DEST[AC MA]    ;Sigh...
41m0161 05043 640160011775001000602027	                        SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0161                               	                ;Put sign extended result into AC and we're done
41m0161                               	
41m0161                               	;(FIXR continued)
41m0161 05044 511140004571000440000000	FIXR1:  D[MEM] COND[OBUS<0] JUMP[FIXRN] C550 $
41m0161                               	                ;Round different directions
41m0161 05045 640050015435074200006401	        D[CONST 20] ROT[30.] ALU[D+Q] DEST[AC AR] PUSHJ[FADSUB] NORM $
41m0161                               	                ;Positive. Finish making constant 0.5 and add it
41m0161 05046 640700014171000330000000	        D[CONST 33] DEST[Q] SHORT $
41m0161                               	                ;Start making magic constant
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

41m0161 05047 640154400551000440000000	        ALU[AC] DEST[AR HOLD] JUMP[FIXR2] NORM $
41m0161                               	                ;Setup for FIXER.  Rest is same as KIFIX
41m0161                               	;       ---
41m0161 05050 640050015537074600006401	FIXRN:  D[CONST 60] ROT[30.] ALU[D-Q] DEST[AC AR] PUSHJ[FADSUB] NORM $
41m0161                               	                ;Negative. Finish making constant -0.5 and add it
41m0161 05051 640700014171000330000000	        D[CONST 33] DEST[Q] SHORT $
41m0161                               	                ;Start making magic constant
41m0161 05052 640700014175014020000000	        D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] SHORT $
41m0161                               	                ;Finish making magic constant
41m0161 05053 640054400513000440000000	        ALU[0-AC] DEST[AR HOLD] PUSHJ[FIXER] NORM $
41m0161                               	                ;Setup for FIXER
41m0161 05054 640160001517000440602027	        ACSEL[AC] ALU[0-Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0161                               	                ;Negate it back again and start next instruction
41m0161                               	;       ---
41m0161                               	;(KIFIX continued)
41m0161 05055 511150004571000440000000	KIFIX1: D[MEM] DEST[AR] COND[OBUS<0] JUMP[KIFIXN] C550 $
41m0161                               	                ;Load up things for FIXER, check for positive mantissa
41m0161 05056 640040014175014020000000	FIXR2:  D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] PUSHJ[FIXER] NORM $
41m0161                               	                ;Finish making magic constant and do fix.
41m0161 05057 640160001555000440602027	        ACSEL[AC] ALU[Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0161                               	                ;Put result into AC and we're done
41m0161                               	;       ---
41m0161                               	;       ---
41m0161 05060 640700014175014020000000	KIFIXN: D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] SHORT $
41m0161                               	                ;Finish making magic constant
41m0161 05061 640054404473000440000000	        D[MEM] ALU[0-D] DEST[HOLD AR] PUSHJ[FIXER] NORM $
41m0161                               	                ;ABS to both MEM and AR.  Fix the number
41m0161 05062 640160001517000440602027	        ACSEL[AC] ALU[0-Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0161                               	                ;Negate it back again and start next instruction
41m0161                               	
41m0161                               	
41m0161                               	;Fix a number (without sign extension) in MEM, AR=ABS(MEM), Q=magic number
41m0161                               	;(233 for normal fix)
41m0161                               	FIXER:  D[AR] ROT[9] MASK[9] ALU[D-Q] DEST[ROTR Q]
41m0161 05063 511141200137022110000000	                        COND[OBUS<0] JUMP[FIXER2] C550 $
41m0161                               	                ;Calculate number of positions to move
41m0161                               	                ;Jump if we'll be shifting right (n<2^26)
41m0161 05064 640701414435000330000000	        D[CONST 27.] ALU[D+Q] DEST[MASKR] NORM $
41m0161                               	                ;Construct appropriate mask
41m0161 05065 640704404571000330000000	        D[MEM] MASK[27.] DEST[HOLD] NORM $
41m0161                               	                ;Flush exponent, our mask won't reach.
41m0161 05066 511140014477000110000000	        D[CONST 9.] ALU[Q-D] COND[OBUS<0] JUMP[FIXER1] C550 $
41m0161                               	                ;Check for overflow
41m0161                               	;;; Set overflow here.  What kind?  (We can live without it for KAFIX, since it
41m0161                               	;;; never did check, but when KIFIX is done, this will have to be corrected.)
41m0161 05067 640040014555106010006147	        D[CONST 1] ROT[35.] ALU[Q] PUSHJ[QORCRY] NORM $
41m0161                               	                ;Set overflow flag.
41m0161 05070 640701414571000440000000	        D[CONST 44] DEST[MASKR] NORM $
41m0161                               	                ;For those losers who want to see some of the number...
41m0161                               	;Now that we know how much to shift things, do it and return.
41m0161 05071 640300004171201000000000	FIXER1: D[MEM] ROT[R] MASK[R] DEST[Q] NORM POPJ $
41m0161                               	                ;Gee, that was fast.
41m0161                               	;Negative, shift count, the easy case.
41m0161 05072 011141414435000330000000	FIXER2: D[CONST 27.] ALU[D+Q] DEST[MASKR] COND[OBUS<0] JUMP[FIXER3] $
41m0161                               	                ;Construct appropriate mask.  If !x!<1, return zero
41m0161 05073 640141214435000440005071	        D[CONST 36.] ALU[D+Q] DEST[ROTR] JUMP[FIXER1] NORM $
41m0161                               	                ;Hardware doesn't believe in negative shift counts
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

41m0161                               	;Number is fractional, i.e. shift would go off the end.  Return zero
41m0161 05074 640301400215000440000000	FIXER3: ALU[0] DEST[Q MASKR] SHORT POPJ $
41m0161                               	                ;Just return zero.  Set mask just in case
41m0161                               	
41m0161                               	.REPEAT XUCODE [
41m0161                               	  .USE[41m0161                               	XLIST
41m0161                               	 LIST ]   ];FLTR, continued
41m0161 06537 640700014171000330000000	FLTR1:  D[CONST 33] DEST[Q] SHORT $
41m0161 06540 640700214575014020000000	        D[CONST 2] ROT[6] ALU[DORQ] DEST[IR-ADR] NORM $
41m0161                               	                ;Make magic constant for exponent
41m0161 06541 000040000215000440006433	        ALU[0] DEST[Q] PUSHJ[FPNAR] $
41m0161                               	                ;Clear low order word
41m0161                               	                ;Normalize and round (happens to have same bit on as FxxR)
41m0161                               	                ;Result goes to AC
41m0161 06542 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
41m0161                               	                ;Start next instruction fetch
41m0161                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

42m0161                               	
42m0161                               	
42m0161                               	  .REPEAT WK [
42m0161                               	
42m0161                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

43m0161                               	
43m0161                               	;;; Device 6 service assembled regardless of whether Tymnet, DR-11,
43m0161                               	;;; or neither is being supported.
43m0161                               	
43m0161                               	;;; Define subdevices of the CFT board for the TYMNET interface
43m0161                               	;;; The first two, if written, reset the interrupt requests.
43m0161                               	
43m0161                               	  .REPEAT OTP [
43m0161                               	;OTP
43m0161                               	
43m0161                               	  .REPEAT NTP [
43m0161       17	TNODIFS = 17    ;OUTPUT DONE INTERRUPT FF SUBSEL = REQ B
43m0161       16	TNIRIFS = 16    ;INPUT READY INTERRUPT FF SUBSEL = REQ A.
43m0161       15	TYM.LD = 15     ;MAPF value for loading output register.
43m0161       5	TYM.RD = 5      ;MAPF value for reading input register.
43m0161                               	  ];NTP
43m0161                               	
43m0161                               	;;; Location 2141 is where device 6 interrupts come.
43m0161                               	
43m0161       6543	TYMFOO = .
43m0161                               	        .ORG[43m0161                               	XLIST
43m0162                               	 LIST ] ;Prepare to call MAPOFF by re-loading DEV-ADR.
43m0162 02141 640141614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM JUMP[TNI] $       
43m0162                               	
43m0162                               	        .USE[XLIST
43m0162                               	 LIST ]
43m0162                               	
43m0162                               	.REPEAT 1 - TYMNET - DR11P [
43m0162                               	1 - TYMNET - DR11P
43m0162                               	
43m0162                               	;;; Device 6 control register hacking.
43m0162                               	;;; Register 1 in device 6's A memory contains the state of the
43m0162                               	;;; control register, since we can't read it back.
43m0162                               	
43m0162                               	;;; Q contains mask for bits not to be changed.  Remaining bits are cleared.
43m0162                               	;;; On return, Q has new value of output register and AR is zeroed.
43m0162 06543 640150000615000440000000	DEV6CL: ALU[0] DEST[AR] NORM JUMP[DEV6ST] $
43m0162                               	
43m0162                               	;;; Q contains mask for bits not to be changed.
43m0162                               	;;; Remaining bits are loaded from AR.
43m0162                               	;;; On return, Q has new value of output register.
43m0162 06544 640701614571000060000000	DEV6ST: D[CONST 6] DEST[DEV-ADR] NORM $
43m0162                               	;;; Enter here if device address already set up to 6.
43m0162 06545 640700044235000440000000	DEV6ST1: D[11] ALU[D&Q] DEST[Q] NORM $                  ;Get AMEM(1), mask it.
43m0162 06546 640702200175000443600000	DEV6ST2: D[AR] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] NORM $       ;Or in new data
43m0162 06547 440300200555000443150000	        MAPF[TYM.LD] ALU[Q] DEST[1] DEST-A-MEM CYLEN[IOB-OUT] POPJ $
43m0162                               	
43m0162                               	.REPEAT TYMNET [
43m0162                               	TYMNET
43m0162                               	.REPEAT DR11P [
43m0162                               	.INSERT DR11.SLO

SLOE   Oct  30, 2543 00:00:00  file DSK:DR11.SLO  --  of -- f2sym

01m0001                               	;;; DR-11 Foonly microcode.
01m0001                               	;;; Modified from Tymnet microcode March 1981 DAM
01m0001                               	
01m0001                               	;A-MEM USAGE.
01m0001                               	; 0: STANDARD.  (microcode interrupt dispatch address)
01m0001                               	; 1: STATE OF OUTPUT FFS FOR DEV6ST (SEE CFTNET PRINT)
01m0001                               	; 2: INPUT HALFWORD COUNT
01m0001                               	; 3: INPUT HALFWORD POINTER
01m0001                               	; 4: OUTPUT HALFWORD COUNT
01m0001                               	; 5: OUTPUT HALFWORD POINTER
01m0001                               	; 6: INPUT BUFFER,,OUTPUT BUFFER
01m0001                               	; 7: B0-2, STATE OF MAP BEFORE INT; B3-35, INP REG AT INT START
01m0001                               	
01m0001                               	;The buffers in register 6 are used to cut the number of memory
01m0001                               	;cycles in half.
01m0001                               	;The counts are zero when the corresponding process is idle.
01m0001                               	
01m0001                               	
01m0001                               	;MAIN MEMORY LOCATIONS:
01m0001                               	; Refer to DR11.PROTOCOL
01m0001                               	
01m0001                               	;DR11C FLAG NAMES.  (FIELD VALUES).
01m0001       2	TNODIBN = 2     ;OUTPUT DONE ROTATE AMOUNT (INPUT) = REQ B.
01m0001       3	TNIRIBN = 3     ;INPUT READY ROTATE AMOUNT (INPUT) = REQ A.
01m0001       6	TNODOBN = 6     ;OUTPUT DONE ROTATE AMOUNT (OUTPUT) = CSR1.
01m0001       7	TNIROBN = 7     ;INPUT READY ROTATE AMOUNT (OUTPUT) = CSR0.
01m0001       2	TNODENB = 2     ;TNODIBN INTERRUPT ENABLE
01m0001       3	TNIRENB = 3     ;TNIRIBN INTERRUPT ENABLE
01m0001                               	
01m0001                               	;TNODIBN and TNIRIBN are the edge versions, not the versions
01m0001                               	;that come straight from the 11.  In loop-back mode, pulsing
01m0001                               	;TNODOBN causes TNODIBN to become 1, and pulsing TNIROBN causes
01m0001                               	;TNIRIBN to become 1.  TNODIBN is cleared by writing to subdevice
01m0001                               	;TNODIFS, and TNIRIBN is cleared by writing to subdevice TNIRIFS.
01m0001                               	
01m0001                               	;Microcode interrupt from device 6 comes here.  This will be due
01m0001                               	;to input ready or output done having been pulsed by the 11,
01m0001                               	;and the corresponding enable bit set in the output register.
01m0001                               	
01m0001                               	;We have to turn the map off in order to reference exec memory,
01m0001                               	;because there is no hope at all for the getting the damned
01m0001                               	;map-miss microcode to win due to the way the machine is designed.
01m0001                               	;This means we can't address pages which are locked down but not
01m0001                               	;in the same physical page as their virtual address.
01m0001                               	
01m0001                               	TNI:    ;;Save map state in A-MEM[7].0-2 & turn map off.
01m0001 06550 640042400571000443405402	        DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] NORM PUSHJ[MAPOFF] $
01m0001 06551 440710034571000030100000	        D[IR] MASK[3] DEST[AR] MAPF[10] CYLEN[IOB-OUT] $ ;MAPF,CYLEN for MAPOFF
01m0001 06552 640700000171102440000000	        D[AR] ROT[41] DEST[Q] SHORT $
01m0001 06553 640701614571000063400000	        D[CONST 6] DEST[DEV-ADR] SPEC[IOB-IN] NORM $    ;Back to device 6
01m0001                               	        ;;The map state is in Q.  Read the DR-11 state, put that
01m0001                               	        ;;in AR and the both of them in Q and A-MEM[7].
01m0001 06554 140710030571000410050000	        MAPF[TYM.RD] D[IOD] MASK[41] DEST[AR] CYLEN[IOB-IN] $
01m0001 06555 640701600175000443000000	        D[AR] ALU[DORQ] DEST[Q 7] DEST-A-MEM NORM $
01m0001                               	        ;;Is the output-done edge latch on?
01m0001 06556 531140074571102440000000	        D[17] ROT[35. - TNODIBN] COND[-OBUS<0] JUMP[TNI1] C550 $
01m0001                               	        ;;Yes, run the output channel.
SLOE   Oct  30, 2543 00:00:00  file DSK:DR11.SLO  --  of -- f2sym

01m0001                               	        D[14] ALU[D-1] DEST[AR]                 ;Decrement the halfword count
01m0001 06557 451150060531000440000000	                COND[OBUS<0] JUMP[DROIDL] C600 $        ; and check for idle.
01m0001 06560 640701000571000443000000	        D[AR] DEST[4] DEST-A-MEM NORM $         ;Write back decremented WC
01m0001                               	        ;;Channel active, clear flag from 11 and see which half of word.
01m0001 06561 510140064571000010000000	        D[15] MASK[1] COND[OBUS=0] JUMP[DRONWD] C550 $
01m0001 06562 640050070571000200000000	        D[16] MASK[16.] DEST[AR] PUSHJ[DRSEND] NORM $   ;Output second halfword
01m0001 06563 640710064433000440000000	        D[15] ALU[D+1] DEST[AR] NORM $          ;Increment pointer
01m0001 06564 640141200571000443000000	TNI0:   D[AR] DEST[5] DEST-A-MEM JUMP[TNI1] NORM $
01m0001                               	
01m0001                               	DROSTP: ;; Turn off output interrupt enable (bit 33)
01m0001 06565 640040014371004010006543	        D[CONST 1] ROT[TNODENB] ALU[NOTD] DEST[Q] PUSHJ[DEV6CL] NORM $
01m0001                               	TNI1:   ;;Is the input-ready edge latch on?
01m0001 06566 531140074571100440000000	        D[17] ROT[35. - TNIRIBN] COND[-OBUS<0] JUMP[TNI9] C550 $
01m0001                               	        ;;Yes, run the input channel.  Copy input data into AR.
01m0001 06567 640710074571070200000000	        D[17] ROT[34] MASK[20] DEST[AR] NORM $
01m0001                               	        ;;Check for packet in progress or start of new packet.
01m0001 06570 510140050571000440000000	        D[12] ALU[D] COND[OBUS=0] JUMP[DRINPK] C550 $
01m0001                               	        ;;Check for need to store a word
01m0001 06571 511160054571106440000000	        D[13] ROT[43] DEST[MA] COND[OBUS<0] JUMP[DRINWD] C550 $
01m0001                               	        ;;Just buffer this halfword
01m0001 06572 640700070171000220000000	        D[16] MASK[18.] DEST[Q] NORM $
01m0001 06573 640041400575050443000000	        D[AR] ROT[20.] ALU[DORQ] DEST[6] DEST-A-MEM PUSHJ[DRTAKE] NORM $
01m0001                               	        ;;Increment pointer, decrement counter
01m0001 06574 640710054433000440000000	        D[13] ALU[D+1] DEST[AR] NORM $
01m0001 06575 640700600571000443000000	TNI2:   D[AR] DEST[3] DEST-A-MEM NORM $
01m0001 06576 640710050531000440000000	        D[12] ALU[D-1] DEST[AR] NORM $
01m0001 06577 470140400571000443000000	        D[AR] DEST[2] DEST-A-MEM COND[-OBUS=0] JUMP[TNI9] C600 $
01m0001                               	        ;;That was the end of a packet, deliver to 10
01m0001 06600 531160054571106440000000	        D[13] ROT[43] DEST[MA] COND[-OBUS<0] JUMP[TNI3] C550 $
01m0001                               	        ;;Oops, there is one halfword still to be stored
01m0001 06601 640704270571000000200000	        D[16] SPEC[LEFT] DEST[MEMSTO] NORM $
01m0001                               	TNI3:   ;;Read & clear input packet in progress and add to input done list
01m0001 06602 640040014171000040000000	        D[CONST 4] DEST[Q] PUSHJ[TNRCW] CYLEN[MEMSTO] $
01m0001 06603 640700004171000220000000	        D[MEM] MASK[18.] DEST[Q] SHORT $
01m0001 06604 640704200615000440000000	        ALU[0] DEST[MEMSTO] NORM $
01m0001 06605 640060014571014200000000	        D[CONST 20] ROT[6] ALU[D] DEST[MA] PUSHJ[DRPUSH] CYLEN[MEMSTO] $
01m0001                               	TNI9:   ;;Done: restore state of map and exit back to MAIN
01m0001 06606 640702274571006030000000	        D[17] ROT[3] MASK[3] DEST[IOD] CYLEN[MEMSTO] $
01m0001 06607 640141600615000443605401	        ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] JUMP[MPOFF1] NORM $
01m0001                               	
01m0001                               	DRINWD: ;;Input channel has two halfwords to store
01m0001 06610 640700000171010440000000	        D[AR] ROT[4] DEST[Q] SHORT $
01m0001 06611 640044270575000000200000	        D[16] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] PUSHJ[DRTAKE] NORM $
01m0001 06612 640150054433000440006575	        D[13] ALU[D+1] DEST[AR] JUMP[TNI2] NORM $
01m0001                               	
01m0001                               	DRINPK: ;;Do nothing if interrupt not enabled
01m0001 06613 531140044571100440006606	        D[11] ROT[35. - TNIRENB] COND[-OBUS<0] JUMP[TNI9] C550 $
01m0001                               	        ;;AR has length of next packet 11 is trying to send
01m0001 06614 510140000571000440000000	        D[AR] COND[OBUS=0] JUMP[DRINP9] C550 $;Ignore zero length
01m0001                               	        ;;Check input ready list, shut down if empty
01m0001 06615 640040014171000020000000	        D[CONST 2] DEST[Q] PUSHJ[TNRCW] NORM $
01m0001                               	        D[MEM] MASK[18.] DEST[IR-ADR]           ;Save last pkt in IR RT
01m0001 06616 510140204571000220000000	                COND[OBUS=0] JUMP[DRISTP] C550 $
01m0001                               	        ;;Get header of first packet on list
01m0001 06617 640060004571044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[MA] PUSHJ[CFIXM0] NORM $
01m0001                               	        ;;Compare length field in header against length from 11,
01m0001                               	        ;;ignore it if too large (this aids resynchronization after booting)
SLOE   Oct  30, 2543 00:00:00  file DSK:DR11.SLO  --  of -- f2sym

01m0001 06620 640700004171044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[Q] SHORT $
01m0001 06621 451140000477000440000000	        D[AR] ALU[Q-D] COND[OBUS<0] JUMP[DRINP9] C600 $
01m0001                               	        ;;Q gets new list header: cdr of that packet,,old last
01m0001 06622 640700034171000220000000	        D[IR] MASK[18.] DEST[Q] SHORT $
01m0001 06623 640700004175044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[Q] SHORT $
01m0001                               	        ;;Smash packet's header with incoming length and 0 cdr
01m0001 06624 640704200571044440000000	        D[AR] ROT[18.] DEST[MEMSTO] NORM $
01m0001                               	        ;;Store packet length in A memory
01m0001 06625 640700400571000443000000	        D[AR] DEST[2] DEST-A-MEM NORM $         ;Save word count
01m0001                               	        ;;Set up the input halfword pointer to point to it.
01m0001 06626 640710024433000220000000	        D[MA] MASK[18.] ALU[D+1] DEST[AR] CYLEN[MEMSTO] $
01m0001 06627 640700600571002443000000	        D[AR] ROT[1] DEST[3] DEST-A-MEM NORM $
01m0001                               	        ;;Cdr the ready list
01m0001                               	        D[MASK 18.] ROT[18.] ALU[D&Q] DEST[AR]
01m0001 06630 510150010635044220000000	                COND[OBUS=0] JUMP[DRINP1] C550 $
01m0001 06631 640710000555000440000000	        ALU[Q] DEST[AR] SHORT $
01m0001 06632 640040014171000020000000	DRINP1: D[CONST 2] DEST[Q] PUSHJ[TNRCW] NORM $
01m0001 06633 640704200571000440000000	        D[AR] DEST[MEMSTO] NORM $
01m0001                               	        ;; Store the packet into packet in progress
01m0001 06634 640040014171000040000000	        D[CONST 4] DEST[Q] PUSHJ[TNRCW] CYLEN[MEMSTO] $
01m0001 06635 640704254531106440000000	        D[13] ROT[43] ALU[D-1] DEST[MEMSTO] NORM $
01m0001                               	DRINP9: ;;Take input from 11 and return
01m0001 06636 640040000571000440000000	        PUSHJ[DRTAKE] CYLEN[MEMSTO] $
01m0001 06637 640140000571000440006606	        JUMP[TNI9] NORM $
01m0001                               	
01m0001                               	DRISTP: ;;No place to put this packet, stop input channel
01m0001                               	        ;; Turn off input interrupt enable (bit 32)
01m0001 06640 640040014371006010006543	        D[CONST 1] ROT[TNIRENB] ALU[NOTD] DEST[Q] PUSHJ[DEV6CL] NORM $
01m0001                               	        ;;Clear packet word count, the -11 is still sending it
01m0001 06641 640140400615000443006606	        ALU[0] DEST[2] DEST-A-MEM JUMP[TNI9] NORM $
01m0001                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:DR11.SLO  --  of -- f2sym

02m0001                               	
02m0001                               	;Output channel needs to fetch another word
02m0001                               	DRONWD: ;;Start read of word, also finish clearing output-done flag
02m0001 06642 640060064571106220000000	        D[15] ROT[43] MASK[18.] DEST[MA] PUSHJ[CFIXM0] NORM $
02m0001 06643 640700070171000000200000	        D[16] SPEC[LEFT] DEST[Q] NORM $         ;Copy input buffer into Q
02m0001                               	        D[MEM] ROT[32.] MASK[16.] ALU[DORQ]     ;Merge second hwd into buf
02m0001 06644 640701404575100203000000	                DEST[6] DEST-A-MEM NORM $
02m0001                               	        D[MEM] ROT[16.] MASK[16.] DEST[AR]      ;Transmit first halfword
02m0001 06645 640050004571040200000000	                PUSHJ[DRSEND] NORM $
02m0001 06646 640150064433000440006564	        D[15] ALU[D+1] DEST[AR] JUMP[TNI0] NORM $       ;Increment pointer
02m0001                               	
02m0001                               	;Here when DR11 says output done and we have no current output packet
02m0001                               	DROIDL: ;;Check interrupt enable.  If 0, don't do anything.
02m0001 06647 531140044571102440006566	        D[11] ROT[35. - TNODENB] COND[-OBUS<0] JUMP[TNI1] C550 $
02m0001                               	        ;;Clean up packet in progress if any.
02m0001 06650 640040014171000050000000	        D[CONST 5] DEST[Q] PUSHJ[TNRCW] NORM $
02m0001 06651 510140004171000220000000	        D[MEM] MASK[18.] DEST[Q] COND[OBUS=0] JUMP[DROI1] C550 $
02m0001 06652 640704200615000440000000	        ALU[0] DEST[MEMSTO] NORM $              ;Store back zero
02m0001                               	        D[CONST 20] ROT[6] ALU[D+1] DEST[MA]    ;Add packet in Q to list
02m0001 06653 640060014433014200000000	                PUSHJ[DRPUSH] CYLEN[MEMSTO] $
02m0001                               	DROI1:  ;;Check output ready list.
02m0001 06654 640040014171000030000000	        D[CONST 3] DEST[Q] PUSHJ[TNRCW] CYLEN[MEMSTO] $
02m0001 06655 510140004571000440006565	        D[MEM] COND[OBUS=0] JUMP[DROSTP] C550 $ ;Shut down if empty
02m0001                               	        ;;Get header of first packet on list
02m0001 06656 640060004171044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[Q MA] PUSHJ[CFIXM0] NORM $
02m0001                               	        ;;Set up the output halfword pointer to point to it.
02m0001 06657 640710000417000440000000	        ALU[Q+1] DEST[AR] SHORT $
02m0001 06660 640701200571002443000000	        D[AR] ROT[1] DEST[5] DEST-A-MEM NORM $
02m0001                               	        ;;Save the halfword count, and send it to the 11.
02m0001 06661 640051004571044203000000	        D[MEM] ROT[18.] MASK[16.] DEST[AR 4] DEST-A-MEM PUSHJ[DRSEND] NORM $
02m0001                               	        ;;Save the cdr: second packet on list.
02m0001 06662 640710004571044000200000	        D[MEM] ROT[18.] SPEC[LEFT] DEST[AR] SHORT $
02m0001                               	        ;;Clobber the cdr to zero.
02m0001 06663 640704204571000000200000	        D[MEM] SPEC[LEFT] DEST[MEMSTO] NORM $
02m0001                               	        ;;Cdr the ready list
02m0001 06664 640040014171000030000000	        D[CONST 3] DEST[Q] PUSHJ[TNRCW] CYLEN[MEMSTO] $
02m0001 06665 510140000171000440000000	        D[AR] DEST[Q] COND[OBUS=0] JUMP[DROI2] C550 $
02m0001 06666 640144204575000220000000	        D[MEM] MASK[18.] ALU[DORQ] DEST[MEMSTO] NORM JUMP[DROI3] $
02m0001 06667 640704200615000440000000	DROI2:  ALU[0] DEST[MEMSTO] NORM $              ;empty
02m0001                               	DROI3:  ;; Store the packet into packet in progress
02m0001 06670 640040014171000050000000	        D[CONST 5] DEST[Q] PUSHJ[TNRCW] CYLEN[MEMSTO] $
02m0001 06671 000144264531106440006566	        D[15] ROT[43] ALU[D-1] DEST[MEMSTO] JUMP[TNI1] $
02m0001                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:DR11.SLO  --  of -- f2sym

03m0001                               	
03m0001                               	;;; Subroutines
03m0001                               	
03m0001                               	;AR<20:35> contains 16 bits to go out the DR-11, rest of AR is zero
03m0001                               	;This clears the output-done flag then sends new data then pulses the
03m0001                               	;input-ready line as seen by the 11.
03m0001 06672 640710000571020443600000	DRSEND: D[AR] ROT[8] DEST[AR] SPEC[IOB-OUT] NORM $ ;Align as hardware wants
03m0001                               	        ;; Output the data and drop TNIROBN (input ready seen by 11)
03m0001 06673 440700010171000100170000	        D[MASK 8] DEST[Q] MAPF[TNODIFS] CYLEN[IOB-OUT] $
03m0001                               	        D[CONST 1] ROT[TNIROBN] ALU[-D&Q] DEST[Q]
03m0001 06674 640040014275016010006545	                PUSHJ[DEV6ST1] NORM $
03m0001                               	        ;; Raise to-11 input ready again and return
03m0001 06675 640150014571016010006546	        D[CONST 1] ROT[TNIROBN] DEST[AR] JUMP[DEV6ST2] NORM $
03m0001                               	
03m0001                               	;;;Take input from 11, smashing Q and AR
03m0001                               	;;;This both clears the ready-for-input interrupt and pulses
03m0001                               	;;;the CSR1 line, telling the 11 to send more input.
03m0001 06676 640710000615000443600000	DRTAKE: ALU[0] DEST[AR] SPEC[IOB-OUT] CYLEN[MEMSTO] $
03m0001                               	        D[MASK 43] ROT[TNODOBN + 1] DEST[Q] PUSHJ[DEV6ST1]
03m0001 06677 440040010171016430166545	                MAPF[TNIRIFS] CYLEN[IOB-OUT] $
03m0001 06700 640150014571014010006546	        D[CONST 1] ROT[TNODOBN] DEST[AR] NORM JUMP[DEV6ST2] $
03m0001                               	
03m0001                               	;Read memory location 2000+Q
03m0001 06701 640720014575014200000000	TNRCW:  D[CONST 20] ROT[6] ALU[DORQ] DEST[MA] NORM $
03m0001 06702 640306000550400440000000	CFIXM0: FIXM0 POPJ $
03m0001                               	
03m0001                               	;Put packet in Q onto list whose header address is in MA
03m0001                               	;Its cdr must already be zero.
03m0001                               	;Location returned to must have CYLEN[MEMSTO]
03m0001 06703 640706000550400440000000	DRPUSH: FIXM0 $
03m0001                               	        ;; Is list empty?
03m0001 06704 510150004571000440000000	        D[MEM] DEST[AR] COND[OBUS=0] JUMP[DRPSH1] C550 $
03m0001                               	        ;; Preserve first, change last
03m0001 06705 640704200575000000200000	        D[AR] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] NORM $
03m0001                               	        ;; Rplacd old last to new last
03m0001 06706 640060000571000220006702	        D[AR] MASK[18.] DEST[MA] PUSHJ[CFIXM0] CYLEN[MEMSTO] $
03m0001 06707 000304204575000000200000	        D[MEM] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] POPJ $
03m0001                               	
03m0001                               	;List was empty, store back Q,,Q
03m0001 06710 640710000555000440000000	DRPSH1: ALU[Q] DEST[AR] SHORT $
03m0001 06711 000304200575044440000000	        D[AR] ROT[18.] ALU[DORQ] DEST[MEMSTO] POPJ $
03m0001                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:DR11.SLO  --  of -- f2sym

04m0001                               	
04m0001                               	;;; IOT Instructions
04m0001                               	;;; It's too much of a pain to make these priveleged, since you have to
04m0001                               	;;; check for USR IOT mode manually.  And the TYMNET ones aren't priveleged.
04m0001                               	;;; We aren't fascist anyway.
04m0001                               	
04m0001                               	TYMAREA:        ;SAVE LOCATION
04m0001                               	
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ];RESET TYMNET
04m0001                               	
04m0001 03710 510140034571032020000000	        D[IR] ROT[13.] MASK[2] COND[OBUS=0] JUMP[DR11R] C550 $
04m0001 03711 530100034571032010000000	        D[IR] ROT[13.] MASK[1] COND[-OBUS=0] LBJUMP[DR11WO] C550 $
04m0001                               	
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ];DIRECT OUTPUT
04m0001                               	
04m0001 03712 640141614571000060000000	        D[CONST 6] DEST[DEV-ADR] JUMP[DR11O] NORM $
04m0001 03713 000700000571000440000000	        NOP $
04m0001                               	
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ];DIRECT INPUT
04m0001                               	
04m0001 03714 640141614571000060000000	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[DR11I] $
04m0001 03715 000700000571000440000000	        NOP $
04m0001                               	
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ];DEBUG (DUMP A-MEMORY)     ((FORMERLY F5DIAG))
04m0001                               	
04m0001 03716 640141614571000060000000	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[DR11DB] $
04m0001 03717 000700000571000440000000	        NOP $
04m0001                               	
04m0001                               	        .USE[XLIST
04m0001                               	 LIST ];RETURN TO MAIN CODE
04m0001                               	
04m0001                               	;;; 744 0,E   (DR11R)  Reset the microcode, and send E to the control register:
04m0001                               	;;;                      30-31  CSR0, CSR1 to 11  (input ready, output done)
04m0001                               	;;;                      32-33  not connected
04m0001                               	;;;                      34-35  interrupt enables (input, output)
04m0001 06712 640710024571004440000000	DR11R:  D[MA] ROT[2] DEST[AR] SHORT $   ;Align control register
04m0001 06713 640040010371004060006544	        D[MASK 6] ROT[2] ALU[NOTD] DEST[Q] PUSHJ[DEV6ST] NORM $
04m0001 06714 640700400615000443000000	        ALU[0] DEST[2] DEST-A-MEM NORM $        ;Reset both halfword counters
04m0001 06715 640701000615000443000000	        ALU[0] DEST[4] DEST-A-MEM NORM $
04m0001 06716 640700600615000443000000	        ALU[0] DEST[3] DEST-A-MEM NORM $        ;Clear other locations only
04m0001 06717 640701200615000443000000	        ALU[0] DEST[5] DEST-A-MEM NORM $        ; to make debugging easier
04m0001 06720 640701400615000443000000	        ALU[0] DEST[6] DEST-A-MEM NORM $        ; ..
04m0001 06721 640700000571000443600000	        SPEC[IOB-OUT] NORM $
04m0001 06722 440700000571000443770000	        MAPF[TNODIFS] SPEC[IOB-OUT] CYLEN[IOB-OUT] $    ;Reset output done flag
04m0001 06723 440140000571000440160000	        MAPF[TNIRIFS] CYLEN[IOB-OUT] JUMP[DR11R1] $     ;Reset input ready flag
04m0001                               	
04m0001                               	        .PAIR
04m0001                               	. \ 2 + .
04m0002                               	];;; 744 2,0   (DR11WO) Wake up the output microcode
04m0002 06724 640140014371004010000000	DR11WO: D[CONST 1] ROT[TNODENB] ALU[NOTD] DEST[Q] JUMP[DR11W] NORM $
04m0002                               	;;; 744 1,0   (DR11WI)  Wake up the input microcode
04m0002 06725 640700014371006010000000	        D[CONST 1] ROT[TNIRENB] ALU[NOTD] DEST[Q] SHORT $
04m0002 06726 640050000755000440006544	DR11W:  ALU[NOTQ] DEST[AR] PUSHJ[DEV6ST] NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:DR11.SLO  --  of -- f2sym

04m0002 06727 640141600615000440002026	DR11R1: ALU[0] DEST[DEV-ADR] JUMP[MAIN] NORM $
04m0002                               	
04m0002                               	;;; 745 0,E   (DR11O)   Output E low 16 bits to pdp11
04m0002 06730 640050024571000200006672	DR11O:  D[MA] MASK[16.] DEST[AR] PUSHJ[DRSEND] NORM $   ;Transmit data
04m0002 06731 640141600615000440002026	        ALU[0] DEST[DEV-ADR] JUMP[MAIN] NORM $
04m0002                               	
04m0002                               	;;; 746 0,E   (DR11I)   Input from pdp11 to C(E)
04m0002 06732 640740014571000310000000	DR11I:  D[CONST 25.] LLOAD NORM $
04m0002 06733 640240000571000440006733	        NORM LOOP[.] $  ;GIVE DMA DEVICES SOME MEMORY TIME.  (???????)
04m0002 06734 640700000571000443400000	        SPEC[IOB-IN] NORM $
04m0002 06735 240054230571070440050000	        MAPF[TYM.RD] D[IOD] ROT[27. + 1] DEST[AR MEMSTO] PUSHJ[STONXT] C800 $
04m0002                               	           ;Align input word with 16 data bits at RIGHT end.
04m0002 06736 531140000571010440006740	        D[AR] ROT[4] C550 COND[-OBUS<0] JUMP[. + 2] $
04m0002                               	           ;Don't clear "INPUT RDY" flag unless it's on.
04m0002 06737 640040000571000440006676	        PUSHJ[DRTAKE] NORM $    ;it's on
04m0002 06740 640141600615000440002026	        ALU[0] DEST[DEV-ADR] JUMP[MAIN] NORM $
04m0002                               	
04m0002                               	;;; 747 0,E   (DR11DB)   Dump device A-memory into E..E+7
04m0002 06741 640044240571000440000000	DR11DB: D[10] DEST[MEMSTO] PUSHJ[STONXT] NORM $
04m0002 06742 640044244571000440000000	        D[11] DEST[MEMSTO] PUSHJ[STONXT] NORM $
04m0002 06743 640044250571000440000000	        D[12] DEST[MEMSTO] PUSHJ[STONXT] NORM $
04m0002 06744 640044254571000440000000	        D[13] DEST[MEMSTO] PUSHJ[STONXT] NORM $
04m0002 06745 640044260571000440000000	        D[14] DEST[MEMSTO] PUSHJ[STONXT] NORM $
04m0002 06746 640044264571000440000000	        D[15] DEST[MEMSTO] PUSHJ[STONXT] NORM $
04m0002 06747 640044270571000440000000	        D[16] DEST[MEMSTO] PUSHJ[STONXT] NORM $
04m0002 06750 640044274571000440000000	        D[17] DEST[MEMSTO] PUSHJ[STONXT] NORM $
04m0002 06751 640141600615000440002026	        ALU[0] DEST[DEV-ADR] JUMP[MAIN] NORM $
04m0002                               	
04m0002 06752 662140000571000440030000	STONXT: MAPF[NORM-WRT] COND[-MA-AC] JUMP[STONX1] CYLEN[MEMSTO] $
04m0002 06753 640700005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] NORM $
04m0002 06754 640320024433000440000000	STONX1: D[MA] ALU[D+1] DEST[MA] POPJ NORM $

SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

43m0162                               	]DR11P
43m0162                               	
43m0162                               	; SOMETHING IS REALLY FUCKED WITH THIS ASSEMBLER, CAUSING
43m0162                               	; THE .USE, .RELOC, AND SO FORTH MACROS NOT TO WORK.
43m0162                               	; EVIDENTLY THE PREVIOUS PERSON TO EDIT THE MICROCODE
43m0162                               	; HAD PROBLEMS WITH THIS TOO.  MAYBE THIS WILL REMOVE THE SYMPTOM.
43m0162                               	
43m0162       6755	BULLSHIT = .
43m0162                               	        .USE[43m0162                               	XLIST
43m0163                               	 LIST ]
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

44m0163                               	;INTERVAL TIMER CODE.
44m0163                               	
44m0163                               	;a-mem useage:
44m0163                               	;       0       dispatch addr for interrupts
44m0163                               	;       1       pi chn (33: 35) and intrpt waiting flag (32)
44m0163                               	;               (BITS 0,19 ARE ON FOR USE BY TAPE CODE)
44m0163                               	;       2       CONSTANT W/ ONLY BIT 19 ON (USED BY TAPE CODE)
44m0163                               	;       3       INTERVAL TIMER REGISTER.
44m0163                               	
44m0163                               	  .REPEAT OTP [
44m0163                               	;OTP
44m0163                               	
44m0163                               	  .REPEAT NTP [
44m0163       0	        TIM.CLR.ROT = 0
44m0163       11	        TIM.DO = 11
44m0163       1	        TIM.DI = 1
44m0163       10	        TIM.ENB = 10
44m0163       5	        TIM.DEV = 5
44m0163       2134	        TIM.LOC = 2134
44m0163                               	    ];NTP
44m0163                               	
44m0163                               	
44m0163                               	        .ORG[XLIST
44m0163                               	 LIST ] ;$*$*$ INTRPTS FROM DEVICE COME HERE.
44m0163                               	   .REPEAT 1 - TIMER [
44m0163                               	
44m0163                               	   .REPEAT TIMER [
44m0163 02134 640140000571000440000000	        NORM JUMP[TIMINT] $
44m0163                               	     ]
44m0163                               	        .RELOC
44m0163                               	USE[44m0163                               	XLIST
44m0164                               	 LIST ]]
44m0164                               	TIMINT:   ;ALL DEV 5 INTS COME FROM INTERVAL TIMER...
44m0164 06755 640702214571000013600000	        START-OUT D[CONST 1] ROT[TIM.CLR.ROT] DEST[IOD] NORM $
44m0164                               	           ;Clear the TIMER OVERFLOW FLAG.
44m0164 06756 240700054171000440100000	        MAPF[TIM.ENB] D[13] DEST[Q] C800 $
44m0164                               	           ;Get TIMER REGISTER.
44m0164                               	        D[CONST 1] ROT[12.] ALU[D+Q] DEST[Q 3] DEST-A-MEM
44m0164 06757 535140614035030013002026	                  C550 COND[-CRY0] JUMP[MAIN] $
44m0164                               	           ;Increment the count by 2^12, exit if no overflow.
44m0164 06760 510150044571000030002026	        D[11] MASK[3] DEST[AR] C550 COND[OBUS=0] JUMP[MAIN] $
44m0164                               	           ;Timer overflowed. ignore if no PI CHANNEL assigned.
44m0164 06761 640700044171000440000000	        D[11] DEST[Q] NORM $
44m0164                               	           ;Get full contents of A-MEM[1].
44m0164 06762 640140214575000103004572	        D[CONST 10] ALU[DORQ] DEST[1] DEST-A-MEM NORM JUMP[PIGEN] $
44m0164                               	           ;Set the "interrupting" status bit and generate a PI.
44m0164                               	
44m0164                               	   .OPCODE[LIST 
44m0164                               	 LIST            ];TIMER PSEUDO-IOT DISPATCH TABLE ENTRIES.
44m0164                               	
44m0164                               	; TCONO -- 760
44m0164 03740 640701614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] SHORT $
44m0164 03741 640140044171000440000000	        D[11] DEST[Q] NORM JUMP[TCNO1]$
44m0164                               	; TCONI -- 761
44m0164 03742 640041614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
44m0164 03743 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$ ;store them and
44m0164                               	 return.
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

44m0164                               	; TCONSO -- 762
44m0164 03744 640041614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
44m0164 03745 530100010635000220000000	        D[MASK 22] ALU[D&Q] C550 COND[-OBUS=0] LBJUMP[DSKP1] $ ;Skip if on.
44m0164                               	; TCONSZ -- 763
44m0164 03746 640041614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
44m0164 03747 510100010635000220000000	        D[MASK 22] ALU[D&Q] C550 COND[OBUS=0] LBJUMP[DSKP1] $ ;Skip if off.
44m0164                               	; TDATAO -- 764  LOAD THE 36-BIT TIMER
44m0164 03750 640701614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM $
44m0164 03751 640146000550400440020000	        FIXM1 JUMP[TDATO] $
44m0164                               	; TDATAI  --  765    READ TIMER REGISTER
44m0164 03752 640041614571000053400000	        START-IN D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TDTI] $ ;get bits.
44m0164 03753 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$ ;Store them and
44m0164                               	 return.
44m0164                               	
44m0164                               	   .RELOC
44m0164                               	USE[44m0164                               	XLIST
44m0165                               	 LIST ]]
44m0165 06763 640700010235010400000000	TCNO1:  D[MASK 32.] ROT[4] ALU[D&Q] DEST[Q] NORM $
44m0165 06764 000140234575000033002026	        D[IR] MASK[3] ALU[DORQ] DEST[1] DEST-A-MEM JUMP[MAIN] $
44m0165                               	           ;Put new PI CHAN. in bits 33-35 of A-MEM[1].
44m0165                               	
44m0165 06765 640710044171000040000000	TCNI1:  D[11] MASK[4] DEST[Q AR] NORM $ ;get intrpt flag and pi chn
44m0165 06766 640300034235000440000000	        D[IR] ALU[D&Q] DEST[Q] NORM POPJ $ ;this is for conso, z
44m0165                               	
44m0165 06767 640700004171000140000000	TDATO:  D[MEM] MASK[12.] DEST[Q] NORM $
44m0165                               	           ;Get low 12 bits of new timer value...
44m0165 06770 640702214575070013600000	        START-OUT D[CONST 1] ROT[35. - 7] ALU[DORQ] DEST[IOD] NORM $
44m0165                               	           ;Place in hardware counter (the "TP TIMER").
44m0165 06771 240700010171030300110000	        MAPF[TIM.DO] D[MASK 24.] ROT[12.] DEST[Q] C800 $
44m0165 06772 640140604635000443002026	        D[MEM] ALU[D&Q] DEST[3] DEST-A-MEM NORM JUMP[MAIN] $
44m0165                               	           ;Put other 24 bits into A-MEM[3] (the "TIMER REGISTER").
44m0165                               	
44m0165 06773 440710030571030143410000	TDTI:   MAPF[TIM.DI] START-IN D[IOD] ROT[12.] MASK[12.] DEST[AR] C600 $
44m0165                               	           ;Read hardware timer.
44m0165 06774 440700030171030140010000	        MAPF[TIM.DI] D[IOD] ROT[12.] MASK[12.] DEST[Q] C600 $
44m0165                               	           ;Read it again.
44m0165 06775 530140000735000443406773	        START-IN D[AR] ALU[D#Q] C550 COND[-OBUS=0] JUMP[TDTI] $
44m0165                               	           ;If it changed, try again (to ensure that we don't get a garbaged
44m0165                               	           ; value because of reading it while it is changing).
44m0165 06776 640310054575000440000000	        D[13] ALU[DORQ] DEST[AR] NORM POPJ $
44m0165                               	           ;Combine high-order bits from A-MEM[3] with
44m0165                               	           ; low-order bits from hardware counter.
44m0165                               	
44m0165                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

45m0165                               	;       IMP,VID,PAN,GRN,DLS,LPT,VC etc.
45m0165                               	;------------------------------------------------------------------------------
45m0165                               	;
45m0165                               	;       Packet Switching Network Interface (IMP)
45m0165                               	;
45m0165                               	;------------------------------------------------------------------------------
45m0165                               	.REPEAT IMP [
45m0165                               	IMP
45m0165                               	
45m0165                               	;------------------------------------------------------------------------------
45m0165                               	;
45m0165                               	;       Panofsky-Samson Interface
45m0165                               	;
45m0165                               	;------------------------------------------------------------------------------
45m0165                               	.REPEAT STANSW [
45m0165                               	.REPEAT STANSW
45m0165                               	
45m0165                               	;------------------------------------------------------------------------------
45m0165                               	;
45m0165                               	;       Data Line Scanner (TTY scanner)
45m0165                               	;
45m0165                               	;------------------------------------------------------------------------------
45m0165                               	.REPEAT DLS [
45m0165                               	
45m0165                               	.DEFINE ASRC[45m0165                               	.DEFINE ADEST[45m0165                               	
45m0165                               	.REPEAT DLS2 [
45m0165                               	.INSERT DLS.SLO

SLOE   Oct  30, 2543 00:00:00  file DSK:DLS.SLO  --  of -- f2sym

01m0001                               	;#####################################################################
01m0001                               	;   Let's make the dls be macro device 370;  so the
01m0001                               	;   iot's will have opcode 737, dispatch table
01m0001                               	;   entry loc. 3676
01m0001                               	;#########################################################################
01m0001                               	
01m0001                               	;-----------------------------------------------------------------------
01m0001                               	;DLS definitions
01m0001                               	;-----------------------------------------------------------------------
01m0001       37	DLS = 37        ;MACRODEVICE CODE 370
01m0001       6777	DLSORG = .  ;; DWP 1/27/80 %%% DLSORG = 7000    ;UCODE ORIGIN
01m0001       2137	DLSVECTOR = 2137        ;Interrupt dispatch address
01m0001                               	
01m0001                               	.REPEAT DLS2 [D01m0001       20	LSWEBIT = 16.   ;ASTRO write enable bit
01m0001       37	DLSNLINES = 37  ;Highest line number
01m0001       5	DLSLNSIZE = 5   ;Number of bits in line-number field
01m0001                               	.DEFINE DLSIRQ 01m0001                               	.DEFINE DLSNOIRQ .REPEAT 1 - DLS2 [D01m0001                               	
01m0001                               	;
01m0001                               	;A-MEM definitions
01m0001                               	;
01m0001       0	DLSINTAD = 0    ;Interrupt service routine
01m0001       1	DLSPICHN = 1    ;PI channel for DLS
01m0001       2	DLSLINE = 2     ;Line number which the scanner is simulated to have
01m0001                               	                ;stopped on
01m0001       3	DLSACT = 3      ;Active line flags
01m0001                               	                ;   DLSCNI1
01m0001       4	DLSTMP = 4      ;SCRATCH
01m0001                               	;
01m0001                               	;MAPF fields (IO SUBSEL)
01m0001                               	;
01m0001       0	DLSCR1 = 0      ;ASTRA CR1 (Control Register 1)
01m0001                               	;               Async                   Sync
01m0001                               	;       Bit 28          Normal mode (NOT looped)
01m0001                               	;       Bit 29  Send break              Xmit transparent
01m0001                               	;       Bit 30  Single stop bit         Transmit parity
01m0001                               	;                 if xmit enabled         if bit 29 is zero
01m0001                               	;         else  Not MISC OUT = 0        Force DLE
01m0001                               	;       Bit 31  Auto-echo (1/2 duplex)  Not MISC OUT = 0 (bit 29=0)
01m0001                               	;                                       DLE stripping (bit 29=1)
01m0001                               	;       Bit 32  Parity enable           Recieve parity enable
01m0001                               	;       Bit 33          Reciever enabled
01m0001                               	;       Bit 34          not RTS OUT = 0
01m0001                               	;       Bit 35          not DTR OUT = 0
01m0001                               	;
01m0001       1	DLSCR2 = 1      ;ASTRA CR2 (Control Register 2)
01m0001                               	;   Bits 28:29          Character length
01m0001                               	;               00  8 bits      10  6 Bits
01m0001                               	;               01  7 bits      11  5 Bits
01m0001                               	;       Bit 30  0  Asynchronous         1  Synchronous
01m0001                               	;       Bit 31  0  Odd parity           1  Even parity
01m0001                               	;       Bit 32  Rcv clk = xmt clk       SYN strip (CR1 bit 29=0)
01m0001                               	;               else Rcv clk = Rate 1   DEL-SYN strip (CR1 bit 29=1)
01m0001                               	;   Bits 33:35  Transmit clock select
01m0001                               	;       000     Ext. clock (EIA pins:  Xmt=15, Rcv=17 [???])
SLOE   Oct  30, 2543 00:00:00  file DSK:DLS.SLO  --  of -- f2sym

01m0001                               	;       001     Rate 1          150 baud
01m0001                               	;       010     Rate 2          300 baud
01m0001                               	;       011     Rate 3          109.9 baud      *** 1200 baud Temp.
01m0001                               	;       100     Rate 4          9600 baud
01m0001                               	;       101     Rate 4 / 2      4800 baud
01m0001                               	;       110     Rate 4 / 4      2400 baud
01m0001                               	;       111     Rate 4 / 8      1200 baud
01m0001                               	;
01m0001       2	DLSSTAT = 2     ;ASTRA Status register
01m0001                               	;       Bit 28  Data Set Change (DSR or CD changed while DTR=1, or RI
01m0001                               	;                 changed while DTR=0)
01m0001                               	;       Bit 29  DSR (Data Set Ready)
01m0001                               	;       Bit 30  CD (Carrier Detect)
01m0001                               	;       Bit 31  Framing error or SYN detect
01m0001                               	;       Bit 32  Parity error [Async, too???] or DLE detect
01m0001                               	;       Bit 33  Overrun error
01m0001                               	;       Bit 34  Data recieved
01m0001                               	;       Bit 35  Transmit holding register empty  (Note: this does NOT
01m0001                               	;                 necessarily mean the transmitter is off)
01m0001                               	;On write, this sets the SYN register, and if immediately followed by
01m0001                               	;another write, that write sets the DLE register.
01m0001       3	DLSHOLD = 3     ;ASTRA xmt/rcv Hold register
01m0001       10	DLSCSR = 10     ;Interface Command/Status Register
01m0001       4	DLSIACK = 4     ;Interrupt acknowledge (also, interrupting line)
01m0001       14	DLSNOSEL = 14   ;Don't select anything
01m0001                               	
01m0001                               	;Macros for reading ASTRA registers.  They are macros because the
01m0001                               	;control logic on the prototype didn't have the timing correct for the
01m0001                               	;ASTRA and the problem was pushed onto the microcode.
01m0001                               	
01m0001                               	.DEFINE DLSREAD[01m0001                               	.DEFINE
01m0001                               	
01m0001                               	.DEFINE DLSWRITE[01m0001                               	DEFINE DLSWRITE
01m0001                               	
01m0001                               	.DEFINE DLSRINT[01m0001                               	DEFINE DLSRINT
01m0001                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:DLS.SLO  --  of -- f2sym

02m0001                               	;-----------------------------------------------------------------------
02m0001                               	; DLS Dispatch
02m0001                               	;-----------------------------------------------------------------------
02m0001       3676	DLSDISP = 3600 + DLS + DLS      ;Dispatch for DLS instructions
02m0001                               	:DLSDISP
02m0001 03676 640141614571000200003677	        D[CONST DLSDEV] DEST[DEV-ADR] JUMP[. + 1] NORM $
02m0001 03677 640140014171014670000000	        D[CONST DLSORG / 100] ROT[6] DEST[Q] JUMP[DLSIOT] NORM $
02m0001                               	:DLSORG         ;DISPATCH ON DLS IOT CODES
02m0001                               	
02m0001                               	DLSDISP2:
02m0001                               	.REPEAT DLSDEB [
02m0001                               	:DLSDISP2 + 40
02m0001                               	].REPEAT 1 - DLSDEB [
02m0001                               	DLSDEB
02m0001                               	
02m0001       77	DLSLOW = DLSORG \ 100
02m0001                               	DLSIOT:
02m0001                               	        .IF DLSLOW /= 0 [
02m0001 07037 640700014175000770000000	                D[CONST DLSLOW] ALU[DORQ] DEST[Q] NORM $]
02m0001 07040 640700034035032040000000	        D[IR] ROT[13.] MASK[4] ALU[D+Q] DEST[Q] NORM $
02m0001 07041 500540034435032040000000	        D[IR] ROT[13.] MASK[4] ALU[D+Q] SDISP CYLEN[C550] $
02m0001                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:DLS.SLO  --  of -- f2sym

03m0001                               	;-----------------------------------------------------------------------
03m0001                               	;BLKI DLS,
03m0001                               	DLSBLKI:
03m0001                               	.REPEAT 1 - DLSDEB [
03m0001                               	DLSDEB
03m0001                               	;-----------------------------------------------------------------------
03m0001                               	;DATAI DLS,
03m0001                               	;
03m0001                               	;       Bit 12  This is a modem control line
03m0001                               	;   Bits 13:17  Line number
03m0001                               	;       Bit 27  Interrupt from reciever (always true for modem control)
03m0001                               	;   Bits 28:35  Character (Note: 5 bit characters do NOT use bit 27 for
03m0001                               	;                          flag.  Use TRNN x,777 to test for rcv. int.)
03m0001                               	;Modem control use of bits 28:35
03m0001                               	;       Bit 28  Unused
03m0001                               	;       Bit 29  DTR (Data Terminal Ready)
03m0001                               	;   Bits 30:32  ACU bits (unimplemented - no auto-dialer)
03m0001                               	;       Bit 33  CD (Carrier Detect)
03m0001                               	;       Bit 34  RI (Ring Indicator)
03m0001                               	;       Bit 35  Unused
03m0001                               	;
03m0001                               	;-----------------------------------------------------------------------
03m0001                               	DLSDI1: ;Prepare to insert into dispatch table
03m0001                               	:DLSDISP2 + 2           ;Two instructions here and the rest elsewhere
03m0001 07001 640150050171000440007002	        ASRC[[10 + DLSLINE]]DEST[AR Q] JUMP[. + 1] NORM $
03m0001 07002 640140414675020013007042	        D[CONST 1] ROT[8.] ALU[-D&Q] ADEST[EST[DLSLINE] DEST-A-MEM]JUMP[DLSDI1] NORM $
03m0001                               	:DLSDI1
03m0001 07042 510140014635020010000000	        D[CONST 1] ROT[8.] ALU[D&Q] COND[OBUS=0] JUMP[DLSDI2] C550 $
03m0001                               	                ;Did scanner stop on a receiver?
03m0001 07043 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
03m0001                               	                ;Yes.  Enable interrupt
03m0001 07044 440700044171000440100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] ASRC[[10 + DLSPICHN]]DEST[Q] $
03m0001                               	                ;Clear RCVR flag.
03m0001 07045 640700214675006013000000	        D[CONST 1] ROT[3] ALU[-D&Q] ADEST[EST[DLSPICHN] DEST-A-MEM]NORM $
03m0001 07046 662104200571000440002032	DLSDI2: D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
03m0001                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:DLS.SLO  --  of -- f2sym

04m0001                               	
04m0001                               	;-----------------------------------------------------------------------
04m0001                               	;BLKO DLS,
04m0001                               	DLSBLKO:
04m0001                               	.REPEAT 1 - DLSDEB [
04m0001                               	DLSDEB
04m0001                               	;-----------------------------------------------------------------------
04m0001                               	;DATAO DLS,
04m0001                               	;
04m0001                               	;       Bit 11  Use this line
04m0001                               	;   Bits 12:17  Line number if bit 11 is on (else interrupting line)
04m0001                               	;       Bit 27  Turn off transmitter (if this bit is on, then scanner is
04m0001                               	;                 restarted, but termination of transmission is not
04m0001                               	;                 implemented.)  Note: bit 30 is NOT used as alternative
04m0001                               	;                 to bit 27 in 5-bit character mode.)
04m0001                               	;Modem Control usage for bits 27:35
04m0001                               	;       Bit 27  Unused
04m0001                               	;       Bit 28  Set Status Flag (request interrupt).  Not implemented;
04m0001                               	;                  causes bug trap.
04m0001                               	;       Bit 29  DTR (Data Terminal Ready)
04m0001                               	;   Bits 30:35  ACU bits (Not implemented - no auto-dialer)
04m0001                               	;DC10 escape - Bit 0 = 1
04m0001                               	;   Bits 20:27  ASTRA Control Register 1
04m0001                               	;   Bits 28:31  ASTRA Control Register 2
04m0001                               	;
04m0001                               	;-----------------------------------------------------------------------
04m0001                               	DLSDO1: ;Prepare to insert into dispatch table
04m0001                               	:DLSDISP2 + 6           ;Two instructions here and the rest elsewhere
04m0001 07005 640706000550400440020000	          FIXM1 $       ;Fetch operand
04m0001 07006 000140000571000440007047	        JUMP[DLSDO1] $
04m0001                               	:DLSDO1
04m0001 07047 531140004571026440000000	        D[MEM] ROT[11.] COND[-OBUS<0] JUMP[DLSNTHIS] C550 $
04m0001                               	                ;Is "use this line" on?
04m0001 07050 531140044571076440000000	        ASRC[[10 + DLSPICHN]]ROT[31.] COND[-OBUS<0] JUMP[DLSTHIS] C550 $
04m0001                               	                ;Yes.  Use it if scanner not stopped on xmitter.
04m0001 07051 640700004171044050000000	        D[MEM] ROT[18.] MASK[DLSLNSIZE] DEST[Q] NORM $
04m0001                               	                ;It has stopped...
04m0001 07052 510140050735044050000000	        ASRC[[10 + DLSLINE]]ROT[18.] MASK[DLSLNSIZE] ALU[D#Q] COND[OBUS=0] JUMP[DLSSCNR]
04m0001                               	 C550 $
04m0001                               	                ;If it stopped on the line to use, ignore the "use this"
04m0001 07053 640150004171044050000000	DLSTHIS:        D[MEM] ROT[18.] MASK[DLSLNSIZE] DEST[AR Q] JUMP[DLSOUT] NORM $
04m0001                               	                ;Set line # from data.
04m0001 07054 531140044571076440002026	DLSNTHIS:       ASRC[[10 + DLSPICHN]]ROT[31.] COND[-OBUS<0] JUMP[MAIN] C550 $
04m0001                               	                ;No "use this" - NOP if scanner not stopped.
04m0001 07055 640700044171000030000000	DLSSCNR:        ASRC[[10 + DLSPICHN]]MASK[3] DEST[Q] NORM $
04m0001 07056 640700214575006043000000	        D[CONST 4] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]NORM $
04m0001                               	                ;Clear XMIT flag.
04m0001 07057 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
04m0001                               	                ;Enable interrupt.
04m0001 07060 440710050171044050100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] ASRC[[10 + DLSLINE]]ROT[18.] MASK[DLSLNSIZE] DEST[AR
04m0001                               	 Q] $
04m0001                               	                ;Use line # from scanner.
04m0001 07061 640701214537000430000000	DLSOUT: D[CONST 35.] ALU[D-Q] DEST[ROTR] NORM $
04m0001 07062 640700054171000440000000	        ASRC[[10 + DLSACT]]DEST[Q] NORM $       ;Prepare to twiddle active bit
04m0001 07063 511140004571066440000000	        D[MEM] ROT[27.] COND[OBUS<0] JUMP[DLSOFF] C550 $
04m0001                               	                ;"turn off transmitter"?
04m0001 07064 640700614575200013000000	        D[CONST 1] ROT[R] ALU[DORQ] ADEST[EST[DLSACT] DEST-A-MEM]NORM $
SLOE   Oct  30, 2543 00:00:00  file DSK:DLS.SLO  --  of -- f2sym

04m0001                               	                ;No.  Turn it on.
04m0001 07065 640700004171000100000000	        D[MEM] MASK[8] DEST[Q] NORM $
04m0001 07066 640700000175052440000000	        D[AR] ROT[21.] ALU[DORQ] DEST[Q] NORM $
04m0001                               	        DLSWRITE[04m0001 07067 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
04m0001                               	                ;Set TTY number
04m0001 07070 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
04m0001                               	                ;SET CS
04m0001 07071 000702214575046013630000	        MAPF[DLSHOLD] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
04m0001                               	
04m0001                               	                ;DROP CS, SET WE
04m0001 07072 000702200555000443630000	        MAPF[DLSHOLD] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
04m0001                               	                ;DROP WE.
04m0001 07073 000700000571000443770000	        MAPF[DLSHOLD + DLSNOSEL] SPEC[IOB-OUT] $
04m0001                               	        MAPF[DLSHOLD + DLSNOSEL]                ;Finish the last IOB-OUT
04m0001 07074 640140000571000440172026	]JUMP[MAIN] NORM $
04m0001 07075 640140614675200013002026	DLSOFF: D[CONST 1] ROT[R] ALU[-D&Q] ADEST[EST[DLSACT] DEST-A-MEM]JUMP[MAIN] NORM $
04m0001                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:DLS.SLO  --  of -- f2sym

05m0001                               	;-----------------------------------------------------------------------
05m0001                               	;CONO DLS,
05m0001                               	
05m0001                               	;
05m0001                               	;       Bit 30  Clear DC10
05m0001                               	;       Bit 31  Ready Hold (Not implemented, DTR switch is simulated as
05m0001                               	;                       being on.)
05m0001                               	;       Bit 32  Reset Scanner (more accurately, restart scanner. Allows
05m0001                               	;                        interrupts)
05m0001                               	;   Bits 33:35  PI channel
05m0001                               	;
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	DLSCNO1:
05m0001                               	:DLSDISP2 + 10
05m0001 07007 511040034571074440000000	        D[IR] ROT[30.] COND[OBUS<0] PUSHJ[DLSRST] C550 $
05m0001 07010 640140014171000700007076	        D[CONST 70] DEST[Q] JUMP[DLSCNO1] NORM $
05m0001                               	:DLSCNO1
05m0001 07076 640700044235000440000000	        ASRC[[10 + DLSPICHN]]ALU[D&Q] DEST[Q] NORM $
05m0001 07077 640140234575000033002026	        D[IR] MASK[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[MAIN] NORM $
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	;CONI DLS,
05m0001                               	;
05m0001                               	;    Bits 0:7   ASTRA Control Register 1
05m0001                               	;    Bits 8:13  ASTRA Control Register 2
05m0001                               	;    Bits 14:20 ASTRA Status Register
05m0001                               	;       Bit 30  DTR Distend (Simulated as always on)
05m0001                               	;       Bit 31  Transmit interrupt
05m0001                               	;       Bit 32  Recieve interrupt
05m0001                               	;               (Both bits 31 and 32 will not be on at the same time.
05m0001                               	;                Recieve will take priority.)
05m0001                               	;   Bits 33:35  PI channel
05m0001                               	;
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	DLSCNISV:
05m0001                               	:DLSDISP2 + 12
05m0001                               	                ;Get CONI information
05m0001 07011 662104244571000440002032	        ASRC[[10 + DLSPICHN]]DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
05m0001 07012 000700000571000440000000	        NOP $
05m0001                               	                ;Store and fetch next instruction
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	;CONSZ DLS,
05m0001                               	;-----------------------------------------------------------------------
05m0001 07013 640710044571000440000000	        ASRC[[10 + DLSPICHN]]DEST[AR] NORM $
05m0001 07014 640140034171000220004500	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
05m0001                               	                ;Do standard skip off AR and IR
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	;CONSO DLS,
05m0001                               	;-----------------------------------------------------------------------
05m0001 07015 640710044571000440000000	        ASRC[[10 + DLSPICHN]]DEST[AR] NORM $
05m0001 07016 640140034171000220004502	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
05m0001                               	                ;Do standard skip off AR and IR
05m0001                               	:DLSCNISV
05m0001                               	
05m0001 07100 000144620531000440004376	DLSBAD: d[pc] alu[d-1] dest[pc] jump[dohalt] $
05m0001                               	                ;Halt macro machine on this lossage...
05m0001                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:DLS.SLO  --  of -- f2sym

06m0001                               	;-----------------------------------------------------------------------
06m0001                               	;Reset DLS
06m0001                               	;
06m0001                               	;Clear PI assignment and A-MEM registers.
06m0001                               	;Turn off interrupts
06m0001                               	;Setup defaults for lines 0:7, 8:5
06m0001                               	;
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	.DEFINE DLSGRP[06m0001                               	;DLSGRP
06m0001                               	DLSRST:
06m0001 07101 640702214571060013600000	        D[CONST 1] ROT[24.] DEST[IOD] SPEC[IOB-OUT] NORM $
06m0001                               	                ;Hit MASTER RESET on all ASTRAs
06m0001 07102 000700214571000403100000	        MAPF[DLSCSR] LONG D[CONST 40] ADEST[EST[DLSPICHN] DEST-A-MEM]$ ;Clear PIA
06m0001 07103 000700400615000443000000	        ALU[0] ADEST[EST[DLSLINE] DEST-A-MEM]LONG $ ;Clear receiver flag
06m0001 07104 000700600615000443000000	        ALU[0] ADEST[EST[DLSACT] DEST-A-MEM]LONG $ ;All transmitters off
06m0001 07105 000712200615000443600000	        ALU[0] DEST[IOD AR] SPEC[IOB-OUT] LONG $ ;Let go of MR
06m0001                               	        MAPF[DLSCSR] LONG
06m0001                               	DLSINI
06m0001                               	DLSGRP[06m0001 07106 000740014571000130100000	        D[CONST 13 - 0] LLOAD $
06m0001 07107 640040014171000340000000	        D[CONST 34] DEST[Q] PUSHJ[DLSSCR2] NORM $
06m0001 07110 640700014171014020000000	        D[CONST 247 / 100] ROT[6] DEST[Q] NORM $
06m0001 07111 640040014175000470000000	        D[CONST 247 & 77] ALU[DORQ] DEST[Q] PUSHJ[DLSSCR1] NORM $
06m0001 07112 640250000433000440007107	        D[AR] ALU[D+1] DEST[AR] LOOP[. - 3] NORM $
06m0001                               	];Lines 0-13 9600 baud
06m0001                               	DLSGRP[06m0001 07113 000740014571000230000000	        D[CONST DLSNLINES - 14] LLOAD $
06m0001 07114 640040014171000330000000	        D[CONST 33] DEST[Q] PUSHJ[DLSSCR2] NORM $
06m0001 07115 640700014171014020000000	        D[CONST 247 / 100] ROT[6] DEST[Q] NORM $
06m0001 07116 640040014175000470000000	        D[CONST 247 & 77] ALU[DORQ] DEST[Q] PUSHJ[DLSSCR1] NORM $
06m0001 07117 640250000433000440007114	        D[AR] ALU[D+1] DEST[AR] LOOP[. - 3] NORM $
06m0001                               	];Lines 14-LAST 1200
06m0002 07120 640040014171000000000000	]       D[CONST 0] DEST[Q] PUSHJ[DLSCINT] NORM $
06m0002                               	.REPEAT DLS2 [
06m0002 07121 640040014171052200000000	        D[CONST 20] ROT[21.] DEST[Q] PUSHJ[DLSCINT] NORM $
06m0002                               	];DLS2
06m0002 07122 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
06m0002 07123 440300000571000440100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] POPJ $
06m0002                               	DLSCINT:
06m0002                               	.REPEAT DLS2 [
06m0002                               	        D[CONST 1] ROT[26.] ALU[DORQ] DEST[IOD Q] SPEC[IOB-OUT]
06m0002 07124 640702214175064013600000	                        NORM $
06m0002 07125 440700000571000443540000	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
06m0002 07126 000701030571000443140000	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM $
06m0002 07127 011300060571022440000000	        D[10 + DLSTMP] DLSNOIRQ OT[9.] COND[OBUS<0]]POPJ LONG $
06m0002                               	];DLS2
06m0002                               	DLSCINT1:       DLSRINT 06m0002                               	        MAPF[DLSNOSEL] SPEC[IOB-OUT]
06m0002 07130 640702200417000443740000	                ALU[Q+1] DEST[IOD] NORM $
06m0002                               	        MAPF[DLSIACK] CYLEN[IOB-OUT] SPEC[IOB-OUT] 
06m0002 07131 440702214437050013640000	                D[CONST 1] ROT[20.] ALU[D+Q+1] DEST[IOD] $
06m0002 07132 000702200555000443640000	        MAPF[DLSIACK] SPEC[IOB-OUT] ALU[Q] DEST[IOD] LONG $
06m0002 07133 000700000571000443440000	        MAPF[DLSIACK] SPEC[IOB-IN] LONG $
06m0002 07134 240701030571000443040000	        MAPF[DLSIACK] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
06m0002 07135 011300060571022440000000	        D[10 + DLSTMP] ]DLSNOIRQ OT[9.] COND[OBUS<0]]POPJ $
06m0002 07136 000700000571000440000000	        NOP LONG $
SLOE   Oct  30, 2543 00:00:00  file DSK:DLS.SLO  --  of -- f2sym

06m0002 07137 000140000571000440007130	        JUMP[DLSCINT1] $
06m0002 07140 640700000175052440000000	DLSSCR1:        D[AR] ROT[21.] ALU[DORQ] DEST[Q] NORM $
06m0002                               	        DLSWRITE[06m0002 07141 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
06m0002                               	                ;Set TTY number
06m0002 07142 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
06m0002                               	                ;SET CS
06m0002 07143 000702214575046013600000	        MAPF[DLSCR1] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
06m0002                               	                ;DROP CS, SET WE
06m0002 07144 000702200555000443600000	        MAPF[DLSCR1] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
06m0002                               	                ;DROP WE.
06m0002 07145 000700000571000443740000	        MAPF[DLSCR1 + DLSNOSEL] SPEC[IOB-OUT] $
06m0002                               	        MAPF[DLSCR1 + DLSNOSEL]                 ;Finish the last IOB-OUT
06m0002 07146 640300000571000440140000	]POPJ NORM $
06m0002 07147 640700000175052440000000	DLSSCR2:        D[AR] ROT[21.] ALU[DORQ] DEST[Q] NORM $
06m0002                               	        DLSWRITE[06m0002 07150 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
06m0002                               	                ;Set TTY number
06m0002 07151 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
06m0002                               	                ;SET CS
06m0002 07152 000702214575046013610000	        MAPF[DLSCR2] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
06m0002                               	                ;DROP CS, SET WE
06m0002 07153 000702200555000443610000	        MAPF[DLSCR2] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
06m0002                               	                ;DROP WE.
06m0002 07154 000700000571000443750000	        MAPF[DLSCR2 + DLSNOSEL] SPEC[IOB-OUT] $
06m0002                               	        MAPF[DLSCR2 + DLSNOSEL]                 ;Finish the last IOB-OUT
06m0002 07155 640300000571000440150000	]POPJ NORM $
06m0002                               	
06m0002                               	;-----------------------------------------------------------------------
06m0002                               	;DLS interrupts are fairly straight-forward.  The micro-interrrupt
06m0002                               	;is turned off, the status of the line is obtained, and if enabled, a
06m0002                               	;macro interrupt is requested.  The macro interrupt is responsible for
06m0002                               	;executing some CONO,DATAI,DATAO which restarts the scanner by enabling
06m0002                               	;micro interrupts again.
06m0002                               	;-----------------------------------------------------------------------
06m0002                               	DLSINT:
06m0002                               	: DLSVECTOR     ;Entry to interrupt
06m0002 02137 640142200615000443607156	        ALU[0] DEST[IOD] SPEC[IOB-OUT] JUMP[DLSINT] NORM $ ;Disable int.
06m0002                               	: DLSINT
06m0002                               	.REPEAT DLS2 [
06m0002                               	        MAPF[DLSCSR] D[CONST 3] ROT[25.] DEST[Q IOD] SPEC[IOB-OUT]
06m0002 07156 440702214171062033700000	                        CYLEN[IOB-OUT] $
06m0002 07157 440700000571000443540000	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
06m0002 07160 240701030571000443140000	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
06m0002 07161 031140060571022440000000	        D[10 + DLSTMP] DLSIRQ OT[9.] COND[-OBUS<0]]JUMP[DLSINT1] $
06m0002 07162 640702214171062023600000	        D[CONST 2] ROT[25.] DEST[Q IOD] SPEC[IOB-OUT] NORM $
06m0002 07163 440700000571000443540000	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
06m0002 07164 240701030571000443140000	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
06m0002 07165 511140060571022440000000	        D[10 + DLSTMP] C550 DLSNOIRQ OT[9.] COND[OBUS<0]]JUMP[DLSIGNORE] $
06m0002                               	];DLS2
06m0002                               	DLSINT1:        DLSRINT 06m0002                               	        MAPF[DLSNOSEL] SPEC[IOB-OUT]
06m0002 07166 640702200417000443740000	                ALU[Q+1] DEST[IOD] NORM $
06m0002                               	        MAPF[DLSIACK] CYLEN[IOB-OUT] SPEC[IOB-OUT] 
06m0002 07167 440702214437050013640000	                D[CONST 1] ROT[20.] ALU[D+Q+1] DEST[IOD] $
06m0002 07170 000702200555000443640000	        MAPF[DLSIACK] SPEC[IOB-OUT] ALU[Q] DEST[IOD] LONG $
06m0002 07171 000700000571000443440000	        MAPF[DLSIACK] SPEC[IOB-IN] LONG $
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

06m0002 07172 240701030571000443040000	        MAPF[DLSIACK] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
06m0002 07173 000704460571000440000000	        D[10 + DLSTMP] ]DEST[HOLD] $
06m0002                               	.REPEAT 1 - DLS2 [
06m0002 07174 640710004571102040000000	        D[MEM] ROT[33.] MASK[4] DEST[AR] NORM $
06m0002 07175 640710000575052440000000	        D[AR] ROT[21.] ALU[DORQ] DEST[AR] NORM $
06m0002 07176 640711200571036050000000	        D[AR] ROT[15.] MASK[DLSLNSIZE] DEST[AR ROTR] NORM $
06m0002 07177 640710000571044440000000	        D[AR] ROT[18.] DEST[AR] NORM $
06m0002 07200 511140004571102440000000	        D[MEM] ROT[33.] COND[OBUS<0] JUMP[DLSRCVINT] C550 $
06m0002 07201 531140054571200440000000	        ASRC[[10 + DLSACT]]ROT[R] COND[-OBUS<0] JUMP[DLSIGNORE] C550 $
06m0002 07202 640700400571000443000000	        D[AR] ADEST[EST[DLSLINE] DEST-A-MEM]NORM $
06m0002 07203 650150044171000440000000	        ASRC[[10 + DLSPICHN]]DEST[AR Q] COND[OBUS=0] JUMP[DLSCH0] NORM $
06m0002 07204 640140214575006063004572	        D[CONST 6] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[PIGEN] NORM $
06m0002 07205 640140214575006063002026	DLSCH0: D[CONST 6] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[MAIN] NORM $
06m0002 07206 640700000171006440000000	DLSRCVINT:      D[AR] ROT[3] DEST[Q] NORM $
06m0002                               	        DLSREAD[06m0002 07207 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
06m0002                               	                ;Set TTY number  -- FBUS 9
06m0002 07210 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
06m0002                               	                ;Assert CS
06m0002 07211 440700000571000440020000	        MAPF[DLSSTAT] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
06m0002 07212 000702214171064013420000	        MAPF[DLSSTAT] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
06m0002                               	                ;Setup to drop CS, start read
06m0002 07213 000704430571000103760000	        MAPF[DLSSTAT + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[HOLD] SPEC[IOB-OUT] $
06m0002                               	                ;Finish read, drop CS
06m0002 07214 000700000571000440160000	        MAPF[DLSSTAT + DLSNOSEL] $
06m0002                               	        MAPF[DLSSTAT + DLSNOSEL]  ]D[MEM] ROT[34.]
06m0002 07215 531140004571104440160000	                COND[-OBUS<0] JUMP[DLSIGNORE] C550 $
06m0002 07216 640700000171006440000000	        D[AR] ROT[3] DEST[Q] NORM $
06m0002                               	        DLSREAD[06m0002 07217 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
06m0002                               	                ;Set TTY number  -- FBUS 9
06m0002 07220 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
06m0002                               	                ;Assert CS
06m0002 07221 440700000571000440030000	        MAPF[DLSHOLD] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
06m0002 07222 000702214171064013430000	        MAPF[DLSHOLD] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
06m0002                               	                ;Setup to drop CS, start read
06m0002 07223 000700030171000103770000	        MAPF[DLSHOLD + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[Q] SPEC[IOB-OUT] $
06m0002                               	                ;Finish read, drop CS
06m0002 07224 000700000571000440170000	        MAPF[DLSHOLD + DLSNOSEL] $
06m0002 07225 640704400433070440170000	        MAPF[DLSHOLD + DLSNOSEL]  ]D[AR] ROT[28.] ALU[D+1] DEST[HOLD] NORM $
06m0002 07226 640700404575020443000000	        D[MEM] ROT[8.] ALU[DORQ] ADEST[EST[DLSLINE] DEST-A-MEM]NORM $
06m0002 07227 650150044171000030000000	        ASRC[[10 + DLSPICHN]]MASK[3] DEST[AR Q] COND[OBUS=0] JUMP[DLSRCVIGN] NORM $
06m0002 07230 640140214575006053004572	        D[CONST 5] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[PIGEN] NORM $
06m0002 07231 640140214575006053002026	DLSRCVIGN:      D[CONST 5] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[MAIN]
06m0002                               	 NORM $
06m0002 07232 640702214571066013600000	DLSIGNORE:      D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
06m0002 07233 440150000215000440102026	        MAPF[DLSCSR] CYLEN[IOB-OUT] ALU[0] DEST[AR Q] JUMP[MAIN] $
06m0002                               	

SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

45m0165                               	
45m0165                               	.REPEAT DLSDEB [
45m0165                               	.INSERT DLSDEB.SLO

SLOE   Oct  30, 2543 00:00:00  file DSK:DLSDEB.SLO  --  of -- f2sym

01m0001                               	;DLS DEBUGGING IOTS
01m0001                               	
01m0001                               	.DEFINE SETLIN 01m0001                               	
01m0001                               	.DEFINE MJUMP[01m0001                               	
01m0001                               	;;;;;  DWP 1/27/80:7600
01m0001                               	DLS.DEB:
01m0001                               	:DLSDISP2 + 20          ;IOT DISPATCH FOR DEVICE 374
01m0001                               	
01m0001 07017 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;BLKI 374 = READ
01m0001                               	 CR1
01m0001 07020 640140000571000440000000	JUMP[DLS.RCR1] NORM $
01m0001                               	
01m0001 07021 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;DATAI 374 = READ
01m0001                               	 CR2
01m0001 07022 640140000571000440000000	JUMP[DLS.RCR2] NORM $
01m0001                               	
01m0001 07023 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;BLKO 374 = READ
01m0001                               	 STAT
01m0001 07024 640140000571000440000000	JUMP[DLS.RSTAT] NORM $
01m0001                               	
01m0001 07025 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;DATAO 374 = READ
01m0001                               	 HOLD
01m0001 07026 640140000571000440000000	JUMP[DLS.RHOLD] NORM $
01m0001                               	
01m0001 07027 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;CONO 374 = WRITE
01m0001                               	 CR1
01m0001 07030 640140000175000440000000	MJUMP[[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WCR1] NORM]$
01m0001                               	
01m0001 07031 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;CONI 374 = WRITE
01m0001                               	 CR2
01m0001 07032 640140000175000440000000	MJUMP[[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WCR2] NORM]$
01m0001                               	
01m0001 07033 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;CONSZ 374 =
01m0001                               	 WRITE STAT (SYN,DLE)
01m0001 07034 640140000175000440000000	MJUMP[[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WSTAT] NORM]$
01m0001                               	
01m0001 07035 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;CONSO 374 =
01m0001                               	 WRITE HOLD
01m0001 07036 640140000175000440000000	MJUMP[[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WHOLD] NORM]$
01m0001                               	
01m0001                               	:DLS.DEB
01m0001                               	
01m0001 07234 640706000550400440020000	DLS.SETLIN:     FIXM1 $                 ;SETUP LINE # IN Q
01m0001 07235 640710004635000440000000	        D[MEM] ALU[D&Q] DEST[AR] NORM $
01m0001 07236 640700010171052050000000	        D[MASK[DLSLNSIZE]] ROT[21.] DEST[Q] NORM $
01m0001 07237 640300004235006440000000	        D[MEM] ROT[3] ALU[D&Q] DEST[Q] POPJ NORM $
01m0001                               	
01m0001                               	DLS.RCR1:       DLSREAD[01m0001 07240 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07241 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07242 440700000571000440000000	        MAPF[DLSCR1] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07243 000702214171064013400000	        MAPF[DLSCR1] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

01m0001 07244 000710030571000103740000	        MAPF[DLSCR1 + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07245 000700000571000440140000	        MAPF[DLSCR1 + DLSNOSEL] $
01m0001 07246 000140000571000440140000	        MAPF[DLSCR1 + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001                               	DLS.RCR2:       DLSREAD[01m0001 07247 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07250 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07251 440700000571000440010000	        MAPF[DLSCR2] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07252 000702214171064013410000	        MAPF[DLSCR2] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
01m0001 07253 000710030571000103750000	        MAPF[DLSCR2 + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07254 000700000571000440150000	        MAPF[DLSCR2 + DLSNOSEL] $
01m0001 07255 000140000571000440150000	        MAPF[DLSCR2 + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001                               	DLS.RSTAT:      DLSREAD[01m0001 07256 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07257 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07260 440700000571000440020000	        MAPF[DLSSTAT] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07261 000702214171064013420000	        MAPF[DLSSTAT] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
01m0001 07262 000710030571000103760000	        MAPF[DLSSTAT + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07263 000700000571000440160000	        MAPF[DLSSTAT + DLSNOSEL] $
01m0001 07264 000140000571000440160000	        MAPF[DLSSTAT + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001                               	DLS.RHOLD:      DLSREAD[01m0001 07265 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07266 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07267 440700000571000440030000	        MAPF[DLSHOLD] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07270 000702214171064013430000	        MAPF[DLSHOLD] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
01m0001 07271 000710030571000103770000	        MAPF[DLSHOLD + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07272 000700000571000440170000	        MAPF[DLSHOLD + DLSNOSEL] $
01m0001 07273 000140000571000440170000	        MAPF[DLSHOLD + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001 07274 640700010171000100000000	DLS.READ:       D[MASK[8.]] DEST[Q] NORM $
01m0001 07275 640700000235000440000000	        D[AR] ALU[D&Q] DEST[Q] NORM $
01m0001 07276 662104204575000000202032	        D[MEM] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
01m0001                               	
01m0001                               	
01m0001                               	DLS.WCR1:       DLSWRITE[01m0001 07277 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07300 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07301 000702214575046013600000	        MAPF[DLSCR1] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP CS, SET WE
01m0001 07302 000702200555000443600000	        MAPF[DLSCR1] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

01m0001                               	                ;DROP WE.
01m0001 07303 000700000571000443740000	        MAPF[DLSCR1 + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSCR1 + DLSNOSEL]                 ;Finish the last IOB-OUT
01m0001 07304 000140000571000440142026	]JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.WCR2:       DLSWRITE[01m0001 07305 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07306 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07307 000702214575046013610000	        MAPF[DLSCR2] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP CS, SET WE
01m0001 07310 000702200555000443610000	        MAPF[DLSCR2] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP WE.
01m0001 07311 000700000571000443750000	        MAPF[DLSCR2 + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSCR2 + DLSNOSEL]                 ;Finish the last IOB-OUT
01m0001 07312 000140000571000440152026	]JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.WSTAT:      DLSWRITE[01m0001 07313 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07314 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07315 000702214575046013620000	        MAPF[DLSSTAT] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	
01m0001                               	                ;DROP CS, SET WE
01m0001 07316 000702200555000443620000	        MAPF[DLSSTAT] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP WE.
01m0001 07317 000700000571000443760000	        MAPF[DLSSTAT + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSSTAT + DLSNOSEL]                ;Finish the last IOB-OUT
01m0001 07320 000140000571000440162026	]JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.WHOLD:      DLSWRITE[01m0001 07321 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07322 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07323 000702214575046013630000	        MAPF[DLSHOLD] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	
01m0001                               	                ;DROP CS, SET WE
01m0001 07324 000702200555000443630000	        MAPF[DLSHOLD] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP WE.
01m0001 07325 000700000571000443770000	        MAPF[DLSHOLD + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSHOLD + DLSNOSEL]                ;Finish the last IOB-OUT
01m0001 07326 000140000571000440172026	]JUMP[MAIN] $
01m0001                               	
01m0001 07327 000140000571000440007327	DLS.INT:        JUMP[.] $
01m0001 07330 000140000571000440007331	        JUMP[. + 1] $
01m0001 07331 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $
01m0001 07332 440700000571000440100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] $
01m0001 07333 000142400571000440002026	        DEST[CLR-DEV-FROM-INTR] JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.RINT:
01m0001                               	: DLSDISP2 + 0  ;BLKI 370 - GET INTERRUPT STATUS
01m0001 06777 000140000571000440006777	        JUMP[.] $
01m0001 07000 000140000571000440007334	        JUMP[DLS.RINT] $
01m0001                               	: DLS.RINT
SLOE   Oct  30, 2543 00:00:00  file DSK:DLSDEB.SLO  --  of -- f2sym

01m0001 07334 640700014171064010000000	        D[CONST 1] ROT[26.] DEST[Q] NORM $
01m0001                               	        MAPF[DLSNOSEL] SPEC[IOB-OUT] D[CONST 1] ROT[20.]
01m0001 07335 640702214437050013740000	                ALU[D+Q+1] DEST[IOD] NORM $
01m0001 07336 440700000571000440140000	        MAPF[DLSNOSEL] CYLEN[IOB-OUT] $
01m0001 07337 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07340 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07341 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07342 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07343 000702200555000443640000	        MAPF[DLSIACK] SPEC[IOB-OUT] ALU[Q] DEST[IOD] LONG $
01m0001 07344 000700000571000443440000	        MAPF[DLSIACK] SPEC[IOB-IN] LONG $
01m0001 07345 140700030171000440040000	        MAPF[DLSIACK] CYLEN[IOB-IN] D[IOD] DEST[Q] $
01m0001 07346 662104200555000440002032	        ALU[Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
01m0001                               	
01m0001                               	DLS.EINT:
01m0001                               	: DLSDISP2 + 4  ;BLKO 370 - ENABLE INTERRUPT
01m0001 07003 000140000571000440007003	        JUMP[.] $
01m0001 07004 000140000571000440007347	        JUMP[DLS.EINT] $
01m0001                               	:DLS.EINT
01m0001 07347 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
01m0001 07350 440140000571000440102026	        MAPF[DLSCSR] CYLEN[IOB-OUT] JUMP[MAIN] $

SLOE   Oct  30, 2543 00:00:00  file STRING:  --  of -- f2sym

45m0165                               	]DLSDEB
45m0165                               	];DLS2
45m0165                               	.REPEAT 1 - DLS2 [
45m0165                               	;1 - DLS2
45m0165                               	
45m0165                               	]DLS                    9 JAN 80  BO
45m0165                               	
45m0165                               	;------------------------------------------------------------------------------
45m0165                               	;
45m0165                               	;       Line Printer Interface (LPT)
45m0165                               	;
45m0165                               	;------------------------------------------------------------------------------
45m0165                               	.REPEAT LPT [
45m0165                               	LPT
45m0165                               	
45m0165                               	;------------------------------------------------------------------------------
45m0165                               	;
45m0165                               	;       Versatec Interface (VC)
45m0165                               	;
45m0165                               	;------------------------------------------------------------------------------
45m0165                               	.REPEAT VC [
45m0165                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

46m0165                               	; dsk stuff
46m0165                               	
46m0165                               	;a-mem useage:
46m0165                               	;       0       dispatch addr for interrupts
46m0165                               	;       1       pi chn (33: 35) and intrpt waiting flag (32)
46m0165                               	;       2       copy of last cmd sent to controller (by opcode 721)
46m0165                               	
46m0165                               	        .OPCODE[LIST 
46m0165                               	 LIST            ];disk pseudo-iot dispatch table entries.
46m0165                               	
46m0165                               	 ; dcono -- 740
46m0165 03700 640701614571000100000000	        d[const 10] dest[dev-adr] short $
46m0165 03701 640140234571000033000000	        d[ir] mask[3] dest[1] DEST-A-MEM norm jump[dcno1]$
46m0165                               	; dconi -- 741
46m0165 03702 640041614571000100000000	        d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
46m0165 03703 662104200571000440002032	        d[ar] dest[memsto] memst OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$ ;store them and
46m0165                               	 return.
46m0165                               	; dconso -- 742
46m0165 03704 640041614571000100000000	        d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
46m0165 03705 530100010635000220000000	        d[mask 22] alu[d&q] c550 cond[-obus=0] lbjump[dskp1] $
46m0165                               	; dconsz -- 743
46m0165 03706 640041614571000100000000	        d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
46m0165 03707 510100010635000220000000	        d[mask 22] alu[d&q] c550 cond[obus=0] lbjump[dskp1] $
46m0165                               	
46m0165                               	        .RELOC
46m0165                               	USE[46m0165                               	XLIST
46m0166                               	 LIST ]]
46m0166 07351 550140034571000030002026	dcno1:  d[ir] mask[3]  c500 cond[obus=0] jump[main] $
46m0166                               	         ; if assigned pi channel is not 0, then
46m0166                               	         ;  enable interrupt on "not active", by
46m0166                               	         ;  re-loading last cmd with 10 bit on.
46m0166 07352 640700014171000200000000	        D[CONST 20] DEST[Q] NORM $
46m0166 07353 510140034635000440000000	        D[IR] ALU[D&Q] C550 OBUS=0 JUMP[DCNO2] $
46m0166 07354 640140014171000400000000	        D[CONST 40] DEST[Q] NORM JUMP[DCNO3] $
46m0166 07355 640700014171000100000000	DCNO2:  d[const 10] dest[q] short $
46m0166 07356 640702250575000443600000	DCNO3:  d[12] alu[dorq] dest[iod] spec[iob-out] norm $
46m0166 07357 440140000571000440042026	        mapf[4] cylen[iob-out] jump[main] $
46m0166                               	
46m0166 07360 640710044171000440000000	dcni1:  d[11] dest[q ar] norm $ ;get intrpt flag and pi chn
46m0166 07361 640300034235000440000000	        d[ir] alu[d&q] dest[q] norm popj $ ;this is for conso, z
46m0166                               	
46m0166                               	        .ORG[XLIST
46m0166                               	 LIST ];$*$*$ 
46m0166                               	
46m0166                               	        ;interrupts from disk (dev 10) come here.
46m0166 02156 640140014371000500000000	        D[CONST 50] ALU[NOTD] DEST[Q] NORM JUMP[DSKINT] $
46m0166                               	
46m0166                               	        .RELOC
46m0166                               	USE[46m0166                               	XLIST
46m0167                               	 LIST ]]        .PAIR
46m0167                               	. \ 2 + .
46m0168                               	];$*$*$ This exists elsewhere by another name.  TVR-Apr80
46m0168 07362 640140000571000440002026	dskp1:  jump[main] norm $       ;conso and consz lbjump to here.
46m0168 07363 640164620433000440002027	        doskip $
46m0168                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

46m0168 07364 640702250635000443600000	dskint: d[12] ALU[D&Q] dest[iod] spec[iob-out] norm  $
46m0168                               	          ;clear interrrupt enable bit (amem[2] has last cmd)
46m0168 07365 510150044171000440040000	        mapf[4] d[11] dest[q ar] c550 cond[obus=0] jump[ddis] $
46m0168                               	        d[const 10] alu[dorq] dest[1] DEST-A-MEM norm
46m0168 07366 640140214575000103004572	                jump[pigen] $ ;set flag and request intrpt.
46m0168 07367 640142400571000440002026	ddis:   dest[clr-dev-from-intr] norm jump[main] $
46m0168                               	
46m0168 07370 640151614571000100000000	DSKWT1: D[CONST 10] DEST[DEV-ADR AR] NORM JUMP[DSKWT4] $
46m0168 07371 511140004571076440000000	DSKWT3: D[MEM] ROT[31.] C550 COND[OBUS<0] JUMP[DSKWDN] $
46m0168 07372 640740014571014010000000	        D[CONST 1] ROT[6] LLOAD NORM $
46m0168 07373 500240000571000440007373	        C550 LOOP[.] $
46m0168 07374 640700000571000443400000	DSKWT4: START-IN NORM $
46m0168 07375 240144430571000440007371	        MAPF[0] D[IOD] DEST[HOLD] C800  JUMP[DSKWT3] $
46m0168 07376 530150000531000440007374	DSKWDN: D[AR] ALU[D-1] DEST[AR] C550 COND[-OBUS=0] JUMP[DSKWT4] $
46m0168 07377 000140000571000440002026	        JUMP[MAIN] $
46m0168                               	
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

47m0168                               	
47m0168                               	;
47m0168                               	;ECC logging area
47m0168                               	;
47m0168                               	.REPEAT 1 - XUCODE [
47m0168                               	.REPEAT 1 - XUCODE
47m0168                               	.REPEAT XUCODE [
47m0168                               	: 17760
47m0168                               	].REPEAT XUCODE
47m0168                               	
47m0168                               	 .REPEAT 20 [N47m0168 17760 000700000571000440000000	OP $
47m0168 17761 000700000571000440000000	]OP $
47m0168 17762 000700000571000440000000	]OP $
47m0168 17763 000700000571000440000000	]OP $
47m0168 17764 000700000571000440000000	]OP $
47m0168 17765 000700000571000440000000	]OP $
47m0168 17766 000700000571000440000000	]OP $
47m0168 17767 000700000571000440000000	]OP $
47m0168 17770 000700000571000440000000	]OP $
47m0168 17771 000700000571000440000000	]OP $
47m0168 17772 000700000571000440000000	]OP $
47m0168 17773 000700000571000440000000	]OP $
47m0168 17774 000700000571000440000000	]OP $
47m0168 17775 000700000571000440000000	]OP $
47m0168 17776 000700000571000440000000	]OP $
47m0168 17777 000700000571000440000000	]OP $
47m0168                               	]
SLOE   Oct  30, 2543 00:00:00  file DSK:CFNEW.SLO  --  of -- f2sym

48m0168                               	;; this should be after everything else
48m0168                               	: 0
48m0168 00000 000140000571000440004000	        JUMP[MSTART] $          ;Auto-load micro code tapes someday.
48m0168                               	

SLOE   Oct  30, 2543 00:00:00  file DSK:F2SYM.SLO  --  of -- f2sym

01m0068                               	
01m0068                               	LIST-LABELS

labels
  0   38     0 .               10   21  3103 ACBI1            4    2  2212 ADJSP
 41  160  5002 ADJSP1          41  160  5010 ADJSP2          17  104  2763 ANDCA1          17  104  2764 ANDCA2
 17  104  2765 ANDCA3          30  142  4711 APDINT          30  146  4725 APIOT           30  142  4701 APRC1
 30  142  4702 APRC2           30  142  4703 APRCHK          30  142  4712 APRCI           30  142  4712 APRCII
 30  142  4704 APRCK1          30  142  4657 APRCO           30  142  4666 APRCO2          30  142  4671 APRCO3
 30  145  4723 APRDI           30  141  5300 APRDSP          30  142  4672 APRIEN          20  138  4533 APRRST
  4    2  2161 AREA216          9   15  2602 AREA260          9   15  2623 AREA262          9   15  2642 AREA264
  9   15  2665 AREA266          9   15  2702 AREA270          9   16  2742 AREA274         12   47  3426 AREA342
 12   49  3444 AREA344         12   49  3470 AREA346         12   51  3504 AREA350         12   51  3526 AREA352
 12   53  3544 AREA354         12   53  3566 AREA356         19  133  5140 AREA51          16   92  4233 ASHC1
 16   92  4251 ASHC2           16   92  4245 ASHC4           16   92  4242 ASHC6           16   93  4254 ASHC7
 16   92  4240 ASHC8           16   92  4244 ASHC9           16   92  4213 ASHDO           16   90  2734 ASHDO1
 16   92  4217 ASHDOP          16   91  4204 ASHNEG          16   91  4205 ASHNN1          16   91  4202 ASHPLS
  9   16  2724 ASOS1            9   16  2722 ASOS2            9   16  2762 ASOS3           14   59  4023 BADPC
 16   92  4231 BIGAS2          16   92  4207 BIGASH          16   90  2725 BIGLSH          14   69  4031 BII
 14   67  2645 BII1            14   69  4034 BII2            14   67  2642 BIIH            17  103  4265 BLT1
 17  103  4274 BLT2            17  103  4273 BLT3            17  103  4304 BLT4            17  103  4272 BLT5
 17  103  4306 BLT6            17  103  4271 BLT7            17  103  4310 BLT8            17  103  4276 BLT9
 17  103  4327 BLTA1           17  103  4341 BLTA10          17  103  4354 BLTA12          17  103  4264 BLTA2
 17  103  4314 BLTA3           17  103  4325 BLTA4           17  103  4336 BLTAL2          17  103  4322 BLTL1
 17  103  4342 BLTL2           18  112  4460 BRPNT           25  140  6177 BWRTA1           1    6 10301 CCLR
  3    1  6702 CFIXM0          20  138  4520 CLKCLR          20  138  4521 CLKENB          32  149  6213 CLKINT
 32  149  6216 CLKRDFLG        20  138  4520 CLKRST          20  138  4535 CLRDEVINT       18  112  4435 CONSW
 19  136  5235 CTYCI           19  136  5241 CTYCI1          19  136  5240 CTYCI2          19  136  5251 CTYCI3
 19  136  5247 CTYCI8          19  136  5245 CTYCI9          19  136  5233 CTYCO           19  136  5252 CTYCO1
 19  136  5256 CTYCO3          19  136  5261 CTYCO4          19  136  5266 CTYCO5          19  138  4502 CTYCS
 19  138  4500 CTYCZ           19  136  5213 CTYDI           19  136  5222 CTYDO           19  133  5100 CTYDSP
 19  133  2144 CTYIN1          19  133  2130 CTYINT          19  135  5211 CTYIOT          19  136  3566 CTYRS1
 19  136  5270 CTYRST           1    6 10334 D1               1    2 10061 DCG1             1    2 10056 DCGO
  1    2 10075 DCGWR            1    2 10040 DCINIT          46  166  7360 dcni1           46  166  7351 dcno1
 46  166  7355 DCNO2           46  166  7356 DCNO3           46  168  7367 ddis            18  112  4446 DEPNSW
 18  112  4447 DEPSW1          18  112  4445 DEPTSW          43  162  6543 DEV6CL          43  162  6544 DEV6ST
 43  162  6545 DEV6ST1         43  162  6546 DEV6ST2          4    3  2262 DFN             40  156  6230 DFN1
 15   77  4136 DIV1            15   79  4142 DIV2            15   81  4146 DIV3             7   10  2471 DIV9
  1    1  7234 DLS.DEB          1    1  7347 DLS.EINT         1    1  7327 DLS.INT          1    1  7240 DLS.RCR1
  1    1  7247 DLS.RCR2         1    1  7274 DLS.READ         1    1  7265 DLS.RHOLD        1    1  7334 DLS.RINT
  1    1  7256 DLS.RSTAT        1    1  7234 DLS.SETLIN       1    1  7277 DLS.WCR1         1    1  7305 DLS.WCR2
  1    1  7321 DLS.WHOLD        1    1  7313 DLS.WSTAT        5    1  7100 DLSBAD           3    1  7042 DLSBLKI
  4    1  7047 DLSBLKO          6    2  7205 DLSCH0           6    2  7124 DLSCINT          6    2  7130 DLSCINT1
  5    1  7100 DLSCNISV         5    1  7076 DLSCNO1          3    1  7042 DLSDI1           3    1  7046 DLSDI2
  2    1  6777 DLSDISP2         4    1  7047 DLSDO1           6    2  7232 DLSIGNORE        6    2  7156 DLSINT
  6    2  7166 DLSINT1          2    1  7037 DLSIOT           4    1  7054 DLSNTHIS         4    1  7075 DLSOFF
  4    1  7061 DLSOUT           6    2  7231 DLSRCVIGN        6    2  7206 DLSRCVINT        6    1  7101 DLSRST
  4    1  7055 DLSSCNR          6    2  7140 DLSSCR1          6    2  7147 DLSSCR2          4    1  7053 DLSTHIS
  4    3  2240 DMOVE           41  160  5015 DMOVE2           4    3  2250 DMOVEM          41  161  5026 DMOVM2
  4    3  2242 DMOVN           41  160  5020 DMOVN2           4    3  2252 DMOVNM          41  161  5031 DMVNM2
 41  161  5034 DMVNM3          41  161  5035 DMVNM4          41  161  5036 DMVNM5          15   83  4152 DODDIV
 15   83  4157 DODIV           15   83  4161 DODIV1          15   83  4165 DODIV2          15   83  4164 DODIV3
 15   85  2170 DODIV4          15   85  2174 DODIV6          15   84  2161 DODIV7          18  106  4376 DOHALT
 15   70  4065 DOIMUL          15   70  4072 DOMMUL          15   70  4076 DOMUL           15   70  4077 DOMUL1
 15   71  4104 DOMUL4           9   15  2622 DOSKP1           5    3  2276 DPB             14   63  2636 DPB1
 14   66  2671 DPB2            14   66  2672 DPB4            14   63  2637 DPB5            14   64  4024 DPB7
  4    2  6741 DR11DB           4    2  6732 DR11I            4    2  6730 DR11O            4    1  6712 DR11R
  4    2  6727 DR11R1           4    2  6726 DR11W            4    2  6724 DR11WO           1    1  6632 DRINP1
  1    1  6636 DRINP9           1    1  6613 DRINPK           1    1  6610 DRINWD           1    1  6640 DRISTP
  2    1  6654 DROI1            2    1  6667 DROI2            2    1  6670 DROI3            2    1  6647 DROIDL
  2    1  6642 DRONWD           1    1  6565 DROSTP           3    1  6710 DRPSH1           3    1  6703 DRPUSH
  3    1  6672 DRSEND           3    1  6676 DRTAKE          46  168  7364 DSKINT          46  168  7362 DSKP1
 20  138  4504 DSKRST          46  168  7376 DSKWDN          46  168  7370 DSKWT1          46  168  7371 DSKWT3
 46  168  7374 DSKWT4          31  149  6206 ECC-UNC         23  138  4657 END-OF-PI-CODE  18  112  4453 EXMNSW
 18  112  4455 EXMSW1          18  112  4452 EXMTSW          40  158  6377 EXPUF            5    3  2300 FAD
 40  158  6402 FADSU1          40  158  6401 FADSUB          40  156  6246 FAOS1           40  156  6250 FAOS2
 40  156  6252 FAOS3           40  156  6256 FAOS4           40  156  6246 FAOS5           40  160  6511 FD
 40  156  6272 FD1             40  156  6275 FD2             40  156  6306 FD2A            40  158  6332 FD2C
 40  158  6331 FD2D            40  158  6333 FD3             40  158  6336 FD4             40  160  6535 FDAD
 40  160  6503 FDS             40  160  6504 FDS1            40  160  6524 FDSHFT           5    3  2360 FDV
 41  161  5063 FIXER           41  161  5071 FIXER1          41  161  5072 FIXER2          41  161  5074 FIXER3
  4    3  2254 FIXR            41  161  5044 FIXR1           41  161  5056 FIXR2           41  161  5050 FIXRN
  4    3  2256 FLTR            41  161  6537 FLTR1           40  159  6460 FM              40  159  6463 FM1
 40  159  6466 FM2              1    2 10022 FMNBW1           1    2 10021 FMNBWT           5    3  2340 FMP
 40  156  6260 FMP1            40  156  6262 FMP2            40  156  6264 FMP3            40  156  6270 FMP4
 40  156  6260 FMP5             1    2 10030 FMTHNG          40  159  6451 FPLOW           40  159  6433 FPNAR
 40  158  6341 FPNDIV          40  158  6404 FS1             40  158  6407 FS2             40  158  6414 FS3
 40  159  6426 FS4             40  159  6430 FS5              5    3  2320 FSB              4    3  2264 FSC
 40  156  6236 FSC1            40  156  6242 FSC2            40  156  6235 FSCZAP          38  150  6224 GOHIGH
 38  153 10352 GOLOW           38  153 10350 GOMAIN           1    6 10342 GOMSTART        18  125  3474 HHS
 38  153 10346 HIGHSMAIN       18  114  3427 HLAR            18  114  3430 HLLEM1          18  120  3454 HLLES1
 18  123  3470 HLLES2          18  129  3533 HLLM1           18  118  3450 HLLOS1          18  113  2774 HLLZS1
 18  114  3432 HLREM1          18  129  3534 HLRM1           18  113  2777 HLRZS1          18  127  3526 HLSZ
 18  124  3472 HMV             18  128  3531 HOL             18  127  3527 HOR             18  114  3426 HRAR
 18  114  3431 HRLEM1          18  129  3532 HRLM1           18  113  2775 HRLZS1          18  114  3433 HRREM1
 18  121  3456 HRRES1          18  129  3535 HRRM1           18  119  3452 HRROS1          18  113  2776 HRRZS1
 18  128  3530 HRSZ            18  116  3444 HSMAIN          18  117  3446 HSMN1            5    3  2266 IBP
 14   70  4042 IBP1            14   70  4045 IBT1            15   71  4106 IDIV1           15   73  4116 IDIV2
 15   75  4126 IDIV3            7   10  2461 IDIV9            5    3  2274 IDPB            14   61  2610 IDPB1
 14   61  2614 IDPB2           14   66  2666 IDPB3            5    3  2270 ILDB            14   60  2602 ILDB1
 14   60  2606 ILDB2           14   61  2616 ILDB3           15   70  4047 IMUL1           15   70  4051 IMUL2
 15   70  4054 IMUL3           40  158  6371 INSEX1          40  158  6370 INSEXP          18  132  3546 JFCL1
 16   86  4172 JFFO1           16   86  4173 JFFO2           16   86  4176 JFFO3           16   86  4201 JFFO4
 16   86  4177 JFFO5           18  132  3555 JRA1            18  131  3504 JRST1           18  131  3514 JRST2
 18  132  3544 JRST3           18  131  3506 JRST4           18  131  3507 JRST5           18  131  3512 JRST9
 18  132  3553 JSA1            27  141  5551 JSMFR            8   13  2553 JSP1            18  132  3551 JSR2
  4    2  2210 JSYS            28  141  5635 JSYS1           28  141  5642 JSYS2            4    2  2211 JSYS3
 41  161  5042 KAFIXN          41  161  5040 KAFIXP           4    3  2244 KIFIX           41  161  5055 KIFIX1
 41  161  5060 KIFIXN           1    1 10001 KNYCLR           1    2 10014 KNYGOA           1    3 10167 KNYMTP
  1    2 10010 KNYRGO           1    1 10001 KNYRS1           1    6 10322 KNYW1            1    6 10320 KNYWAIT
  5    3  2272 LDB             14   62  2624 LDB1            14   62  2633 LDB2            14   62  2635 LDB4
 14   62  2625 LDB5            17  104  2766 LOG2            17  104  2767 LOG3            19  133  5120 LPTDSP
 16   97  2752 LSHC1           16   99  2735 LSHC2           16   90  2731 LSHDO           16   90  2733 LSHDO1
 16   88  2713 LSHNEG          16   88  2714 LSHNN1          16   90  2726 LSHPDO          16   88  2711 LSHPLS
  4    1  2026 MAIN             4    1  2027 MAIN1            4    1  2030 MAIN2           25  140  5147 MAPCO0
 26  141  5363 MAPCO1          26  141  5400 MAPCO4          26  141  5405 MAPCO6          26  141  5407 MAPCO7
 26  141  5356 MAPCOA          25  140  5170 MAPCOB          25  140  5171 MAPCOC          26  141  5360 MAPCOE
 26  141  5367 MAPCOG          25  141  5344 MAPCW1          25  141  5345 MAPCW2          26  141  5412 MAPCW9
 25  141  5340 MAPCWT          26  141  5414 MAPDO           25  140  5145 MAPIO1          25  140  5141 MAPIOT
 26  141  5402 MAPOFF          27  141  5625 MAPRSL          27  141  5624 MAPRSS          27  141  5622 MAPRST
 25  140  6201 MBLT2           25  140  6126 MBLT3            1    6  5000 MBOOT            1    7  6220 MBOOTA
  1    6 10264 MBOOTH           1    6 10307 MBTBY1           1    6 10315 MBTBY2           1    6 10306 MBTBYTE
  1    6 10317 MBTBYX           1    6 10326 MBTCHECK         1    6 10332 MBTDNX           1    6 10344 MBTERR
 26  141  5444 MFA1            26  141  5452 MFA2            26  141  5426 MFA3            26  141  5433 MFA4
 27  141  5520 MFA5            26  141  5432 MFA6            26  141  5427 MFA7            26  141  5456 MFB3
 27  141  5561 MFB4            27  141  5561 MFB5            27  141  5573 MFC1            26  141  5443 MFHIEX
 25  140  6111 MFOTH           25  140  6110 MFRD            25  140  6104 MFT1            25  140  6105 MFT1A
 26  141  5437 MFT1B           25  140  6106 MFT1D           27  141  5554 MFTR1           27  141  5557 MFTR10
 27  141  5604 MFTR2           27  141  5605 MFTR3           27  141  5607 MFTR4           27  141  5620 MFTR41
 27  141  5607 MFTR5           27  141  5610 MFTR6           27  141  5616 MFTR7           27  141  5617 MFTR9
 26  141  5475 MFTYP0          26  141  5473 MFTYP1          26  141  5423 MFUS             6    3  2400 MOVE
  6    3  2401 MOVE1            6    3  2402 MOVEI            6    3  2404 MOVEM            6    3  2406 MOVES
  6    3  2430 MOVM             6    4  2142 MOVM1            6    4  2432 MOVMI            6    4  2434 MOVMM
  6    4  2436 MOVMS            6    6  2042 MOVMS1           6   10  2054 MOVMS2           6    7  2044 MOVMS3
  6    8  2046 MOVMS4           6    9  2050 MOVMS5           6   10  2052 MOVMS6           6    3  2420 MOVN
  6    3  2422 MOVNI            6    3  2424 MOVNM            6    3  2426 MOVNS           18  113  2773 MOVNS1
  6    3  2410 MOVS             6    3  2412 MOVSI            6    3  2414 MOVSM            6    3  2416 MOVSS
 18  113  2772 MOVSS1          27  141  5546 MPINC1          26  141  5401 MPOFF1          15   70  4070 MSETOV
  4    1  2032 MSMAIN           4    1  2033 MSMAIN1         14   58  4000 MSTART          15   70  4071 MSTOV1
 14   59  4001 MSTRT1          27  141  5605 MTRPAL          18  133  4470 MUJSA           18  133  4474 MUJSM1
 18  133  4466 MUJSP           18  133  4463 MUJSR           18  133  4472 MUJSYS          15   70  4056 MUL1
 15   70  4060 MUL2            15   70  4062 MUL3             4    1  2100 MUUO             4    2  2101 MUUO2
  4    2  2103 MUUO3            4    2  2105 MUUO4            4    2  2106 MUUO44           4    2  2120 MUUO5X
  4    2  2124 MUUO5Y           0   38     0*NAF              1    2 10032 NCNTW1           1    2 10032 NCNTWT
 40  158  6353 NEGNOR          40  158  6356 NN1              3    1     0*no-@            40  158  6361 NORMOV
 40  159  6445 NORND           18  105  2071 NORSW           18  106  4421 NORSW2          18  105  2073 NOSW
 40  158  6366 NOVNO           40  158  6364 NOVYES          40  158  6344 NRMLIZ          10   23  3133 OCAI1
 10   24  3163 OCBI1           10   24  3153 OCMI1           17  104  2770 ORCM2           17  104  2771 ORCM3
  1    6 10273 P2               1    6 10274 P2A             31  147  4744 PDLO            31  147  4727 PDLO1
 31  147  4732 PDLO2           31  147  4734 PDLO3           31  147  4737 PDLO4           31  147  4733 PDLO5
 31  147  4742 PDLO6           31  147  4746 PDLTRP          21  138  4544 PI-CHECK-RQS    22  138  4613 PI-DISMISS
 21  138  4536 PI-GET-CHN      23  138  4654 PI-RESET        23  138  4647 PICONISUB       23  138  4616 PICONO
 30  141  5320 PIDSP           22  138  4572 PIGEN           22  138  4577 PIGEN1          22  138  4604 PIGENWT
 21  138  4542 PIGETMASK       21  138  4563 PIINTGO         21  138  4540 PIL1            21  138  4564 PIL11
 23  138  4632 PIL3            23  138  4634 PIL4            23  138  4636 PIL5            23  138  4640 PIL6
 23  138  4623 PIL7            23  138  4625 PIL8            23  138  4627 PIL9             4    2  2105 PIMUUO
 16  102  4257 POP1            16  102  4262 POPJ1           40  158  6350 POSNOR          16  102  4255 PUSH1
 16  102  4263 PUSHJ1          25  140  6147 QORCRY          18  106  4360 RESET           18  106  4363 RESLOP
 18  106  4355 RESW1           18  112  4430 RESW2           16   94  2742 ROTC1           16   95  2747 ROTC2
 16   88  2707 ROTDO           16   87  2704 ROTNEG          16   87  2705 ROTNN1          16   87  2702 ROTPLS
 20  138  4511 SDSKO2          31  149  6042 SECCS           20  138  4507 SET-DSK-OUT     40  158  6376 SETFOV
 25  140  6152 SETHFU          25  140  6146 SETHLF          18  112  4454 SETLTS          10   17  3030 SETM
 16   92  4212 SETOV1          16  101  2034 SJMAIN           9   15  2663 SKIPX1          12   47  3424 SKMAIN
  4    1  2024 SMAIN            4    1  2025 SMAIN1          31  148  6072 SOEDOV          31  148  4755 SOVRS
  1    2 10051 STDC1            4    2  6754 STONX1           4    2  6752 STONXT          31  148  4754 STOPS
 18  106  4377 STPLOP          18  106  4413 STPLP1           1    2 10047 STRTDC          18  112  4434 STRTSW
 18  105  2062 SWINT           38  150  6222 TAPDSP           1    3 10175 TAPEBR           1    3 10174 TAPEFR
  1    3 10147 TAPEMT           1    4 10231 TAPENR           1    2 10005 TAPERD           1    3 10206 TAPERS
  1    3 10173 TAPERW           1    5 10233 TAPERX           1    5 10241 TAPEWR          20  138  4524 TAPRST
 44  165  6765 TCNI1           44  165  6763 TCNO1           44  165  6767 TDATO           12   51  3525 TDC1
 12   53  3565 TDO1            44  165  6773 TDTI            12   49  3466 TDZ1            12   49  3467 TDZ2
  1    3 10165 TERAS1           1    3 10166 TERASE          40  160  6501 TESMUL          13   55  3740 TIMER-IOTS
 44  164  6755 TIMINT          20  138  4527 TIMRST          12   45  3416 TLC1            12   43  3412 TLO1
 12   41  3406 TLZ1             1    1  6550 TNI              1    1  6564 TNI0             1    1  6566 TNI1
  1    1  6575 TNI2             1    1  6602 TNI3             1    1  6606 TNI9             3    1  6701 TNRCW
  1    5 10237 TNRP3            1    3 10204 TPCLRNK          1    2 10115 TPMAOK           1    3 10200 TPSETDMP
  1    3 10176 TPSETIND         1    3 10202 TPSETNK         12   44  3414 TRC1             1    2 10105 TRCHA
  1    2 10103 TRCHECK          1    2 10104 TRCHKB           1    2 10131 TRCRET           1    2 10140 TRCX
  1    2 10107 TRDONE           1    2 10141 TREOF            1    2 10142 TRERR           12   42  3410 TRO1
  1    2 10100 TRP2            12   40  3404 TRZ1            12   49  3465 TSZ2             1    5 10257 TWER1
  1    5 10254 TWERR            1    3 10164 TWREOF           1    5 10242 TWRTRY           4    1  6712 TYMAREA
 20  138  4516 TYMRST           4    2  2125 UAOP            20  138  4512 UDSKST           4    3  2260 UFA
 40  156  6225 UFA1            40  159  6446 UFANOR           4    2  2200 UMOVE           28  141  5656 UMOVX
  1    5 10240 UTAPWR           4    1  2076 UUO0-7           4    1  2020 UUO1             4    1  2021 UUO2
  4    1  2060 UUOGO            4    2  2117 UUOPJ            1    2 10055 WCDONE          29  141  6002 XBLTL
 28  141  5742 XBY1            28  141  5767 XBY13           28  141  5760 XBY14           28  141  5747 XBY15
 28  141  5755 XBY16           28  141  5772 XBY3            28  141  5745 XBY4            28  141  5662 XCT1
 28  141  5734 XCT10           28  141  5712 XCT11           28  141  5711 XCT12           28  141  5702 XCT13
 28  141  5703 XCT18           28  141  5714 XCT2            28  141  5675 XCT3            28  141  5670 XCT4
 28  141  5666 XCT5            28  141  5672 XCT6            28  141  5721 XCTAC           28  141  5736 XCTBLG
 29  141  6001 XCTBLT          28  141  5741 XCTBYT          28  141  5730 XCTSTK          28  141  5665 XCTUMV
 28  141  5713 XDISP           28  141  5715 XFIXMA           4    3  2041 XMOVEM1         29  141  6024 XPDLO2
 29  141  6026 XPOP1           29  141  6037 XPOP2           29  141  6041 XPOP3           29  141  6015 XPUSH1
 40  159  6442 YESRND          40  159  6457 ZLOW           
01m0067                               	LIST-CORMAP


			Storage map


     0	X...............................................................
   100	................................................................
   200	................................................................
   300	................................................................
   400	................................................................
   500	................................................................
   600	................................................................
   700	................................................................
  1000	................................................................
  1100	................................................................
  1200	................................................................
  1300	................................................................
  1400	................................................................
  1500	................................................................
  1600	................................................................
  1700	................................................................
  2000	XXXXXXXXXXX.XXXXXXXXXXXXX.XXXX..XXXXXXXXXXXXX...X.XXXXXXXXXX..XX
  2100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXX..XXXXXXXXXX.....X.XXXXXX..XXXXXX..
  2200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  2300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  2400	XXX.X.XXXXX.XXXXXXX.X.XXXXX.XXXXXXX.XXXXXXX.XXXXXXX.XXXXXXX.XXXX
  2500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  2600	XXXXXXX.XXXXX.XXXXX.XXXXXXXXXXXXXXXXXXXXXXX.....XXXXX.XXXXXXXX..
  2700	XXXXXXXXXXXXXX..XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXX
  3000	X.X.X.X.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.X.X.XX
  3200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3400	XXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  3500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..XXXXXXXXXXXXXXXXXXXXXXXXXX......
  3600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.X.
  4000	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX...............
  5000	XXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX...
  5100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  5200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  5300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6000	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  6100	X...XXXXXX..X...XXXXXXX.XXX.XX..XXXXXXXXXXXXXX..XXXXXXX.X...XXXX
  6200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7000	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7400	................................................................
  7500	................................................................
  7600	................................................................
  7700	................................................................
 10000	XXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXX
 10200	XXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXX.....................
 10400	................................................................
 10500	................................................................
 10600	................................................................
 10700	................................................................
 11000	................................................................
 11100	................................................................
 11200	................................................................
 11300	................................................................
 11400	................................................................
 11500	................................................................
 11600	................................................................
 11700	................................................................
 12000	................................................................
 12100	................................................................
 12200	................................................................
 12300	................................................................
 12400	................................................................
 12500	................................................................
 12600	................................................................
 12700	................................................................
 13000	................................................................
 13100	................................................................
 13200	................................................................
 13300	................................................................
 13400	................................................................
 13500	................................................................
 13600	................................................................
 13700	................................................................
 14000	................................................................
 14100	................................................................
 14200	................................................................
 14300	................................................................
 14400	................................................................
 14500	................................................................
 14600	................................................................
 14700	................................................................
 15000	................................................................
 15100	................................................................
 15200	................................................................
 15300	................................................................
 15400	................................................................
 15500	................................................................
 15600	................................................................
 15700	................................................................
 16000	................................................................
 16100	X.......X...X...............................................X...
 16200	................................................................
 16300	................................................................
 16400	................................................................
 16500	................................................................
 16600	................................................................
 16700	................................................................
 17000	................................................................
 17100	................................................................
 17200	................................................................
 17300	................................................................
 17400	................................................................
 17500	................................................................
 17600	................................................................
 17700	................................................XXXXXXXXXXXXXXXX
  2955 locations used,  highest used = 17777
%Warn    no-@  is an undefined label 
