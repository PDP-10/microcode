01 0001  	;microcrox for SCI system
01 0002  	
01 0003  	;Initialize switch settings
01 0004  	.INSERT SWINIT.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:SWINIT.SLO  --  of -- SCI

01 0001  	;INIT ALL SWITCHES FOR CF TO 0.
01 0002  	
01 0003  	.DEFINE FOOLIST[01 0004  	
01 0005  0 	!-.INSERT-'SWINIT.SLO'-! = 0  ;ERROR MESSAGE FOR LOSERS
01 0006  	
01 0007  1 	F2SW = 1        ; SET F2SW = 1 FOR F2,  F2SW = 0 FOR F3
01 0008  	
01 0009  1 	FAST = 1        ;IF 0, ALL CYCLES ARE 500NS OR MORE.
01 0010  	
01 0011  1 	SLOW1 = 1       ;MAKES 350NS CYCLES LONGER BY 50*SLOW1 NS. DWP 2/10
01 0012  	
01 0013  0 	SLOW2 = 0       ;MAKES 400NS CYCLES LONGER BY 50*SLOW2 NS.
01 0014  	
01 0015  0 	TYMNET = 0
01 0016  	
01 0017  0 	TLXTAPE = 0
01 0018  	
01 0019  0 	125TAPE = 0
01 0020  	
01 0021  0 	SLOWTAPE = 0
01 0022  	
01 0023  0 	KNYTAPE = 0
01 0024  	
01 0025  0 	NTP = 0         ;NEW TAPE CTRL (DMA TYPE)
01 0026  	
01 0027  0 	TAPE = 0        ;New tape ctrl with long records.
01 0028  	
01 0029  0 	75IPS = 0       ;Not 75IPS drive -- implies 125IPS
01 0030  	
01 0031  0 	DLS = 0
01 0032  	
01 0033  0 	IMP = 0
01 0034  	
01 0035  0 	VID = 0         ;FooVision
01 0036  0 	VIC2 = 0        ;Smart video controler (with sysnthsis)
01 0037  	
01 0038  0 	LPT = 0         ;Lineprinter (Printronix, etc.)
01 0039  	
01 0040  0 	VC = 0          ;Versatec/Varian plotter interface.
01 0041  	
01 0042  1 	NEWMAP = 1      ;SET FOR MACHINES F3-3 AND LATER.
01 0043  	
01 0044  1 	CROCK = 1       ;set to 1 to get some old crockish code back
01 0045  	
01 0046  0 	DEBUGSW = 0     ;Set to 1 to get some debugging crocks
01 0047  	
01 0048  0 	TIMER = 0       ;INTERVAL TIMER
01 0049  	
01 0050  0 	STANSW = 0      ;Special Stanford I/O devices
01 0051  	
01 0052  0 	WAITS = 0       ;BBN Pager was modified for WAITS
01 0053  	
01 0054  0 	XUCODE = 0      ;Set to 1 (exactly !) if 8k u-memory present.

SLOE   Jan ***, 1859 00:00:03  file DSK:SCI.SLO  --  of -- SCI

01 0004  	
01 0005  	; SET F2SW = 1 FOR F2,  F2SW = 0 FOR F3
01 0006  	
01 0007  1 	XUCODE = 1
01 0008  	
01 0009  1 	F2SW = 1
01 0010  	
01 0011  0 	NEWMAP = 0
01 0012  	
01 0013  0 	TLXTAPE = 0             ;Down: THIS IMPLIES TELEX TAPE CTRLR
01 0014  	
01 0015  1 	NTP = 1
01 0016  1 	TAPE = 1
01 0017  	
01 0018  1 	DLS = 1                 ;Set to 1 to include DLS
01 0019  1 	DLSDEB = 1              ;Set to 1 for debugging
01 0020  1 	DLS2 = 1
01 0021  20  	DLSDEV = 20
01 0022  	
01 0023  1 	IMP = 1                 ;Set to 1 to include IMP
01 0024  	
01 0025  1 	VC = 1
01 0026  14  	 VCDEV = 14
01 0027  	
01 0028  	XLIST
01m0030                               	LIST
01m0030                               	
01m0030                               	.INSERT CFNEW

SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

01m0001                               	COMMENT \       FOONLY F2-F3 MICRO-CODE
01m0001                               	
01m0001                               	
01m0001                               	Recent history:
01m0001                               	
01m0001                               	21 Mar 80 TVR   Added DMOVE, DMOVEM and ADJSP instructions.  Changed opcode of
01m0001                               	                XMOVE to 107, as it conflicted with ADJSP.  Experimental boot
01m0001                               	                switches in preparation for auto-loading tapes.
01m0001                               	22 Mar 80 TVR   Fixed some typos with above.  
01m0001                               	26 Mar 80 TVR   Added WAITS switch to modify pager to make references to user
01m0001                               	                ACs go to user shadow memory (instead of special place pointed
01m0001                               	                to by AC Base Register in BBN Pager).  Since the addresses
01m0001                               	                supplied to the random instructions must be larger than 17
01m0001                               	                to prevent references to ACs in 2901, a page was stolen from
01m0001                               	                the EXEC address space, currently 770xxx, and that page table
01m0001                               	                entry in the hardware is copied from entry 0 of the user page
01m0001                               	                table in core.
01m0001                               	                Also, for Stanford only, defined ILGIOT to reference the PAN
01m0001                               	                interface, so that CONSZ will skip when no device is present
01m0001                               	                and new devices can be added to that bus without microcode
01m0001                               	                changes.
01m0001                               	                Fixed dispatch for UUO0 to look at opcode field only.  Made
01m0001                               	                indirect dispatch test for the stop switch, so that stop will
01m0001                               	                stop indirection loops
01m0001                               	                Fixed DATAO PI, to page fault properly.
01m0001                               	27 Mar 80 TVR   Pager mods and tape hack for CCRMA were both buggy.  Fixed.
01m0001                               	                Fixed bug in pager: PC was being over-decremented on page
01m0001                               	                fill cycle when indirection failed in XCTR'ed instruction.
01m0001                               	29 Mar 80 TVR   Flushed a spurious DEST-A-MEM which prevented WAITS from
01m0001                               	                working at XCTAC+1.
01m0001                               	02 Apr 80 TVR   Added code to trap IOT references if not Exec or IOT-User
01m0001                               	                mode.  New macro, UIOTRP, jumps if in IOT-USER mode.
01m0001                               	                ILGIOT still is a no-op for non-Stanford microcode for
01m0001                               	                the moment.
01m0001                               	                For Stanford only, the PAN interface has its micro-interrupts
01m0001                               	                re-enabled on PI-CHECK-RQS.
01m0001                               	                Bummed an instruction out of IOTDIS. Indirect bit is guaranteed
01m0001                               	                zero so one can double by shifting instead of doing an add.
01m0001                               	03 Apr 80 TVR   Fixed ADJSP.  XCT n,[PUSH x,y] failed if x was a user AC
01m0001                               	                reference.  Added code to emulate PUSH/POP.
01m0001                               	04 Apr 80 TVR   XCT 1,[POP x,AC] didn't have a chance of working.  It gets
01m0001                               	                emulated as well.  Added code for KAFIX.
01m0001                               	11 Apr 80 TVR   Changed PAN interrupt enables in PI-CHECK-RQS.  Added reset
01m0001                               	                code and IOT dispatch for temp. Grinnell code (under STANSW).
01m0001                               	                Looked at DIV code to try to fix divide-by-zero.  Gave up in
01m0001                               	                disgust.  I won't touch that code with a 10 ft battle axe!
01m0001                               	                Fixed another stupid typo in ADJSP.
01m0001                               	22 Apr 80 TVR   Fixed two bugs in DPB (and one in LDB).  DPB sets half flag
01m0001                               	                if it gets a page fault on the pointer reference.  The monitor
01m0001                               	                doesn't care much, but some user programs look at the fault
01m0001                               	                PC and flags to decide what kind of Pager and CPU they are
01m0001                               	                running under.  The other bug was that in LDB and DPB; they
01m0001                               	                do not handle bytes which 'wrap-around', i.e. 36-P<S.  If this
01m0001                               	                is the case, i think the right thing is S:=P.
01m0001                               	                Fixed bug in DMOVEM references to ACs.  One more time on ADJSP.
01m0001                               	                Added code (MAPRST) the clear entire map (not just valid bits)
01m0001                               	                on 'power-up' to prevent immediate mode references from going
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

01m0001                               	                to non-ex memory and/or causing spurious ECC traps.
01m0001                               	                Wrote some code for DMOVN, DMOVNM, and KIFIX.
01m0001                               	                Re-arranged a few things to make things fix (%$%@*#& orgs).
01m0001                               	26 Apr 80 TVR   Merged with DWP's version, which did not contain indications
01m0001                               	                of alterations.  Unfortunately, i did not have the most recent
01m0001                               	                CCRMA version available, so another merge will be necessary.
01m0001                               	                Many comments added.
01m0001                               	30 Apr 80 TVR   Attempted merge with CCRMA version.  That tape was not complete
01m0001                               	                so only some of the code will be merged.  Enough to proceed
01m0001                               	                with cleanup.
01m0001                               	                Replaced most :<expression> with macro calls in order to use
01m0001                               	                microcode memory in a more reasonable fashion.
01m0001                               	                More comments added.
01m0001                               	07 May 80 TVR   The assembler is a loser!  It redefines macros alright, some of
01m0001                               	                the time.  At any rate, the macros were rewritten and all
01m0001                               	                (shudder) of the macro calls changed.
01m0001                               	10 May 80 TVR   Merged in the rest of the CCRMA changes.
01m0001                               	11 May 80 TVR   Grumble, curse, moan!!!  No, the assembler isn't THAT bad.
01m0001                               	                The REAL loser not the assembler, but the person who wrote oet
01m0001                               	                the old version (which had a different name) onto
01m0001                               	                SCI:<POOLE>SLOEXP.SAV and which contains various and sundry
01m0001                               	                bugs, one of which appears to be macro re-definition and
01m0001                               	                another being an unusable storage map.  So, everything was
01m0001                               	                delayed a week while i tried to get around bugs which had
01m0001                               	                already been fixed.
01m0001                               	                Fortunately, this time it could be converted back to the
01m0001                               	                original form with the aid of a TECO macro.
01m0001                               	                Adjusted memory usage and it now assembles except for
01m0001                               	                re-usage of 5300 and 5301.
01m0001                               	12 May 80 TVR   Adjusted some of memory usage to make the silly thing assemble
01m0001                               	                WAITS version in preparation for making larger adjustments.
01m0001                               	                PAN interrupts are come out in the status word as low true. PAN
01m0001                               	                interrupt code has been corrected for that.
01m0001                               	                Fixed a rather obscure bug in SETHLF.  Because SETHLF stores
01m0001                               	                into CRYOV, the EXEC mode shift register (what COND[USER] is
01m0001                               	                based on) gets forced to be the current space.  Thus,
01m0001                               	                page faults from User pages in Exec mode on certain
01m0001                               	                instructions (like IDPB) were being processed as being Exec
01m0001                               	                mode page faults.
01m0001                               	13 May 80 TVR   Added .QUAD macro and put it in places jumped to by SLOOP
01m0001                               	                which were previously controlled by :<absolute number>.
01m0001                               	                Adjusted memory usage to make the one area using .QUAD fit.
01m0001                               	                Fixed misfeature in experimental boot.
01m0001                               	                LDB/DPB for bytes that wrap around just isn't right at all!
01m0001                               	                BYTE-OVERF is condition BEFORE incrementing, not after.  So,
01m0001                               	                i will have to rethink this one to come up with something
01m0001                               	                that handles that case properly without slowing byte
01m0001                               	                instructions down significantly.
01m0001                               	
01m0001                               	Changes at CCRMA follow:
01m0001                               	
01m0001                               	15 May 80 TVR   Fixed bug in DMOVNM.  Changed mechanism for PAN interrupts.
01m0001                               	                The PAN microinterrupt enable is turned off when the interrupt
01m0001                               	                for that channel is recieved and turned on by PI-CHECK-RQS
01m0001                               	                by setting all of the microinterrupt enables for the PAN to
01m0001                               	                the complement of PI IN PROGRESS and PI REQUEST.  This means
01m0001                               	                that the PAN can only request interrupts whenever something
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

01m0001                               	                else isn't using those channels.  This implies that any PAN
01m0001                               	                devices must be on the end of CONSZ chains, or else they will
01m0001                               	                steal interrupts from other, interrupt counting devices.
01m0001                               	24 May 80 TVR   Grinnell interrupt bug fixes.  Starting putting names on
01m0001                               	                opcodes and stuff to make it easier to use with E.
01m0001                               	26 May 80 TVR   Fixed problem in JRST1+1 falling thru to nothingness.  A few
01m0001                               	                more editorial changes.
01m0001                               	07 Jul 80 TVR   Changed CONO APR, code to turn on AR INT ENB and also made
01m0001                               	                symbols some references to APR A-MEM relating to APR.
01m0001                               	                Fixed bugs in F2 version of overflow interrupt.
01m0001                               	                *** Did not look at F3 code for same. ***
01m0001                               	                More comments added.
01m0001                               	08 Jul 80 TVR   Made attempt to fix [I]DIV by zero and no divide.
01m0001                               	                As part of that, commented the setup part of DODIV, and added
01m0001                               	                code to try to restore AC after finding no divide case.  I'm
01m0001                               	                not sure the DIV case will work properly, but we'll see...
01m0001                               	                Fixed bug in FDVR of negative number which set the flags wrong.
01m0001                               	                It had the wrong MASK when complementing a negative dividend
01m0001                               	                exponent.
01m0001                               	                Many comments added to divide and KA floating point as a result
01m0001                               	                of chasing these.  Some have (???) being i'm not sure that either
01m0001                               	                the code and/or the comments are right.
01m0001                               	15 Jul 80 TVR   Installed LPT device.  Microcode for LPT is still being tested.
01m0001                               	                Fixed bug in PAN enabling, so that PI channels that are not
01m0001                               	                turned on do not have their micro interrupts enabled.
01m0001                               	22 Jul 80 TVR   Fixed bug in [I]DIV which clobbered PC on divide by zero.
01m0001                               	                Sets overflow on KIFIX now.  Also, sets overflow on KAFIX, which
01m0001                               	                should not cause any problems.
01m0001                               	25 Jul 80 TVR   Added FIXR and FLTR.
01m0001                               	23 Aug 80 TVR   Fixed bugs in LDB/DPB having to do with bytes which overflow
01m0001                               	                word boundaries.
01m0001                               	                Ran out of micro-code space and re-adjusted .USEs to recover
01m0001                               	                some wasted space.
01m0001                               	                More work on LPT device.
01m0001                               	20 Sep 80 TVR   Added a new switch, MUM2.  At the moment, this only causes
01m0001                               	                ECC logging information to go to 1776x instead of 0776x.
01m0001                               	                Under WAITS switch, changed APR CONI, and clock interrupt
01m0001                               	                decision, to implement special feature of SAIL's KA, which
01m0001                               	                turns on bit 27 in APR CONI when it is NOT interrupting.
01m0001                               	25 Sep 80 TVR   Began merge of CCRMA version with DWP version.  MUM2 became
01m0001                               	                XUCODE.
01m0001                               	                Tape code got moved to separate files in order to make SRCCOM
01m0001                               	                feasible.
01m0001                               	                New symbol TYMORG defines where absolute part of TYMNET code
01m0001                               	                is assembled. It only need be changed in the future.
01m0001                               	
01m0001                               	Changes at Foonly follow:
01m0001                               	
01m0001                               	
01m0001                               	15 Aug 80 BO    Added Versatec to unused half of CTY IOT dispatch,
01m0001                               	                device code 124.
01m0001                               	                Removed the 16 NOP's at the very end of memory.  VC code
01m0001                               	                is broken up to fit available space.
01m0001                               	                Used absolute locations 5340-5437 (5340 defined as
01m0001                               	                VCORG1) and 7733-7777 (VCORG2) defined in VC.SLO
01m0001                               	                
01m0001                               	25 Sep 80 TVR   Following changes were not documented but evident from source
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

01m0001                               	                comparison:
01m0001                               	
01m0001                               	                MASK[18] was added to dispatch code at 2002. Presumably, this
01m0001                               	                        done to make the interrupt bug trap work properly.
01m0001                               	                CONSZ to DLS when no code is assembled now always skips, so
01m0001                               	                        that TENEX can tell if the DLS exists.
01m0001                               	                New device, VID, added.  This is Gossett's new display.
01m0001                               	                uDevice numbers for the DLS, VC are now variables.
01m0001                               	                Code for DMA tape controller was added.
01m0001                               	                Two new switches were added, OTP and NTP, which stand for
01m0001                               	                        Old Tape and New Tape controllers.  NTP is for
01m0001                               	                        the DMA tape controller and all others are OTP.
01m0001                               	                Changes to CTY code and TYMNet code to account for differences
01m0001                               	                        in MAPF fields for new tape controller.
01m0001                               	                Some adjustment of .ORG and .USE were done to make things fit.
01m0001                               	                FDVL was fixed.  This involved making changes to A-MEM usage
01m0001                               	                        in floating divide code.
01m0001                               	                SLOEXP was modified to truncate jump addresses to 12 bits without
01m0001                               	                        complaint.
01m0001                               	                New switch, XUCODE, was added.  If XUCODE=1, then some I/O devices
01m0001                               	                        are assembled into the upper 4K of microcode memory.
01m0001                               	                A new macro, .GETADR(X), constructs a 12 bit number in Q.
01m0001                               	                Tape code is optionally moved into upper 4K of microcode memory
01m0001                               	                        if XUCODE=1.  Dispatches for tape code were moved.
01m0001                               	                
01m0001                               	Versions merged.  This version is designated 1.02 by fiat of TVR.
01m0001                               	
01m0001                               	25 Sep 80 TVR   Completed merge.
01m0001                               	                *** VC needs a new device code.  It had used the slot assigned
01m0001                               	                historically to the LPT.
01m0001                               	                Some other minor formatting/comment changes were made to make
01m0001                               	                the source merge program work properly.
01m0001                               	                There were strong differences between the two in the floating
01m0001                               	                divide code.  Hopefully, all of the A-MEM changes made it
01m0001                               	                across.  I have checked them by hand.
01m0001                               	
01m0001                               	26 Sep 80 TVR   Assigned device 520 to VC (Versatec interface), and modified
01m0001                               	                VC.SLO to accomdate that.
01m0001                               	
01m0001                               	4 Nov 80 PG     Added new display service for FooVision (VID.SLO). This
01m0001                               	                stuff makes use of high memory, since it is quite large. Note
01m0001                               	                that the ,INSERT must be right after the tape code, since
01m0001                               	                (due to kludgery) .USE[OTHER] doesn't work properly for getting
01m0001                               	                you back to low memory (see TYMFOO). For your information:
01m0001                               	                .USE[HIGHMEM]   gets you to high memory
01m0001                               	                .USE[OTHER]     gets you back to low memory
01m0001                               	                GETADR[FOO] JUMP[GOHIGH] $      jumps to high memory 10000+FOO
01m0001                               	                                                (Note that this expands
01m0001                               	                                                to 2 microcode words.)
01m0001                               	                JUMP[GOMAIN] $                  jumps to MAIN in low memory
01m0001                               	
01m0001                               	21 Nov 80 - PG  Added new output instruction to TYMNET for F5 diagnostics.
01m0001                               	                Takes the data in the effective address, using the right
01m0001                               	                16. bits of the right half as data to go out;
01m0001                               	                AC=1 => STB DATA, and AC=2 => STB CTRL.
01m0001                               	
01m0001                               	(End history)
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

01m0001                               	\
01m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

02m0001                               	COMMENT \
02m0001                               	
02m0001                               	********************************************************
02m0001                               	
02m0001                               	        USEFUL MICROCODE WORD DEFINITIONS
02m0001                               	
02m0001                               	********************************************************
02m0001                               	\
02m0001                               	
02m0001       0	F3SW = 1 - F2SW
02m0001                               	
02m0001       0	OTP = 1 - NTP
02m0001                               	
02m0001                               	
02m0001       740007602375400000170000	FIXM1 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-RD] CYLEN[FIXM] $
02m0001       740007602375400000170000	FIXML = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-RD] CYLEN[LONG] $
02m0001       740007602375400000170000	FIXM2 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM] $
02m0001       740007602375400000170000	FIXM0 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[0] CYLEN[FIXM] $
02m0001                               	.DEFINE MEMST 02m0001                               	  ;  NOTE:  BECAUSE OF XCT MAPPED, MEMST IS SAME AS MEMSTMA
02m0001                               	 ; .DEFINE MEMST [] [COND[-MA-AC] LBJUMP[SMAIN] NORM ]
02m0001                               	.DEFINE MEMSTMA 02m0001                               	
02m0001       740767676376000000007777	DOSKIP = D[PC] ALU[D+1] DEST[MA PC] JUMP[MAIN1] NORM $
02m0001       000760000000000003607777	DONTSKIP = DEST[MA] SPEC[MA_PC] JUMP[MAIN1] $
02m0001       740767674000000000007777	DOJUMP = D[IR] DEST[MA PC] JUMP[MAIN1] NORM $
02m0001       740740000000000003607777	DOM1    = SPEC[MA_PC] JUMP[MAIN1] NORM $
02m0001                               	
02m0001       000000077775576770000000	CLRR    = ROT 22 D[MASK 22] ALU[D&AC] ACSEL[AC] DEST[AC] $
02m0001       000000077775400770000000	CLRL    =        D[MASK 22] ALU[D&AC] ACSEL[AC] DEST[AC] $
02m0001                               	
02m0001                               	;SLFFXM - Self FIXM (?)
02m0001                               	;Finish read fetch of read-modify-write type cycle.
02m0001                               	;Check to make sure effective address is writable.
02m0001                               	;Jump if AC field in IR is non-zero
02m0001                               	.DEFINE SLFFXM[02m0001                               	
02m0001                               	;;;;;;APR-A-MEM DEFINITIONS -- THERE SHOULD BE 7 MORE OF THESE !
02m0001                               	
02m0001       1	A-MEM-ECC-DATA = 1      ;Data on last ECC error -- readable by op. 750
02m0001                               	
02m0001                               	;;;;;;;
02m0001                               	
02m0001       000740000000000000007777	BADLOC = JUMP[MAIN] $;NOP FOR NOWJUMP BADPC $           ;FOR WORDS WE SHOULDN'T USE
02m0001                               	;;;;;ILGIOT = NORM JUMP[2000] $
02m0001                               	
02m0001                               	;The standard case for IOTs without devices
02m0001                               	.REPEAT 1 - STANSW [
02m0001                               	.DEFINE ILGIOT[02m0001                               	].REPEAT 1 - STANSW
02m0001                               	
02m0001                               	;At Stanford, any devices we don't know about go to the PAN interface.  It
02m0001                               	;may have something plugged into it that will respond to that address in a
02m0001                               	;PDP-10ish manner.
02m0001                               	.REPEAT STANSW [
02m0001                               	.REPEAT STANSW
02m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

02m0001                               	;Jump not IOT-USER mode
02m0001                               	.DEFINE UIOTRP[02m0001                               	DEFINE
02m0001                               	
02m0001                               	.DEFINE GETADR[02m0001                               	 ;Low-order 6 bits
02m0001                               	         ;NOTICE that a "$" is REQUIRED after a call of GETADR.
02m0001                               	
02m0001       740740074000001770007777	UUOLOC = D[CONST 40] JUMP[UUO1] NORM $
02m0001                               	
02m0001                               	   .DEFINE MUUO1 02m0001                               	   .DEFINE UAOP1 02m0001                               	
02m0001       740007674000177770000000	SET-TEMP-USER = D[CONST 17] ROT[11] DEST[MAP-EXEC-SR] NORM $
02m0001       740007674000177770000000	SET-TEMP-EXEC = D[CONST 0] ROT[11] DEST[MAP-EXEC-SR] NORM $
02m0001                               	
02m0001                               	;
02m0001                               	; THESE OUTLANDISHLY EXPLICIT DEFINITIONS OF NOP ASSURE THAT THE
02m0001                               	; DECODER WILL PRINT 'NOP' ONLY WHEN YOU REALLY MEAN IT.
02m0001                               	;
02m0001       037747602374000000000000	NOP =    COND[0] DEST[0] CONT ALU[D]
02m0001                               	        ACSEL[AC] NO-MA-STB NO-AR-STB ROT[0] MASK[-1] ALU-D[NONE] $
02m0001                               	
02m0001       037007602374000000000000	DONOP  = COND 0 DEST[ 0] ALU[D]
02m0001                               	         ROT[0] MASK[-1] ACSEL[AC] JUMP[MAIN] ALU-D[NONE] NORM $
02m0001                               	
02m0001       740777674000000003607777	DODISP  = D[MEM] DEST[IR-ALL MA AR] SPEC[PC+1-IF&] DISP[2374] CYLEN[DISP] $
02m0001                               	
02m0001                               	;------------------------------------------------------------------------------
02m0001                               	;
02m0001                               	;       CPU special registers                           uDevice 0
02m0001                               	;
02m0001                               	;------------------------------------------------------------------------------
02m0001                               	;
02m0001                               	; Dev  Subsel       Read                            Write
02m0001                               	;
02m0001                               	;  0     1                                      Address Break Register
02m0001                               	;        2      Data switches                   Data lights
02m0001                               	;        4      Address and console switches    Clear latched switches (no data)
02m0001                               	;       10      PC History (unimplemented)      Set AR,ECC enables, MAP ON, etc.
02m0001                               	;
02m0001                               	;  1     1      ECC status
02m0001                               	;        2      MAP status                      MAP (address in MA, LOCAL USER)
02m0001                               	;        4      (Same as 1)
02m0001                               	;       10      (Same as 1)
02m0001                               	;
02m0001                               	
02m0001                               	;------------------------------------------------------------------------------
02m0001                               	;
02m0001                               	;       A-Mem usage                                     uDevice 0 & 1
02m0001                               	;       (Note: Not all references are symbolic as yet.
02m0001                               	;
02m0001                               	;------------------------------------------------------------------------------
02m0001                               	;Device 0
02m0001       1	A-MEM-ECC-DATA = 1      ;Data on last ECC error -- readable by op. 750
02m0001       2	APRSTS = 2      ;Firmware status bits for APR
02m0001       7	APRENB = 7      ;Used to save ECC,AR interrupt enables, MAP ON, etc. during map
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

02m0001                               	                ;trap processing
02m0001                               	;Device 1
02m0001       3	ECCSVP = 3      ;Pointer to next place to remember ECC interrupt in microcode
02m0001                               	                ;memory
02m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

03m0001                               	
03m0001                               	COMMENT \
03m0001                               	
03m0001                               	*****************************************************
03m0001                               	
03m0001                               	                REAL CODE
03m0001                               	
03m0001                               	*****************************************************
03m0001                               	\
03m0001                               	
03m0001       2000	INST-DISP = 2000        ;Address of instruction dispatch.
03m0001       4001	NORMAL = 4001           ;Assembly starts here
03m0001                               	  .REPEAT XUCODE [
03m0001       10001	HIGHMEM = 10001         ;Upper 4K of 8K u-mem.
03m0001                               	    ]
03m0001                               	                        ;**** Next macro blows up with multiply defined symbol.          
03m0001                               	       ;**** Note that it usually does not complain!!!
03m0001                               	        .OPCODE[LIST 
03m0001                               	 LIST            ]      UUO 0 COMES HERE (ALONG WITH UUO 1 - 7 )
03m0001                               	
03m0001 02000 640140000571000440000000	        NORM JUMP[UUO0-7] $
03m0001                               	
03m0001                               	;; Location 2001 is used elsewhere !!!
03m0001                               	
03m0001                               	.REPEAT F3SW [
03m0001                               	
03m0001                               	.REPEAT F2SW [
03m0001                               	.REPEAT 0 [
03m0001                               	1 - DLS 9 JAN 80 BO
03m0001                               	
03m0001                               	:2002   ;I/O INTERRUPTS TRAP HERE
03m0001 02002 440540040571000440000000	        D[10] SDISP C600 $
03m0001                               	                ;Just dispatch to ucode intrpt. routine for device.
03m0001                               	: 2003 ;STOP SWITCH TRAPS HERE
03m0001 02003 640142400571000440000000	        DEST[CLR-DEV-FROM-INTR] JUMP[STOPS] NORM $
03m0001                               	: 2004  ;CAN'T GET HERE FROM THERE...
03m0001 02004 000140000571000440002004	        JUMP[.] $ ;HANG FOR NOW.
03m0001                               	: 2005  ;ECC ERRORS TRAP HERE
03m0001 02005 640142400571000440000000	        DEST[CLR-DEV-FROM-INTR] JUMP[SECCS] NORM $
03m0001                               	: 2006  ;PC OV TRAPS HERE
03m0001                               	;;;     DEST[CLR-DEV-FROM-INTR] JUMP[SOVRS] NORM $
03m0001 02006 640141614571000010000000	        D[CONST 1] DEST[DEV-ADR] JUMP[SOVRS] NORM $
03m0001                               	                ;Start setting up to read AR enabling
03m0001                               	: 2007 ;BOTH ECC AND OV (AT THE SAME TIME) TRAPS HERE
03m0001 02007 640142400571000440000000	        DEST[CLR-DEV-FROM-INTR] JUMP[SECCS] NORM $
03m0001                               	: 2010 ;NORMAL INDIRECT TRAPS HERE
03m0001 02010 640706000550400440010000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
03m0001 02011 540530404571000441602374	        D[MEM] DEST[IR-23 MA AR] DISP[2374] SPEC[PC+1-IF] CYLEN[DISP] $
03m0001                               	                ;WHEN EXTEND HAPPENS, DISP[2176]? NO-- HOW WOULD WE SEE
03m0001                               	                ;EXTENDED AREA OF IX REG?
03m0001                               	                ;Changed from 2174 to 2374 to allow stop switch to stop
03m0001                               	                ;indirection loops.  TVR-Mar80
03m0001                               	: 2012  ;NORMAL INDEXING TRAPS HERE
03m0001 02012 540530234420400221602024	        ALU[IX+D] D[IR] MASK[18.] DEST[AR IR-ADR MA] DISP[2024] SPEC[PC+1-IF]
03m0001                               	 CYLEN[DISP]$
03m0001                               	                ;WHEN EXTEND HAPPENS, DISP[2026]
03m0001                               	: 2014  ;EXTENDED INDIRECT TRAPS HERE
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

03m0001                               	; SOMETHING MAKES THIS DIFFERENT FROM 2010 -- MAYBE LOADING H.O. MA??
03m0001 02014 000140000571000440002014	 JUMP[.] $      ;FOR NOW ;;;ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
03m0001                               	
03m0001 02015 540530404571000441602176	        D[MEM] DEST[IR-23 MA AR] DISP[2176] SPEC[PC+1-IF] CYLEN[DISP] $
03m0001                               	: 2016  ;EXTENDED INDEXING TRAPS HERE
03m0001 02016 000140000571000440002016	 JUMP[.] $      ;FOR NOW ;;;D[AR] ROT[6] MASK[4] DEST[AC-SEL] NORM $
03m0001 02017 540530200420000441602026	        D[AR] ALU[D+AC] ACSEL[REG] DEST[IR-ADR MA AR] SPEC[PC+1-IF] DISP[2026]
03m0001                               	 CYLEN[DISP] $
03m0001                               	  ]
03m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

04m0001                               	;UUO1 UUO2 SMAIN SMAIN1 MAIN NMAIN1 MAIN1 MAIN2 MSMAIN MSMAIN1 MUUO MUUO2 MUUO3 MUUO4
04m0001                               	 PIMUUO MUUO44 UUOPJ MUUO5X MUUO5Y UAOP AREA216 UMOVE JSYS JSYS3 ADJSP XMOVEM1 DMOVE
04m0001                               	 DMOVN KIFIX DMOVEM DMOVNM FIXR FLTR UFA DFN FSC
04m0001                               	;------------------------------------------------------------------------------
04m0001                               	;       User UUO Trap
04m0001                               	;
04m0001                               	;       Traps thru location 40 of the current space
04m0001                               	;
04m0001                               	;       Instruction is stored in 40 (with effective address computed and
04m0001                               	;               index/indirection removed)
04m0001                               	;       Instruction in location 41 is executed, in the current space.  It
04m0001                               	;               customarily either jumps, saving the PC and flags, or halts.
04m0001                               	;------------------------------------------------------------------------------
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ];User UUOs 010:017
04m0001 02020 640060014571000400000000	UUO1:   D[CONST 40] DEST[MA] PUSHJ[UUOPJ] NORM  $
04m0001                               	                ;Setup MA for trap area and make mask for removing index/indir.
04m0001 02021 640704234635000440000000	UUO2:   D[IR] ALU[D&Q] DEST[MEMSTO] NORM $
04m0001                               	                ;Store instruction which caused trap.
04m0001 02022 640704620531000440170000	        D[PC] ALU[D-1] DEST[PC] MAPF[MASTO] CYLEN[MEMSTO] $
04m0001                               	                ;Ordinary page fault if not writable.  (*** Is PC correct???)
04m0001                               	                ;Backup the PC to point at the offensive instruction
04m0001 02023 640160014571000410000000	        D[CONST 41] DEST[MA] JUMP[NMAIN1] NORM $
04m0001                               	                ;Execute contents of (same space) location 41, usually a JSR or
04m0001                               	                ;a HALT instruction
04m0001                               	
04m0001                               	: 2024
04m0001 02024 640170005570400440640000	SMAIN: ACSEL[MA] D[MEM] DEST[AC AR MA] SPEC[MA_PC] JUMP[NMAIN1] CYLEN[MEMSTO] MAPF[STO] $
04m0001                               	
04m0001 02025 640170004571000440640000	SMAIN1: D[MEM] SPEC[MA_PC] DEST[AR MA] JUMP[NMAIN1] CYLEN[MEMSTO] MAPF[STO] $
04m0001                               	
04m0001 02026 640362400571000440600000	MAIN:   SPEC[MA_PC] DEST[MA CLR-DEV-FROM-INTR] NORM JPOP[MAIN1] $
04m0001                               	           ;START THE INSTR. FETCH (AND POP THE STACK A LITTLE...)
04m0001                               	           ;Also, clear forcing of interrupt device code, if still present
04m0001                               	
04m0001                               	NMAIN1:
04m0001                               	MAIN1:  ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] 
04m0001 02027 640346000550400440010000	         JPOP[MAIN2] CYLEN[FIXM] $ ; I.E. FIXM ### AND FLUSH STACK ####
04m0001                               	
04m0001 02030 540530604571000441602374	MAIN2:  D[MEM] DEST[IR-ALL MA AR] SPEC[PC+1-IF&] DISP[2374] CYLEN[DISP] $
04m0001                               	
04m0001                               	        .PAIR   . \ 2 + .
04m0001                               	];: 2032 ; .PAIR
04m0001 02032 640140005570400440172026	MSMAIN: ACSEL[MA] D[MEM] DEST[AC] JUMP[MAIN] CYLEN[MEMSTO] MAPF[MASTO] $
04m0001 02033 640140000571000440172026	MSMAIN1:        MAPF[MASTO] JUMP[MAIN] CYLEN[MEMSTO] $
04m0001                               	
04m0001       2034	AREA202 = .     ;(Not a lot left)
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ]      User UUOs 020-027
04m0001 02040 640140014571000400002020	        UUOLOC $
04m0001       2041	AREA204 = .
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ]      User UUOs 030-037
04m0001 02060 640140014571000400002020	UUOGO:  UUOLOC $
04m0001                               	
04m0001       2061	AREA206 = .
04m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

04m0001                               	;$*$*$*$ This should go somewhere else!!!
04m0001                               	  .OPCODE[LIST 
04m0001                               	 LIST            ] ;Set loc. to 2 before MUUO (opcode 37 doesn't come here).
04m0001                               	               ;We come here (from 2000) on opcodes 0-7.
04m0001 02076 510140034571022110000000	UUO0-7: D[IR] ROT[9.] MASK[9.] COND[OBUS=0] JUMP[MUUO] C550 $;J IF 0 UUO
04m0001 02077 640140014571000400002020	        UUOLOC $
04m0001                               	
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ]      Monitor UUOs 040-047 (CALL,INIT,CALLI)
04m0001                               	MUUO:   MUUO1
04m0001 02100 640150020171000440000000	D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
04m0002                               	];The following need not be contiguous with MUUO, it is merely here for clarity.
04m0002                               	;It may be moved to another area if necessary.  TVR-Apr80
04m0002                               	
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;       Monitor UUO Trap
04m0002                               	;
04m0002                               	;       Traps thru location 40 of the current space, typically to handle user 
04m0002                               	;               request to the Monitor
04m0002                               	;
04m0002                               	;       Instruction is stored in 40 (with effective address computed and
04m0002                               	;               index/indirection removed)
04m0002                               	;       Instruction in Monitor 41 is executed, in the Monitor space.  It
04m0002                               	;               should save PC and flags, and handle the user's request.
04m0002                               	;------------------------------------------------------------------------------
04m0002 02101 640705410635076430000000	MUUO2:  D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $
04m0002                               	                ;Clear USER
04m0002 02102 640060014571000400000000	        D[CONST 40] DEST[MA] PUSHJ[UUOPJ] NORM $
04m0002                               	                ;Setup MA for trap area and make mask for removing index/indir.
04m0002                               	;       \ /
04m0002                               	;Common code for instruction traps
04m0002 02103 640704234635000440000000	MUUO3:  D[IR] ALU[D&Q] DEST[MEMSTO] NORM $
04m0002                               	                ;Store instruction which caused trap.
04m0002 02104 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] CYLEN[MEMSTO] $
04m0002                               	                ;Now, get dispatch instruction
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;***  CAUTION:  If write fails, micro-machine hangs at 6100.  This should be
04m0002                               	;***            fixed when a more general page-fault mechanism is added.  The
04m0002                               	;***            best thing would be to just halt the macro machine.
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	MUUO4:
04m0002 02105 640706014171004550000000	PIMUUO: D[CONST 55] ROT[2] DEST[Q FIXMAC-MAPF-RD] CYLEN[FIXM] $; JSR OPCODE
04m0002                               	                ;TVR-Apr80:  I don't have the foggiest notion what that FIXMAC
04m0002                               	                ;is supposed to do here.  The FIXM is needed for memory timing,
04m0002                               	                ;but aren't we guaranteed not to be fetching from ACs here????
04m0002 02106 410140004735022110000000	MUUO44: D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSR] CYLEN[C650] $
04m0002                               	                ;Jump if trap instruction is a JSR (opcode 264 = 55*4)
04m0002 02107 640700000017000440000000	        ALU[Q+1] DEST[Q] SHORT $
04m0002 02110 510140004735022110000000	        D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSP] C550 $
04m0002                               	                ;Jump if trap instruction is a JSP (opcode 265)
04m0002 02111 640700000017000440000000	        ALU[Q+1] DEST[Q] SHORT $
04m0002 02112 510140004735022110000000	        D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSA] C550 $
04m0002                               	                ;Jump if trap instruction is a JSA (opcode 266)
04m0002 02113 640700014171002420000000	        D[CONST 42] ROT[1] DEST[Q] SHORT $; JSYS OP
04m0002 02114 510140004735022110000000	        D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSYS] C550 $
04m0002                               	                ;Jump if trap instruction is a JSYS (opcode 104 = 42*2)
04m0002 02115 640704620531000440000000	        D[PC] ALU[D-1] DEST[PC] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

04m0002                               	                ;Any other opcode will be XCTed and the regular code will
04m0002                               	                ;resume.
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;***  CAUTION:  No special dispensation has been made for BLKI/BLKO.  They
04m0002                               	;***            MUST be handled specially, as if they DON'T skip, the
04m0002                               	;***            second trap location should be executed and should be a JSR
04m0002                               	;***            or some other instruction which saves flags.    TVR-Apr80
04m0002                               	;------------------------------------------------------------------------------
04m0002 02116 000145400571000440002030	        D[AR] DEST[CRYOV] JUMP[MAIN2] $
04m0002                               	                ;Else restore flags and dispatch
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;***  CAUTION:  This probably will not work proper if reference is being made
04m0002                               	;***            to EXEC memory and trap was from USER.  What really needs to
04m0002                               	;***            happen here is that the instruction should be XCTRed instead,
04m0002                               	;***            It may be sufficient to SET-TEMP-EXEC.  I haven't looked at
04m0002                               	;***            the problem seriously.                          TVR-Apr80
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	
04m0002                               	;Construct a mask which excludes indexing and indirection.  Used by UUO trap
04m0002                               	;routines (and currently no where else)
04m0002 02117 640300010171056370000000	UUOPJ:  D[MASK 37] ROT[27] DEST[Q] POPJ NORM $
04m0002                               	
04m0002                               	;(NO SPACE IS LEFT.  You will have plant jumps to another area to expand the
04m0002                               	; above code!)
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      Monitor UUOs 050-057 (OPEN,INIT,RENAME,IN,OUT)
04m0002                               	
04m0002 02120 640700034171016010000000	MUUO5X: D[IR] ROT[7] MASK[1] DEST[Q] NORM $
04m0002                               	                ;Special check for UUOs actually used by monitors we care about
04m0002 02121 510140034735020010002100	        D[IR] ROT[10] MASK[1] ALU[D#Q] COND[OBUS=0] JUMP[MUUO] C550 $
04m0002                               	                ;Jump if UUO 50,51,56, OR 57
04m0002 02122 610140000555000440000000	        ALU[Q] COND[OBUS=0] JUMP[MUUO5Y] CYLEN[C450] $
04m0002                               	                ;Jump if 52 OR 53 ("Reserved for DEC")
04m0002 02123 530140034571022010002100	        D[IR] ROT[11] MASK[1] COND[-OBUS=0] JUMP[MUUO] C550 $
04m0002                               	                ;Jump if 55
04m0002 02124 640710020171000440000000	MUUO5Y: D[PC] DEST[Q AR] SHORT $
04m0002                               	;       \ /
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;       Illegal Instruction Trap
04m0002                               	;
04m0002                               	;       Traps thru Monitor 60
04m0002                               	;
04m0002                               	;       Instruction is stored in 60 (with effective address computed and
04m0002                               	;               index/indirection removed)
04m0002                               	;       Instruction in Monitor 61 is executed, in the Monitor space.  It
04m0002                               	;               should save PC and flags, and stop the offensive process.
04m0002                               	;------------------------------------------------------------------------------
04m0002 02125 640705410635076430000000	UAOP:   D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $; CLR USER
04m0002 02126 640700010171056370000000	        D[MASK 37] ROT[27] DEST[Q] NORM $
04m0002 02127 640160014571000600002103	        D[CONST 60] DEST[MA] JUMP[MUUO3] NORM $
04m0002                               	
04m0002       2130	AREA212 = .     ;$*$** Stupid interrupt code makes this unusable!
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      Monitor UUOs 060-067
04m0002                               	                        ;(SETSTS,STATO,GETSTS,STATZ,INBUF,OUTBUF,INPUT,OUTPUT)
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

04m0002 02140 640150020171000440002101	        MUUO1 D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
04m0002                               	]$
04m0002                               	;;;AREA214 = .
04m0002       2142	area214 = 2142          ;Sigh... Another fixed location
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      Monitor UUOs 070-077
04m0002                               	                        ;(CLOSE,RELEAS,MTAPE,UGETF,USETI,USETO,LOOKUP,ENTER)
04m0002 02160 640150020171000440002101	        MUUO1 D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
04m0002                               	]$
04m0002                               	AREA216:
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      UMOVE
04m0002 02200 640724620531000440000000	UMOVE:  D[PC] ALU[D-1] DEST[MA PC] NORM $ ;RE-FETCH INSTR.
04m0002 02201 640146000550400440020000	        FIXM1 JUMP[UMOVX] $     ;WAIT FOR FETCH.
04m0002                               	
04m0002                               	; UMOVEI, UMOVEM, UMOVES
04m0002                               	        .REPEAT 3 [ 04m0002 02202 640140000571000440002200	JUMP[UMOVE] NORM $
04m0002 02203 000700000571000440000000	                        NOP $ 
04m0002 02204 640140000571000440002200	                ]JUMP[UMOVE] NORM $
04m0002 02205 000700000571000440000000	                        NOP $ 
04m0002 02206 640140000571000440002200	                ]JUMP[UMOVE] NORM $
04m0002 02207 000700000571000440000000	                        NOP $ 
04m0002                               	                ]
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      JSYS
04m0002                               	JSYS:
04m0002                               	.REPEAT 1 - WAITS [
04m0002 02210 530140034571066110000000	        D[IR] ROT[33] MASK[11] COND[-OBUS=0] JUMP[JSYS1] C550 $; J IF NOT EX JSYS
04m0002                               	].REPEAT 1 - WAITS
04m0002                               	.REPEAT WAITS [
04m0002                               	.REPEAT WAITS
04m0002 02211 000150020171000440000000	JSYS3:  D[PC] DEST[Q AR] JUMP[JSYS2] $; GET PC & FLAGS
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      ADJSP
04m0002                               	ADJSP:  D[IR] ROT[22] MASK[0] ALU[D+AC] SPEC[LEFT] DEST[Q]
04m0002 02212 511140034021044000200000	                        COND[OBUS<0] JUMP[ADJSP1] C550$
04m0002                               	                ;Jump if left result is negative
04m0002 02213 640150034421000220000000	        D[IR] MASK[22] ALU[D+AC] DEST[AR] JUMP[ADJSP2] NORM $   ;Add right half
04m0002                               	        ;(Continued just before TYMNET code)
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ];XMOVEM
04m0002 02214 640722600551400440000000	        ALU[AC] ACSEL[AC+1] DEST[HI-ABS-MA MA] NORM $
04m0002 02215 640144200551000440000000	        ALU[AC] DEST[MEMSTO] NORM JUMP[XMOVEM1] $
04m0002                               	        .USE[04m0002                               	XLIST
04m0003 02041 640142600615000440002026	 LIST ]XMOVEM1: ALU[0] DEST[HI-ABS-MA] NORM JUMP[MAIN] $
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];XMOVE
04m0003 02216 640722600551400440000000	        ALU[AC] ACSEL[AC+1] DEST[HI-ABS-MA MA] NORM $
04m0003 02217 640142600615000440002401	        ALU[0] DEST[HI-ABS-MA] JUMP[2401] NORM $
04m0003                               	
04m0003                               	;Illegal instructions (?)
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

04m0003                               	        .REPEAT 117 - 110 + 1
04m0003 02220 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02221 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02222 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02223 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02224 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02225 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02226 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02227 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02230 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02231 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02232 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02233 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02234 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02235 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02236 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02237 000700000571000440000000	        NOP $
04m0003                               	        ]
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DMOVE
04m0003 02240 640706000550400440020000	DMOVE:  FIXM1 $                 ; Fetch first word
04m0003 02241 640140005571000440000000	        ACSEL[AC] D[MEM] DEST[AC] JUMP[DMOVE2] CYLEN[FIXM+1] $
04m0003                               	                ;Put it in an AC [*** Is CYLEN right? ***]
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DMOVN
04m0003 02242 640706000550400440020000	DMOVN:  FIXM1 $ ;Fetch first word
04m0003                               	        ACSEL[AC] D[MEM] ALU[NOTD] DEST[AC] SPEC[CRYOV]
04m0003 02243 640140005771000441200000	                        JUMP[DMOVN2] CYLEN[FIXM+1] $
04m0003                               	                ;Ones complement high order word.  Set result flags
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];KIFIX
04m0003 02244 640706000550400440020000	KIFIX:  FIXM1 $ ;Fetch first word
04m0003 02245 640140014171000330000000	        D[CONST 33] DEST[Q] JUMP[KIFIX1] NORM $
04m0003                               	                ;Start making magic constant
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	;123
04m0003 02246 640150020171000440002125	        UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02247 000700000571000440000000	        NOP $
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DMOVEM
04m0003                               	;*** Note: Like on the KI10, DMOVEM AC,AC+1 will lose.
04m0003 02250 640706200550400440030000	DMOVEM: FIXM2 $                 ; Make sure first word is in core
04m0003 02251 662104200551000440000000	        ACSEL[AC] ALU[AC] DEST[MEMSTO] COND[-MA-AC] LBJUMP[DMOVM2] NORM $
04m0003                               	                ;Store first word.  Decide where it really goes.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DMOVNM
04m0003                               	;*** Note: Like on the KI10, DMOVNM AC,AC+1 will lose.
04m0003 02252 640706200550400440030000	DMOVNM: FIXM2 $                 ; Make sure first word is in core
04m0003 02253 640150000751000441200000	        ACSEL[AC] ALU[NOTAC] DEST[AR] SPEC[CRYOV] JUMP[DMVNM2] NORM $
04m0003                               	                ;Ones complement high order word, leave result in IR
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];FIXR
04m0003 02254 640706000550400440020000	FIXR:   FIXM1 $ ;Fetch first word
04m0003 02255 640140014171060040000000	        D[CONST 04] ROT[24.] DEST[Q] JUMP[FIXR1] NORM $
04m0003                               	                ;Start making constant 0.5
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];FLTR
04m0003 02256 640706000550400440020000	FLTR:   FIXM1 $ ;Fetch first word
04m0003 02257 000150004571000440000000	        D[MEM] DEST[AR] JUMP[FLTR1] $
04m0003                               	                ;Setup for normalize
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];UFA
04m0003 02260 640706000550400440020000	UFA:    FIXM1 $
04m0003 02261 000141614571000110000000	        D[CONST 11] DEST[DEV-ADR] JUMP[UFA1] $
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DFN
04m0003 02262 640706200550400440030000	DFN:    FIXM2 $
04m0003 02263 450110004473000330000000	        D[MEM] MASK[27.] ALU[0-D] DEST[AR] COND[OBUS=0] LBJUMP[DFN1] C600 $
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];FSC
04m0003 02264 510140010621000330000000	FSC:    D[MASK 27.] ALU[D&AC] ACSEL[AC] COND[OBUS=0] JUMP[FSCZAP] C550 $
04m0003 02265 640150000551000440000000	        ACSEL[AC] ALU[AC] DEST[AR] JUMP[FSC1] NORM $
04m0003                               	
04m0003                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

05m0003                               	;IBP ILDB LDB IDPB DPB FAD FSB FMP FDV
05m0003                               	;------------------------------------------------------------------------------
05m0003                               	;
05m0003                               	;       Byte Manipulation Instructions
05m0003                               	;
05m0003                               	;------------------------------------------------------------------------------
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ];IBP (and ADJBP)
05m0003 02266 656146200550400440032026	IBP:    FIXM2 COND[HALF] JUMP[MAIN] $
05m0003                               	                ;A no-op if we're already incremented.
05m0003 02267 643110004171000440000000	        D[MEM] DEST[Q AR] COND[AC=0] LBJUMP[IBP1] NORM $
05m0003                               	                ;Get byte pointer and decide if it's an ADJBP or a IBP
05m0003                               	
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ];ILDB
05m0003 02270 640706200550400440030000	ILDB:   FIXM2 $
05m0003 02271 676110004171000440000000	        D[MEM] DEST[Q AR] COND[-HALF] LBJUMP[ILDB1] NORM $
05m0003                               	
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ];LDB
05m0003 02272 640706000550400440020000	LDB:    FIXM1 $
05m0003 02273 564130004171000440000000	        D[MEM] DEST[Q AR MA] COND[-MEM-IDX-IND] LBJUMP[LDB1] CYLEN[C500] $
05m0003                               	
05m0003                               	IDPB:   .OPCODE[LIST 
05m0003                               	 LIST            ];IDPB
05m0003 02274 640706200550400440030000	        FIXM2 $
05m0003 02275 676110004171000440000000	        D[MEM] DEST[Q AR] COND[-HALF] LBJUMP[IDPB1] NORM $
05m0003                               	
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ];DPB
05m0003 02276 640706000550400440020000	DPB:    FIXM1 $
05m0003 02277 564130004171000440000000	        D[MEM] DEST[Q AR MA] LBJUMP[DPB1] COND[-MEM-IDX-IND] CYLEN[C500]  $
05m0003                               	
05m0003                               	;------------------------------------------------------------------------------
05m0003                               	;
05m0003                               	;       Single Procession Floating Point
05m0003                               	;
05m0003                               	;------------------------------------------------------------------------------
05m0003                               	
05m0003                               	;
05m0003                               	;FAD FADL FADM FADB FADR FADRI FADRM FADRB
05m0003                               	;
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ]      ;Opcodes 140-147
05m0003 02300 640146000550400440020000	FAD:    FIXM1 JUMP[FAOS1] $ NOP $
05m0003 02301 000700000571000440000000	
05m0003 02302 640146000550400440020000	        FIXM1 JUMP[FAOS2] $ NOP $
05m0003 02303 000700000571000440000000	
05m0003 02304 640146200550400440030000	        FIXM2 JUMP[FAOS3] $ NOP $
05m0003 02305 000700000571000440000000	
05m0003 02306 640146200550400440030000	        FIXM2 JUMP[FAOS4] $ NOP $
05m0003 02307 000700000571000440000000	
05m0003 02310 640146000550400440020000	        FIXM1 JUMP[FAOS1] $ NOP $
05m0003 02311 000700000571000440000000	
05m0003 02312 640144424571044000200000	        D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] JUMP[FAOS5] NORM $ NOP $
05m0003 02313 000700000571000440000000	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

05m0003 02314 640146200550400440030000	        FIXM2 JUMP[FAOS3] $ NOP $
05m0003 02315 000700000571000440000000	
05m0003 02316 640146200550400440030000	        FIXM2 JUMP[FAOS4] $ NOP $
05m0003 02317 000700000571000440000000	
05m0003                               	
05m0003                               	;
05m0003                               	;FSB FSBL FSBM FSBB FSBR FSBRI FSBRM FSBRB
05m0003                               	;
05m0003                               	.DEFINE FSBMAC[05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ]      ;Opcodes 150-157
05m0003 02320 640706000550400440020000	FSB:    FIXM1 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS1] NORM 
05m0003 02321 640144404473000440000000	]$
05m0003 02322 640706000550400440020000	        FIXM1 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS2] NORM 
05m0003 02323 640144404473000440000000	]$
05m0003 02324 640706200550400440030000	        FIXM2 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS3] NORM 
05m0003 02325 640144404473000440000000	]$
05m0003 02326 640706200550400440030000	        FIXM2 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS4] NORM 
05m0003 02327 640144404473000440000000	]$
05m0003 02330 640706000550400440020000	        FIXM1 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS1] NORM 
05m0003 02331 640144404473000440000000	]$
05m0003 02332 640144424473044000200000	        D[MA] ROT[18.] DEST[HOLD] ALU[0-D] SPEC[LEFT] JUMP[FAOS5] NORM $ NOP $
05m0003 02333 000700000571000440000000	
05m0003 02334 640706200550400440030000	        FIXM2 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS3] NORM 
05m0003 02335 640144404473000440000000	]$
05m0003 02336 640706200550400440030000	        FIXM2 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS4] NORM 
05m0003 02337 640144404473000440000000	]$
05m0003                               	
05m0003                               	;
05m0003                               	;FMP FMPL FMPM FMPB FMPR FMPRI FMPRM FMPRB
05m0003                               	;
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ]      ;Opcodes 160-167
05m0003 02340 640146000550400440020000	FMP:    FIXM1 JUMP[FMP1] $ NOP $
05m0003 02341 000700000571000440000000	
05m0003 02342 640146000550400440020000	        FIXM1 JUMP[FMP2] $ NOP $
05m0003 02343 000700000571000440000000	
05m0003 02344 640146200550400440030000	        FIXM2 JUMP[FMP3] $ NOP $
05m0003 02345 000700000571000440000000	
05m0003 02346 640146200550400440030000	        FIXM2 JUMP[FMP4] $ NOP $
05m0003 02347 000700000571000440000000	
05m0003 02350 640146000550400440020000	        FIXM1 JUMP[FMP1] $ NOP $
05m0003 02351 000700000571000440000000	
05m0003 02352 640144424571044000200000	        D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] JUMP[FMP5] NORM $ NOP $
05m0003 02353 000700000571000440000000	
05m0003 02354 640146200550400440030000	        FIXM2 JUMP[FMP3] $ NOP $
05m0003 02355 000700000571000440000000	
05m0003 02356 640146200550400440030000	        FIXM2 JUMP[FMP4] $ NOP $
05m0003 02357 000700000571000440000000	
05m0003                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

05m0003                               	;FDV FDVL FDVM FDVB FDVR FDVRI FDVRM FDVRB
05m0003                               	.DEFINE DIVMAC[05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ]      ;Opcodes 170-177
05m0003 02360 640706000550400440020000	FDV:    FIXM1 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD1] NORM
05m0003 02361 640141614571000110000000	]$
05m0003 02362 640706000550400440020000	        FIXM1 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD2] NORM
05m0003 02363 640141614571000110000000	]$
05m0003 02364 640706200550400440030000	        FIXM2 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD3] NORM
05m0003 02365 640141614571000110000000	]$
05m0003 02366 640706200550400440030000	        FIXM2 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD4] NORM
05m0003 02367 640141614571000110000000	]$
05m0003 02370 640706000550400440020000	        FIXM1 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD1] NORM
05m0003 02371 640141614571000110000000	]$
05m0003 02372 640704424571044000200000	        D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] NORM $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD1] NORM
05m0003 02373 640141614571000110000000	]$
05m0003 02374 640706200550400440030000	        FIXM2 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD3] NORM
05m0003 02375 640141614571000110000000	]$
05m0003 02376 640706200550400440030000	        FIXM2 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD4] NORM
05m0003 02377 640141614571000110000000	]$
05m0003                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

06m0003                               	;MOVE MOVE1 MOVEI MOVEM MOVES MOVS MOVSI MOVSM MOVSS MOVN MOVNI MOVNM MOVNS MOVM MOVM1
06m0003                               	 MOVMI MOVMM MOVMS MOVMS1 MOVMS3 MOVMS4 MOVMS5 MOVMS6 MOVMS2
06m0003                               	;------------------------------------------------------------------------------
06m0003                               	;
06m0003                               	;       MOVE Group
06m0003                               	;
06m0003                               	;------------------------------------------------------------------------------
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVE
06m0003 02400 640706000550400440020000	MOVE:   FIXM1 $
06m0003                               	                ;Wait for memory, handle page faults, and fixup AC references
06m0003 02401 640160005571000440602027	MOVE1:  ACSEL[AC] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
06m0003                               	                ;Store result of read in AC
06m0003                               	                ;Start next instruction fetch (DEST[MA] refers to SPEC[MA_PC])
06m0003                               	                ;We are referring to the AC specified by the AC field in the IR
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVEI
06m0003 02402 640160035571000220602027	MOVEI:  ACSEL[AC] D[IR] MASK[18.] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
06m0003                               	                ;Store effective address into AC
06m0003                               	                ;Ignore any page faults or other memory related problems.  Read
06m0003                               	                ;will be ignored (except for ECC checking)
06m0003                               	                ;Start next instruction fetch (DEST[MA] refers to SPEC[MA_PC])
06m0003                               	                ;We are referring to the AC specified by the AC field in the IR
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVEM
06m0003 02404 662104200551000440002032	MOVEM:  ACSEL[AC] ALU[AC] DEST[MEMSTO]  MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	                ;Start writing AC (selected by AC field in IR) into memory.
06m0003                               	                ;MEMST macro will send us to MSMAIN (if we're writing to
06m0003                               	                ;another AC) or MSMAIN1 (if it's a real memory reference)
06m0003                               	                ;to complete to store.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVES
06m0003 02406 663146000550400440022401	MOVES:  FIXM1 COND[-AC=0] JUMP[MOVE1]  $
06m0003                               	                ;If AC field (in IR) is non-zero, we treat this as if it
06m0003                               	                ;were a MOVE instruction (a slight fudge).
06m0003                               	                ;*** Shouldn't this be a FIXM2?  Then it would do the right
06m0003                               	                ;*** thing for the clever person trying to fetch and dirty
06m0003                               	                ;*** a page.   TVR-Apr80
06m0003 02407 662104204571000440002032	        D[MEM] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	                ;If AC field is zero, this is a no-op which writes memory.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVS
06m0003 02410 640706000550400440020000	MOVS:   FIXM1 $
06m0003                               	        ACSEL[AC] D[MEM] ROT[18.] DEST[AC MA] SPEC[MA_PC]
06m0003 02411 640160005571044440602027	                        JUMP[MAIN1] CYLEN[FIXM+1] $
06m0003                               	                ;Rotating by 18 swaps halves.  Otherwise, it's just like a MOVE
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVSI
06m0003 02412 640160035571044000402027	MOVSI:  ACSEL[AC] D[IR] ROT[18.] DEST[AC MA] SPEC[LEFT&MA_PC] JUMP[MAIN1] NORM$
06m0003                               	                ;Just like a MOVEI except it puts the result in the left half
06m0003                               	                ;of the AC.  (SPEC[LEFT] makes a mask of -1,,0)
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVSM
06m0003 02414 640710000551000440000000	MOVSM:  ALU[AC] ACSEL[AC] DEST[AR] NORM $
06m0003 02415 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	                ;Swap halves and write it into memory like a MOVEM
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVSS
06m0003                               	MOVSS:  SLFFXM[06m0003 02416 663146200550400440030000	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM] COND[-AC=0] JUMP[
06m0003                               	 MOVSS1 ] $
06m0003                               	]$
06m0003                               	                ;Finish read fetch of read-modify-write type cycle.
06m0003                               	                ;Check to make sure effective address is writable.
06m0003                               	                ;Jump if AC field in IR is non-zero
06m0003 02417 662104204571044440002032	        D[MEM] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	                ;Swap halves and write backing into same place in memory.
06m0003                               	
06m0003                               	;*$*$*$ Move MOVSS1 here, a single instruction
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVN
06m0003 02420 640706000550400440020000	MOVN:   FIXM1 $
06m0003                               	        ACSEL[AC] D[MEM] ALU[0-D] DEST[AC MA] SPEC[CRYOV&MA_PC]
06m0003 02421 640160005473000441002027	                        JUMP[MAIN1] CYLEN[FIXM+1] $
06m0003                               	                ;Like MOVE except it negates the number it loads.
06m0003                               	                ;Set flags.  400000,,0 will overflow.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVNI
06m0003                               	MOVNI:  ACSEL[AC] D[IR] ALU[0-D] MASK[18.] DEST[AC MA] SPEC[CRYOV&MA_PC]
06m0003 02422 640160035473000221002027	                        JUMP[MAIN1] NORM $
06m0003                               	                ;Like MOVEI except that it load a negative number
06m0003                               	                ;Set flags.  Cannot overflow.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVNM
06m0003 02424 662104200513000441202032	MOVNM:  ACSEL[AC] ALU[0-AC] DEST[MEMSTO] SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN]
06m0003                               	 NORM ]$
06m0003                               	                ;Write negative of AC into memory.
06m0003                               	                ;Set flags.  400000,,0 will overflow.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVNS
06m0003                               	MOVNS:  SLFFXM[06m0003 02426 663146200550400440030000	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM] COND[-AC=0] JUMP[
06m0003                               	 MOVNS1 ] $
06m0003                               	]$
06m0003                               	                ;Complete fetch of read-modify-write
06m0003                               	                ;Jump if AC field (of IR) is non-zero, i.e. it loads an AC
06m0003 02427 662104204473000441202032	        D[MEM] ALU[0-D] DEST[MEMSTO] SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	
06m0003                               	                ;Write negative of number read back into memory.
06m0003                               	
06m0003                               	;
06m0003                               	; MOVM - Move Magnitude (Absolute value)
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

06m0003                               	;
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVM
06m0003 02430 640706000550400440020000	MOVM:   FIXM1 $ ;Complete data fetch
06m0003 02431 451100005571000440000000	        ACSEL[AC] D[MEM] DEST[AC] COND[OBUS<0] LBJUMP[MOVM1] C600 $
06m0003                               	                ;Load number.
06m0003                               	                ;If negative, negate it to make it positive.
06m0003                               	                ;In either case, start fetch of next instruction
06m0003                               	        .USE[XLIST
06m0003                               	 LIST ];$*$*$ Random hole
06m0003                               	        .PAIR
06m0003                               	. \ 2 + .
06m0004 02142 640160000571000440602027	]MOVM1: SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
06m0004                               	                ;Number is positive, leave it alone
06m0004                               	                ;Start next instruction fetch
06m0004 02143 640160001513000441002027	        ACSEL[AC] ALU[0-AC] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1] NORM$
06m0004                               	                ;Number is negative, make it positive.
06m0004                               	                ;Start next instruction fetch
06m0004                               	
06m0004                               	        .OPCODE[LIST 
06m0004                               	 LIST            ];MOVMI
06m0004 02432 640160035571000220602027	MOVMI:  ACSEL[AC] D[IR] MASK[18.] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
06m0004                               	                ;Immediate implies it's positive.  Equivalent to MOVEI
06m0004                               	
06m0004                               	        .OPCODE[LIST 
06m0004                               	 LIST            ];MOVMM
06m0004 02434 611140000551000440002424	MOVMM:  ACSEL[AC] ALU[AC] COND[OBUS<0] JUMP[MOVNM] CYLEN[C450] $
06m0004                               	                ;If AC is negative, store its negation and set flags
06m0004                               	                ;Note:  It will set overflow if AC contains 400000,,0
06m0004 02435 662104200551000441202032	        ACSEL[AC] ALU[AC] DEST[MEMSTO] SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM
06m0004                               	 ]$
06m0004                               	                ;Otherwise, store positive form.  (Both paths take same amount
06m0004                               	                ;of time.)
06m0004                               	                ;Also, set flags.
06m0004                               	
06m0004                               	        .OPCODE[LIST 
06m0004                               	 LIST            ];MOVMS
06m0004                               	MOVMS:  COND[MA-AC] JUMP[MOVMS2]
06m0004 02436 642146200571000440030000	                        DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM]$
06m0004                               	                ;Finish fetch of read-modify-write
06m0004                               	                ;Jump if we have to deal with two ACs
06m0004 02437 643100000571000440000000	        COND[AC=0] LBJUMP[MOVMS1] NORM $
06m0004                               	                ;Split off case where we load AC as side effect
06m0004                               	        .USE[06m0004                               	XLIST
06m0005                               	 LIST ] .PAIR
06m0005                               	. \ 2 + .
06m0006 02042 511100004571000440000000	]MOVMS1:        D[MEM] COND[OBUS<0] LBJUMP[MOVMS3] C550 $
06m0006                               	                ;AC field of IR is non-zero, AC is loaded as side effect
06m0006 02043 511100004571000440000000	        D[MEM] COND[OBUS<0] LBJUMP[MOVMS4] C550 $
06m0006                               	                ;Reference is only to memory
06m0006                               	        .PAIR
06m0006                               	. \ 2 + .
06m0007 02044 640160005571000440602027	]MOVMS3:        D[MEM] ACSEL[AC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $
06m0007                               	                ;Memory location is positive, just load AC
06m0007 02045 662104205473000441202032	        D[MEM] ALU[0-D] ACSEL[AC] DEST[MEMSTO AC] SPEC[CRYOV] MEMST OND[-MA-AC]
06m0007                               	 LBJUMP[MSMAIN] NORM ]$
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

06m0007                               	                ;Load AC with negative of memory and write negative back
06m0007                               	                ;into memory.
06m0007                               	                ;Set flags.  Will overflow if memory contains 400000,,0
06m0007                               	        .PAIR
06m0007                               	. \ 2 + .
06m0008 02046 640160000571000440602027	]MOVMS4:        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
06m0008                               	                ;Memory is positive.  Don't have to do anything here.
06m0008 02047 640144204473000441202033	        D[MEM] ALU[0-D] DEST[MEMSTO] SPEC[CRYOV] JUMP[MSMAIN1] NORM $
06m0008                               	                ;Memory is negative.  Store negation.
06m0008                               	                ;Set flags.  Will overflow if memory contains 400000,,0
06m0008                               	;Special cases for references to two ACs
06m0008                               	        .PAIR
06m0008                               	. \ 2 + .
06m0009                               	]MOVMS5:        ACSEL[MA] ALU[0-AC] DEST[AC AR] SPEC[CRYOV]
06m0009 02050 643110001512400441200000	                        COND[AC=0] LBJUMP[MOVMS6] NORM $
06m0009                               	                ;'memory' AC is negative, negate it and put it somewhere
06m0009                               	                ;the other AC loaded from.
06m0009                               	                ;Then, decide whether to load it into another AC
06m0009 02051 643110000550400440000000	        ACSEL[MA] ALU[AC] DEST[AR] COND[AC=0] LBJUMP[MOVMS6] NORM $
06m0009                               	                ;'memory' AC is positive.  Put it somewhere the other AC
06m0009                               	                ;can reference.
06m0009                               	                ;Decide whether to load it into another AC
06m0009                               	        .PAIR
06m0009                               	. \ 2 + .
06m0010 02052 640160001571000440602027	]MOVMS6:        ACSEL[AC] D[AR] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
06m0010                               	                ;AC field (of IR) is non-zero, load corresponding AC from
06m0010                               	                ;saved value of 'memory' AC.
06m0010                               	                ;Start next instruction fetch
06m0010 02053 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
06m0010                               	                ;AC field (of IR) is zero, just start next instruction fetch
06m0010                               	;       ---
06m0010                               	;MA refers to an AC.  Decide which special case we're dealing with.
06m0010 02054 571100000550400440002050	MOVMS2: ACSEL[MA] ALU[AC] COND[-OBUS<0] LBJUMP[MOVMS5] CYLEN[C500] $
06m0010                               	                ;Decide sign of 'memory' AC
06m0010                               	
06m0010                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

07m0010                               	;------------------------------------------------------------------------------
07m0010                               	;
07m0010                               	;       Integer Multiply
07m0010                               	;
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IMUL
07m0010 02440 640706000550400440020000	        FIXM1 $
07m0010 02441 640140004171000440000000	        D[MEM] DEST[Q] JUMP[IMUL1] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IMULI
07m0010 02442 640140034171000220000000	        D[IR] MASK[18.] DEST[Q] JUMP[IMUL1] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IMULM
07m0010 02444 640706200550400440030000	        FIXM2 $
07m0010 02445 640140004171000440000000	        D[MEM] DEST[Q] JUMP[IMUL2] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IMULB
07m0010 02446 640706200550400440030000	        FIXM2 $
07m0010 02447 640140004171000440000000	        D[MEM] DEST[Q] JUMP[IMUL3] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];MUL
07m0010 02450 640706000550400440020000	        FIXM1 $
07m0010 02451 640140004171000440000000	        D[MEM] DEST[Q] JUMP[MUL1] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];MULI
07m0010 02452 640140034171000220000000	        D[IR] MASK[18.] DEST[Q] JUMP[MUL1] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];MULM
07m0010 02454 640706200550400440030000	        FIXM2 $
07m0010 02455 640140004171000440000000	        D[MEM] DEST[Q] JUMP[MUL2] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];MULB
07m0010 02456 640706200550400440030000	        FIXM2 $
07m0010 02457 640140004171000440000000	        D[MEM] DEST[Q] JUMP[MUL3] NORM $
07m0010                               	
07m0010                               	;*$*$* Move rest of multiply code here
07m0010                               	
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	;
07m0010                               	;       Integer Divide
07m0010                               	;
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IDIV
07m0010 02460 640706000550400440020000	        FIXM1 $
07m0010 02461 571110000151000440000000	IDIV9:  ACSEL[AC] ALU[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV1] CYLEN[C500] $
07m0010                               	                ;LO PART TO Q, CHECK SIGN
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IDIVI
07m0010 02462 640144434571000220002461	        D[IR] MASK[18.] DEST[HOLD] JUMP[IDIV9]  NORM $ ;IMMD
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IDIVM
07m0010 02464 640706200550400440030000	        FIXM2 $
07m0010 02465 571110000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV2]  CYLEN[C500] $
07m0010                               	                ;LO PART TO Q, SAVE AC, CHECK SIGN
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IDIVB
07m0010 02466 640706200550400440030000	        FIXM2 $
07m0010 02467 571110000151000440000000	        ACSEL[AC] ALU[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV3] CYLEN[C500] $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];DIV
07m0010 02470 640706000550400440020000	        FIXM1 $
07m0010 02471 000140000151400440000000	DIV9:   ACSEL[AC+1] ALU[AC] DEST[Q] JUMP[DIV1] $ ;LO PART
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];DIVI
07m0010 02472 000144434571000220002471	        D[IR] MASK[18.] DEST[HOLD] JUMP[DIV9] $ ;IMMD
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];DIVM
07m0010 02474 640706200550400440030000	        FIXM2 $
07m0010 02475 000140000151400440000000	        ALU[AC] ACSEL[AC+1] DEST[Q] JUMP[DIV2] $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];DIVB
07m0010 02476 640706200550400440030000	        FIXM2 $
07m0010 02477 000140000151400440000000	        ALU[AC] ACSEL[AC+1] DEST[Q] JUMP[DIV3] $
07m0010                               	
07m0010                               	;$*$*$  Move rest of divide code here
07m0010                               	
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	;
07m0010                               	;       Shifts and Rotates
07m0010                               	;
07m0010                               	;       Two branches are taken for each shift/rotate, depending on direction.
07m0010                               	;       The macro SH1ST handles that.  The positive case gets ROTR loaded by
07m0010                               	;       that macro and other negative case will have to load it itself.
07m0010                               	;
07m0010                               	;       Note that by the time we get here, indexing and indirection have
07m0010                               	;       already been done, so the left half of the IR contains an honest
07m0010                               	;       shift count, albeit not necessarily in the range -35..35
07m0010                               	;
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	   .DEFINE SH1ST 07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];ASH
07m0010                               	        SH1ST 07m0010 02500 513140034171000440000000	D[IR] COND[OBUS18] DEST[Q] JUMP[ASHNEG] C550 $
07m0010 02501 640141234171000100000000	        D[IR] MASK[10] DEST[Q ROTR] JUMP[ASHPLS] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

07m0011                               	]
07m0011                               	        .OPCODE[LIST 
07m0011                               	 LIST            ];ROT
07m0011                               	        SH1ST 07m0011 02502 513140034171000440000000	D[IR] COND[OBUS18] DEST[Q] JUMP[ROTNEG] C550 $
07m0011 02503 640141234171000100000000	        D[IR] MASK[10] DEST[Q ROTR] JUMP[ROTPLS] NORM $
07m0012                               	]
07m0012                               	        .OPCODE[LIST 
07m0012                               	 LIST            ];LSH
07m0012                               	        SH1ST 07m0012 02504 513140034171000440000000	D[IR] COND[OBUS18] DEST[Q] JUMP[LSHNEG] C550 $
07m0012 02505 640141234171000100000000	        D[IR] MASK[10] DEST[Q ROTR] JUMP[LSHPLS] NORM $
07m0013                               	]
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];JFFO (a funny kind of shift instruction)
07m0013 02506 610150000551000440000000	        ACSEL[AC] ALU[AC] COND[OBUS=0] JUMP[JFFO1] DEST[AR] CYLEN[C450] $
07m0013 02507 640140001615400440000000	        ACSEL[AC+1] ALU[0] DEST[AC] JUMP[JFFO2] NORM $
07m0013                               	
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];ASHC
07m0013 02510 640710010621400430000000	        ACSEL[AC+1] D[MASK 43] ALU[D&AC]   DEST[AR] NORM $
07m0013 02511 640140000171002440000000	        D[AR] ROT[1] DEST[Q] JUMP[ASHC1] NORM $
07m0013                               	
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];ROTC
07m0013 02512 640700000151400440000000	        ACSEL[AC+1] ALU[AC] DEST[Q]   NORM $
07m0013 02513 533100034571000440000000	        D[IR] COND[-OBUS18] LBJUMP[ROTC1] C550 $
07m0013                               	
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];LSHC
07m0013 02514 640700000151400440000000	        ACSEL[AC+1] ALU[AC] DEST[Q]   NORM $
07m0013 02515 533100034571000440000000	        D[IR] COND[-OBUS18] LBJUMP[LSHC1] C550 $
07m0013                               	
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];(KAFIX at SAIL: "A. Kotok should have done this")
07m0013 02516 531154400551000440000000	        ACSEL[AC] ALU[AC] DEST[HOLD AR] COND[-OBUS<0] JUMP[KAFIXP] C550 $
07m0013                               	                ;Load up things for FIXER, check for positive mantissa
07m0013 02517 640150000513000440000000	        ACSEL[AC] ALU[0-AC] DEST[AR] JUMP[KAFIXN] NORM $
07m0013                               	                ;Negate AR so that its exponent can be used.
07m0013                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;       Exchange AC and memory
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];EXCH
08m0013 02520 640706200550400440030000	        FIXM2 $
08m0013                               	                ;Finish fetch of read-modify-write, checking for faults
08m0013 02521 662104205171000440002032	        ACSEL[AC] D[MEM] DEST[MEMSTO O_AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
08m0013                               	                ;Store result of fetch into AC, writing the old contents of
08m0013                               	                ;that AC into memory (O_AC means store new AC and output old
08m0013                               	                ;contents).
08m0013                               	
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;       Block Transfer Instruction
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];BLT
08m0013 02522 510140010621010160000000	        D[MASK 16] ROT[4] ACSEL[AC] ALU[D&AC] COND[OBUS=0] JUMP[BLTA1] C550 $ ;J IF DEST
08m0013                               	 IS AC
08m0013 02523 470100010621054160000000	        D[MASK 16] ROT[26] ACSEL[AC] ALU[D&AC] COND[-OBUS=0] LBJUMP[BLTA2] C600 $ ; J ON
08m0013                               	 SRC NOT AC
08m0013                               	
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;       Conditional jumps which add one to both halves
08m0013                               	;
08m0013                               	;  Caution:     With these instructions, overflow from the right half will be
08m0013                               	;               added to the left half, as on a KA.
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];AOBJP
08m0013                               	        D[CONST 1,,1] ACSEL[AC] ALU[D+AC] DEST[AC]
08m0013 02524 451140015421001000002026	                        COND[OBUS<0] JUMP[MAIN] C600 $
08m0013                               	                ;Add to both halves.  If result is negative, do not jump
08m0013 02525 640164634571000440002027	        DOJUMP $
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];AOBJN
08m0013                               	        D[CONST 1,,1] ACSEL[AC] ALU[D+AC]   DEST[AC]
08m0013 02526 471140015421001000002026	          COND[-OBUS<0] JUMP[MAIN] C600 $
08m0013 02527 640164634571000440002027	        DOJUMP $
08m0013                               	
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;       Jump Instructions (and halts)
08m0013                               	;
08m0013                               	;  Caution:     Halts set PC to effective address instead of the instruction
08m0013                               	;               that caused the halt.  This is especially bad because most
08m0013                               	;               programs which do not use UUOs place a halt in location 40,
08m0013                               	;               and the location of the UUO is then lost on an F2.  This
08m0013                               	;               might be cured by replicating the instruction fetch seqeunce
08m0013                               	;               herein with the copying of the IR into the PC happening later
08m0013                               	;               during that sequence.
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JRST
08m0013 02530 643164634571000440002027	        D[IR] DEST[MA PC] COND[AC=0] JUMP[MAIN1] NORM $
08m0013                               	                ;Make ordinary jumps as fast as possible.  Always load the PC
08m0013                               	                ;from the effective address, even on halts!?!
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

08m0013 02531 510100034571024010000000	        D[IR] ROT[12] MASK[1] COND[OBUS=0] LBJUMP[JRST1] C550 $
08m0013                               	                ;Seperate according to the 10 bit of the AC field.
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JFCL
08m0013 02532 643150034571032040002026	        D[IR] ROT[15] MASK[4] DEST[AR] COND[AC=0] JUMP[MAIN] NORM $
08m0013                               	                ;Check AC field and jump to instruction fetch if zero.
08m0013                               	                ;JFCL 0,  is the fastest no-op on a KA
08m0013 02533 640140020171000440000000	        D[PC] DEST[Q] JUMP[JFCL1] NORM $
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];XCT
08m0013 02534 663146000550400440020000	        FIXM1 COND[-AC=0] JUMP[XCT1] $
08m0013 02535 640144620531000440000000	        D[PC] ALU[D-1] DEST[PC] JUMP[XCT2] NORM $
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];A No-Op on KA's not having special features
08m0013 02536 640140000571000440002026	        JUMP[MAIN] NORM $
08m0013                               	
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;
08m0013                               	;       Stack Instructions
08m0013                               	;
08m0013                               	;  Caution:     If a stack crosses zero (i.e. a carry from the right half
08m0013                               	;               occurs, the left half will be off by one, as on a KA
08m0013                               	;               (People who wrap their stacks around and thru ACs deserve to
08m0013                               	;               lose!)
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];PUSHJ
08m0013                               	        ACSEL[AC] D[CONST 1,,1] ALU[D+AC]   DEST[AC MA]
08m0013 02540 455160015421001000000000	          COND[CRY0] JUMP[PDLO1] C600 $
08m0013                               	                ;Increment stack pointer.
08m0013                               	                ;Jump on overflow (overflow code will complete instruction)
08m0013 02541 640144220571000440000000	        D[PC] DEST[MEMSTO] JUMP[PUSHJ1] NORM $
08m0013                               	                ;Store the PC and flags on the stack
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];PUSH
08m0013 02542 640706000550400440020000	        FIXM1 $
08m0013                               	                ;Complete fetch of thing to push
08m0013 02543 640150004571000440000000	        D[MEM] DEST[AR] JUMP[PUSH1] NORM $
08m0013                               	                ;Move it somewhere else so we set MA to point to stack.
08m0013                               	                ;(Setting the MA implies a read, which would destroy the thing
08m0013                               	                ;to push).
08m0013                               	                ;*$*$* Go elsewhere to finish instruction
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];POP
08m0013                               	        ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC]
08m0013 02544 475160015063001000000000	                        COND[-CRY0] JUMP[PDLO3] C600 $
08m0013                               	                ;Decrement stack pointer, but setting the MA to the old top of
08m0013                               	                ;stack.
08m0013                               	                ;If stack underflow, jump.  (Underflow code will finish the
08m0013                               	                ;instruction).
08m0013                               	         MAPF[PPOP] ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD]
08m0013 02545 640146000550400440160000	                        JUMP[POP1] CYLEN[FIXM] $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

08m0013                               	                ;If page fault, trap to special code to handle POP
08m0013                               	                ;*$*$* Go elsewhere to finish instruction
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];POPJ
08m0013                               	        ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC]
08m0013 02546 475160015063001000000000	                        COND[-CRY0] JUMP[PDLO4] C600 $
08m0013                               	                ;Decrement stack pointer, but setting the MA to the old top of
08m0013                               	                ;stack.
08m0013                               	                ;If stack underflow, jump.  (Underflow code will finish the
08m0013                               	                ;instruction).
08m0013                               	        MAPF[PPOP] ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD]
08m0013 02547 640146000550400440160000	                        JUMP[POPJ1] CYLEN[FIXM] $
08m0013                               	                ;If page fault, trap to special code to handle POP
08m0013                               	                ;*$*$* Go elsewhere to finish instruction
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JSR
08m0013 02550 642154220571000440000000	        D[PC] DEST[AR MEMSTO] COND[MA-AC] JUMP[JSR2] NORM $
08m0013                               	                ;Write PC (and flags) into effective address.
08m0013                               	                ;Watch for special case of store into AC
08m0013                               	        MAPF[STO] D[MA] ALU[D+1] DEST[PC] SPEC[CLR-HALF]
08m0013 02551 640144624433000442242026	                        JUMP[MAIN] CYLEN[MEMSTO] $
08m0013                               	                ;Set PC into one after effective address (where we stored old
08m0013                               	                ;PC) and take next instruction from there.
08m0013                               	                ;Make sure some nurd hasn't left the BIS flag on. (*** i assume
08m0013                               	                ;  that's what going on here.  TVR-Apr80)
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JSP
08m0013 02552 640700021571000440000000	        D[PC] ACSEL[AC] DEST[AC] NORM $
08m0013                               	                ;Store PC (and flags) in AC
08m0013 02553 640144624571000442202027	JSP1:   D[MA] DEST[PC] JUMP[MAIN1] SPEC[CLR-HALF] NORM $
08m0013                               	                ;Jump to effective address
08m0013                               	                ;Make sure some nurd hasn't left the BIS flag on. (*** i assume
08m0013                               	                ;  that's what going on here.  TVR-Apr80)
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JSA
08m0013 02554 640710021171000220000000	        D[PC] MASK[18.] DEST[O_AC AR] ACSEL[AC] NORM $
08m0013                               	                ;Copy PC into left half of AC and save old contents of AC in AR
08m0013                               	                ; DID SAVE A CYCLE WITH O_AC ****
08m0013                               	        D[MA] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC]
08m0013 02555 640140025561044000200000	                        JUMP[JSA1] NORM $
08m0013                               	                ;Put effective address into right half, i.e. were the old
08m0013                               	                ;contents of the AC is stored.
08m0013                               	                ;(This is the FORTRAN subroutine call, in case you were
08m0013                               	                ; wondering why it was so wierd...)
08m0013                               	                ;*$*$* (Finish instruction elsewhere)
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JRA
08m0013 02556 640710000551000440000000	        ACSEL[AC] ALU[AC] DEST[AR] NORM  $
08m0013                               	                ;Save the return address in AR
08m0013 02557 640160000571044220000000	        D[AR] ROT[18.] MASK[18.] DEST[MA] JUMP[JRA1] NORM $
08m0013                               	                ;Begin read of location containing what's to be restored into
08m0013                               	                ;the AC (to invert a JSA)
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

08m0013                               	                ;*$*$* (Finish instruction elsewhere)
08m0013                               	
08m0013                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

09m0013                               	;------------------------------------------------------------------------------
09m0013                               	;
09m0013                               	;       Integer Add and Subtract
09m0013                               	;
09m0013                               	;------------------------------------------------------------------------------
09m0013                               	
09m0013                               	;These two macros make xxx,xxxI,xxxM,xxxB for instructions which map into a
09m0013                               	;single 2901 instruction involving AC and MEM.  OP is thing to put in the 
09m0013                               	;ALU field to do this 2901 instruction.
09m0013                               	;
09m0013                               	;ADOP and LOGOP differ only in that ADOP sets flags, and can get integer
09m0013                               	;overflow
09m0013                               	;
09m0013                               	.DEFINE ADOP 09m0013                               	
09m0013                               	.DEFINE LOGOP 09m0013                               	
09m0013                               	        .OPCODE[LIST 
09m0013                               	 LIST            ];Opcodes 270-273: ADD,ADDI,ADDM,ADDB
09m0013                               	        ADOP[09m0013 02560 640706000550400440020000	        FIXM1 $
09m0013 02561 640160005421000441002027	        ACSEL[AC] D[MEM] ALU[ D+AC ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1]
09m0013                               	 CYLEN[FIXM+1] $
09m0013                               	
09m0013 02562 640160035421000221002027	        ACSEL[AC] D[IR] MASK[18.] ALU[ D+AC ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1]
09m0013                               	 NORM $
09m0013 02563 000700000571000440000000	        NOP $
09m0013                               	
09m0013 02564 640706200550400440030000	        FIXM2 $
09m0013                               	        ACSEL[AC] D[MEM] ALU[ D+AC ] DEST[MEMSTO]
09m0013 02565 662104204421000441202032	          SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0013                               	
09m0013 02566 640706200550400440030000	        FIXM2 $
09m0013                               	        ACSEL[AC] D[MEM] ALU[ D+AC ] DEST[MEMSTO AC]
09m0013 02567 662104205421000441202032	          SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0014                               	END ADOP                ;Macro defines four instructions.  See above
09m0014                               	
09m0014                               	        .OPCODE[LIST 
09m0014                               	 LIST            ];Opcodes 274-277: SUB,SUBI,SUBM,SUBB
09m0014                               	        ADOP[09m0014 02570 640706000550400440020000	        FIXM1 $
09m0014 02571 640160005463000441002027	        ACSEL[AC] D[MEM] ALU[ AC-D ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1]
09m0014                               	 CYLEN[FIXM+1] $
09m0014                               	
09m0014 02572 640160035463000221002027	        ACSEL[AC] D[IR] MASK[18.] ALU[ AC-D ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1]
09m0014                               	 NORM $
09m0014 02573 000700000571000440000000	        NOP $
09m0014                               	
09m0014 02574 640706200550400440030000	        FIXM2 $
09m0014                               	        ACSEL[AC] D[MEM] ALU[ AC-D ] DEST[MEMSTO]
09m0014 02575 662104204463000441202032	          SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0014                               	
09m0014 02576 640706200550400440030000	        FIXM2 $
09m0014                               	        ACSEL[AC] D[MEM] ALU[ AC-D ] DEST[MEMSTO AC]
09m0014 02577 662104205463000441202032	          SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0015                               	END ADOP                ;Macro defines four instructions.  See above
09m0015                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

09m0015                               	;------------------------------------------------------------------------------
09m0015                               	;
09m0015                               	;       Conditional Instructions
09m0015                               	;
09m0015                               	;       Instruction dispatch sends each group of eight instructions to one 
09m0015                               	;       place.  The condition JCOND looks at the IR to decide whether the
09m0015                               	;       condition specified by the low order three bits of the opcode has
09m0015                               	;       been satisfied.
09m0015                               	;
09m0015                               	;------------------------------------------------------------------------------
09m0015                               	
09m0015                               	;Compare AC to effective address
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];CAI
09m0015 02600 472140034463000220002026	        D[IR] MASK[18.] ACSEL[AC] ALU[AC-D] COND[-JCOND] JUMP[MAIN] C600 $
09m0015 02601 640164620433000440002027	        DOSKIP $
09m0015                               	
09m0015                               	AREA260:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Compare AC to memory
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];CAM
09m0015 02620 640706000550400440020000	        FIXM1 $
09m0015 02621 472140004463000440002026	        D[MEM] ACSEL[AC] ALU[AC-D] COND[-JCOND] JUMP[MAIN] C600 $
09m0015 02622 640164620433000440002027	DOSKP1: DOSKIP $
09m0015                               	
09m0015                               	AREA262:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Jump on AC [compared with zero]
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];JUMP
09m0015 02640 472140014421000000002026	        D[CONST 0] ACSEL[AC] ALU[AC+D] COND[-JCOND] JUMP[MAIN] C600 $
09m0015 02641 640164634571000440002027	        DOJUMP $
09m0015                               	
09m0015                               	AREA264:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Skip on memory [compared with zero]
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];SKIP
09m0015 02660 643146000550400440020000	        FIXM1 COND[AC=0] JUMP[SKIPX1] $
09m0015                               	                ;Jump if AC not loaded as side effect
09m0015 02661 472140005533000440002026	        D[MEM] ALU[D-0] ACSEL[AC] DEST[AC] COND[-JCOND] JUMP[MAIN] C600 $
09m0015                               	                ;AC field (in IR) is zero.  Just skip on appropriate condition
09m0015 02662 640164620433000440002027	        DOSKIP $
09m0015 02663 472140004533000440002026	SKIPX1: D[MEM] ALU[D-0] COND[-JCOND] JUMP[MAIN] C600 $
09m0015                               	                ;Load memory into AC as well as skipping on appropriate
09m0015                               	                ;condition
09m0015 02664 640164620433000440002027	        DOSKIP $
09m0015                               	
09m0015                               	AREA266:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Add One to AC and jump [on AC compared with zero]
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];AOJ
09m0015 02700 472140001413000441202026	        ACSEL[AC] ALU[AC+1] DEST[AC] SPEC[CRYOV] COND[-JCOND] JUMP[MAIN] C600 $
09m0015 02701 640164634571000440002027	        DOJUMP $
09m0015                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

09m0015                               	AREA270:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Add One to Memory and skip [on memory compared to zero]
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];AOS
09m0015 02720 643146200550400440030000	        FIXM2 COND[AC=0] JUMP[ASOS1]  $
09m0015                               	                ;Finish fetch part of read-modify-write
09m0015                               	                ;Jump if AC is not loaded as a side effect.
09m0015                               	        D[MEM] ALU[D+1] ACSEL[AC] DEST[AC MEMSTO] SPEC[CRYOV]
09m0015 02721 452104205433000441200000	                        COND[JCOND] LBJUMP[ASOS2] C600 $
09m0015                               	                ;(AC field (in IR) is non-zero.  Load AC as side effect.)
09m0015                               	                ;Increment memory and store result in AC.
09m0015                               	                ;Set flags (set overflow if memory was 377777,,777777)
09m0015                               	                ;Decide where or not to skip before checking for store to AC
09m0015                               	        .PAIR
09m0015                               	. \ 2 + .
09m0016 02722 662100000571000440002032	]ASOS2: MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0016                               	                ;Do not skip.  Finish store (checking for store to AC)
09m0016 02723 662104620433000440002032	        D[PC] ALU[D+1] DEST[PC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0016                               	                ;Do skip.  Finish store.
09m0016                               	;       ---
09m0016                               	ASOS1:  D[MEM] ALU[D+1] DEST[MEMSTO] SPEC[CRYOV]
09m0016 02724 452104204433000441202722	                        COND[JCOND] LBJUMP[ASOS2] C600 $
09m0016                               	                ;Simply increment memory location.  Otherwise, same as above.
09m0016                               	
09m0016       2725	AREA272 = .     ;Recover space from hole in instruction dispatch
09m0016                               	
09m0016                               	;Subtract One from AC and jump [on AC compared with zero]
09m0016                               	        .OPCODE[LIST 
09m0016                               	 LIST            ];SOJ
09m0016 02740 472140001451000441202026	        ACSEL[AC] ALU[AC-1] DEST[AC] SPEC[CRYOV] COND[-JCOND] JUMP[MAIN] C600 $
09m0016 02741 640164634571000440002027	        DOJUMP $
09m0016                               	
09m0016                               	AREA274:        ;Recover space from hole in instruction dispatch
09m0016                               	
09m0016                               	;Subtract One from Memory and skip [on memory compared to zero]
09m0016                               	        .OPCODE[LIST 
09m0016                               	 LIST            ];SOS
09m0016 02760 643146200550400440030000	        FIXM2 COND[AC=0] JUMP[ASOS3] $
09m0016                               	                ;Finish fetch part of read-modify-write
09m0016                               	                ;Jump if AC is not loaded as a side effect.
09m0016                               	        D[MEM] ALU[D-1] ACSEL[AC] DEST[AC MEMSTO] SPEC[CRYOV]
09m0016 02761 452104205531000441202722	                        COND[JCOND] LBJUMP[ASOS2] C600 $
09m0016                               	                ;(AC field (in IR) is non-zero.  Load AC as side effect.)
09m0016                               	                ;Decrement memory and store result in AC.
09m0016                               	                ;Set flags (set overflow if memory was 400000,,0)
09m0016                               	                ;Decide where or not to skip before checking for store to AC
09m0016                               	ASOS3:  D[MEM] ALU[D-1] DEST[MEMSTO] SPEC[CRYOV]
09m0016 02762 452104204531000441202722	                        COND[JCOND] LBJUMP[ASOS2] C600 $
09m0016                               	                ;Simply decrement memory location.  Otherwise, same as above.
09m0016                               	
09m0016       2763	AREA276 = .     ;Recover space from hole in instruction dispatch
09m0016                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

10m0016                               	;------------------------------------------------------------------------------
10m0016                               	;
10m0016                               	;       Boolean Instructions
10m0016                               	;
10m0016                               	;------------------------------------------------------------------------------
10m0016                               	
10m0016                               	.DEFINE CLRAC 10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];SETZ
10m0016 03000 640140001615000440002026	        CLRAC ALU[0] ACSEL[AC] DEST[AC] NORM ]  JUMP[MAIN] $
10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];SETZI
10m0016 03002 640140001615000440002026	        CLRAC ALU[0] ACSEL[AC] DEST[AC] NORM ]  JUMP[MAIN] $
10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];SETZM
10m0016 03004 662104200615000440002032	          ALU[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];SETZB
10m0016 03006 662104201615000440002032	          ALU[0] DEST[MEMSTO AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];AND,ANDI,ANDM,ANDB
10m0016                               	                ;Generates code for four instructions.  See ADD (ADOP)  
10m0016                               	        LOGOP[10m0016 03010 640706000550400440020000	        FIXM1 $
10m0016 03011 640160005621000440602027	        ACSEL[AC] D[MEM] ALU[ D&AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0016                               	
10m0016                               	
10m0016 03012 640160035621000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ D&AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0016                               	
10m0016 03013 000700000571000440000000	        NOP $
10m0016                               	
10m0016 03014 640706200550400440030000	        FIXM2 $
10m0016                               	        ACSEL[AC] D[MEM] ALU[ D&AC ] DEST[MEMSTO]
10m0016 03015 662104204621000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0016                               	
10m0016 03016 640706200550400440030000	        FIXM2 $
10m0016                               	        ACSEL[AC] D[MEM] ALU[ D&AC ] DEST[MEMSTO AC]
10m0016 03017 662104205621000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0017                               	END LOGOP
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];ANDCA
10m0017 03020 640706000550400440020000	        FIXM1 $
10m0017 03021 640140000351000440000000	        ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA1] CYLEN[FIXM+1] $
10m0017                               	
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];ANDCAI
10m0017 03022 640700000351000440000000	        ALU[NOTAC] DEST[Q] ACSEL[AC] NORM $
10m0017                               	        D[IR] MASK[18.] ACSEL[AC] ALU[D&Q] DEST[AC MA] SPEC[MA_PC]
10m0017 03023 640160035635000220602027	                        JUMP[MAIN1] NORM $
10m0017                               	
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];ANDCAM
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

10m0017 03024 640706200550400440030000	        FIXM2 $
10m0017 03025 640140000351000440000000	        ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA2] CYLEN[FIXM+1] $
10m0017                               	
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];ANDCAB
10m0017 03026 640706200550400440030000	        FIXM2 $
10m0017 03027 640140000351000440000000	        ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA3] CYLEN[FIXM+1] $
10m0017                               	
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];SETM,SETMI,SETMM,SETMB
10m0017                               	SETM:   LOGOP[10m0017 03030 640706000550400440020000	        FIXM1 $
10m0017 03031 640160005571000440602027	        ACSEL[AC] D[MEM] ALU[ D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0017                               	
10m0017 03032 640160035571000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0017 03033 000700000571000440000000	        NOP $
10m0017                               	
10m0017 03034 640706200550400440030000	        FIXM2 $
10m0017                               	        ACSEL[AC] D[MEM] ALU[ D ] DEST[MEMSTO]
10m0017 03035 662104204571000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0017                               	
10m0017 03036 640706200550400440030000	        FIXM2 $
10m0017                               	        ACSEL[AC] D[MEM] ALU[ D ] DEST[MEMSTO AC]
10m0017 03037 662104205571000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0018                               	END LOGOP
10m0018                               	        .OPCODE[LIST 
10m0018                               	 LIST            ];ANDCM,ANDCMI,ANDCMM,ANDCMB
10m0018                               	        LOGOP[10m0018 03040 640706000550400440020000	        FIXM1 $
10m0018 03041 640160005661000440602027	        ACSEL[AC] D[MEM] ALU[ -D&AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0018                               	
10m0018                               	
10m0018 03042 640160035661000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ -D&AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0018                               	
10m0018 03043 000700000571000440000000	        NOP $
10m0018                               	
10m0018 03044 640706200550400440030000	        FIXM2 $
10m0018                               	        ACSEL[AC] D[MEM] ALU[ -D&AC ] DEST[MEMSTO]
10m0018 03045 662104204661000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0018                               	
10m0018 03046 640706200550400440030000	        FIXM2 $
10m0018                               	        ACSEL[AC] D[MEM] ALU[ -D&AC ] DEST[MEMSTO AC]
10m0018 03047 662104205661000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0019                               	END LOGOP
10m0019                               	        .OPCODE[LIST 
10m0019                               	 LIST            ];SETA,SETAI,SETAM,SETAB
10m0019                               	        LOGOP[10m0019 03050 640706000550400440020000	        FIXM1 $
10m0019 03051 640160005551000440602027	        ACSEL[AC] D[MEM] ALU[ AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0019                               	
10m0019 03052 640160035551000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0019 03053 000700000571000440000000	        NOP $
10m0019                               	
10m0019 03054 640706200550400440030000	        FIXM2 $
10m0019                               	        ACSEL[AC] D[MEM] ALU[ AC ] DEST[MEMSTO]
10m0019 03055 662104204551000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0019                               	
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

10m0019 03056 640706200550400440030000	        FIXM2 $
10m0019                               	        ACSEL[AC] D[MEM] ALU[ AC ] DEST[MEMSTO AC]
10m0019 03057 662104205551000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0019                               	END LOGOP$
10m0019                               	
10m0019                               	        .OPCODE[LIST 
10m0019                               	 LIST            ];XOR,XORI,XORM,XORB
10m0019                               	        LOGOP[10m0019 03060 640706000550400440020000	        FIXM1 $
10m0019 03061 640160005721000440602027	        ACSEL[AC] D[MEM] ALU[ AC#D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0019                               	
10m0019                               	
10m0019 03062 640160035721000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ AC#D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0019                               	
10m0019 03063 000700000571000440000000	        NOP $
10m0019                               	
10m0019 03064 640706200550400440030000	        FIXM2 $
10m0019                               	        ACSEL[AC] D[MEM] ALU[ AC#D ] DEST[MEMSTO]
10m0019 03065 662104204721000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0019                               	
10m0019 03066 640706200550400440030000	        FIXM2 $
10m0019                               	        ACSEL[AC] D[MEM] ALU[ AC#D ] DEST[MEMSTO AC]
10m0019 03067 662104205721000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0020                               	END LOGOP
10m0020                               	        .OPCODE[LIST 
10m0020                               	 LIST            ];IOR,IORI,IORM,IORB
10m0020                               	        LOGOP[10m0020 03070 640706000550400440020000	        FIXM1 $
10m0020 03071 640160005561000440602027	        ACSEL[AC] D[MEM] ALU[ DORAC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0020                               	
10m0020                               	
10m0020 03072 640160035561000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ DORAC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0020                               	
10m0020 03073 000700000571000440000000	        NOP $
10m0020                               	
10m0020 03074 640706200550400440030000	        FIXM2 $
10m0020                               	        ACSEL[AC] D[MEM] ALU[ DORAC ] DEST[MEMSTO]
10m0020 03075 662104204561000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0020                               	
10m0020 03076 640706200550400440030000	        FIXM2 $
10m0020                               	        ACSEL[AC] D[MEM] ALU[ DORAC ] DEST[MEMSTO AC]
10m0020 03077 662104205561000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0021                               	END LOGOP
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];ANDCB
10m0021 03100 640706000550400440020000	        FIXM1 $
10m0021 03101 640140004161000440000000	        ACSEL[AC] ALU[DORAC] DEST[Q] D[MEM] JUMP[ACBI1] CYLEN[FIXM+1] $
10m0021                               	
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];ANDCBI
10m0021 03102 640700034161000220000000	          ACSEL[AC] D[IR] MASK[18.] ALU[DORAC] DEST[Q] NORM $
10m0021 03103 640160001755000440602027	ACBI1:  ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0021                               	
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];ANDCBM
10m0021 03104 640706200550400440030000	        FIXM2 $
10m0021 03105 640140004161000440000000	        ACSEL[AC] ALU[DORAC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

10m0021                               	
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];ANDCBB
10m0021 03106 640706200550400440030000	        FIXM2 $
10m0021 03107 640140004161000440000000	        ACSEL[AC] ALU[DORAC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $
10m0021                               	
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];EQV,EQVI,EQVM,EQVB
10m0021                               	        LOGOP[10m0021 03110 640706000550400440020000	        FIXM1 $
10m0021 03111 640160005761000440602027	        ACSEL[AC] D[MEM] ALU[ AC/#D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0021                               	
10m0021                               	
10m0021 03112 640160035761000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ AC/#D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0021                               	
10m0021 03113 000700000571000440000000	        NOP $
10m0021                               	
10m0021 03114 640706200550400440030000	        FIXM2 $
10m0021                               	        ACSEL[AC] D[MEM] ALU[ AC/#D ] DEST[MEMSTO]
10m0021 03115 662104204761000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0021                               	
10m0021 03116 640706200550400440030000	        FIXM2 $
10m0021                               	        ACSEL[AC] D[MEM] ALU[ AC/#D ] DEST[MEMSTO AC]
10m0021 03117 662104205761000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0022                               	END LOGOP
10m0022                               	        .OPCODE[LIST 
10m0022                               	 LIST            ];SETCA,SETCAI,SETCAM,SETCAB
10m0022                               	        LOGOP[10m0022 03120 640706000550400440020000	        FIXM1 $
10m0022 03121 640160005751000440602027	        ACSEL[AC] D[MEM] ALU[ NOTAC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0022                               	
10m0022                               	
10m0022 03122 640160035751000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ NOTAC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0022                               	
10m0022 03123 000700000571000440000000	        NOP $
10m0022                               	
10m0022 03124 640706200550400440030000	        FIXM2 $
10m0022                               	        ACSEL[AC] D[MEM] ALU[ NOTAC ] DEST[MEMSTO]
10m0022 03125 662104204751000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0022                               	
10m0022 03126 640706200550400440030000	        FIXM2 $
10m0022                               	        ACSEL[AC] D[MEM] ALU[ NOTAC ] DEST[MEMSTO AC]
10m0022 03127 662104205751000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0023                               	END LOGOP
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];ORCA
10m0023 03130 640706000550400440020000	        FIXM1 $
10m0023 03131 640140004261000440000000	        ACSEL[AC] D[MEM] ALU[-D&AC] DEST[Q] JUMP[OCAI1] CYLEN[FIXM+1] $
10m0023                               	
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];ORCAI
10m0023 03132 640700034261000220000000	          ACSEL[AC] D[IR] MASK[18.] ALU[-D&AC] DEST[Q] NORM $
10m0023 03133 640160001755000440602027	OCAI1:  ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0023                               	
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];ORCAM
10m0023 03134 640706200550400440030000	        FIXM2 $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

10m0023 03135 640140004261000440000000	        ACSEL[AC] ALU[-D&AC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $
10m0023                               	
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];ORCAB
10m0023 03136 640706200550400440030000	        FIXM2 $
10m0023 03137 640140004261000440000000	        ACSEL[AC] ALU[-D&AC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $
10m0023                               	
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];SETCM,SETCMI,SETCMM,SETCMB
10m0023                               	        LOGOP[10m0023 03140 640706000550400440020000	        FIXM1 $
10m0023 03141 640160005771000440602027	        ACSEL[AC] D[MEM] ALU[ NOTD ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0023                               	
10m0023                               	
10m0023 03142 640160035771000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ NOTD ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0023                               	
10m0023 03143 000700000571000440000000	        NOP $
10m0023                               	
10m0023 03144 640706200550400440030000	        FIXM2 $
10m0023                               	        ACSEL[AC] D[MEM] ALU[ NOTD ] DEST[MEMSTO]
10m0023 03145 662104204771000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0023                               	
10m0023 03146 640706200550400440030000	        FIXM2 $
10m0023                               	        ACSEL[AC] D[MEM] ALU[ NOTD ] DEST[MEMSTO AC]
10m0023 03147 662104205771000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0024                               	END LOGOP
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCM,ORCMI,ORCMM,ORCMB
10m0024 03150 640706000550400440020000	        FIXM1 $
10m0024 03151 640140004371000440000000	        D[MEM] ALU[NOTD] DEST[Q] JUMP[OCMI1] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCMI
10m0024 03152 640700034371000220000000	          D[IR] MASK[18.] ALU[NOTD] DEST[Q] NORM $
10m0024 03153 640160001545000440602027	OCMI1:  ACSEL[AC] ALU[QORAC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCMM
10m0024 03154 640706200550400440030000	        FIXM2 $
10m0024 03155 640140004371000440000000	        D[MEM] ALU[NOTD] DEST[Q] JUMP[ORCM2] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCMB
10m0024 03156 640706200550400440030000	        FIXM2 $
10m0024 03157 640140004371000440000000	        D[MEM] ALU[NOTD] DEST[Q] JUMP[ORCM3] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCB
10m0024 03160 640706000550400440020000	        FIXM1 $
10m0024 03161 640140004221000440000000	        ACSEL[AC] D[MEM] ALU[D&AC] DEST[Q] JUMP[OCBI1] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCBI
10m0024 03162 640700034221000220000000	          ACSEL[AC] D[IR] MASK[18.] ALU[D&AC] DEST[Q] NORM $
10m0024 03163 640160001755000440602027	OCBI1:  ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

10m0024                               	 LIST            ];ORCBM
10m0024 03164 640706200550400440030000	        FIXM2 $
10m0024 03165 640140004221000440000000	        ACSEL[AC] ALU[D&AC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCBB
10m0024 03166 640706200550400440030000	        FIXM2 $
10m0024 03167 640140004221000440000000	        ACSEL[AC] ALU[D&AC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];SETO
10m0024 03170 640160001741000440602027	        ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];SETOI
10m0024 03172 640160001741000440602027	        ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];SETOM
10m0024 03174 662104200741000440002032	        ALU[-1] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]    $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];SETOB
10m0024 03176 662104201741000440002032	        ALU[-1] ACSEL[AC] DEST[MEMSTO AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0024 03177 000700000571000440000000	        NOP $
10m0024                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

11m0024                               	;------------------------------------------------------------------------------
11m0024                               	;
11m0024                               	;       Half Word Instructions
11m0024                               	;
11m0024                               	;------------------------------------------------------------------------------
11m0024                               	
11m0024                               	.DEFINE MH1 11m0024                               	
11m0024                               	.DEFINE MH2 11m0024                               	
11m0024                               	.DEFINE MH3 11m0024                               	
11m0024                               	        .OPCODE[LIST 
11m0024                               	 LIST            ];HLL,HLLI,HLLM,HLLS
11m0024                               	        MH3[11m0024 03200 640706000550400440020000	FIXM1 $
11m0024 03201 640150005171000000200000	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[O_AC AR] JUMP[ HRAR ]
11m0024                               	 CYLEN[FIXM+1] $
11m0024 03202 640150025171000000200000	        D[MA] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[O_AC AR] JUMP[ HRAR ] NORM $
11m0024                               	
11m0024 03203 000700000571000440000000	        NOP $
11m0024 03204 640706200550400440030000	        FIXM2 $
11m0024 03205 640150010221044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ HLLM1 ] CYLEN[FIXM+1] $
11m0024                               	
11m0024 03206 663100000550400440030000	        ACSEL[MA] ALU[AC] DEST[ 0 ] MAPF[3] COND[-AC=0] LBJUMP[HMV] CYLEN[FIXM] $
11m0024 03207 663110004171000000200000	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS]
11m0024                               	 CYLEN[FIXM+1] $
11m0025                               	];HRL
11m0025                               	        MH3[11m0025 03210 640706000550400440020000	FIXM1 $
11m0025 03211 640150005171044000200000	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[O_AC AR] JUMP[ HRAR ]
11m0025                               	 CYLEN[FIXM+1] $
11m0025 03212 640150025171044000200000	        D[MA] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[O_AC AR] JUMP[ HRAR ] NORM
11m0025                               	 $
11m0025 03213 000700000571000440000000	        NOP $
11m0025 03214 640706200550400440030000	        FIXM2 $
11m0025 03215 640150010221000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ HRLM1 ] CYLEN[FIXM+1] $
11m0025                               	
11m0025 03216 663706200550400440030000	        ACSEL[MA] ALU[AC] DEST[ FIXMAC-MAPF-WRT ] MAPF[3] COND[-AC=0] CONTA[0]
11m0025                               	 CYLEN[FIXM] $
11m0025 03217 663110004171044000200000	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS]
11m0025                               	 CYLEN[FIXM+1] $
11m0026                               	];HLLZ
11m0026                               	        MH1[11m0026 03220 640706000550400440020000	FIXM1 $
11m0026 03221 640160005571000000402027	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT&MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1]
11m0026                               	 CYLEN[FIXM+1] $
11m0026 03222 640160025571000000402027	        D[MA] ROT[0] MASK[ 0 ] SPEC[ LEFT&MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM
11m0026                               	 $
11m0026 03223 000700000571000440000000	        NOP $
11m0026 03224 662104210621044220002032	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[D&AC] DEST[ MEMSTO ] COND[-MA-AC] LBJUMP [
11m0026                               	 MSMAIN ]  CYLEN[ NORM ] $
11m0026 03225 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0026 03226 642146200550400440030000	        ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ HLLZS1 ] DEST[FIXMAC-MAPF-WRT] MAPF[3]
11m0026                               	 CYLEN[FIXM] $
11m0026 03227 663104204571000000200000	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1]
11m0026                               	 CYLEN[FIXM+1] $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

11m0027                               	];HRLZ
11m0027                               	        MH1[11m0027 03230 640706000550400440020000	FIXM1 $
11m0027 03231 640160005571044000402027	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT&MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1]
11m0027                               	 CYLEN[FIXM+1] $
11m0027 03232 640160025571044000402027	        D[MA] ROT[22] MASK[ 0 ] SPEC[ LEFT&MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM
11m0027                               	 $
11m0027 03233 000700000571000440000000	        NOP $
11m0027 03234 662710010621000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[D&AC] DEST[ AR ] COND[-MA-AC] CONTA [ 0 ] 
11m0027                               	 CYLEN[ NORM ] $
11m0027 03235 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0027 03236 642146200550400440030000	        ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ HRLZS1 ] DEST[FIXMAC-MAPF-WRT] MAPF[3]
11m0027                               	 CYLEN[FIXM] $
11m0027 03237 663104204571044000200000	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1]
11m0027                               	 CYLEN[FIXM+1] $
11m0028                               	];HLLO
11m0028                               	        MH2[11m0028 03240 640706000550400440020000	FIXM1 $
11m0028 03241 640150005571000440000000	        D[MEM] ROT[ 0 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOR ]
11m0028                               	 CYLEN[FIXM+1] $
11m0028 03242 640150025571000440000000	        D[MA] ROT[ 0 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOR ]
11m0028                               	 NORM $
11m0028 03243 000700000571000440000000	        NOP $
11m0028 03244 662104210161000220002032	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[DORAC] DEST[Q MEMSTO ] COND[ -MA-AC ]
11m0028                               	 LBJUMP[MSMAIN] CYLEN[ NORM ] $
11m0028 03245 662104200571000440002032	        D[AR] ROT[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0028 03246 640706200550400440030000	        FIXM2 $
11m0028 03247 663110004171000440000000	        D[MEM] ROT[ 0 ] DEST[Q AR] COND[ -AC=0 ] LBJUMP[ HLLOS1] CYLEN[FIXM+1] $
11m0029                               	];HRLO
11m0029                               	        MH2[11m0029 03250 640706000550400440020000	FIXM1 $
11m0029 03251 640150005571044440000000	        D[MEM] ROT[ 22 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOR
11m0029                               	 ] CYLEN[FIXM+1] $
11m0029 03252 640150025571044440000000	        D[MA] ROT[ 22 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOR ]
11m0029                               	 NORM $
11m0029 03253 000700000571000440000000	        NOP $
11m0029 03254 640710010161044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ 0 ] CONTA[0] CYLEN[
11m0029                               	 NORM ] $
11m0029 03255 662104200571044440002032	        D[AR] ROT[22] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0029 03256 640706200550400440030000	        FIXM2 $
11m0029 03257 663110004171044440000000	        D[MEM] ROT[ 22 ] DEST[Q AR] COND[ -AC=0 ] LBJUMP[ HLLOS1] CYLEN[FIXM+1] $
11m0030                               	];HLLE
11m0030                               	        MH2[11m0030 03260 640706000550400440020000	FIXM1 $
11m0030 03261 651110005571000000200000	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[AC AR] COND[ OBUS<0 ]
11m0030                               	 LBJUMP [ HLSZ ] CYLEN[FIXM+1] $
11m0030 03262 651110025571000000200000	        D[MA] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[AC AR] COND[ OBUS<0 ] LBJUMP
11m0030                               	 [ HLSZ ] NORM $
11m0030 03263 000700000571000440000000	        NOP $
11m0030 03264 531150010161000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ -OBUS<0 ] JUMP[HLLEM1]
11m0030                               	 CYLEN[ C550 ] $
11m0030 03265 662104200571000440002032	        D[AR] ROT[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0030 03266 640706200550400440030000	        FIXM2 $
11m0030 03267 651110004171000440000000	        D[MEM] ROT[ 0 ] DEST[Q AR] COND[ OBUS<0 ] LBJUMP[ HLLES1] CYLEN[FIXM+1] $
11m0031                               	];HRLE
11m0031                               	        MH2[11m0031 03270 640706000550400440020000	FIXM1 $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

11m0031 03271 651110005571044000200000	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[AC AR] COND[ OBUS<0 ]
11m0031                               	 LBJUMP [ HLSZ ] CYLEN[FIXM+1] $
11m0031 03272 651110025571044000200000	        D[MA] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[AC AR] COND[ OBUS<0 ]
11m0031                               	 LBJUMP [ HLSZ ] NORM $
11m0031 03273 000700000571000440000000	        NOP $
11m0031 03274 533150010161044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ -OBUS18 ]
11m0031                               	 JUMP[HRLEM1] CYLEN[ C550 ] $
11m0031 03275 662104200571044440002032	        D[AR] ROT[22] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0031 03276 640706200550400440030000	        FIXM2 $
11m0031 03277 651110004171044440000000	        D[MEM] ROT[ 22 ] DEST[Q AR] COND[ OBUS<0 ] LBJUMP[ HLLES1] CYLEN[FIXM+1] $
11m0032                               	];HRR
11m0032                               	        MH3[11m0032 03300 640706000550400440020000	FIXM1 $
11m0032 03301 640150005171000220000000	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[O_AC AR] JUMP[ HLAR ]
11m0032                               	 CYLEN[FIXM+1] $
11m0032 03302 640150025171000220000000	        D[MA] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[O_AC AR] JUMP[ HLAR ] NORM $
11m0032 03303 000700000571000440000000	        NOP $
11m0032 03304 640706200550400440030000	        FIXM2 $
11m0032 03305 640150010221000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ HRRM1 ] CYLEN[FIXM+1] $
11m0032                               	
11m0032 03306 663100000550400440030000	        ACSEL[MA] ALU[AC] DEST[ 0 ] MAPF[3] COND[-AC=0] LBJUMP[HMV] CYLEN[FIXM] $
11m0032 03307 663110004171000220000000	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS]
11m0032                               	 CYLEN[FIXM+1] $
11m0033                               	];HLR
11m0033                               	        MH3[11m0033 03310 640706000550400440020000	FIXM1 $
11m0033 03311 640150005171044220000000	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[O_AC AR] JUMP[ HLAR ]
11m0033                               	 CYLEN[FIXM+1] $
11m0033 03312 640150025171044220000000	        D[MA] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[O_AC AR] JUMP[ HLAR ] NORM $
11m0033                               	
11m0033 03313 000700000571000440000000	        NOP $
11m0033 03314 640706200550400440030000	        FIXM2 $
11m0033 03315 640150010221044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ HLRM1 ] CYLEN[FIXM+1] $
11m0033                               	
11m0033 03316 663706200550400440030000	        ACSEL[MA] ALU[AC] DEST[ FIXMAC-MAPF-WRT ] MAPF[3] COND[-AC=0] CONTA[0]
11m0033                               	 CYLEN[FIXM] $
11m0033 03317 663110004171044220000000	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS]
11m0033                               	 CYLEN[FIXM+1] $
11m0034                               	];HRRZ
11m0034                               	        MH1[11m0034 03320 640706000550400440020000	FIXM1 $
11m0034 03321 640160005571000220602027	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1]
11m0034                               	 CYLEN[FIXM+1] $
11m0034 03322 640160025571000220602027	        D[MA] ROT[0] MASK[ 22 ] SPEC[ MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM $
11m0034 03323 000700000571000440000000	        NOP $
11m0034 03324 662104210621000220002032	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[D&AC] DEST[ MEMSTO ] COND[-MA-AC] LBJUMP [
11m0034                               	 MSMAIN ]  CYLEN[ NORM ] $
11m0034 03325 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0034 03326 642146200550400440030000	        ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ HRRZS1 ] DEST[FIXMAC-MAPF-WRT] MAPF[3]
11m0034                               	 CYLEN[FIXM] $
11m0034 03327 663104204571000220000000	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1]
11m0034                               	 CYLEN[FIXM+1] $
11m0035                               	];HLRZ
11m0035                               	        MH1[11m0035 03330 640706000550400440020000	FIXM1 $
11m0035 03331 640160005571044220602027	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1]
11m0035                               	 CYLEN[FIXM+1] $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

11m0035 03332 640160025571044220602027	        D[MA] ROT[22] MASK[ 22 ] SPEC[ MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM $
11m0035 03333 000700000571000440000000	        NOP $
11m0035 03334 662710010621044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[D&AC] DEST[ AR ] COND[-MA-AC] CONTA [ 0 ] 
11m0035                               	 CYLEN[ NORM ] $
11m0035 03335 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0035 03336 642146200550400440030000	        ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ HLRZS1 ] DEST[FIXMAC-MAPF-WRT] MAPF[3]
11m0035                               	 CYLEN[FIXM] $
11m0035 03337 663104204571044220000000	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1]
11m0035                               	 CYLEN[FIXM+1] $
11m0036                               	];HRRO
11m0036                               	        MH2[11m0036 03340 640706000550400440020000	FIXM1 $
11m0036 03341 640150005571000440000000	        D[MEM] ROT[ 0 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOL ]
11m0036                               	 CYLEN[FIXM+1] $
11m0036 03342 640150025571000440000000	        D[MA] ROT[ 0 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOL ]
11m0036                               	 NORM $
11m0036 03343 000700000571000440000000	        NOP $
11m0036 03344 662104210161044220002032	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[DORAC] DEST[Q MEMSTO ] COND[ -MA-AC ]
11m0036                               	 LBJUMP[MSMAIN] CYLEN[ NORM ] $
11m0036 03345 662104200571000440002032	        D[AR] ROT[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0036 03346 640706200550400440030000	        FIXM2 $
11m0036 03347 663110004171000440000000	        D[MEM] ROT[ 0 ] DEST[Q AR] COND[ -AC=0 ] LBJUMP[ HRROS1] CYLEN[FIXM+1] $
11m0037                               	];HLRO
11m0037                               	        MH2[11m0037 03350 640706000550400440020000	FIXM1 $
11m0037 03351 640150005571044440000000	        D[MEM] ROT[ 22 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOL
11m0037                               	 ] CYLEN[FIXM+1] $
11m0037 03352 640150025571044440000000	        D[MA] ROT[ 22 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOL ]
11m0037                               	 NORM $
11m0037 03353 000700000571000440000000	        NOP $
11m0037 03354 640710010161000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ 0 ] CONTA[0] CYLEN[
11m0037                               	 NORM ] $
11m0037 03355 662104200571044440002032	        D[AR] ROT[22] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0037 03356 640706200550400440030000	        FIXM2 $
11m0037 03357 663110004171044440000000	        D[MEM] ROT[ 22 ] DEST[Q AR] COND[ -AC=0 ] LBJUMP[ HRROS1] CYLEN[FIXM+1] $
11m0038                               	];HRRE
11m0038                               	        MH2[11m0038 03360 640706000550400440020000	FIXM1 $
11m0038 03361 653110005571000220000000	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ OBUS18 ] LBJUMP
11m0038                               	 [ HRSZ ] CYLEN[FIXM+1] $
11m0038 03362 653110025571000220000000	        D[MA] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ OBUS18 ] LBJUMP [
11m0038                               	 HRSZ ] NORM $
11m0038 03363 000700000571000440000000	        NOP $
11m0038 03364 533150010161044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ -OBUS18 ]
11m0038                               	 JUMP[HRREM1] CYLEN[ C550 ] $
11m0038 03365 662104200571000440002032	        D[AR] ROT[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0038 03366 640706200550400440030000	        FIXM2 $
11m0038 03367 653110004171000440000000	        D[MEM] ROT[ 0 ] DEST[Q AR] COND[ OBUS18 ] LBJUMP[ HRRES1] CYLEN[FIXM+1] $
11m0039                               	];HLRE
11m0039                               	        MH2[11m0039 03370 640706000550400440020000	FIXM1 $
11m0039 03371 653110005571044220000000	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ OBUS18 ] LBJUMP
11m0039                               	 [ HRSZ ] CYLEN[FIXM+1] $
11m0039 03372 653110025571044220000000	        D[MA] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ OBUS18 ] LBJUMP
11m0039                               	 [ HRSZ ] NORM $
11m0039 03373 000700000571000440000000	        NOP $
11m0039 03374 531150010161000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ -OBUS<0 ] JUMP[HLREM1]
11m0039                               	 CYLEN[ C550 ] $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

11m0039 03375 662104200571044440002032	        D[AR] ROT[22] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0039 03376 640706200550400440030000	        FIXM2 $
11m0039 03377 653110004171044440000000	        D[MEM] ROT[ 22 ] DEST[Q AR] COND[ OBUS18 ] LBJUMP[ HRRES1] CYLEN[FIXM+1] $
11m0040                               	]
11m0040                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

12m0040                               	;------------------------------------------------------------------------------
12m0040                               	;
12m0040                               	;       Bit Test Instructions
12m0040                               	;
12m0040                               	;  Caution:     Instruction dispatch for these instructions is peculiar.
12m0040                               	;
12m0040                               	;------------------------------------------------------------------------------
12m0040                               	
12m0040                               	        .OPCODE[LIST 
12m0040                               	 LIST            ];TRN GROUP
12m0040                               	          D[IR] MASK[18.] ACSEL[AC] ALU[D&AC]
12m0040 03400 532160034621000220602027	            SPEC[MA_PC] DEST[MA] COND[-JCOND] JUMP[MAIN1] C550 $
12m0040 03401 640164620433000440002027	        DOSKIP $
12m0040                               	
12m0040                               	        .OPCODE[LIST 
12m0040                               	 LIST            ];TLN GROUP
12m0040                               	          D[IR] ROT[18.] ACSEL[AC] ALU[D&AC]
12m0040 03402 532160034621044000402027	            SPEC[LEFT&MA_PC] DEST[MA] COND[-JCOND] JUMP[MAIN1] C550 $
12m0040 03403 640164620433000440002027	        DOSKIP $
12m0040                               	
12m0040                               	   .DEFINE T2GRP 12m0040                               	
12m0040                               	;Following code is NOT dispatched to, it is JUMPed to.
12m0040                               	TRZ1:   T2GRP 12m0040 03404 640700035661000220000000	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[-D&AC] DEST[AC] NORM $
12m0040 03405 640164620433000440002027	        DOSKIP $
12m0041                               	]TLZ1:  T2GRP 12m0041 03406 640700035661044000200000	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[-D&AC] DEST[AC] NORM $
12m0041 03407 640164620433000440002027	        DOSKIP $
12m0042                               	]TRO1:  T2GRP 12m0042 03410 640700035561000220000000	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[DORAC] DEST[AC] NORM $
12m0042 03411 640164620433000440002027	        DOSKIP $
12m0043                               	]TLO1:  T2GRP 12m0043 03412 640700035561044000200000	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[DORAC] DEST[AC] NORM $
12m0043 03413 640164620433000440002027	        DOSKIP $
12m0044                               	]TRC1:  T2GRP 12m0044 03414 640700035721000220000000	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[D#AC] DEST[AC] NORM $
12m0044 03415 640164620433000440002027	        DOSKIP $
12m0045                               	]TLC1:  T2GRP 12m0045 03416 640700035721044000200000	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[D#AC] DEST[AC] NORM $
12m0045 03417 640164620433000440002027	        DOSKIP $
12m0046                               	]
12m0046                               	;(No space left before dispatch entry)
12m0046                               	
12m0046                               	        .OPCODE[LIST 
12m0046                               	 LIST            ];TDN GROUP
12m0046 03420 640706000550400440020000	        FIXM1 $
12m0046 03421 452100004621000440000000	        D[MEM] ACSEL[AC] ALU[D&AC] COND[JCOND] LBJUMP[SKMAIN] C600 $
12m0046                               	        .OPCODE[LIST 
12m0046                               	 LIST            ];TSN GROUP
12m0046 03422 640706000550400440020000	        FIXM1 $
12m0046 03423 452100004621044440000000	        D[MEM] ACSEL[AC] ROT[18.] ALU[D&AC] COND[JCOND] LBJUMP[SKMAIN] C600 $
12m0046                               	
12m0046                               	;(Following is not dispatched to.  It probably belongs with MSMAIN, etc.)
12m0046                               	        .PAIR
12m0046                               	. \ 2 + .
12m0047 03424 640160000571000440602027	]SKMAIN:        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

12m0047 03425 640164620433000440002027	        DOSKIP $
12m0047                               	
12m0047                               	AREA342:        ;Recover space from hole in instruction dispatch
12m0047                               	
12m0047                               	  .DEFINE T1GRP 12m0047                               	        .OPCODE[LIST 
12m0047                               	 LIST            ];TRZ GROUP
12m0047                               	        T1GRP 12m0047 03440 512140034621000220003404	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[D&AC] COND[JCOND] JUMP[TRZ1] C550 $
12m0047 03441 640160035661000220602027	        ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[MA_PC] ALU[-D&AC] DEST[AC MA] JUMP[MAIN1]
12m0047                               	 NORM $
12m0048                               	]
12m0048                               	        .OPCODE[LIST 
12m0048                               	 LIST            ];TLZ GROUP
12m0048                               	        T1GRP 12m0048 03442 512140034621044000203406	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[D&AC] COND[JCOND] JUMP[TLZ1] C550 $
12m0048 03443 640160035661044000402027	        ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT&MA_PC] ALU[-D&AC] DEST[AC MA]
12m0048                               	 JUMP[MAIN1] NORM $
12m0049                               	]
12m0049                               	AREA344:        ;Recover space from hole in instruction dispatch
12m0049                               	
12m0049                               	        .OPCODE[LIST 
12m0049                               	 LIST            ];TDZ
12m0049 03460 640706000550400440020000	        FIXM1 $
12m0049 03461 640140000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDZ1] NORM $
12m0049                               	
12m0049                               	        .OPCODE[LIST 
12m0049                               	 LIST            ];TSZ
12m0049 03462 640706000550400440020000	        FIXM1 $
12m0049 03463 640700000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] NORM $
12m0049                               	;       \ /
12m0049                               	;Following is not in instruction dispatch
12m0049 03464 640700005661044440000000	        ACSEL[AC] D[MEM] ROT[18.] ALU[-D&AC] DEST[AC] SHORT $
12m0049 03465 452100004635044440003424	TSZ2:   D[MEM] ROT[18.] ALU[D&Q] COND[JCOND] LBJUMP[SKMAIN] C600 $
12m0049 03466 640700005661000440000000	TDZ1:   ACSEL[AC] D[MEM] ALU[-D&AC] DEST[AC] SHORT $
12m0049 03467 452100004635000440003424	TDZ2:   D[MEM] ALU[D&Q] COND[JCOND] LBJUMP[SKMAIN] C600 $
12m0049                               	
12m0049                               	AREA346:        ;Recover space from hole in instruction dispatch
12m0049                               	
12m0049                               	        .OPCODE[LIST 
12m0049                               	 LIST            ];TRC GROUP
12m0049                               	        T1GRP 12m0049 03500 512140034621000220003414	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[D&AC] COND[JCOND] JUMP[TRC1] C550 $
12m0049 03501 640160035721000220602027	        ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[MA_PC] ALU[D#AC] DEST[AC MA] JUMP[MAIN1]
12m0049                               	 NORM $
12m0050                               	]
12m0050                               	        .OPCODE[LIST 
12m0050                               	 LIST            ];TLC GROUP
12m0050                               	        T1GRP 12m0050 03502 512140034621044000203416	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[D&AC] COND[JCOND] JUMP[TLC1] C550 $
12m0050 03503 640160035721044000402027	        ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT&MA_PC] ALU[D#AC] DEST[AC MA]
12m0050                               	 JUMP[MAIN1] NORM $
12m0051                               	]
12m0051                               	AREA350:        ;Recover space from hole in instruction dispatch
12m0051                               	
12m0051                               	        .OPCODE[LIST 
12m0051                               	 LIST            ];TDC
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

12m0051 03520 640706000550400440020000	        FIXM1 $
12m0051 03521 640140000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDC1] NORM $
12m0051                               	
12m0051                               	        .OPCODE[LIST 
12m0051                               	 LIST            ];TSC
12m0051 03522 640706000550400440020000	        FIXM1 $
12m0051 03523 640700000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] NORM $
12m0051 03524 640140005721044440003465	        ACSEL[AC] D[MEM] ROT[18.] ALU[AC#D] DEST[AC] JUMP[TSZ2] NORM $
12m0051 03525 640140005721000440003467	TDC1:   ACSEL[AC] D[MEM] ALU[AC#D] DEST[AC] JUMP[TDZ2] NORM $
12m0051                               	
12m0051                               	AREA352:        ;Recover space from hole in instruction dispatch
12m0051                               	
12m0051                               	        .OPCODE[LIST 
12m0051                               	 LIST            ];TRO GROUP
12m0051                               	        T1GRP 12m0051 03540 512140034621000220003410	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[D&AC] COND[JCOND] JUMP[TRO1] C550 $
12m0051 03541 640160035561000220602027	        ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[MA_PC] ALU[DORAC] DEST[AC MA] JUMP[MAIN1]
12m0051                               	 NORM $
12m0052                               	]
12m0052                               	        .OPCODE[LIST 
12m0052                               	 LIST            ];TLO GROUP
12m0052                               	        T1GRP 12m0052 03542 512140034621044000203412	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[D&AC] COND[JCOND] JUMP[TLO1] C550 $
12m0052 03543 640160035561044000402027	        ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT&MA_PC] ALU[DORAC] DEST[AC MA]
12m0052                               	 JUMP[MAIN1] NORM $
12m0053                               	]
12m0053                               	AREA354:        ;Recover space from hole in instruction dispatch
12m0053                               	
12m0053                               	        .OPCODE[LIST 
12m0053                               	 LIST            ];TDO GROUP
12m0053 03560 640706000550400440020000	        FIXM1 $
12m0053 03561 640140000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDO1] NORM $
12m0053                               	
12m0053                               	        .OPCODE[LIST 
12m0053                               	 LIST            ];TSO GROUP
12m0053 03562 640706000550400440020000	        FIXM1 $
12m0053 03563 640700000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] NORM $
12m0053 03564 640140005561044440003465	        ACSEL[AC] D[MEM] ROT[18.] ALU[DORAC] DEST[AC] JUMP[TSZ2] NORM $
12m0053 03565 640140005561000440003467	TDO1:   ACSEL[AC] D[MEM] ALU[DORAC] DEST[AC] JUMP[TDZ2] NORM $
12m0053                               	
12m0053                               	AREA356:        ;Recover space from hole in instruction dispatch
12m0053                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

13m0053                               	; IOT GROUP -- FOR NOW
13m0053                               	
13m0053                               	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
13m0053                               	;;;;                                                                    ;;;;
13m0053                               	;;;;    CAUTION: Hardware currently does not check for User when doing  ;;;;
13m0053                               	;;;;    IOTs.  Most, but not all, now check it in micro code.  The      ;;;;
13m0053                               	;;;;    instruction dispatch hardware is probably the right place to    ;;;;
13m0053                               	;;;;    check for this, but try to convince Poole of that...            ;;;;
13m0053                               	;;;;                                                                    ;;;;
13m0053                               	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
13m0053                               	
13m0053                               	
13m0053                               	.repeat 0[
13m0053                               	repeat 0
13m0053                               	
13m0053                               	.DEFINE IOTDIS 13m0053                               	.DEFINE IOTDIS
13m0053                               	        ;Bit 14 is guaranteed zero by instruction decode process and therefore
13m0053                               	        ;doubling can be obtained by extraction.   TVR-Apr80
13m0053                               	
13m0053                               	        .OPCODE[LIST 
13m0053                               	 LIST            ];APR & PI
13m0053 03600 665101614571000060020000	        MAPF[2] D[CONST 6] DEST[DEV-ADR] COND[-USER] LBJUMP[APIOT] NORM $
13m0053 03601 000700000571000440000000	        NOP $
13m0053                               	
13m0053                               	        .OPCODE[13m0053                               	LIST 
13m0054                               	 LIST            ]      ILGIOT 13m0054 03602 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03603 000700000571000440000000	        NOP $
13m0054                               	
13m0054                               	        .OPCODE[LIST 
13m0054                               	 LIST            ];UNUSED & MAP
13m0054 03604 640701614571000010020000	        MAPF[2] D[CONST 1] DEST[DEV-ADR] NORM $
13m0054 03605 665100034171032040000000	        D[IR] ROT[15] MASK[4] DEST[Q] COND[-USER] LBJUMP[MAPIOT] NORM $
13m0054                               	
13m0054                               	.REPEAT 7 [I13m0054                               	LGIOT 13m0054 03606 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03607 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03610 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03611 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03612 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03613 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03614 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03615 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03616 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03617 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03620 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03621 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03622 000140000571000440002026	 JUMP [MAIN] ]$
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

13m0054 03623 000700000571000440000000	        NOP $
13m0054                               	         ]
13m0054                               	        .OPCODE[LIST 
13m0054                               	 LIST            ];CTY & LPT
13m0054 03624 665101614571000040020000	        MAPF[2] D[CONST 4] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[CTYIOT] $
13m0054 03625 000700000571000440000000	        NOP $
13m0054                               	
13m0054                               	        ILGIOT 13m0054 03626 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03627 000700000571000440000000	         NOP $
13m0054                               	        ILGIOT 13m0054 03630 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03631 000700000571000440000000	         NOP $
13m0054                               	
13m0054                               	;DISK CTRL IOTS-- 140 - 174
13m0054                               	
13m0054                               	        .OPCODE[LIST 
13m0054                               	 LIST            ];DISK CTRL IOTS-- OPCODES 715 TO 724
13m0054 03632 005141614571000103400000	        D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
13m0054                               	         MAPF[0] D[IOD] DEST[MEMSTO] 
13m0054 03633 022104230571000440002024	                COND[-MA-AC] LBJUMP[SMAIN] $
13m0054 03634 005141614571000103400000	        D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
13m0054                               	         MAPF[1] D[IOD] DEST[MEMSTO] 
13m0054 03635 022104230571000440012024	                COND[-MA-AC] LBJUMP[SMAIN] $
13m0054 03636 005141614571000103400000	        D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
13m0054                               	         MAPF[2] D[IOD] DEST[MEMSTO] 
13m0054 03637 022104230571000440022024	                COND[-MA-AC] LBJUMP[SMAIN] $
13m0054 03640 005141614571000103400000	        D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
13m0054                               	         MAPF[3] D[IOD] DEST[MEMSTO] 
13m0054 03641 022104230571000440032024	                COND[-MA-AC] LBJUMP[SMAIN] $
13m0054 03642 000046000550400440020000	        FIXML PUSHJ[SET-DSK-OUT] $ ;ld cmd -- opcode 721
13m0054 03643 000140400571000443042026	         MAPF[4] d[ar] DEST[2]  DEST-A-MEM JUMP[MAIN] $
13m0054 03644 000046000550400440020000	        FIXML PUSHJ[SET-DSK-OUT] $
13m0054 03645 000160000571000440652027	         MAPF[5] DEST[MA]  SPEC[MA_PC]  JUMP[MAIN1] $
13m0054 03646 000046000550400440020000	        FIXML PUSHJ[SET-DSK-OUT] $
13m0054 03647 000160000571000440662027	         MAPF[6] DEST[MA]  SPEC[MA_PC]  JUMP[MAIN1] $
13m0054 03650 000046000550400440020000	        FIXML PUSHJ[SET-DSK-OUT] $
13m0054 03651 000160000571000440672027	         MAPF[7] DEST[MA]  SPEC[MA_PC]  JUMP[MAIN1] $
13m0054                               	        
13m0054                               	;TAPE IOTS - OPCODES 725 - 732 --Dispatch entries on page headed ";TAPE DISP"
13m0054                               	
13m0054                               	
13m0054                               	.OPCODE[13m0054                               	LIST 
13m0055                               	 LIST            ]
13m0055                               	  .REPEAT  4 [I13m0055                               	LGIOT 13m0055 03666 000140000571000440002026	 JUMP [MAIN] ]$ ;SKIP OPCODES 733 - 736
13m0055 03667 000700000571000440000000	        NOP $
13m0055                               	  ]LGIOT 13m0055 03670 000140000571000440002026	 JUMP [MAIN] ]$ ;SKIP OPCODES 733 - 736
13m0055 03671 000700000571000440000000	        NOP $
13m0055                               	  ]LGIOT 13m0055 03672 000140000571000440002026	 JUMP [MAIN] ]$ ;SKIP OPCODES 733 - 736
13m0055 03673 000700000571000440000000	        NOP $
13m0055                               	  ]LGIOT 13m0055 03674 000140000571000440002026	 JUMP [MAIN] ]$ ;SKIP OPCODES 733 - 736
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

13m0055 03675 000700000571000440000000	        NOP $
13m0055                               	  ]     .OPCODE[LIST 
13m0055                               	 LIST            ];DLS iot's (DLS is device 370)
13m0055                               	 .REPEAT 1 - DLS [ 13m0055                               	;1 - DLS
13m0055                               	
13m0055                               	   ;skip space for disk cono,coni, etc. OPS 740 - 743
13m0055                               	   ;locs 3700 to 3707
13m0055                               	          ; these dispatch entries are on dsk page.
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Tymnet opcodes (or undefined)
13m0055                               	 .repeat 1 - Tymnet [
13m0055                               	        .repeat 4 [ 13m0055                               	ilgiot 13m0055 03710 000140000571000440002026	 JUMP [MAIN] ]$  nop $  ;if no tymnet, 744-747 = nop
13m0055 03711 000700000571000440000000	
13m0055                               	                   ]ilgiot 13m0055 03712 000140000571000440002026	 JUMP [MAIN] ]$  nop $  ;if no tymnet, 744-747 = nop
13m0055 03713 000700000571000440000000	
13m0055                               	                   ]ilgiot 13m0055 03714 000140000571000440002026	 JUMP [MAIN] ]$  nop $  ;if no tymnet, 744-747 = nop
13m0055 03715 000700000571000440000000	
13m0055                               	                   ]ilgiot 13m0055 03716 000140000571000440002026	 JUMP [MAIN] ]$  nop $  ;if no tymnet, 744-747 = nop
13m0055 03717 000700000571000440000000	
13m0055                               	                   ]               ]
13m0055                               	.repeat tymnet [
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ] ;READ ECC INFO
13m0055 03720 662104244571000442402032	        D[11] A-MEM-APR DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
13m0055                               	         ;Get info on last ECC error from A-MEM(1), store in eff. adr.
13m0055 03721 000700000571000440000000	        NOP $
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Undefined
13m0055                               	        ILGIOT 13m0055 03722 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03723 000700000571000440000000	        NOP $
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];
13m0055                               	.REPEAT 1 - VC [
13m0055                               	.REPEAT 1 - VC
13m0055                               	.REPEAT VC [    13m0055                               	        ;Versatec
13m0055 03724 665101614571000140000000	        D[CONST VCDEV] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[VCIOT] $
13m0055                               	                ;Set micro device address for Versatec and check for
13m0055                               	                ;IOT-User mode
13m0055 03725 000700000571000440000000	        NOP $
13m0055                               	].REPEAT VC
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Undefined
13m0055                               	        ILGIOT 13m0055 03726 000140000571000440002026	 JUMP [MAIN] ]$
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

13m0055 03727 000700000571000440000000	        NOP $
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Undefined
13m0055                               	        ILGIOT 13m0055 03730 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03731 000700000571000440000000	        NOP $
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];IMP (BBN), device code 550
13m0055                               	.REPEAT 1 - IMP [I13m0055                               	1 - IMP
13m0055                               	
13m0055                               	.REPEAT IMP [   13m0055                               	;Reserve space for the IMP IOT dispatch instructions
13m0055                               	IMP-IOT:
13m0055                               	]IMP
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Undefined
13m0055                               	.REPEAT (757 - 756 + 1) [I13m0055                               	LGIOT 13m0055 03734 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03735 000700000571000440000000	        NOP $
13m0055                               	 ]LGIOT 13m0055 03736 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03737 000700000571000440000000	        NOP $
13m0055                               	 ]
13m0055                               	TIMER-IOTS:
13m0055                               	  
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];760:765
13m0055                               	.REPEAT 0 * (1 - TIMER) * (765 - 760 + 1) [I13m0055                               	;;; : TIMER-IOTS + 12.  ;LEAVE SPACE FOR OPCODES 760-765
13m0055                               	;*** This is an unreasonably large waste of opcode space.  It should dispatch
13m0055                               	;*** on the AC field at least if normal PDP-10 I/O opcodes aren't suitable.
13m0055                               	;*** Furthermore, this kind of opcode has no chance of being properly
13m0055                               	;*** disassembled by DDT.                                       TVR-Apr80
13m0055                               	
13m0055                               	        .OPCODE[13m0055                               	LIST 
13m0056                               	 LIST            ].REPEAT STANSW [      13m0056                               	.REPEAT 1 - STANSW [C13m0056 03770 000140100571000440002026	URRENTLY-UNUSED[1]  JUMP[MAIN] $
13m0056                               	
13m0056 03771 000700000571000440000000	        NOP $
13m0056                               	]
13m0056                               	        .OPCODE[13m0056                               	LIST 
13m0057                               	 LIST            ]
13m0057                               	 .REPEAT 1 [
13m0057                               	        
13m0057                               	;CAM -- A COPY OF CAM WHICH HALTS IF IT DOESN'T SKIP.  WOW !
13m0057 03772 640706000550400440020000	        FIXM1 $
13m0057 03773 452140004463000440002622	        D[MEM] ACSEL[AC] ALU[AC-D] COND[JCOND] JUMP[DOSKP1] C600 $
13m0057 03774 000140104571000440003774	        D[MEM] CURRENTLY-UNUSED[1] JUMP[.] $
13m0057                               	
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

13m0057                               	;;DSKWT  -- DELAY UNTIL DISK NOT BUSY
13m0057                               	;       JUMP[DSKWT1] $          ;OPCODE 775
13m0057                               	;       NOP $
13m0057                               	;       NOP $
13m0057                               	;       NOP $
13m0057                               	
13m0057                               	]
13m0057                               	.REPEAT 0 [ 13m0057                               	
13m0057                               	        .OPCODE[LIST 
13m0057                               	 LIST            ];OPCODE 777 --- MAKE IT A UUO
13m0057                               	;;;     JUMP[MUUO] $
13m0057 03776 640150020171000440002125	        UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$             ;Illegal instruction
13m0057                               	 rather than an IOT.  It's an
13m0057                               	                        ;easy thing to stumble upon in buggy programs (or
13m0057                               	                        ;hardware), being it is most common negative integers
13m0057                               	
13m0057                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

14m0057                               	;MSTART MSTRT1 BADPC ILDB1 ILDB2 IDPB1 IDPB2 ILDB3 LDB1 LDB5 LDB2 LDB4 DPB1 DPB5 DPB7
14m0057                               	 IDPB3 DPB2 DPB4 BIIH1 BIIH BII IBP1 IBT1
14m0057                               	;NON DISPATCH STUFF HERE
14m0057                               	
14m0057                               	        .ORG[14m0057                               	XLIST
14m0058                               	 LIST ]; INIT THINGS -- INITIALIZE MACHINE, POWER-UP COMES HERE.
14m0058                               	
14m0058                               	MSTART:
14m0058 04000 000140000571000440000000	JUMP[MSTRT1] $  ;to help operator start from switches (KEEP THIS SIMPLE -- MLB)
14m0058                               	
14m0058                               	        .USE[14m0058                               	XLIST
14m0059                               	 LIST ]MSTRT1:
14m0059                               	
14m0059                               	;******* This code to be made a subroutine to allow machine resetting *******
14m0059                               	;******* to be done by auto-loading and via CONO APR,20000  TVR-Mar80 *******
14m0059                               	
14m0059                               	.REPEAT 1 - CROCK [     14m0059                               	1 - CROCK
14m0059                               	
14m0059                               	
14m0059                               	;The following code sets up the AMEM zero vectors for various random devices.
14m0059                               	;this is a complete CROCK!  The device reset subroutines should do this!!
14m0059                               	;I plan to fix this soon (when I have time, ha ha)      -- MLB 23JAN80
14m0059                               	;$*$*$ Fix this soon.   TVR-Apr80
14m0059                               	
14m0059 04001 640702414171014200000000	        D[CONST 20] ROT[6] DEST[Q CLR-DEV-FROM-INTR] NORM $
14m0059                               	
14m0059                               	        .DEFINE AMLD2 14m0059                               	        AMLD2 14m0059 04002 640701614571000010000000	D[CONST 1] DEST[DEV-ADR] NORM $
14m0059 04003 640700014575000623000000	        D[CONST 62] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTERRUPTS FROM DEV 1 (SWITCHES) GO TO 2062
14m0059 04004 640700014171014210000000	        D[CONST 21] ROT[6] DEST[Q] NORM $
14m0059                               	;;;     AMLD2 [ 4 0 30 ] ; INTERRUPTS FROM DEV 4 GO TO 2130 [Now set at CTYRST]
14m0059                               	        AMLD2 14m0059 04005 640701614571000050000000	D[CONST 5] DEST[DEV-ADR] NORM $
14m0059 04006 640700014575000343000000	        D[CONST 34] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTRS FROM DEV 5 GO TO 2134
14m0059                               	        AMLD2 14m0059 04007 640701614571000060000000	D[CONST 6] DEST[DEV-ADR] NORM $
14m0059 04010 640700014575000413000000	        D[CONST 41] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTS FROM DEV 6 GO TO 2141
14m0059                               	        AMLD2 14m0059 04011 640701614571000070000000	D[CONST 7] DEST[DEV-ADR] NORM $
14m0059 04012 640700014575000503000000	        D[CONST 50] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTS FROM DEV 7 GO TO 2150
14m0059                               	        AMLD2 14m0059 04013 640701614571000100000000	D[CONST 10] DEST[DEV-ADR] NORM $
14m0059 04014 640700014575000563000000	        D[CONST 56] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTS FROM DEV 10 GO TO 2156
14m0059                               	.REPEAT DLS [
14m0059                               	        AMLD2 14m0059 04015 640701614571000200000000	D[CONST DLSDEV] DEST[DEV-ADR] NORM $
14m0059 04016 640700014575000373000000	        D[CONST 37] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; DLS GOES TO 2137
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

14m0059                               	]DLS
14m0059                               	;;      the IMP reset code takes care of this for itself!!
14m0059                               	
14m0059                               	;;; Moved code to set MAP-DISP to MAPRST (due to lack of space between
14m0059                               	;;; 4000:4777).                                           TVR-Apr80
14m0059 04017 640705400615000440000000	        ALU[0] DEST[CRYOV] NORM $
14m0059 04020 640703600615000440000000	        ALU[0] DEST[CLR-MI-ERR] NORM $
14m0059 04021 640700614571000002600000	        D[CONST 0] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
14m0059 04022 640140000571000440000000	        JUMP[RESLOP] NORM $
14m0059                               	
14m0059 04023 000140000571000440002026	BADPC:  BADLOC $
14m0059                               	
14m0059                               	;------------------------------------------------------------------------------
14m0059                               	;$*$*$* THIS JUNK HAS GOT TO MOVE! TVR-Apr80
14m0059                               	;
14m0059                               	;Some of it also needs commenting but this must be postponed until after CCRMA
14m0059                               	;merge.
14m0059                               	;------------------------------------------------------------------------------
14m0059                               	
14m0059                               	        .USE[14m0059                               	XLIST
14m0060                               	 LIST ] .PAIR   . \ 2 + .
14m0060                               	];Goes to second if HALF is not set
14m0060 02602 640141400571030060000000	ILDB1:  D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[ILDB2] NORM $
14m0060                               	                ;Extract S field.  Being HALF was set, don't increment
14m0060 02603 657051400571030060000000	        D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $;GET S FLD,
14m0060                               	 OVFL?
14m0060                               	                ;Extract S field.  Increment word if byte overflow will happen
14m0060 02604 662154200077074440002606	        D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $;SUB S
14m0060                               	 FROM P
14m0060                               	                ;Increment byte pointer, no overflow possible now
14m0060                               	                ;Store into memory, check for store into AC
14m0060 02605 640700005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] $
14m0060                               	                ;Store is into an AC, write it there.
14m0060 02606 664120000555000440000000	ILDB2:  ALU[Q] DEST[MA] COND[-MEM-IDX-IND] LBJUMP[ILDB3] NORM $
14m0060                               	                ;Fetch data, perhaps.  Maybe also do indexing or indirection
14m0060                               	        .PAIR
14m0060                               	. \ 2 + .
14m0061 02610 640141400571030060000000	]IDPB1: D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[IDPB2] NORM $
14m0061 02611 657051400571030060000000	        D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $;GET S FLD,
14m0061                               	 OVFL?
14m0061 02612 662154200077074440002614	        D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $;SUB S
14m0061                               	 FROM P
14m0061 02613 640700005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] $
14m0061 02614 664120000555000440000000	IDPB2:  ALU[Q] DEST[MA] COND[-MEM-IDX-IND] LBJUMP[IDPB3] NORM $
14m0061                               	
14m0061                               	        .PAIR   . \ 2 + .
14m0061                               	];Goes to second if not indexing or indirecting
14m0061 02616 640040000571000440020000	ILDB3:  MAPF[NORM-RD] PUSHJ[BIIH] NORM $;HANDLE IDX-IND
14m0061                               	        MAPF[BYTE-ILD] ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD]
14m0061 02617 640146000550400440110000	                        JUMP[LDB2] CYLEN[FIXM] $
14m0061                               	                ;Finish read of data word, then go extract byte
14m0061                               	
14m0061                               	        .USE[14m0061                               	XLIST
14m0062                               	 LIST ] .PAIR   . \ 2 + .
14m0062                               	];Goes to second if not indexing or indirecting
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

14m0062 02624 640040000571000440020000	LDB1:   MAPF[2] PUSHJ[BII] NORM $
14m0062 02625 640706000550400440020000	LDB5:   FIXM1 $ ;Also gets here from XBY13
14m0062 02626 640701400571030060000000	        D[AR] ROT[14] MASK[6] DEST[MASKR] SHORT $
14m0062                               	                ;GET S FLD
14m0062 02627 640700014171000442200000	        SPEC[CLR-HALF] D[CONST 44] DEST[Q] SHORT $
14m0062 02630 640701200077014060000000	        D[AR] ROT[6] MASK[6] ALU[Q-D] DEST[Q ROTR] SHORT $
14m0062                               	                ;SUB P FLD FROM 44
14m0062 02631 531140000477030060000000	        D[AR] ROT[12.] MASK[6] ALU[Q-D] COND[-OBUS<0] JUMP[LDB4] C550 $
14m0062                               	                ;Also, subtract S field.  If result is positive, then byte
14m0062                               	                ;of size S fits with at least P bits remaining in the right
14m0062                               	                ;side of the word
14m0062 02632 640141400555000440000000	        ALU[Q] DEST[MASKR] JUMP[LDB4] NORM $
14m0062                               	                ;Byte does not fit!!!  We want only the stuff to the left
14m0062                               	                ;of postion P, which is 36.-P bits, coincidentally, the same
14m0062                               	                ;size as the rotation
14m0062                               	;S field is already set up.  Set up P field and extract data from word.
14m0062 02633 640700014171000442200000	LDB2:   SPEC[CLR-HALF] D[CONST 44] DEST[Q] SHORT $
14m0062 02634 640701200477014060000000	        D[AR] ROT[6] MASK[6] ALU[Q-D] DEST[ROTR] SHORT $
14m0062                               	                ;SUB P FLD FROM 44
14m0062 02635 640160005571201000602027	LDB4:   D[MEM] ACSEL[AC] ROT[R] MASK[R] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $; DO
14m0062                               	 THE LDB
14m0062                               	
14m0062                               	
14m0062                               	        .PAIR
14m0062                               	. \ 2 + .
14m0063 02636 640040000571000440020000	]DPB1:  MAPF[2] PUSHJ[BII] NORM $
14m0063                               	DPB5:           ;Also gets here from XBY13
14m0063                               	;;;     FIXM2 $ ;Wrong thing for WAITS.
14m0063                               	          MAPF[BYTE-IDP] CYLEN[FIXM]
14m0063 02637 640146200550400440120000	                        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] JUMP[DPB7] $
14m0063                               	                ;KA/KL set half flag even on DPB.  They would also set read
14m0063                               	                ;failure, not write, in the case of not in map; but we don't
14m0063                               	                ;have time to be particular.                    TVR-Apr80
14m0063                               	
14m0063                               	        .USE[14m0063                               	XLIST
14m0064 04024 640701400571030060000000	 LIST ]DPB7:    D[AR] ROT[12.] MASK[6] DEST[MASKR] SHORT $
14m0064                               	                ;Fetch S field.
14m0064 04025 640701200171014062200000	        SPEC[CLR-HALF] D[AR] ROT[6] MASK[6] DEST[Q ROTR] SHORT $
14m0064                               	                ;Fetch P field.
14m0064 04026 640700014137000440000000	        D[CONST 44] ALU[D-Q] DEST[Q] SHORT $
14m0064                               	                ;Calculate 36-P, which is maximum number of bits in this byte
14m0064 04027 531140000477030060000000	        D[AR] ROT[12.] MASK[6] ALU[Q-D] COND[-OBUS<0] JUMP[DPB4] C550 $
14m0064                               	                ;Does this byte fit?  I.e. 36-P-S is non-negative.  If so,
14m0064                               	                ;use this mask field
14m0064 04030 640141400555000440000000	        ALU[Q] DEST[MASKR] JUMP[DPB4] NORM $
14m0064                               	                ;Setup mask which is everything to the left of the position
14m0064                               	                ;designated by P.
14m0064                               	
14m0064                               	        .USE[14m0064                               	XLIST
14m0065                               	 LIST ] .PAIR
14m0065                               	. \ 2 + .
14m0066 02666 640040000571000440020000	]IDPB3: MAPF[2] PUSHJ[BIIH] NORM $;HANDLE IDX-IND
14m0066                               	        MAPF[BYTE-IDP] CYLEN[FIXM]
14m0066 02667 640706200550400440120000	                ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] $
14m0066 02670 640701400571030060000000	        D[AR] ROT[14] MASK[6] DEST[MASKR] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

14m0066 02671 640701200171014062200000	DPB2:   SPEC[CLR-HALF] D[AR] ROT[6] MASK[6] DEST[Q ROTR] SHORT $
14m0066 02672 640710010621001000000000	DPB4:   D[2] MASK[R] ACSEL[AC] ALU[D&AC] DEST[AR] SHORT $;GET BYTE
14m0066 02673 640700004171000440000000	        D[MEM] DEST[Q] SHORT $; GET DEST WORD
14m0066 02674 640700010275201000000000	        D[2] MASK[R] ROT[R] ALU[-D&Q] DEST[Q] SHORT $;CLR DEST BYTE
14m0066 02675 662104200575200440002032	        D[AR] ROT[R] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$;DO
14m0066                               	 IT
14m0066                               	
14m0066                               	.DEFINE BIIMAC[14m0066                               	        .USE[14m0066                               	XLIST
14m0067                               	 LIST ]BIIH:    BIIMAC 14m0067 02642 510141000571044040000000	D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[BII1] C550 $;IDX FLD
14m0067 02643 640720024420000220000000	        D[MA] ACSEL[REG] MASK[18.] ALU[D+AC] DEST[MA] SHORT $;DO INDEXING
14m0067 02644 550300000571034010020000	        D[AR] ROT[16] MASK[1] MAPF[2] COND[OBUS=0] POPJ CYLEN[C500] $;LEAV IF NO IND
14m0067 02645 640706000550400440130000	BII1:   ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BYTE-IND] CYLEN[FIXM] $
14m0067 02646 564320004171000270000000	        D[MEM] MASK[27] DEST[Q MA] COND[-MEM-IDX-IND] POPJ CYLEN[C500] $;GET INDIRECT
14m0067                               	 WORD, LEAVE IF NO MORE IND OR IDX
14m0067 02647 640710000571030140020000	        D[AR] ROT[14] MASK[14] DEST[AR] MAPF[2] NORM $
14m0067 02650 640150000175060440002642	        D[AR] ROT[30] ALU[DORQ] DEST[Q AR] JUMP[BIIH] NORM $
14m0068                               	]BII:   BIIMAC 14m0068 02651 510141000571044040000000	D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[BII2] C550 $;IDX FLD
14m0068 02652 640720024420000220000000	        D[MA] ACSEL[REG] MASK[18.] ALU[D+AC] DEST[MA] SHORT $;DO INDEXING
14m0068 02653 550300000571034010020000	        D[AR] ROT[16] MASK[1] MAPF[2] COND[OBUS=0] POPJ CYLEN[C500] $;LEAV IF NO IND
14m0068 02654 640706000550400440020000	BII2:   ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-RD] CYLEN[FIXM] $
14m0068 02655 564320004171000270000000	        D[MEM] MASK[27] DEST[Q MA] COND[-MEM-IDX-IND] POPJ CYLEN[C500] $;GET INDIRECT
14m0068                               	 WORD, LEAVE IF NO MORE IND OR IDX
14m0068 02656 640710000571030140020000	        D[AR] ROT[14] MASK[14] DEST[AR] MAPF[2] NORM $
14m0068 02657 640150000175060440002651	        D[AR] ROT[30] ALU[DORQ] DEST[Q AR] JUMP[BII] NORM $
14m0069                               	]
14m0069                               	        .USE[14m0069                               	XLIST
14m0070                               	 LIST ] .PAIR   . \ 2 + .
14m0070                               	];Skip if AC=0
14m0070 04032 640150020171000440002125	IBP1:   UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$     ;Non-zero AC implies ADJBP.  We
14m0070                               	 don't, yet.
14m0070 04033 657050000571030060000000	        D[AR] ROT[14] MASK[6] DEST[AR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $;GET S FLD, OVFL?
14m0070                               	
14m0070                               	                ;Zero AC.  Do ordinary increment byte pointer.
14m0070                               	                ;PUSHJ if we are about to overflow a word.
14m0070 04034 662104200077074440002032	        D[AR] ROT[36] ALU[Q-D] DEST[Q MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
14m0070                               	                ;Finish updating byte position part of pointer
14m0070                               	
14m0070                               	;Increment byte pointer which crosses a word boundary
14m0070 04035 640700010235000360000000	IBT1:   D[MASK 36] ALU[D&Q] DEST[Q] SHORT $
14m0070 04036 640300014037074440000000	        D[CONST 44] ROT[36] ALU[D+Q+1] DEST[Q] POPJ NORM $
14m0070                               	                ;NEW P FLD OF 44, ADD 1 TO ADR
14m0070                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

15m0070                               	;IMUL1 IMUL2 IMUL3 MUL1 MUL2 MUL3 DOIMUL MSETOV DOMMUL DOMUL DOMUL1 DOMUL4 IDIV1 IDIV2
15m0070                               	 IDIV3 DIV1 DIV2 DIV3 DODDIV DODIV DODIV1 DODIV3 DODIV2 STOVFQ DODIV4 DODIV6 DODIV5
15m0070                               	
15m0070 04037 640050001215000440000000	IMUL1:  ALU[0] DEST[AR O_AC] PUSHJ[DOIMUL] NORM $       ;0 TO AC,AC TO AR
15m0070 04040 640140001555000440002026	        ALU[Q] DEST[AC] JUMP[MAIN] NORM $
15m0070 04041 640050001215000440000000	IMUL2:  ALU[0] DEST[AR O_AC] PUSHJ[DOIMUL] NORM $       ;0 TO AC
15m0070 04042 640700001571000440000000	        D[AR] DEST[AC] NORM $
15m0070 04043 662104200555000440002032	        ALU[Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0070                               	
15m0070 04044 640050001215000440000000	IMUL3:  ALU[0] DEST[AR O_AC] PUSHJ[DOIMUL] NORM $
15m0070 04045 662104201555000440002032	        ALU[Q] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0070                               	
15m0070 04046 640050001215000440000000	MUL1:   ALU[0] DEST[AR O_AC] PUSHJ[DOMMUL] NORM $
15m0070 04047 640140001555400440002026	        ACSEL[AC+1] ALU[Q] DEST[AC] JUMP[MAIN] NORM $
15m0070                               	
15m0070 04050 640050001215000440000000	MUL2:   ALU[0] DEST[AR O_AC] PUSHJ[DOMMUL] NORM $
15m0070 04051 662104201171000440002032	        D[AR] DEST[O_AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0070 04052 640050001215000440000000	MUL3:   ALU[0] DEST[AR O_AC] PUSHJ[DOMMUL] NORM $
15m0070 04053 640700001555400440000000	        ACSEL[AC+1] ALU[Q] DEST[AC] NORM $
15m0070 04054 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0070                               	
15m0070 04055 640040000571000440000000	DOIMUL: PUSHJ[DOMUL] NORM $
15m0070 04056 550300000551000440000000	        ALU[AC] COND[OBUS=0] POPJ CYLEN[C500] $; NO OV IF 0
15m0070 04057 550300000751000440000000	        ALU[NOTAC] COND[OBUS=0] POPJ CYLEN[C500] $; NO OV IF -1
15m0070 04060 640700021571000440000000	MSETOV: D[PC] DEST[AC] SHORT $; GET FLAGS
15m0070 04061 640305414561106010000000	MSTOV1: D[CONST 1] ROT[43] ALU[DORAC] DEST[CRYOV] NORM POPJ $; SET OV
15m0070 04062 570140000735000440000000	DOMMUL: D[AR] ALU[D#Q] COND[-OBUS=0] JUMP[DOMUL] CYLEN[C500] $; NO OV IF DIFF OPERS
15m0070 04063 570140014735106010000000	        D[CONST 1] ROT[43] ALU[D#Q] COND[-OBUS=0] JUMP[DOMUL] CYLEN[C500] $; J IF NOT
15m0070                               	 -2**35
15m0070 04064 640040000571000440004060	        PUSHJ[MSETOV] NORM $;SET OV
15m0070 04065 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
15m0070 04066 640740014571000420000000	DOMUL:  D[CONST 42] LLOAD NORM $        ;LOOP 35 TIMES
15m0070                               	
15m0070                               	DOMUL1: D[AR] ALU[MULAC+D] DEST[D4] MASK[3]
15m0070 04067 640240002021000030004067	                        LOOP[DOMUL1] NORM $ ;SHIFT, END-COND MUL; SOJGE, SH RT
15m0070                               	                ;This shifts right, with the low order bit of the partial
15m0070                               	                ;product being saved in Q.  At the same time, shift out of Q
15m0070                               	                ;a bit of the multiplier (and somehow??? the hardware uses this
15m0070                               	                ;to decide whether to add or not???)
15m0070                               	                ;MASK field specifies what gets shifted into AC, in this case,
15m0070                               	                ;(ALU OV) XOR (-OUT<0)
15m0070                               	        D[AR] ALU[MULAC+D] DEST[D4] MASK[3]
15m0070 04070 634140002021000030004072	                        COND[-Q0-35] JUMP[. + 2] CYLEN[C450] $ ;J IF QUOT WAS +
15m0070                               	                ;Do last step of multiply. Jump on sign of multiplier(?)
15m0070                               	        D[AR] ALU[MULAC-D] DEST[D7]
15m0070 04071 640140003443000440004073	                        JUMP[. + 2] NORM $ ; DEST AC SH LFT, ALU=1, ALU S=0
15m0070                               	                ;Multiplier was positive... ???: Shift left to make properly
15m0070                               	                ;signed result, with low order bit coming from Q0 (i think???)
15m0070 04072 640700003545000440000000	        ALU[SH-AC] DEST[D7] NORM $ ;DEST AC SH LFT
15m0070                               	                ;SINCE DEST IS >3, ALU[QORAC] IS ALU[AC]
15m0070                               	                ;Multiplier was negative... ???
15m0070 04073 551100000551000440000000	        ALU[AC] COND[OBUS<0] LBJUMP[DOMUL4] CYLEN[C500] $
15m0070                               	                ;Decide what sign should be in the low order result.
15m0070                               	
15m0070                               	        .PAIR
15m0070                               	. \ 2 + .
15m0071 04074 640300010235000430000000	]DOMUL4:        D[MASK 35.] ALU[D&Q] DEST[Q] POPJ NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

15m0071                               	                ;Positive.  Turn off Q0, which was copied into AC35.
15m0071 04075 640300014175106010000000	        D[CONST 1] ROT[35.] ALU[DORQ] DEST[Q] POPJ NORM $
15m0071                               	                ;Negative.  Set Q0 so the number is negative (Q0 was copied into
15m0071                               	                ;AC35).
15m0071                               	
15m0071       740000000000000000000000	  CCC1  = SHORT $       ;Apparently used as a NO-OP for macros below. TVR-Apr80
15m0071       777740000000000000007777	  MEMST1 = MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$     ;Store to memory. (Cause macro
15m0071                               	 expansion now, rather
15m0071                               	                        ;than in macro call.)
15m0071                               	
15m0071                               	.DEFINE DMACFN 15m0071                               	.DEFINE DMAC2 15m0071                               	.DEFINE DMAC1 15m0071                               	
15m0071                               	IDIV1:  DMAC1
15m0071                               	.PAIR
15m0071                               	. \ 2 + .
15m0072 04076 640140001741000440004100	]       ALU[-1] DEST[AC] JUMP[. + 2] NORM $
15m0072 04077 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
15m0072 04100 640710004721000440000000	        D[MEM] ALU[D#AC] DEST[AR] SHORT $
15m0072 04101 640700200571002010000000	        D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
15m0072 04102 640050000555000440000000	        ALU[Q] DEST[AR] PUSHJ[DODIV] NORM $
15m0072                               	]       DMACFN[15m0072 04103 640710001155000440000000	ALU[Q] D[AR] DEST[O_AC AR] SHORT $
15m0072 04104 640160001571400440602027	        ACSEL[AC+1] D[AR] ALU[D] DEST[AC MA] DOM1 $
15m0072 04105 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0073                               	]IDIV2: DMAC1
15m0073                               	.PAIR
15m0073                               	. \ 2 + .
15m0074 04106 640140001741000440004110	]       ALU[-1] DEST[AC] JUMP[. + 2] NORM $
15m0074 04107 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
15m0074 04110 640710004721000440000000	        D[MEM] ALU[D#AC] DEST[AR] SHORT $
15m0074 04111 640700200571002010000000	        D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
15m0074 04112 640050000555000440000000	        ALU[Q] DEST[AR] PUSHJ[DODIV] NORM $
15m0074                               	]       DMACFN[15m0074 04113 640710001171000440000000	ALU[D] D[AR] DEST[O_AC AR] SHORT $
15m0074 04114 662114200555400440002032	        ACSEL[AC+1] D[AR] ALU[Q] DEST[MEMSTO AR] MEMST1 $
15m0074 04115 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0075                               	]IDIV3: DMAC1
15m0075                               	.PAIR
15m0075                               	. \ 2 + .
15m0076 04116 640140001741000440004120	]       ALU[-1] DEST[AC] JUMP[. + 2] NORM $
15m0076 04117 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
15m0076 04120 640710004721000440000000	        D[MEM] ALU[D#AC] DEST[AR] SHORT $
15m0076 04121 640700200571002010000000	        D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
15m0076 04122 640050000555000440000000	        ALU[Q] DEST[AR] PUSHJ[DODIV] NORM $
15m0076                               	]       DMACFN[15m0076 04123 640710001155000440000000	ALU[Q] D[AR] DEST[O_AC AR] SHORT $
15m0076 04124 640700001571400440000000	        ACSEL[AC+1] D[AR] ALU[D] DEST[AC 0] CCC1 $
15m0076 04125 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0077                               	]DIV1:  DMAC2
15m0077 04126 640050004721000440000000	D[MEM] ALU[D#AC] DEST[AR] PUSHJ[DODDIV] NORM $
15m0078                               	]       DMACFN[15m0078 04127 640710001155000440000000	ALU[Q] D[AR] DEST[O_AC AR] SHORT $
15m0078 04130 640160001571400440602027	        ACSEL[AC+1] D[AR] ALU[D] DEST[AC MA] DOM1 $
15m0078 04131 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0079                               	]DIV2:  DMAC2
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

15m0079 04132 640050004721000440000000	D[MEM] ALU[D#AC] DEST[AR] PUSHJ[DODDIV] NORM $
15m0080                               	]       DMACFN[15m0080 04133 640710001171000440000000	ALU[D] D[AR] DEST[O_AC AR] SHORT $
15m0080 04134 662114200555400440002032	        ACSEL[AC+1] D[AR] ALU[Q] DEST[MEMSTO AR] MEMST1 $
15m0080 04135 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0081                               	]DIV3:  DMAC2
15m0081 04136 640050004721000440000000	D[MEM] ALU[D#AC] DEST[AR] PUSHJ[DODDIV] NORM $
15m0082                               	]       DMACFN[15m0082 04137 640710001155000440000000	ALU[Q] D[AR] DEST[O_AC AR] SHORT $
15m0082 04140 640700001571400440000000	        ACSEL[AC+1] D[AR] ALU[D] DEST[AC 0] CCC1 $
15m0082 04141 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0083                               	]
15m0083 04142 640700200571002010000000	DODDIV: D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
15m0083 04143 640710002545000010000000	        ALU[SH-AC] DEST[AR D5] MASK[1] NORM $
15m0083 04144 510140000571000010004146	        D[AR] MASK[1] COND[OBUS=0] JUMP[. + 2] C550 $
15m0083 04145 640140014175106010004147	        D[CONST 1] ROT[43] ALU[DORQ] DEST[Q] JUMP[. + 2] NORM $
15m0083 04146 640700010235000430000000	        D[MASK 43] ALU[D&Q] DEST[Q] NORM $
15m0083                               	;------------------------------------------------------------------------------
15m0083                               	;
15m0083                               	;       Single Precision Divide (and continuation of double precision)
15m0083                               	;
15m0083                               	;       (Reminder: Quotient, Remainder = Dividend / Divisor)
15m0083                               	;
15m0083                               	;Where we get here:
15m0083                               	;    MEM        36 bit signed divisor
15m0083                               	;    AC         High order dividend (0 or -1 for single precision)
15m0083                               	;    Q          Low order dividend
15m0083                               	;    IR<35>     Sign of dividend XOR sign of divisor
15m0083                               	;    AR         Sign of dividend and original contents of AC
15m0083                               	;  
15m0083                               	;------------------------------------------------------------------------------
15m0083 04147 531140004571000440000000	DODIV:  D[MEM] COND[-OBUS<0] JUMP[DODIV1] C550 $
15m0083                               	                ;Jump if divide by positive number
15m0083 04150 640704404473000440000000	        D[MEM] ALU[0-D] DEST[HOLD] SHORT $
15m0083                               	                ;Take absolute value
15m0083 04151 631140000551000440000000	DODIV1: ALU[AC] COND[-OBUS<0] JUMP[DODIV2] CYLEN[C450] $
15m0083                               	                ;Check sign of high order word.  If positive, we're ready to go
15m0083 04152 550140000117000440000000	        ALU[0-Q] DEST[Q] COND[OBUS=0] JUMP[DODIV3] CYLEN[C500] $
15m0083                               	                ;Double precision negate, low order word
15m0083 04153 640140001751000440000000	        ALU[NOTAC] DEST[AC] JUMP[DODIV2] NORM $
15m0083                               	                ;High order word, no carry
15m0083 04154 640700001513000440000000	DODIV3: ALU[0-AC] DEST[AC] NORM $
15m0083                               	                ;High order word, with carry
15m0083 04155 640740014571000440000000	DODIV2: D[CONST 44] LLOAD NORM $
15m0083                               	                ;LOOP 37 TIMES
15m0083                               	;Now have:
15m0083                               	;   MEM         Absolute value of divisor
15m0083                               	;   AC          Absolute value of high order dividend
15m0083                               	;   Q           Absolute value of low order dividend
15m0083                               	;   R           Repeat count for division
15m0083 04156 511140004463000440000000	        D[MEM] ALU[AC-D] COND[OBUS<0] JUMP[DODIV7] C550 $
15m0083                               	                ;Jump if not no divide case
15m0083 04157 640700021571000440000000	        D[PC] DEST[AC] SHORT $
15m0083                               	                ;Get ready to set flags
15m0083 04160 640040015561056010004061	        D[CONST 1] ROT[23.] ALU[DORAC] DEST[AC] PUSHJ[MSTOV1] NORM $
15m0083                               	                ;Set no divide
15m0083 04161 640300001571000440000000	        D[AR] DEST[AC] POPJ NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

15m0083                               	                ;Fix clobbered AC
15m0083                               	
15m0083                               	        ;$*$*$* NORMAL area runs of space for now.  TVR-Apr80
15m0083                               	        .USE[15m0083                               	XLIST
15m0084 02161 640040000571000440000000	 LIST ]DODIV7:  NORM PUSHJ[DODIV4] $
15m0084 02162 531140000571000440002164	        D[AR] COND[-OBUS<0] JUMP[. + 2] C550 $; J IF DIVIDEND WAS +
15m0084 02163 640700001513000440000000	        ALU[0-AC] DEST[AC] SHORT $
15m0084 02164 510300034571000010000000	        D[IR] MASK[1] COND[OBUS=0] POPJ C550 $ ;LEAVE IF RESULT SHOULD BE +
15m0084 02165 640300000117000440000000	        ALU[0-Q] DEST[Q] POPJ NORM $
15m0084                               	;On completion:
15m0084                               	;   MEM         Absolute value of divisor
15m0084                               	;   AC          Remainder
15m0084                               	;   Q           Quotient
15m0084                               	;   AR<0>       Sign of dividend
15m0084                               	;   IR<35>      Sign of dividend
15m0084                               	
15m0084                               	        .QUAD
15m0084                               	. + 3 - (. + 3) \ 4 
15m0085 02170 451640007043000030002170	]DODIV4:        D[MEM] ALU[DIVAC-D] DEST[D6] MASK[3] COND[OBUS<0] SLOOP[DODIV4] C600 $
15m0085 02171 640140002545000000000000	        ALU[SH-AC] DEST[D5] MASK[0] JUMP[DODIV6] NORM $ ; RE-SHIFT REMAINDER
15m0085 02172 451640007001000030002170	        D[MEM] ALU[DIVAC+D] DEST[D6] MASK[3] COND[OBUS<0] SLOOP[DODIV4] C600 $
15m0085 02173 640700002545000000000000	        ALU[SH-AC] DEST[D5] MASK[0] NORM $
15m0085                               	    ;end of .QUAD
15m0085 02174 531300015721106010000000	DODIV6: D[CONST 1] ROT[43] ALU[D#AC] DEST[AC] COND[-OBUS<0] C550 POPJ $ 
15m0085                               	                ;ADJUST REM SIGN, CHECK IT
15m0085 02175 640300005421000440000000	        D[MEM] ALU[D+AC] DEST[AC] NORM POPJ $ 
15m0085                               	                ;ADJUST REM.
15m0085                               	
15m0085                               	        .USE[15m0085                               	XLIST
15m0086                               	 LIST ]
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

16m0086                               	;JFFO1 JFFO2 JFFO3 JFFO5 JFFO4 ROTDO BIGLSH LSHPDO LSHDO LSHDO1 ASHDO1 BIGASH SETOV1
16m0086                               	 ASHDO ASHDOP BIGAS2 ASHC1 ASHC8 ASHC6 ASHC9 ASHC4 ASHC2 ASHC7 ROTC1 ROTC2 LSHC1 LSHC2
16m0086                               	 SJMAIN PUSH1 POP1 POPJ1 PUSHJ1
16m0086                               	
16m0086 04162 640140001615400440002026	JFFO1:  ACSEL[AC+1] ALU[0] DEST[AC] JUMP[MAIN] NORM $
16m0086 04163 530140000571014060000000	JFFO2:  D[AR] ROT[6] MASK[6] COND[-OBUS=0] JUMP[JFFO3] C550 $
16m0086 04164 640710000571014440000000	        D[AR] ROT[6] DEST[AR] NORM $
16m0086 04165 640140015421400060004163	        D[CONST 6] ACSEL[AC+1] ALU[AC+D] DEST[AC] JUMP[JFFO2] NORM $
16m0086 04166 511140000571000440000000	JFFO3:  D[AR] COND[OBUS<0] JUMP[JFFO4] C550 $
16m0086 04167 640700001413400440000000	JFFO5:  ACSEL[AC+1] ALU[AC+1] DEST[AC] NORM $
16m0086 04170 531150000571002440004167	        D[AR] ROT[1] DEST[AR] COND[-OBUS<0] JUMP[JFFO5] C550 $
16m0086 04171 640164634571000440002027	JFFO4:  D[IR] DEST[PC MA] JUMP[MAIN1] NORM $; JUMP
16m0086                               	.DEFINE SH2ND 16m0086                               	
16m0086                               	        .USE[16m0086                               	XLIST
16m0087                               	 LIST ] SH2ND 16m0087 02702 453140014477000440000000	OTPLS:  D[CONST 44] ALU[Q-D] COND[OBUS18] JUMP[ROTDO] C600 $
16m0087 02703 640141214077000440002702	        D[CONST 44] ALU[Q-D] DEST[Q ROTR] JUMP[ROTPLS] NORM $
16m0087 02704 640701210175020220000000	ROTNEG: D[MASK 22] ROT[10] ALU[DORQ] DEST[Q ROTR] NORM $
16m0087 02705 473141214035000440000000	ROTNN1: D[CONST 44] ALU[D+Q] DEST[Q ROTR] COND[-OBUS18] JUMP[ROTDO] C600 $
16m0087 02706 640140000571000440002705	        JUMP[ROTNN1] NORM $
16m0088 02707 640710000551000440000000	]ROTDO: ACSEL[AC] ALU[AC] DEST[AR] SHORT $
16m0088 02710 640160001571200440602027	        D[AR] ROT[R] ACSEL[AC] SPEC[MA_PC] DEST[AC MA] JUMP[MAIN1] NORM $
16m0088                               	        SH2ND 16m0088 02711 453140014477000440000000	SHPLS:  D[CONST 44] ALU[Q-D] COND[OBUS18] JUMP[LSHPDO] C600 $
16m0088 02712 640141214077000440000000	        D[CONST 44] ALU[Q-D] DEST[Q ROTR] JUMP[BIGLSH] NORM $
16m0088 02713 640701210175020220000000	LSHNEG: D[MASK 22] ROT[10] ALU[DORQ] DEST[Q ROTR] NORM $
16m0088 02714 473141214035000440000000	LSHNN1: D[CONST 44] ALU[D+Q] DEST[Q ROTR] COND[-OBUS18] JUMP[LSHDO] C600 $
16m0088 02715 640140000571000440000000	        JUMP[BIGLSH] NORM $
16m0089                               	]
16m0089                               	        .USE[16m0089                               	XLIST
16m0090 02725 640160001615000440602027	 LIST ]BIGLSH:  ACSEL[AC] ALU[0] SPEC[MA_PC] DEST[AC MA] JUMP[MAIN1] NORM $
16m0090                               	
16m0090 02726 640701414537000440000000	LSHPDO: D[CONST 44] ALU[D-Q] DEST[MASKR] SHORT $
16m0090 02727 640710010621001000000000	        D[2] MASK[R] ALU[D&AC] ACSEL[AC] DEST[AR] SHORT $
16m0090 02730 640160001571200440602027	        D[AR] ROT[R] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
16m0090                               	
16m0090 02731 640701400555000440000000	LSHDO:  ALU[Q] DEST[MASKR] SHORT $
16m0090 02732 640710000551000440000000	        ALU[AC] ACSEL[AC] DEST[AR] SHORT $
16m0090 02733 640160001571201000602027	LSHDO1: D[AR] MASK[R] ROT[R] SPEC[MA_PC] DEST[AC MA] ACSEL[AC] JUMP[MAIN1] NORM $
16m0090 02734 640141400555000440002733	ASHDO1: ALU[Q] DEST[MASKR] JUMP[LSHDO1] NORM $
16m0090                               	
16m0090                               	        .USE[16m0090                               	XLIST
16m0091                               	 LIST ] SH2ND 16m0091 04172 453140014477000440000000	SHPLS:  D[CONST 44] ALU[Q-D] COND[OBUS18] JUMP[ASHDOP] C600 $
16m0091 04173 640141214077000440000000	        D[CONST 44] ALU[Q-D] DEST[Q ROTR] JUMP[BIGASH] NORM $
16m0091 04174 640701210175020220000000	ASHNEG: D[MASK 22] ROT[10] ALU[DORQ] DEST[Q ROTR] NORM $
16m0091 04175 473141214035000440000000	ASHNN1: D[CONST 44] ALU[D+Q] DEST[Q ROTR] COND[-OBUS18] JUMP[ASHDO] C600 $
16m0091 04176 640140000571000440000000	        JUMP[BIGAS2] NORM $
16m0092 04177 610140000551000440002026	]BIGASH:        ALU[AC] ACSEL[AC] COND[OBUS=0] JUMP[MAIN] CYLEN[C450] $
16m0092 04200 640700015621106010000000	        D[CONST 1] ROT[43] ACSEL[AC] ALU[D&AC] DEST[AC] SHORT $
16m0092 04201 640700020171000440000000	        D[PC] DEST[Q] SHORT $
16m0092 04202 640165414575106010602027	SETOV1: D[CONST 1] ROT[43] ALU[DORQ] DEST[MA CRYOV] SPEC[MA_PC] NORM JUMP[MAIN1] $
16m0092 04203 571150000551000440002734	ASHDO:  ACSEL[AC] ALU[AC] DEST[AR] COND[-OBUS<0] JUMP[ASHDO1] CYLEN[C500] $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

16m0092 04204 640701414537000440000000	        D[CONST 44] ALU[D-Q] DEST[MASKR] SHORT $
16m0092 04205 640700010171201000000000	        D[2] MASK[R] ROT[R] DEST[Q] SHORT $
16m0092 04206 640160001575200440602027	        D[AR] ROT[R] ALU[DORQ] SPEC[MA_PC] DEST[AC MA] ACSEL[AC] JUMP[MAIN1] NORM $
16m0092 04207 640701414537000430000000	ASHDOP: D[CONST 43] ALU[D-Q] DEST[MASKR] SHORT $
16m0092 04210 640700200555000440000000	        ALU[Q] DEST[IR-ADR] SHORT $; SAVE SH AMT
16m0092 04211 640700014221106010000000	        D[CONST 1] ROT[43] ACSEL[AC] ALU[D&AC] DEST[Q] SHORT $ ;GET SIGN BIT
16m0092 04212 640710010621001000000000	        D[2] MASK[R] ACSEL[AC] ALU[D&AC] DEST[AR] SHORT $
16m0092 04213 640710001175200440000000	        D[AR] ROT[R] ACSEL[AC] ALU[DORQ] DEST[O_AC AR] SHORT $
16m0092 04214 640701434433000440000000	        D[IR] ALU[D+1] DEST[MASKR] SHORT $
16m0092 04215 640700000171200440000000	        D[AR] ROT[R] DEST[Q] SHORT $
16m0092 04216 510140010235107000002026	        D[2] MASK[R] ROT[43] ALU[D&Q] DEST[Q] COND[OBUS=0] JUMP[MAIN] C550 $
16m0092 04217 510140010735107000002026	        D[2] MASK[R] ROT[43] ALU[D#Q] COND[OBUS=0] JUMP[MAIN] C550 $
16m0092 04220 640140020171000440004202	        D[PC] DEST[Q] JUMP[SETOV1] NORM $
16m0092 04221 631140000551000440002725	BIGAS2: ACSEL[AC] ALU[AC] COND[-OBUS<0] JUMP[BIGLSH] CYLEN[C450] $
16m0092 04222 640160001741000440602027	        ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
16m0092                               	
16m0092 04223 640704414621106010000000	ASHC1:  D[CONST 1] ROT[43] ALU[D&AC] ACSEL[AC] DEST[HOLD] NORM $ ; SAVE SIGN BIT
16m0092 04224 513140034571000220000000	        D[IR] MASK[18.] COND[OBUS18] JUMP[ASHC2] C550 $
16m0092 04225 510140034571000100002026	        D[IR] MASK[10] COND[OBUS=0] JUMP[MAIN] C550 $
16m0092 04226 640700001615400440000000	        ALU[0] ACSEL[AC+1] DEST[AC] SHORT $
16m0092 04227 640740034531000100000000	        D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0092 04230 640700003145000010000000	ASHC8:  ALU[SH-AC] DEST[D6] MASK[1] ACSEL[AC] NORM $
16m0092 04231 511140004721000440000000	        ACSEL[AC] D[MEM] ALU[D#AC] COND[OBUS<0] JUMP[ASHC9] C550 $
16m0092 04232 640240000571000440004230	ASHC6:  LOOP[ASHC8] NORM $
16m0092 04233 640145420561400440000000	        D[PC] ACSEL[AC+1] ALU[DORAC] DEST[CRYOV] JUMP[ASHC7] NORM $
16m0092 04234 640140015571506010004232	ASHC9:  D[CONST 1] ROT[43] ACSEL[AC+1] DEST[AC] JUMP[ASHC6] NORM $
16m0092                               	
16m0092                               	.DEFINE SHLOOP 16m0092                               	
16m0092 04235 640700004171000440000000	ASHC4:  D[MEM] DEST[Q] SHORT $
16m0092 04236 640700001575506430000000	        D[AR] ROT[43] MASK[43] ALU[DORQ] ACSEL[AC+1] DEST[AC] NORM $
16m0092 04237 640700011621000430000000	        D[MASK 43] ACSEL[AC] ALU[D&AC] DEST[AC] SHORT $
16m0092 04240 640140001545000440002026	        ACSEL[AC] ALU[QORAC] DEST[AC] JUMP[MAIN] NORM $
16m0092 04241 640700234473000440000000	ASHC2:  D[IR] ALU[0-D] DEST[IR-ADR] NORM $
16m0092                               	        SHLOOP 16m0092 04242 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0092 04243 640240002145000010004243	        ALU[SH-AC] DEST[D4] MASK[1] ACSEL[AC] LOOP[.] NORM $
16m0093 04244 640150000555000440004235	]ASHC7: ALU[Q] DEST[AR] JUMP[ASHC4] NORM $
16m0093                               	
16m0093                               	        .USE[16m0093                               	XLIST
16m0094 02742 640140234473000440000000	 LIST ]ROTC1:   D[IR] ALU[0-D] DEST[IR-ADR] JUMP[ROTC2] NORM $
16m0094 02743 510140034571000100002026	        D[IR] COND[OBUS=0] MASK[10] JUMP[MAIN] C550 $
16m0094                               	        SHLOOP[16m0094 02744 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0094 02745 640240003145000000002745	        ALU[SH-AC] DEST[D6] MASK[0] ACSEL[AC] LOOP[.] NORM $
16m0095 02746 640140001555400440002026	]       ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
16m0095                               	ROTC2:  SHLOOP[16m0095 02747 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0095 02750 640240002145000000002750	        ALU[SH-AC] DEST[D4] MASK[0] ACSEL[AC] LOOP[.] NORM $
16m0096 02751 640140001555400440002026	]       ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
16m0096                               	
16m0096                               	        .PAIR
16m0096                               	. \ 2 + .
16m0097 02752 640140234473000220000000	]LSHC1: D[IR] MASK[18.] ALU[0-D] DEST[IR-ADR] JUMP[LSHC2] NORM $
16m0097 02753 510140034571000100002026	        D[IR] MASK[10] COND[OBUS=0] JUMP[MAIN] C550 $
16m0097                               	        SHLOOP SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

16m0097 02754 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0097 02755 640240003145000020002755	        ALU[SH-AC] DEST[D6] MASK[2] ACSEL[AC] LOOP[.] NORM $
16m0098 02756 640140001555400440002026	]       ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
16m0098                               	        .USE[16m0098                               	XLIST
16m0099       2735	 LIST ] debuguse = .            ;See if it is still losing
16m0099                               	: 2735  ;%$@#&@# SLOEXP didn't redefine AREA272 properly!!! $*$*$*
16m0099                               	LSHC2:  SHLOOP[16m0099 02735 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0099 02736 640240002145000020002736	        ALU[SH-AC] DEST[D4] MASK[2] ACSEL[AC] LOOP[.] NORM $
16m0100 02737 640140001555400440002026	]       ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
16m0100                               	
16m0100                               	        .USE[16m0100                               	XLIST
16m0101 02034 000700005570400440000000	 LIST ]SJMAIN:  ACSEL[MA] D[MEM] DEST[AC] $
16m0101 02035 000164634571000440002027	        D[IR] DEST[MA PC] JUMP[MAIN1] $
16m0101                               	
16m0101                               	        .USE[16m0101                               	XLIST
16m0102 04245 455160015421001000000000	 LIST ]PUSH1:   ACSEL[AC] D[CONST 1,,1] ALU[D+AC] DEST[AC MA] COND[CRY0] JUMP[PDLO2] C600
16m0102                               	 $
16m0102 04246 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
16m0102                               	
16m0102 04247 640710004571000440000000	POP1:   D[MEM] DEST[AR] SHORT $
16m0102 04250 640720034571000220000000	        D[IR] MASK[18.] DEST[MA] SHORT $
16m0102 04251 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
16m0102                               	
16m0102 04252 640164604571000220002027	POPJ1:  D[MEM] MASK[18.] DEST[PC MA] JUMP[MAIN1] NORM $
16m0102                               	
16m0102 04253 662104634571000222372032	PUSHJ1: MAPF[MASTO] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] MEMST OND[-MA-AC]
16m0102                               	 LBJUMP[MSMAIN] NORM ]$
16m0102                               	
16m0102                               	
16m0102                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

17m0102                               	;BLTA2 BLT1 BLT7 BLT5 BLT3 BLT2 BLT9 BLT4 BLT6 BLT8 BLTA3 BLTL1 BLTA4 BLTA1 BLTAL2 BLTA10
17m0102                               	 BLTL2 BLTA12 ANDCA1 ANDCA2 ANDCA3 LOG2 LOG3 ORCM2 ORCM3
17m0102                               	        .PAIR
17m0102                               	. \ 2 + .
17m0103 04254 640170000551000440000000	]BLTA2: ACSEL[AC] ALU[AC] DEST[AR MA] JUMP[BLTA3] NORM $ ;SRC IS AC GET DEST ADR
17m0103 04255 640710021171000440000000	BLT1:   D[PC] DEST[O_AC AR] ACSEL[AC] SHORT $
17m0103 04256 640704600171000220000000	        D[AR] MASK[18.] DEST[Q PC] SHORT $
17m0103 04257 640740034137000220000000	        D[IR] MASK[18.] ALU[D-Q] DEST[Q] LLOAD NORM $;GET COUNT
17m0103 04260 611140000555000440000000	        ALU[Q] COND[OBUS<0] JUMP[BLT4] CYLEN[C450] $ ; J IF END PRECEDES STRT
17m0103 04261 640730000171044220000000	BLT7:   D[AR] MASK[18.] ROT[18.] DEST[Q MA AR] SHORT $; FETCH FIRST WORD
17m0103 04262 640146000571000440050000	BLT5:   DEST[FIXMAC-MAPF-RD] MAPF[BLT-RD] JUMP[BLT2] CYLEN[FIXM] $
17m0103 04263 640706000571000442050000	BLT3:   DEST[FIXMAC-MAPF-RD] MAPF[BLT-RD] SPEC[PC+1] CYLEN[FIXM] $
17m0103 04264 641164204571000440600000	BLT2:   D[MEM] SPEC[MA_PC] DEST[MEMSTO MA] COND[INTRPT] JUMP[BLT6] NORM $
17m0103 04265 640270000017000440064263	        ALU[Q+1] DEST[Q AR MA] LOOP[BLT3] MAPF[BLT-WRT] CYLEN[MEMSTO] $
17m0103 04266 640704621171000220000000	BLT9:   D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC] NORM $
17m0103 04267 531140034463000220002026	        ACSEL[AC] D[IR] MASK[18.] ALU[AC-D] COND[-OBUS<0] JUMP[MAIN] C550 $ ;J IF DONE
17m0103 04270 640700001413000440000000	        ACSEL[AC] ALU[AC+1] DEST[AC] SHORT $
17m0103 04271 640740034523000440000000	        D[IR] ACSEL[AC] ALU[D-AC] LLOAD NORM $ ;GET COUNT
17m0103 04272 640704621171000440000000	        D[PC] ACSEL[AC] DEST[O_AC PC] SHORT $
17m0103 04273 640160000555000440004262	        ALU[Q] DEST[MA] JUMP[BLT5] NORM $
17m0103 04274 640740000615000440000000	BLT4:   ALU[0] LLOAD NORM $
17m0103 04275 640140000571000440004261	        JUMP[BLT7] NORM $
17m0103 04276 640250000017000440060000	BLT6:   ALU[Q+1] DEST[Q AR] LOOP[BLT8] MAPF[BLT-WRT] CYLEN[MEMSTO] $
17m0103 04277 000140000571000440004266	        JUMP[BLT9] $
17m0103 04300 640700001451000442000000	BLT8:   ACSEL[AC] ALU[AC-1] DEST[AC] SPEC[PC+1] NORM $
17m0103 04301 640704621171000220000000	        ACSEL[AC] D[PC] MASK[18.] DEST[O_AC PC] SHORT $
17m0103 04302 640700001561044000200000	        D[AR] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC] SHORT $
17m0103 04303 540500000571000441602320	        DISP[2320] SPEC[PC+1-IF&] CYLEN[DISP] $
17m0103 04304 640701000571044440000000	BLTA3:  D[AR] ROT[18.] DEST[AC-SEL] SHORT $ ;GET SRC ADR
17m0103 04305 640700034171000220000000	        D[IR] MASK[18.] DEST[Q] SHORT $
17m0103 04306 640740024077000220000000	        D[MA] MASK[18.] ALU[Q-D] DEST[Q] LLOAD NORM $
17m0103 04307 611040000555000440000000	        ALU[Q] COND[OBUS<0] PUSHJ[BLTA4] CYLEN[C450] $
17m0103 04310 640700000035044220000000	        D[AR] ROT[18.] MASK[18.] ALU[D+Q] DEST[Q] SHORT $
17m0103 04311 530140010635010300000000	        D[MASK 30] ROT[4] ALU[D&Q] COND[-OBUS=0] JUMP[BLTA10] C550  $;J IF SRC LEAVES
17m0103                               	 AC'S
17m0103 04312 640704200550000440000000	BLTL1:  ACSEL[REG] ALU[AC] DEST[MEMSTO] NORM $
17m0103 04313 640267024433000440104312	        D[MA] ALU[D+1] DEST[MA A-MEM-CNTR&INC] MAPF[BLT-WRTA] LOOP[BLTL1] CYLEN[MEMSTO] $
17m0103                               	
17m0103 04314 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
17m0103 04315 640740000215000440000000	BLTA4:  ALU[0] DEST[Q] LLOAD NORM $
17m0103 04316 640300000571000440000000	        POPJ NORM $
17m0103 04317 510140010621054160000000	BLTA1:  D[MASK 16] ROT[26] ACSEL[AC] ALU[D&AC] COND[OBUS=0] JUMP[BLTA10] C550 $; DEST IS
17m0103                               	 AC, J IF SRC AC?
17m0103 04320 530140034571100160000000	        D[IR] ROT[40] MASK[16] COND[-OBUS=0] JUMP[BLTA10] C550 $;J IF FINAL DEST NOT AC
17m0103 04321 640711000551000440000000	        ACSEL[AC] ALU[AC] DEST[AR AC-SEL] SHORT $;GET DEST ADR
17m0103 04322 640700034171000220000000	        D[IR] MASK[18.] DEST[Q] SHORT $
17m0103 04323 640740000077000220000000	        D[AR] MASK[18.] ALU[Q-D] DEST[Q] LLOAD NORM $;GET COUNT
17m0103 04324 611040000555000440004315	        ALU[Q] COND[OBUS<0] PUSHJ[BLTA4] CYLEN[C450] $;ADJUST IF CNT NEG.
17m0103 04325 640720000571044220000000	        D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $;GET SRC ADR
17m0103 04326 640706025432000440070000	BLTAL2: DEST[FIXMAC-MAPF-RD AC] MAPF[BLT-RDA] D[MA] ALU[D+1] ACSEL[REG] CYLEN[FIXM] $
17m0103 04327 640267005170000440004326	        ACSEL[REG] D[MEM] DEST[O_AC MA A-MEM-CNTR&INC] LOOP[BLTAL2] NORM $
17m0103 04330 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
17m0103 04331 640710000551000440000000	BLTA10: ACSEL[AC] ALU[AC] DEST[AR] SHORT $
17m0103 04332 640720000571044220000000	BLTL2:  D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $;GET WORD
17m0103 04333 640706000550400440070000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BLT-RDA] CYLEN[FIXM] $
17m0103 04334 640704404171000440000000	        D[MEM] DEST[HOLD Q] SHORT $
17m0103 04335 640724000571000220000000	        D[AR] MASK[18.] DEST[MA STRT-WRT] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

17m0103 04336 562140000571000440104340	        MAPF[BLT-WRTA] COND[-MA-AC] JUMP[. + 2] C500 $
17m0103 04337 640700001554400440000000	        ALU[Q] ACSEL[MA] DEST[AC] SHORT $
17m0103 04340 640700000171000220000000	        D[AR] MASK[18.] DEST[Q] NORM $
17m0103 04341 471140034477000220102026	        D[IR] MASK[18.] ALU[Q-D] MAPF[BLT-WRTA] COND[-OBUS<0] JUMP[MAIN] C600 $
17m0103 04342 640700014171001000000000	        D[CONST 1,,1] DEST[Q]  NORM $
17m0103 04343 640150000435000440004332	        D[AR] ALU[D+Q] DEST[AR] JUMP[BLTL2] NORM $;*** TEST FOR INTERRUPT HERE?
17m0103 04344 662100000571000440002032	BLTA12: MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0103                               	
17m0103                               	        .USE[17m0103                               	XLIST
17m0104                               	 LIST ]
17m0104 02763 640160005635000440602027	ANDCA1: D[MEM] ACSEL[AC] ALU[D&Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
17m0104                               	
17m0104 02764 662104204635000440002032	ANDCA2: D[MEM] ALU[D&Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104 02765 662104205635000440002032	ANDCA3: D[MEM] ACSEL[AC] ALU[D&Q] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM
17m0104                               	 ]$
17m0104                               	
17m0104 02766 662104200755000440002032	LOG2:   ALU[NOTQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104 02767 662104201755000440002032	LOG3:   ACSEL[AC] ALU[NOTQ] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104 02770 662104200545000440002032	ORCM2:  ACSEL[AC] ALU[QORAC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104 02771 662104201545000440002032	ORCM3:  ACSEL[AC] ALU[QORAC] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104                               	        .USE[17m0104                               	XLIST
17m0105                               	 LIST ]
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

18m0105                               	;SWINT NORSW NOSW RESW1 RESET RESET RESLOP DOHALT STPLOP STPLP1 NORSW2 RESW2 STRTSW CONSW
18m0105                               	 DEPTSW DEPNSW DEPSW1 EXMTSW EXMNSW SETLTS EXMSW1 BRPNT MOVSS1 MOVNS1 HLLZS1 HRLZS1
18m0105                               	 HRRZS1 HLRZS1 HRAR HLAR HLLEM1 HRLEM1 HLREM1 HRREM1 HSMAIN HSMN1 HLLOS1 HRROS1 HLLES1
18m0105                               	 HRRES1 HLLES2 HMV HHS HLSZ HOR HRSZ HOL HRLM1 HLLM1 HLRM1 HRRM1 JRST1 JRST4 JRST5 JRST9
18m0105                               	 JRST8 JRST2 JRST3 JFCL1 JSR2 JSA1 JRA1 MUJSR MUJSP
18m0105                               	;  MUJSA MUJSYS MUJSM1
18m0105                               	;;;RESW1:
18m0105                               	        .ORG[XLIST
18m0105                               	 LIST ];*$*$* No REAL reason for this
18m0105                               	: 2062  ;SWITCH, AR & ECC INTERRUPTS COME HERE
18m0105 02062 640702400571000440000000	SWINT:  DEST[CLR-DEV-FROM-INTR] SHORT $
18m0105 02063 640701600615000443400000	        ALU[0] DEST[DEV-ADR] SPEC[IOB-IN] SHORT $
18m0105 02064 140710030571000440040000	        D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $                 ;GET SW BITS
18m0105 02065 530140000571016010000000	        D[AR] ROT[7] MASK[1] COND[-OBUS=0] JUMP[APDINT] C550 $  ;JUMP IF OVFL OR ECC INT
18m0105                               	
18m0105 02066 640700014171002153600000	        D[CONST 15] ROT[1] DEST[Q] SPEC[IOB-OUT] SHORT $
18m0105 02067 510140000635030440040000	        D[AR] ROT[14] ALU[D&Q] MAPF[4] COND[OBUS=0] JUMP[NOSW] C550 $   ;CHECK FOR
18m0105                               	 RELEVANT SW, & CLR FF.
18m0105 02070 530140000571020010000000	        D[AR] ROT[10] MASK[1] COND[-OBUS=0] JUMP[RESW1] C550 $  ;J IF RESET SW
18m0105 02071 530040000571026010000000	NORSW:  D[AR] ROT[13] MASK[1] COND[-OBUS=0] PUSHJ[EXMTSW] C550 $        ;PUSHJ IF EXAM
18m0105                               	 THIS
18m0105 02072 530040000571022010000000	        D[AR] ROT[11] MASK[1] COND[-OBUS=0] PUSHJ[DEPTSW] C550 $        ;PUSHJ IF DEPO
18m0105                               	 THIS
18m0105 02073 640160000571000440602027	NOSW:   SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
18m0105                               	
18m0105       2074	area206 = .     ;Sigh...
18m0105                               	
18m0105                               	        .RELOC
18m0105                               	USE[18m0105                               	XLIST
18m0106                               	 LIST ]]
18m0106 04345 640700000571000443400000	RESW1:  SPEC[IOB-IN] SHORT $
18m0106 04346 140710030571000440000000	        D[IOD] DEST[AR]  CYLEN[IOB-IN] $        ;DOUBLE CHECK RESET SW
18m0106 04347 410140000571020010002071	        D[AR] ROT[10] MASK[1] COND[OBUS=0] JUMP[NORSW] CYLEN[C650] $    ;DOUBLE CHECK
18m0106                               	 RESET SW
18m0106                               	
18m0106                               	;******* This code to be made a subroutine to allow machine resetting *******
18m0106                               	;******* to be done by auto-loading and via CONO APR,20000  TVR-Mar80 *******
18m0106                               	
18m0106                               	.REPEAT F2SW [
18m0106 04350 640702214571000003600000	RESET:  D[CONST 0] DEST[IOD] SPEC[IOB-OUT] NORM $
18m0106                               	  ] ;END F2SW
18m0106                               	
18m0106                               	.REPEAT 1 - F2SW [
18m0106                               	 ;END 1 - F2SW
18m0106                               	;*** Disable ECC interrupts on F3's?????
18m0106                               	
18m0106 04351 440705400615000440100000	        MAPF[10] ALU[0] DEST[CRYOV] CYLEN[IOB-OUT] $    ;CLR MAP-IN-USE & PC FLAGS & AR
18m0106                               	 INT ENBL, ETC.
18m0106 04352 640143600571000440000000	        DEST[CLR-MI-ERR] JUMP[RESLOP] NORM $
18m0106 04353 640702600615000440000000	RESLOP: ALU[0] DEST[HI-ABS-MA] NORM $
18m0106 04354 640041614571000000000000	        D[CONST 0] DEST[DEV-ADR] PUSHJ[APRRST] NORM $
18m0106 04355 640041614571000010000000	        D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPRST] NORM $
18m0106 04356 640041614571000040000000	        D[CONST 4] DEST[DEV-ADR] PUSHJ[CTYRST] NORM $
18m0106 04357 640041614571000100000000	        D[CONST 10] DEST[DEV-ADR] PUSHJ[DSKRST] NORM $
18m0106 04360 640041614571000070000000	        D[CONST 7] DEST[DEV-ADR] PUSHJ[TAPRST] NORM $
18m0106                               	.REPEAT DLS [;SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

18m0106                               	 9 JAN 80  BO
18m0106 04361 640041614571000200000000	        D[CONST DLSDEV] DEST[DEV-ADR] PUSHJ[DLSRST] NORM $
18m0106                               	]DLS
18m0106                               	.REPEAT VC [ 18m0106                               	; 24 AUG 80  BO
18m0106 04362 640041614571000140000000	        D[CONST VCDEV] DEST[DEV-ADR] PUSHJ[VCRST] NORM $
18m0106                               	]; VC
18m0106                               	.REPEAT IMP [;18m0106                               	 23JAN80 MLB
18m0106 04363 640041614571000160000000	        D[CONST 16] DEST[DEV-ADR] PUSHJ[IMPRST] NORM $
18m0106                               	]IMP
18m0106                               	.REPEAT LPT [
18m0106                               	LPT
18m0106                               	.REPEAT STANSW [;18m0106                               	REPEAT STANSW
18m0106 04364 640041614571000060000000	        D[CONST 6] DEST[DEV-ADR] PUSHJ[CLKRST] NORM $
18m0106 04365 640041614571000060000000	        D[CONST 6] DEST[DEV-ADR] PUSHJ[TYMRST] NORM $
18m0106 04366 640041614571000060000000	        D[CONST 6] DEST[DEV-ADR] PUSHJ[PI-RESET] NORM $
18m0106 04367 640702400571000440000000	DOHALT: DEST[CLR-DEV-FROM-INTR] NORM $
18m0106 04370 640701614571000013400000	STPLOP: D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
18m0106 04371 140700030171000440040000	        MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
18m0106 04372 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
18m0106 04373 640702214575000103600000	        D[CONST 10] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $
18m0106 04374 440700000571000440100000	        MAPF[10] CYLEN[IOB-OUT] $; SET PROG HALT LIGHT
18m0106 04375 640721600615000440600000	        ALU[0] DEST[DEV-ADR MA] SPEC[MA_PC] NORM $
18m0106 04376 640706000550400443620000	        FIXM1 SPEC[IOB-OUT] $
18m0106 04377 000700004571000440060000	        D[MEM] MAPF[6] CYLEN[LONG] $
18m0106 04400 640700000571000443400000	        SPEC[IOB-IN] NORM $
18m0106 04401 140710030571000440040000	        D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $
18m0106 04402 451140000571000440000000	        D[AR] COND[OBUS<0] JUMP[BRPNT] C600 $; J IF BRK POINT SW
18m0106 04403 640700000571000443400000	        SPEC[IOB-IN] NORM $
18m0106 04404 140710030571000440040000	STPLP1: D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $ ;GET SW BITS
18m0106 04405 530140000571020010000000	        D[AR] ROT[10] MASK[1] COND[-OBUS=0] JUMP[RESW2] C550 $  ;J IF RESET SW
18m0106 04406 640700000171030110000000	        D[AR] ROT[14] MASK[11] DEST[Q] NORM $
18m0106 04407 450140014675010073404404	        D[CONST 7] ROT[4] ALU[-D&Q] COND[OBUS=0] SPEC[IOB-IN] JUMP[STPLP1] C600 $; LOOP
18m0106                               	 IF NO SW
18m0106 04410 640700000571000443600000	        SPEC[IOB-OUT] NORM $
18m0106 04411 440700000571000440040000	        MAPF[4] CYLEN[IOB-OUT] $        ;CLR SW FF'S
18m0106                               	        .DEFINE SWTEST 18m0106                               	NORSW2: SWTEST[18m0106 04412 530140000571010010000000	D[AR] ROT[4] MASK[1] COND[-OBUS=0] JUMP [ CONSW ] C550 $
18m0107                               	]       SWTEST[18m0107 04413 530140000571012010000000	D[AR] ROT[5] MASK[1] COND[-OBUS=0] JUMP [ STRTSW ] C550 $
18m0108                               	]       SWTEST[18m0108 04414 530040000571022010000000	D[AR] ROT[11] MASK[1] COND[-OBUS=0] PUSHJ [ DEPTSW ] C550 $
18m0109                               	]       SWTEST[18m0109 04415 530040000571024010000000	D[AR] ROT[12] MASK[1] COND[-OBUS=0] PUSHJ [ DEPNSW ] C550 $
18m0110                               	]       SWTEST[18m0110 04416 530040000571026010000000	D[AR] ROT[13] MASK[1] COND[-OBUS=0] PUSHJ [ EXMTSW ] C550 $
18m0111                               	]       SWTEST[18m0111 04417 530040000571030010000000	D[AR] ROT[14] MASK[1] COND[-OBUS=0] PUSHJ [ EXMNSW ] C550 $
18m0112 04420 640141614571000003404404	]       D[CONST 0] DEST[DEV-ADR] SPEC[IOB-IN] JUMP[STPLP1] NORM $       ;LOOP
18m0112                               	
18m0112 04421 640700000571000443400000	RESW2:  SPEC[IOB-IN] SHORT $
18m0112 04422 140710030571000440000000	        D[IOD] DEST[AR]  CYLEN[IOB-IN] $        ;DOUBLE CHECK RESET SW
18m0112 04423 150140000571020010004412	        D[AR] ROT[10] MASK[1] COND[OBUS=0] JUMP[NORSW2] CYLEN[IOB-IN] $ ;DOUBLE CHECK
18m0112                               	 RESET SW
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

18m0112 04424 640140000571000440004350	        JUMP[RESET] NORM $
18m0112 04425 640704600571000230000000	STRTSW: D[AR] MASK[23] DEST[PC] NORM $
18m0112 04426 640722600615000440600000	CONSW:  ALU[0] SPEC[MA_PC] DEST[MA HI-ABS-MA] NORM $
18m0112 04427 640701614571000013400000	        D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
18m0112 04430 140700030171000440040000	        MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
18m0112 04431 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
18m0112 04432 640702214635000073600000	        D[CONST 7] ALU[D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $
18m0112 04433 440700000571000440100000	        MAPF[10] CYLEN[IOB-OUT] $; CLEAR PROG HALT LIGHT
18m0112 04434 640706000550400440010000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
18m0112 04435 540530604571000441602174	        D[MEM] DEST[IR-ALL AR MA] DISP[2174] SPEC[PC+1-IF] CYLEN[DISP] $; IGNORE STOP SW
18m0112                               	
18m0112                               	
18m0112 04436 640162600571000233400000	DEPTSW: D[AR] MASK[23] DEST[MA HI-ABS-MA] SPEC[IOB-IN] JUMP[DEPSW1] NORM $
18m0112 04437 640720024433000443400000	DEPNSW: D[MA] ALU[D+1] DEST[MA] NORM SPEC[IOB-IN] $
18m0112 04440 140704230571000440020000	DEPSW1: D[IOD] DEST[MEMSTO] MAPF[2] CYLEN[IOB-IN] $
18m0112 04441 662300000571000440000000	        MAPF[TEMP] COND[-MA-AC] POPJ CYLEN[MEMSTO] $
18m0112 04442 640300005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] POPJ NORM $
18m0112                               	
18m0112 04443 640162600571000230000000	EXMTSW: D[AR] MASK[23] DEST[MA HI-ABS-MA] JUMP[EXMSW1] NORM $
18m0112 04444 640160024433000440000000	EXMNSW: D[MA] ALU[D+1] DEST[MA] JUMP[EXMSW1] NORM $
18m0112                               	;NOTE: This subroutine is called by DATAO PI, which displays in the lights
18m0112 04445 640706000550400440020000	SETLTS: FIXM1 $                 ;Take page faults, if any.
18m0112 04446 640706000550400440000000	EXMSW1: ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[TEMP] CYLEN[FIXM] $
18m0112 04447 640700000571000443600000	        SPEC[IOB-OUT] NORM $
18m0112 04450 000300004571000440020000	        D[MEM] MAPF[2] CYLEN[LONG] POPJ $
18m0112 04451 640700000171000270000000	BRPNT:  D[AR] MASK[27] DEST[Q] NORM $
18m0112 04452 470140020537000270004426	        D[PC] MASK[27] ALU[D-Q] COND[-OBUS=0] JUMP[CONSW] C600 $
18m0112 04453 640140000571000443404404	        SPEC[IOB-IN] JUMP[STPLP1] NORM $
18m0112                               	
18m0112                               	        .USE[18m0112                               	XLIST
18m0113 02772 662104205571044440002032	 LIST ]MOVSS1:  D[MEM] ROT[18.] ACSEL[AC] DEST[AC MEMSTO] MEMST OND[-MA-AC]
18m0113                               	 LBJUMP[MSMAIN] NORM ]$
18m0113                               	
18m0113 02773 662104205473000440002032	MOVNS1: D[MEM] ALU[0-D] ACSEL[AC] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM
18m0113                               	 ]$
18m0113                               	
18m0113 02774 643130005570400000400000	HLLZS1: ACSEL[MA] D[MEM] COND[AC=0] DEST[AC AR MA] SPEC[LEFT&MA_PC] LBJUMP[HSMAIN] NORM $
18m0113                               	
18m0113                               	
18m0113 02775 643130005570444000400000	HRLZS1: ACSEL[MA] D[MEM] ROT[18.] COND[AC=0] DEST[AC AR MA] SPEC[LEFT&MA_PC]
18m0113                               	 LBJUMP[HSMAIN] NORM $
18m0113                               	
18m0113 02776 643130005570400220600000	HRRZS1: ACSEL[MA] D[MEM] MASK[18.] COND[AC=0] DEST[AC AR MA] SPEC[MA_PC] LBJUMP[HSMAIN]
18m0113                               	 NORM $
18m0113                               	
18m0113 02777 643130005570444220600000	HLRZS1: ACSEL[MA] D[MEM] ROT[18.] MASK[18.] COND[AC=0] DEST[AC AR MA] SPEC[MA_PC]
18m0113                               	 LBJUMP[HSMAIN] NORM $
18m0113                               	
18m0113                               	        .USE[18m0113                               	XLIST
18m0114 03426 640160001561000220602027	 LIST ]HRAR:    D[AR] MASK[18.] ALU[DORAC] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1]
18m0114                               	 NORM $
18m0114                               	
18m0114 03427 640160001561000000402027	HLAR:   D[AR] SPEC[LEFT&MA_PC] MASK[0] ALU[DORAC] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM
18m0114                               	 $
18m0114                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

18m0114 03430 662104200571000000202032	HLLEM1: D[AR] MASK[0] SPEC[LEFT] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0114                               	
18m0114 03431 662104200571044000202032	HRLEM1: D[AR] ROT[18.] MASK[0] SPEC[LEFT] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN]
18m0114                               	 NORM ]$
18m0114                               	
18m0114 03432 662104200571044220002032	HLREM1: D[AR] ROT[18.] MASK[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0114                               	
18m0114 03433 662104200571000220002032	HRREM1: D[AR] MASK[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0114                               	
18m0114                               	        .USE[18m0114                               	XLIST
18m0115                               	 LIST ] .PAIR
18m0115                               	. \ 2 + .
18m0116 03444 640700001571000440000000	]HSMAIN:        ACSEL[AC] D[AR] DEST[AC] NORM $
18m0116 03445 640146000550400440022030	        FIXM1 JUMP[MAIN2] $
18m0116                               	        .PAIR
18m0116                               	. \ 2 + .
18m0117 03446 640160000571000440602027	]HSMN1: SPEC[MA_PC] DEST[MA] JUMP[MAIN1] CYLEN[MEMSTO] $
18m0117 03447 640160005571000440602027	        D[MEM] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[MEMSTO] $
18m0117                               	        .PAIR
18m0117                               	. \ 2 + .
18m0118 03450 662104210575000220002032	]HLLOS1:        D[MASK 22] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM
18m0118                               	 ]$
18m0118 03451 662104211575000220002032	        D[MASK 22] ALU[DORQ] DEST[MEMSTO AC] ACSEL[AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN]
18m0118                               	 NORM ]$
18m0118                               	        .PAIR
18m0118                               	. \ 2 + .
18m0119 03452 662104210575044220002032	]HRROS1:        D[MASK 22] ROT[18.] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC]
18m0119                               	 LBJUMP[MSMAIN] NORM ]$
18m0119 03453 662104211575044220002032	        D[MASK 22] ROT[18.] ALU[DORQ] DEST[MEMSTO AC] ACSEL[AC] MEMST OND[-MA-AC]
18m0119                               	 LBJUMP[MSMAIN] NORM ]$
18m0119                               	        .PAIR
18m0119                               	. \ 2 + .
18m0120 03454 663100010235044220000000	]HLLES1:        D[MASK 22] ROT[18.] ALU[D&Q] DEST[Q] COND[-AC=0] LBJUMP[HLLES2] NORM $
18m0120 03455 663100000571000440003450	        COND[-AC=0] LBJUMP[HLLOS1] NORM $
18m0120                               	        .PAIR
18m0120                               	. \ 2 + .
18m0121 03456 663100010235000220000000	]HRRES1:        D[MASK 22] ALU[D&Q] DEST[Q] COND[-AC=0] LBJUMP[HLLES2] NORM $
18m0121 03457 663100000571000440003452	        COND[-AC=0] LBJUMP[HRROS1] NORM $
18m0121                               	        .USE[18m0121                               	XLIST
18m0122                               	 LIST ] .PAIR
18m0122                               	. \ 2 + .
18m0123 03470 662104200555000440002032	]HLLES2:        ALU[Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0123 03471 662104201555000440002032	        ALU[Q] ACSEL[AC] DEST[MEMSTO AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0123                               	        .PAIR
18m0123                               	. \ 2 + .
18m0124 03472 640140000571000440002026	]HMV:   JUMP[MAIN] NORM $
18m0124 03473 640140000571000440002400	        JUMP[MOVE] NORM $
18m0124                               	        .PAIR
18m0124                               	. \ 2 + .
18m0125 03474 662104200575044440002032	]HHS:   D[AR] ROT[18.] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0125 03475 662104201575044440002032	        D[AR] ROT[18.] ALU[DORQ] ACSEL[AC] DEST[MEMSTO AC] MEMST OND[-MA-AC]
18m0125                               	 LBJUMP[MSMAIN] NORM ]$
18m0125                               	        .USE[18m0125                               	XLIST
18m0126                               	 LIST ] .PAIR
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

18m0126                               	. \ 2 + .
18m0127 03526 640160000571000440602027	]HLSZ:  SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
18m0127 03527 640160011561000220602027	HOR:    D[MASK 22] ACSEL[AC] ALU[DORAC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $
18m0127                               	        .PAIR
18m0127                               	. \ 2 + .
18m0128 03530 640160000571000440602027	]HRSZ:  SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
18m0128 03531 640160011561044220602027	HOL:    D[MASK 22] ACSEL[AC] ROT[18.] ALU[DORAC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM
18m0128                               	 $
18m0128                               	        .PAIR
18m0128                               	. \ 2 + .
18m0129 03532 640700000171044440000000	]HRLM1: D[AR] ROT[18.] DEST[Q] NORM $
18m0129 03533 662104204575000220002032	HLLM1:  D[MEM] MASK[18.] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0129                               	
18m0129                               	        .PAIR   . \ 2 + .
18m0129                               	];(??) Added TVR-Apr80
18m0129 03534 640700000171044440000000	HLRM1:  D[AR] ROT[18.] DEST[Q] NORM $
18m0129 03535 662104204575000000202032	HRRM1:  D[MEM] MASK[0] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN]
18m0129                               	 NORM ]$
18m0129                               	
18m0129                               	        .USE[18m0129                               	XLIST
18m0130                               	 LIST ] .PAIR
18m0130                               	. \ 2 + .
18m0131 03504 645140000571000440000000	]JRST1: COND[USER] JUMP[JRST8] NORM $; ILLEGAL IF USER MODE
18m0131 03505 530140034571030010000000	        D[IR] ROT[14] MASK[1] COND[-OBUS=0] JUMP[JRST2] C550 $
18m0131 03506 640140000571000440000000	        JUMP[JRST4] NORM $
18m0131 03507 530140034571032010000000	JRST4:  D[IR] ROT[15] MASK[1] COND[-OBUS=0] JUMP[JRST3] C550 $
18m0131 03510 530140034571026010000000	JRST5:  D[IR] ROT[13] MASK[1] COND[-OBUS=0] JUMP[JRST9] C550 $;J TO STOP SWITCH IF HALT
18m0131 03511 530140034571024010000000	        D[IR] ROT[12] MASK[1] COND[-OBUS=0] JUMP[PI-DISMISS] C550 $; J IF DISMISS BIT ON
18m0131                               	
18m0131 03512 640160000571000440602027	        JUMP[MAIN1] NORM SPEC[MA_PC] DEST[MA] $
18m0131 03513 665140000571000440004367	JRST9:  COND[EXEC] JUMP[DOHALT] NORM $; HALT IF EXEC MODE
18m0131                               	JRST8:  MUUO1
18m0131 03514 640150020171000440002101	D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
18m0132                               	]
18m0132 03515 640700020171000440000000	JRST2:  D[PC] DEST[Q] SHORT $
18m0132 03516 640700014235074010000000	        D[CONST 1] ROT[36] ALU[D&Q] DEST[Q] SHORT $
18m0132 03517 640145400575000440003507	        D[AR] ALU[DORQ] DEST[CRYOV] JUMP[JRST4] NORM $
18m0132                               	        .USE[18m0132                               	XLIST
18m0133 03544 640700014171074010000000	 LIST ]JRST3:   D[CONST 1] ROT[36] DEST[Q] SHORT $
18m0133 03545 640145420575000440003510	        D[PC] ALU[DORQ] DEST[CRYOV] JUMP[JRST5] NORM $
18m0133                               	
18m0133 03546 510140000635100440002026	JFCL1:  D[AR] ROT[40] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $;TEST SELECTED FLAGS
18m0133 03547 640705400675100440000000	        D[AR] ROT[40] ALU[-D&Q] DEST[CRYOV] SHORT $;CLEAR FLAGS
18m0133 03550 640164634571000440002027	        DOJUMP $
18m0133 03551 640704624433000442240000	JSR2:   D[MA] ALU[D+1] DEST[PC] SPEC[CLR-HALF] MAPF[STO] NORM $
18m0133 03552 640160005570400440602027	        ACSEL[MA] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
18m0133 03553 640704624433000440000000	JSA1:   D[MA] ALU[D+1] DEST[PC] SHORT $
18m0133 03554 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0133 03555 640706000550400440020000	JRA1:   FIXM1 $
18m0133 03556 640700005571000440000000	        ACSEL[AC] D[MEM] DEST[AC] CYLEN[FIXM+1] $
18m0133 03557 640164634571000220002027	        D[IR] MASK[18.] DEST[PC MA] JUMP[MAIN1] NORM $
18m0133                               	
18m0133                               	        .USE[18m0133                               	XLIST
18m0134 04454 640720604571000440000000	 LIST ]MUJSR:   D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

18m0134 04455 642144200571000440003551	        D[AR] DEST[MEMSTO] COND[MA-AC] JUMP[JSR2] NORM $
18m0134 04456 640164624433000442242027	        D[MA] ALU[D+1] DEST[MA PC] MAPF[STO] SPEC[CLR-HALF] JUMP[MAIN1] CYLEN[MEMSTO] $
18m0134 04457 640720604571000440000000	MUJSP:  D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
18m0134 04460 640140001571000440002553	        D[AR] ACSEL[AC] DEST[AC] JUMP[JSP1] NORM $
18m0134 04461 640720604571000440000000	MUJSA:  D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
18m0134 04462 640150001171000440003553	        D[AR] ACSEL[AC] DEST[O_AC AR] JUMP[JSA1] NORM $
18m0134 04463 640720604571000440000000	MUJSYS: D[MEM] DEST[IR-ALL MA] SHORT $
18m0134 04464 510140034571066110002211	        D[IR] ROT[33] MASK[11] COND[OBUS=0] JUMP[JSYS3] C550 $; J IF EX JSYS
18m0134 04465 640706000550400440150000	MUJSM1: ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[MAPFTR] CYLEN[FIXM] $
18m0134 04466 640704604571000220000000	        D[MEM] MASK[18.] DEST[PC] NORM $; JUMP TO RIGHT HALF
18m0134 04467 640720004571044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $; GET READY TO STORE
18m0134 04470 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0134                               	
18m0134                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

19m0134                               	;CTYDSP AREA51 CTYINT CTYIOT CTYDI CTYDO CTYCO CTYCI CTYCI2 CTYCI1 CTYCI9 CTYCI8 CTYCI3
19m0134                               	 CTYCO1 CTYCO3 CTYCO4 CTYCO5 CTYRST ctyrs1 AREA52 CTYCZ CTYCS
19m0134                               	;------------------------------------------------------------------------------
19m0134                               	;
19m0134                               	;       CTY - Console Teletype                          Device 120
19m0134                               	;
19m0134                               	;------------------------------------------------------------------------------
19m0134                               	
19m0134                               	;
19m0134                               	;A-MEM Usage
19m0134                               	;
19m0134       0	CTY-DISP = 0            ;Instruction and interrupt dispatch
19m0134       1	CTY-CONT = 1            ;Control bits for UART, etc.
19m0134       2	CTY-STATUS = 2          ;Firmware status
19m0134                               	
19m0134                               	;
19m0134                               	;*** Meanings of hardware bits should be documented here.
19m0134                               	;
19m0134                               	;MAPF values
19m0134                               	
19m0134                               	.REPEAT NTP [
19m0134       0	TTY.DI = 0      ;read data
19m0134       12	TTY.WD = 12     ;write data
19m0134       14	TTY.WC = 14     ;write control
19m0134                               	  ];NTP
19m0134                               	
19m0134                               	.REPEAT OTP [
19m0134                               	;OTP
19m0134                               	
19m0134                               	;*$*$*  This ORG is ready to be flushed.  It only remains to test the code
19m0134                               	;       and merge the AREAs
19m0134                               	
19m0134                               	        .ORG[XLIST
19m0134                               	 LIST ];CTY IOT DISPATCH TABLE
19m0134                               	
19m0134                               	CTYDSP: ILGIOT 19m0134 05100 000140000571000440002026	 JUMP [MAIN] ]$ ;BLKI
19m0134 05101 000700000571000440000000	        NOP $
19m0134 05102 640700050171000443400000	        D[CTY-STATUS + 10] DEST[Q] SPEC[IOB-IN] NORM $ ;DATAI
19m0134 05103 140150030571000440000000	        MAPF[TTY.DI] D[IOD] DEST[AR] JUMP[CTYDI] CYLEN[IOB-IN] $
19m0134                               	        ILGIOT 19m0134 05104 000140000571000440002026	 JUMP [MAIN] ]$ ;BLKO
19m0134 05105 000700000571000440000000	        NOP $
19m0134 05106 640706000550400440020000	        FIXM1 $         ;DATAO
19m0134 05107 640140050171000440000000	        D[CTY-STATUS + 10] DEST[Q] JUMP[CTYDO] NORM $ ; GET CONI BITS
19m0134 05110 640700050171000070000000	        D[CTY-STATUS + 10] MASK[7] DEST[Q] NORM $ ;CONO, GET CONI BITS
19m0134 05111 640140034275100070000000	        D[IR] MASK[7] ROT[40] ALU[-D&Q] DEST[Q] JUMP[CTYCO] NORM $ ;CLR THE CLR BITS
19m0134 05112 640040050171000443400000	        D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
19m0134                               	                ; CONI, GET BITS
19m0134 05113 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
19m0134 05114 640040050171000443400000	        D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
19m0134                               	                ;CONSZ, GET BITS
19m0134 05115 640140034171000220000000	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
19m0134 05116 640040050171000443400000	        D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
19m0134                               	                ;CONSO, GET CONI BITS
19m0134 05117 640140034171000220000000	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
19m0134                               	;$*$*$ We may not be able to afford this in the future...  TVR-Apr80
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

19m0134                               	LPTDSP:
19m0134                               	.REPEAT 1 - LPT [
19m0134                               	     .REPEAT 10 [I19m0134                               	LGIOT 19m0134 05120 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05121 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05122 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05123 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05124 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05125 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05126 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05127 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05130 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05131 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05132 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05133 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05134 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05135 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05136 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05137 000700000571000440000000	        NOP $
19m0134                               	].REPEAT 10
19m0134                               	].REPEAT 1 - LPT
19m0134                               	
19m0134                               	.REPEAT LPT [   19m0134                               	.REPEAT LPT
19m0134                               	
19m0134                               	AREA51: ;$*$*$ Start code from here for now.  This should go away
19m0134                               	
19m0134                               	
19m0134                               	: 2130 ;CTY and 60 HZ CLOCK INTS COME HERE
19m0134                               	
19m0134                               	CTYINT:
19m0134                               	  .REPEAT NTP [;19m0134                               	With new tape controller, 60HZ clk shares DEV 4 w/ CTY.
19m0134 02130 640700000571000443400000	        START-IN SHORT $
19m0134 02131 440710030771000440050000	        MAPF[5] D[IOD] ALU[NOTD] DEST[AR] C600 $
19m0134                               	                ;Read the NET interface status...
19m0134 02132 530140000571000010000000	        D[AR] MASK[1] C550 -OBUS=0 JUMP[CLKINT] $
19m0134                               	                ;Is 60HZ clk requesting an int. ? Jump if so.
19m0134 02133 640140000571000440000000	        NORM JUMP[CTYIN1] $
19m0134                               	                ;Else it is the CTY's turn.
19m0134                               	: 2144
19m0134                               	      ];NTP
19m0134                               	
19m0134 02144 640040050171000443400000	CTYIN1: D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
19m0134                               	                ; DO A CONI, GET BITS
19m0134 02145 640702244571000113600000	        D[CTY-CONT + 10] MASK[11] DEST[IOD] SPEC[IOB-OUT] NORM $; DISABLE INTS
19m0134 02146 440710050171000030140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] D[CTY-STATUS + 10] MASK[3] DEST[Q AR] $
19m0134                               	                ; GET PI CHAN
19m0134 02147 640142400571000440000000	        NORM  DEST[CLR-DEV-FROM-INTR] JUMP[PIGEN] $;CAUSE INTR.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

19m0134                               	
19m0134                               	;$*$*$ This one is referenced off the MAP dispatch
19m0134                               	: 5210
19m0134                               	        .PAIR
19m0134                               	. \ 2 + .
19m0135                               	]       UIOTRP[19m0135 05210 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
19m0135                               	]$
19m0135                               	CTYIOT: IOTDIS 19m0135 05211 640700034171034050000000	D[IR] ROT[16] MASK[5] DEST[Q] NORM $
19m0135 05212 540540014575014510000000	        D[CONST 51] ROT[6] ALU[DORQ] SDISP CYLEN[C500] $
19m0136                               	]
19m0136 05213 640700414675000403000000	CTYDI:  D[CONST 40] ALU[-D&Q] DEST-A-MEM DEST[CTY-STATUS] NORM $; CLR TTI FLAG
19m0136 05214 640700014171006100000000	        D[CONST 10] ROT[3] DEST[Q] SHORT $
19m0136 05215 640702244575000443600000	        D[CTY-CONT + 10] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] SHORT $;CLR RCV. CHR
19m0136 05216 440700000571000440140000	        MAPF[TTY.WC]  CYLEN[IOB-OUT] $
19m0136 05217 640702244571000443600000	        D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] SHORT $
19m0136 05220 440700000571000440140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] $
19m0136 05221 662104200571000100002032	        D[AR] MASK[10] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
19m0136 05222 640702204571000443600000	CTYDO:  D[MEM] DEST[IOD] SPEC[IOB-OUT] NORM $;SEND CHR.
19m0136 05223 440700014275000100120000	        MAPF[TTY.WD] CYLEN[IOB-OUT] D[CONST 10] ALU[-D&Q] DEST[Q] $;CLR TTO FLAG
19m0136 05224 640702244433000443600000	        D[CTY-CONT + 10] ALU[D+1] DEST[IOD] SPEC[IOB-OUT] NORM $
19m0136                               	                ;ENABLE UART STB
19m0136                               	        MAPF[TTY.WC] CYLEN[IOB-OUT]
19m0136 05225 440700414575000203140000	                        D[CONST 20] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM $
19m0136                               	                ;SET TTO BUSY
19m0136 05226 640702244571000443600000	        D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] NORM $;CLR UART STB
19m0136 05227 450140014635000070142026	        MAPF[TTY.WC] CYLEN[IOB-OUT] D[CONST 7] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] $ ; DONE
19m0136                               	 IF NO PI CHAN
19m0136 05230 640700044171000440000000	        D[CTY-CONT + 10] DEST[Q] SHORT $; GET IOB-OUT BITS
19m0136 05231 640702214175022043600000	        D[CONST 4] ROT[11] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] NORM $ ;ENABLE XMT INT
19m0136 05232 440140200555000443142026	        MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[Q] DEST[CTY-CONT] DEST-A-MEM JUMP[MAIN] $
19m0136 05233 640700014235006170000000	CTYCO:  D[CONST 17] ROT[3] ALU[D&Q] DEST[Q] NORM $;CLR PI BITS
19m0136 05234 640140434575000073000000	        D[IR] MASK[7] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM JUMP[CTYCO1] NORM $
19m0136                               	                ;OR IN NEW PI BITS
19m0136 05235 140704430571000440000000	CTYCI:  MAPF[TTY.DI] D[IOD] DEST[HOLD] CYLEN[IOB-IN] $;GET UART BITS
19m0136 05236 640702244571000443600000	        D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] NORM $
19m0136 05237 170140004571054010140000	        MAPF[TTY.WC] D[MEM] ROT[26] MASK[1] COND[-OBUS=0] JUMP[CTYCI1]
19m0136                               	 CYLEN[MAX,IOB-OUT,C550] $; J IF RCV RDY
19m0136 05240 640150014275006100000000	CTYCI2: D[CONST 10] ROT[3] ALU[-D&Q] DEST[Q AR] JUMP[CTYCI9] NORM $;CLR TTI BUSY
19m0136 05241 530140014635000400005240	CTYCI1: D[CONST 40] ALU[D&Q] COND[-OBUS=0] JUMP[CTYCI2] C550 $;J IF TTI FLAG ON
19m0136 05242 640710014335006100000000	        D[CONST 10] ROT[3] ALU[D#Q] DEST[Q AR] NORM $;COMPL BUSY.
19m0136 05243 530140014635006100000000	        D[CONST 10] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[CTYCI9] C550 $;J IF BUSY NOW ON
19m0136 05244 640710014175000400000000	        D[CONST 40] ALU[DORQ] DEST[Q AR] NORM $; SET TTI FLAG
19m0136 05245 530140004571052010000000	CTYCI9: D[MEM] ROT[25] MASK[1] COND[-OBUS=0] JUMP[CTYCI8] C550 $;J IF XMT RDY
19m0136 05246 640300414575000203000000	        D[CONST 20] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM POPJ NORM $
19m0136                               	                ;SET BUSY -- NOTE, NO "AR DEST" IS CORRECT
19m0136 05247 510140014635000200000000	CTYCI8: D[CONST 20] ALU[D&Q] COND[OBUS=0] JUMP[CTYCI3] C550 $; J IF BUSY OFF
19m0136 05250 640700014175000100000000	        D[CONST 10] ALU[DORQ] DEST[Q] NORM $; SET FLAG
19m0136 05251 640300414675000203000000	CTYCI3: D[CONST 20] ALU[-D&Q] DEST[CTY-STATUS] DEST-A-MEM POPJ NORM $ ;CLR BUSY
19m0136 05252 640700034171102100000000	CTYCO1: D[IR] ROT[41] MASK[10] DEST[Q] NORM $; GET SET&CLR BITS
19m0136 05253 010140014635006100000000	        D[CONST 10] ROT[3] ALU[D&Q] COND[OBUS=0] JUMP[CTYCO4] $
19m0136                               	                ; J IF CLR TTI FLAG OFF
19m0136 05254 640700044171000110000000	        D[CTY-CONT + 10] MASK[11] DEST[Q] NORM $;GET IOB-OUT BITS
19m0136 05255 640702214575006103600000	        D[CONST 10] ROT[3] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $
19m0136                               	                ;GET CLR RCV RDY BIT
19m0136 05256 440700000571000440140000	CTYCO3: MAPF[TTY.WC] CYLEN[IOB-OUT] $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

19m0136 05257 640702200555000443600000	        ALU[Q] DEST[IOD] SPEC[IOB-OUT] NORM $;CLR IT
19m0136 05260 440700000571000440140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] $
19m0136 05261 640700044171000110000000	CTYCO4: D[CTY-CONT + 10] MASK[11] DEST[Q] NORM $; GET IOB-OUT BITS
19m0136 05262 510140050571000030000000	        D[CTY-STATUS + 10] MASK[3] COND[OBUS=0] JUMP[CTYCO5] C550 $
19m0136                               	                ; J IF NO PI CHAN
19m0136 05263 640700014175022020000000	        D[CONST 2] ROT[11] ALU[DORQ] DEST[Q] SHORT $; ENBL RCV INT
19m0136 05264 510140050571102020000000	        D[CTY-STATUS + 10] ROT[41] MASK[2] COND[OBUS=0] JUMP[CTYCO5] C550 $
19m0136                               	                ; J IF NO OUT FLAG OR BUSY
19m0136 05265 640700014175022040000000	        D[CONST 4] ROT[11] ALU[DORQ] DEST[Q] SHORT $;ENBL XMT INT
19m0136 05266 640702200555000443600000	CTYCO5: ALU[Q] DEST[IOD] SPEC[IOB-OUT] SHORT $; FIX INT ENBLS
19m0136 05267 440140200555000443142026	        MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[Q] DEST[CTY-CONT] DEST-A-MEM JUMP[MAIN] $
19m0136                               	; **** HERE IS DEFN. OF CTY UART CONSTANTS ****
19m0136                               	
19m0136 05270 640701614571000040000000	CTYRST: D[CONST 4] DEST[DEV-ADR] NORM $
19m0136 05271 640702414171014040000000	        D[CONST 4] ROT[6] DEST[Q CLR-DEV-FROM-INTR] NORM $
19m0136 05272 640700214175000743000000	        D[CONST 74] ALU[DORQ] DEST[Q CTY-CONT] DEST-A-MEM NORM $
19m0136 05273 640702214575014033600000	        D[CONST 3] ROT[6] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $; RESET UART
19m0136 05274 440700400615000443140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[0] DEST[CTY-STATUS] DEST-A-MEM $
19m0136 05275 640142200555000443600000	        ALU[Q] DEST[IOD] SPEC[IOB-OUT] NORM JUMP[CTYRS1] $
19m0136                               	    .USE[XLIST
19m0136                               	 LIST ] ;$*$*$*$ Temporary ****
19m0136                               	CTYRS1:
19m0136                               	;Setup entry vectors: IOT vector in left half, interrupt vector in right half   
19m0136 03566 440700014171060510140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] D[CONST (CTYDSP / 100)] ROT[18. + 6.] DEST[Q] $
19m0136                               	                ;High order 6 IOT bits
19m0136 03567 640700014175044000000000	        D[CONST (CTYDSP \ 100)] ROT[18.] ALU[DORQ] DEST[Q] NORM $
19m0136                               	                ;Low order 6 IOT bits
19m0136 03570 640700014175014210000000	        D[CONST (CTYINT / 100)] ROT[6.] ALU[DORQ] DEST[Q] NORM $
19m0136                               	                ;High order 6 interrupt bits
19m0136                               	        D[CONST (CTYINT \ 100)] ROT[0] ALU[DORQ]
19m0136 03571 640300014575000303000000	                        SPEC[DEST-A-MEM] DEST[CTY-DISP] POPJ NORM $
19m0136                               	                ;Low order 6 interrupt bits
19m0136                               	                ;Finish setting up vectors and return.
19m0136                               	
19m0136                               	AREA52: ;$*$*$* Recover what space may be left???
19m0136                               	
19m0136                               	;;;     .USE[AREA206]
19m0136                               	;;;     debuguse = .
19m0136                               	
19m0136                               	;;;:2074        ;%$#@#$% SLOEXP didn't redefine AREA206 properly??? $*$*$*$
19m0136                               	
19m0136                               	        .USE[19m0136                               	XLIST
19m0137                               	 LIST ]
19m0137                               	        .PAIR
19m0137                               	. \ 2 + .
19m0138 04472 530140000635000440002026	]CTYCZ: D[AR] ALU[D&Q] COND[-OBUS=0] JUMP[MAIN] C550 $
19m0138 04473 640164620433000440002027	        DOSKIP $
19m0138 04474 510140000635000440002026	CTYCS:  D[AR] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $
19m0138 04475 640164620433000440002027	        DOSKIP $
19m0138                               	
19m0138                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

20m0138                               	;$*$*$ This code should set up dispatch and interrupt vectors.  It will have to
20m0138                               	;      be moved to the end of regular disk stuff.  TVR-Apr80
20m0138 04476 640702200615000443600000	DSKRST: ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $
20m0138                               	          ;SET DSK CTRL COMMAND REGISTER TO 0 (DISABLES INTS).
20m0138                               	        MAPF[4] D[CONST 2] DEST[IOD] SPEC[IOB-OUT]
20m0138 04477 440702214571000023640000	                                CYLEN[IOB-OUT] $
20m0138                               	          ;NOW CLEAR THE STATE.
20m0138 04500 440300000571000440070000	        MAPF[7]  CYLEN[IOB-OUT]  POPJ $
20m0138                               	
20m0138                               	SET-DSK-OUT:
20m0138 04501 665141614571000100000000	        D[CONST 10] DEST[DEV-ADR] NORM COND[-USER] JUMP[SDSKO2] $
20m0138                               	        UIOTRP[20m0138 04502 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
20m0138                               	]$
20m0138                               	                ;Watch for IOT-USER mode.
20m0138 04503 640312204571000443600000	SDSKO2: D[MEM] DEST[IOD AR] SPEC[IOB-OUT] NORM POPJ $
20m0138                               	
20m0138                               	;Kludge to allow disk controller status IOTs from IOT-USER Mode.  This is
20m0138                               	;so a wizard can look at the state of the disk controller from MDDT (or UEDDT).
20m0138                               	UDSKST: UIOTRP[20m0138 04504 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
20m0138                               	]$
20m0138                               	                ;Ignore SPEC[IOB-IN] we just did and trap if in user mode.
20m0138 04505 000700034171024120000000	        D[IR] ROT[8 + 1 + 1] MASK[10.] DEST[Q] $
20m0138                               	                ;Extract opcode
20m0138 04506 000700014175000010000000	        D[CONST 1] ALU[DORQ] DEST[Q] $
20m0138                               	                ;Skip first micro instruction that got us here
20m0138 04507 540540014575022023400000	        D[CONST 2] ROT[9.] ALU[DORQ] SDISP CYLEN[DISP] SPEC[IOB-IN] $
20m0138                               	                ;Dispatch again to finish instruction
20m0138                               	
20m0138                               	;$*$*$ This code should set up dispatch and interrupt vectors.  It will have to
20m0138                               	;      be moved to the end of regular disk stuff.  TVR-Apr80
20m0138                               	TYMRST:         ;RESET TYMNET INTERFACE
20m0138 04510 640040014171000010000000	        D[CONST 1] DEST[Q] PUSHJ[DEV6CL] NORM $
20m0138                               	.REPEAT TYMNET [
20m0138                               	TYMNET
20m0138                               	.REPEAT 1 - tymnet [
20m0138 04511 640300000571000440000000	        POPJ NORM $
20m0138                               	] 1 - tymnet
20m0138                               	
20m0138                               	;$*$*$ This code should set up dispatch and interrupt vectors.  TVR-Apr80
20m0138                               	
20m0138                               	 .REPEAT OTP [
20m0138                               	;OTP
20m0138                               	
20m0138                               	 .REPEAT NTP [
20m0138                               	
20m0138                               	CLKRST:         ;Fall in to CLKCLR
20m0138 04512 640701614571000043600000	CLKCLR: START-OUT D[CONST 4] DEST[DEV-ADR] NORM $
20m0138                               	                ;Clear clk flag.
20m0138 04513 440702250571064442470000	CLKENB: MAPF[7] D[12] SPEC[A-MEM-APR] ROT[26.] DEST[IOD] C600 $
20m0138                               	                ;Get the APR conditions wd, put CLK INT ENB bit in bit 35.
20m0138 04514 640700000571000443600000	        START-OUT NORM $
20m0138 04515 440300000571000440060000	        MAPF[6] C600 POPJ $
20m0138                               	                ;SET OR CLEAR THE HARDWARE INTRPT. ENB. ACCORDING TO
20m0138                               	                ; STATE OF CLK INT ENB BIT IN APR 
20m0138                               	  ];NTP
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

20m0138                               	
20m0138                               	.REPEAT OTP [ 20m0138                               	;OTP
20m0138                               	
20m0138                               	;$*$*$*$* This should be moved to CFKNYD.SLO   TVR-Sep80
20m0138                               	  .REPEAT NTP [
20m0138                               	
20m0138                               	TAPRST:  ;RESET THE TAPE CONTROLLER.
20m0138 04516 640701614571000070000000	        D[CONST 7] DEST[DEV-ADR] NORM $ ;SELECT DEVICE.
20m0138 04517 000702200615000443600000	        START-OUT ALU[0]  DEST[IOD] $
20m0138                               	         ;Turn off "FORMATTER ENABLE"
20m0138 04520 000700000571000440020000	        MAPF[2] LONG $
20m0138                               	          ;Fall in to TIMRST.
20m0138                               	
20m0138 04521 640701614571000050000000	TIMRST: D[CONST 5] DEST[DEV-ADR] NORM $
20m0138 04522 640702214571000003600000	        START-OUT D[CONST TIMER] DEST[IOD] NORM $
20m0138                               	                ;Enable timer interrupts if TIMER is 1, else disable them.
20m0138 04523 440700200615000443100000	        MAPF[10] ALU[0] DEST[1] DEST-A-MEM C600 $
20m0138                               	                ;Clear pi channel
20m0138 04524 640300600615000443000000	        ALU[0] DEST[3] DEST-A-MEM NORM POPJ $
20m0138                               	                ;Clear timer reg.
20m0138                               	   ];NTP
20m0138                               	
20m0138                               	APRRST:
20m0138                               	.REPEAT F2SW [
20m0138 04525 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $   ;Clear Addr. Break
20m0138                               	]REPEAT F2SW
20m0138 04526 440300400615000442610000	        MAPF[1] ALU[0] DEST[APRSTS] SPEC[A-MEM-APR&DEST-A-MEM] CYLEN[IOB-OUT] POPJ $
20m0138                               	;$*$*$ This code should set up dispatch and interrupt vectors.  TVR-Apr80
20m0138                               	
20m0138 04527 640302400571000440000000	CLRDEVINT:         DEST[CLR-DEV-FROM-INTR] POPJ NORM $
20m0138                               	                ;CLEAR FLAG WHICH CAUSES DEV-ADR TO BE
20m0138                               	                ; ADR OF LAST INTERRUPTING DEVICE,
20m0138                               	                ; SO THE DEV-ADR REGISTER WILL WORK AGAIN.
20m0138                               	
20m0138                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

21m0138                               	;------------------------------------------------------------------------------
21m0138                               	;
21m0138                               	;       PI - Priority Interrupt Service                 Device 4
21m0138                               	;
21m0138                               	;------------------------------------------------------------------------------
21m0138                               	
21m0138                               	;PI SYSTEM USE OF APR AMEM---
21m0138                               	; 4     MEM PAR ERR(BIT 19), MEM PAR ERR INTRPT ENB(BIT 20),
21m0138                               	;        PI SYSTEM ON(BIT 28) CHN1-7 ON (BITS 29-35)
21m0138                               	; 5     WAITING RQ 1-7 (11-18)  IN PROG 1-7 (29-35)
21m0138                               	; 6     RQ COUNTS - 4-BIT FIELDS, CHN. 7 AT RIGHT END OF WORD.
21m0138                               	;
21m0138                               	;Other uses of APR AMEM are documented at the beginning 
21m0138                               	
21m0138                               	PI-GET-CHN:     ;MAKE BINARY CHN. NO. FROM MASK IN AR.
21m0138 04530 640710000571070440000000	        D[AR] ROT[34] DEST[AR] NORM $
21m0138                               	                ;PUT RQ 1 INTO BIT 1
21m0138 04531 640720014571000060000000	        D[CONST 6] DEST[MA] NORM $
21m0138                               	                ;MA WILL GET 7-CHN (FOR USE IN SHIFTING)
21m0138                               	PIL1:   D[AR] ROT[1] DEST[AR] C550
21m0138 04532 511150000571002440000000	           COND[OBUS<0] JUMP[PIGETMASK] $ ;FOUND FIRST BIT ?
21m0138 04533 640160024531000440004532	        D[MA] ALU[D-1] DEST[MA] NORM JUMP[PIL1] $
21m0138                               	                ;NO. DECREMENT COUNT AND LOOP.
21m0138 04534 640701224571000440000000	PIGETMASK:      D[MA] DEST[ROTR] NORM $ ;LOAD ROTATE AMT.
21m0138                               	        D[CONST 1] ROT[R] DEST[AR] NORM 
21m0138 04535 640310014571200010000000	          POPJ $        ;MAKE MASK OF FIRST BIT ONLY IN AR.
21m0138                               	
21m0138                               	
21m0138                               	PI-CHECK-RQS:    ;SEE IF IT IS TIME TO TAKE AN INTRPT.
21m0138                               	.REPEAT STANSW [        21m0138                               	.REPEAT STANSW
21m0138                               	.REPEAT 1 - STANSW [
21m0138                               	        D[15] SPEC[A-MEM-APR] ROT[18.] MASK[7] DEST[AR]
21m0138 04536 510150064571044072402026	          C550 COND[OBUS=0] JUMP[MAIN] $ ;ANY RQ'S ?
21m0138                               	].REPEAT 1 -STANSW
21m0138 04537 640041600615000440004530	        ALU[0] DEST[DEV-ADR] NORM PUSHJ[PI-GET-CHN] $
21m0138                               	                ;GET UNARY CHN NO. IN AR, SHIFT AMT. IN MA, ROTR
21m0138 04540 531140060571070440002026	        D[14] ROT[34] C550 COND[-OBUS<0] JUMP[MAIN] $
21m0138                               	                ;EXIT IF PI SYS NOT ON.
21m0138 04541 640700010171200070000000	        D[MASK 7] ROT[R] DEST[Q] NORM $
21m0138                               	                ;MASK OF CHN AND ALL HIGHER CHNS.
21m0138 04542 530140064635000440002026	        D[15] ALU[D&Q] C550 COND[-OBUS=0] JUMP[MAIN] $
21m0138                               	                ;EXIT IF THIS OR HIGHER CHN IN PROGRESS.
21m0138 04543 640700000171000440000000	        D[AR] DEST[Q] NORM $ ;MOVE UNARY CHN # TO Q.
21m0138 04544 510140060635000440002026	        D[14] ALU[D&Q] C550 COND[OBUS=0] JUMP[MAIN] $
21m0138                               	                ;EXIT IF CHN NOT ON.
21m0138 04545 640701224571004440000000	        D[MA] ROT[2] DEST[ROTR] NORM $
21m0138                               	                ;GET SHIFT AMT 4 TIMES LARGER, TO ACCESS CNT FIELD
21m0138 04546 640700014171200010000000	        D[CONST 1] ROT[R] DEST[Q] NORM $
21m0138                               	                ;A ONE ALIGNED WITH RQ CNT FIELD FOR THIS CHN.
21m0138 04547 640704470137000440000000	        D[16] ALU[D-Q] DEST[Q HOLD] NORM $
21m0138                               	                ;DECREMENT OUR WAITING RQ COUNT.
21m0138 04550 640700070335000440000000	        D[16] ALU[D#Q] DEST[Q] NORM $ ;DID WE OVERFLOW ?
21m0138 04551 530140014635200200004551	        D[CONST 20] ROT[R] ALU[D&Q] COND[-OBUS=0] C550 JUMP[.] $
21m0138                               	          ;LOOP HERE FOREVER IF WE OVERFLOWED 4-BIT CNT FIELD
21m0138 04552 640701404171000443000000	        D[MEM] DEST[6 Q] DEST-A-MEM NORM $
21m0138                               	                ;PUT BACK WORD OF RQ COUNTS.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

21m0138                               	        D[CONST 17] ROT[R] ALU[D&Q] C550
21m0138 04553 530140014635200170000000	          COND[-OBUS=0] JUMP[PIINTGO] $ ;JUMP IF OUR COUNT NEQ 0
21m0138 04554 640140000371044440000000	        D[AR] ROT[18.] ALU[NOTD] DEST[Q] NORM JUMP[PIL11] $
21m0138                               	                ;MASK FOR CLEARING THE WAITING RQ BIT.
21m0138 04555 640700014371000000000000	PIINTGO:        D[CONST 0] ALU[NOTD] DEST[Q] NORM $
21m0138                               	                ;DON'T CLEAR THE BIT, RQ'S STILL WAITING
21m0138 04556 640700064235000440000000	PIL11:  D[15] ALU[D&Q] DEST[Q] NORM $
21m0138                               	                ;GET STATUS B, EITHER DO OR DO NOT CLEAR RQ BIT
21m0138 04557 640701200575000443000000	        D[AR] ALU[DORQ] DEST[5] DEST-A-MEM NORM $
21m0138                               	                ;SET IN PROGRESS BIT, STORE STATUS B.
21m0138 04560 640710020171000440000000	        D[PC] DEST[Q AR] NORM $ ;GET PC INTO Q, AR.
21m0138 04561 640705410635076430000000	        D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $ ;CLR USR MODE
21m0138                               	
21m0138                               	;;;     D[MA] ROT[18.] ALU[DORQ] DEST[1] DEST-A-MEM NORM $
21m0138                               	;;; This is an obsolete bug trap -- DWP 9/80
21m0138                               	
21m0138                               	 ;; FOLLOWING INSTR. IS DEBUGGING AID
21m0138 04562 640700014171000560000000	        D[CONST 56] DEST[Q] NORM $
21m0138                               	                ;PREPARE TO CALC. INTRPT. ADDRESS.
21m0138 04563 640160024477002440002105	        D[MA] ROT[1] ALU[Q-D] DEST[MA] NORM JUMP[PIMUUO] $
21m0138                               	                ;FETCH INTRPT. INSTR AND GO INTERPRET IT.
21m0138                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

22m0138                               	PIGEN:   ;ENTER WITH CHN IN AR TO REQUEST INTRPT.
22m0138 04564 640041600615000440004527	        ALU[0] DEST[DEV-ADR] NORM PUSHJ[CLRDEVINT] $
22m0138 04565 640700060171000440000000	        D[14] DEST[Q] NORM $
22m0138                               	        D[CONST 1] ROT[18.] ALU[D+Q] DEST[4] DEST-A-MEM
22m0138 04566 640701014435044013000000	                NORM $
22m0138 04567 640700014171000070000000	        D[CONST 7] DEST[Q] NORM $
22m0138                               	                ;7-CHN IS AMT TO SHIFT BY FOR MASK BIT.
22m0138                               	        D[AR] MASK[3] ALU[Q-D] DEST[MA] NORM
22m0138 04570 640060000477000030004534	          PUSHJ[PIGETMASK] $ ;LOAD ROTR, FORM MASK IN AR
22m0138 04571 531140060571070440000000	PIGEN1: D[14] ROT[34] C550 COND[-OBUS<0] JUMP[PIGENWT] $
22m0138                               	                ;BRANCH IF PI SYS NOT ON.
22m0138 04572 640700010171200070000000	        MASK[7] D[2] ROT[R] DEST[Q] NORM $
22m0138                               	                ;MASK OF CHN AND ALL HIGHER CHNS.
22m0138 04573 530140064635000440000000	        D[15] ALU[D&Q] C550 COND[-OBUS=0] JUMP[PIGENWT] $
22m0138                               	                ;BRANCH IF THIS OR HIGHER CHN IN PROGRESS.
22m0138 04574 640700000171000440000000	        D[AR] DEST[Q] NORM $ ;MOVE UNARY CHN # TO Q.
22m0138 04575 530140060635000440004555	        D[14] ALU[D&Q] C550 COND[-OBUS=0] JUMP[PIINTGO] $
22m0138                               	                ;IF CHN ON, GO TAKE INTRPT.
22m0138                               	PIGENWT:          ;INTRPT CANNOT HAPPEN NOW, SO SET A WAITING RQ.
22m0138 04576 640701224571004440000000	        D[MA] ROT[2] DEST[ROTR] NORM $
22m0138                               	                ;GET SHIFT AMT 4 TIMES LARGER, TO GET CNT FIELD
22m0138 04577 640700014171200010000000	        D[CONST 1] ROT[R] DEST[Q] NORM $
22m0138                               	                ;A ONE ALIGNED WITH RQ CNT FIELD FOR THIS CHN.
22m0138 04600 640704470035000440000000	        D[16] ALU[D+Q] DEST[Q HOLD] NORM $
22m0138                               	                ;INCREMENT OUR WAITING RQ COUNT.
22m0138 04601 530140014635200100004603	        D[CONST 10] ROT[R] ALU[D&Q] COND[-OBUS=0] C550 JUMP[. + 2] $
22m0138                               	          ;DON'T LET COUNT GET HIGHER THAN 7.
22m0138 04602 640701404571000443000000	        D[MEM] DEST[6] DEST-A-MEM NORM $
22m0138                               	                ;PUT BACK WORD OF RQ COUNTS.
22m0138 04603 640700064171000440000000	        D[15] DEST[Q] NORM $
22m0138                               	                ;GET STATUS B.
22m0138                               	        D[AR] ROT[18.] ALU[DORQ] DEST[5] DEST-A-MEM
22m0138 04604 640141200575044443002026	           NORM JUMP[MAIN] $ ;SET WAITING RQ BIT.
22m0138                               	
22m0138                               	PI-DISMISS:
22m0138                               	        D[15] SPEC[A-MEM-APR] MASK[7] DEST[AR]
22m0138 04605 530050064571000072404530	          C550 COND[-OBUS=0] PUSHJ[PI-GET-CHN] $
22m0138 04606 640700064171000442400000	        D[15] SPEC[A-MEM-APR] DEST[Q] NORM $
22m0138                               	        D[AR] ALU[-D&Q] DEST[5] SPEC[A-MEM-APR&DEST-A-MEM]
22m0138 04607 640141200675000442604536	                NORM JUMP[PI-CHECK-RQS] $
22m0138                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

23m0138                               	PICONO:  ;Here from any CONO PI,
23m0138 04610 640710024571000070000000	        D[MA] MASK[7]  DEST[AR] NORM $
23m0138 04611 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
23m0138 04612 640700060171000440000000	        D[14]  DEST[Q] NORM $ ;GET STATUS A
23m0138 04613 531140024571052440000000	        D[MA] ROT[21.]  C550 COND[-OBUS<0] JUMP[PIL7] $
23m0138 04614 640700014175036010000000	        D[CONST 1] ROT[35. - 20.] ALU[DORQ] DEST[Q] NORM $ 
23m0138                               	         ; TURN ON PAR ERR INTRPT ENB.
23m0138 04615 531140024571050440000000	PIL7:   D[MA] ROT[20.]  C550 COND[-OBUS<0] JUMP[PIL8] $
23m0138 04616 640700014275036010000000	        D[CONST 1] ROT[35. - 20.] ALU[-D&Q] DEST[Q] NORM $ 
23m0138                               	         ;TURN OFF PAR ERR INT ENB
23m0138 04617 531140024571046440000000	PIL8:   D[MA] ROT[19.] C550 COND[-OBUS<0] JUMP[PIL9] $
23m0138 04620 640700014275040010000000	        D[CONST 1] ROT[35. - 19.] ALU[-D&Q] DEST[Q] NORM $ 
23m0138                               	         ;CLEAR MEM PAR ERR FLAG
23m0138 04621 513040024571012440000000	PIL9:   D[MA] ROT[5]  C550 COND[OBUS18] PUSHJ[PI-RESET] $
23m0138 04622 533140024571024440000000	        D[MA] ROT[12]  C550 COND[-OBUS18] JUMP[PIL3] $
23m0138 04623 640700014175016010000000	        D[CONST 1] ROT[7] ALU[DORQ] DEST[Q] NORM $ ; PI ON
23m0138 04624 533140024571022440000000	PIL3:   D[MA] ROT[11]  C550 COND[-OBUS18] JUMP[PIL4] $
23m0138 04625 640700014275016010000000	        D[CONST 1] ROT[7] ALU[-D&Q] DEST[Q] NORM $ ; PI OFF
23m0138 04626 533140024571016440000000	PIL4:   D[MA] ROT[7]  C550 COND[-OBUS18] JUMP[PIL5] $
23m0138 04627 640700000175000440000000	        D[AR] ALU[DORQ] DEST[Q] NORM $ ; CHNS ON
23m0138 04630 533140024571020440000000	PIL5:   D[MA] ROT[10]  C550 COND[-OBUS18] JUMP[PIL6] $
23m0138 04631 640700000275000440000000	        D[AR] ALU[-D&Q] DEST[Q] NORM $ ; CHNS OFF
23m0138 04632 640701000555000443000000	PIL6:   ALU[Q] DEST[4] DEST-A-MEM NORM $
23m0138 04633 533140024571014440004536	        D[MA] ROT[6]  C550 COND[-OBUS18] JUMP[PI-CHECK-RQS] $
23m0138 04634 640700000073000070000000	        D[AR] MASK[7] ALU[0-D] DEST[Q] NORM $
23m0138                               	                ;GENERATED INTRPTS REQUESTED. CHECK TO
23m0138                               	                ; MAKE SURE ONLY ONE CHN IS SPECIFIED.
23m0138 04635 640700000235000070000000	        D[AR] MASK[7] ALU[D&Q] DEST[Q] NORM $
23m0138                               	        D[AR] MASK[7] ALU[D-Q] C600
23m0138 04636 470140000537000070004636	          COND[-OBUS=0] JUMP[.] $ ;HANG HERE IF MORE THAN ONE.
23m0138 04637 640050000571000070004530	        D[AR] MASK[7]  DEST[AR] NORM PUSHJ[PI-GET-CHN] $
23m0138                               	                ;GET BINARY CHN. NUMBER AND UNARY MASK.
23m0138 04640 640140000571000440004571	        NORM JUMP[PIGEN1] $ ;GO GENERATE REQUEST.
23m0138                               	
23m0138                               	
23m0138                               	PICONISUB:
23m0138 04641 640700060171000222400000	        D[14] SPEC[A-MEM-APR] MASK[18.] DEST[Q] NORM $
23m0138                               	          ;GET SYS ON AND CHN ON BITS.
23m0138 04642 640710064571000102400000	        D[15] SPEC[A-MEM-APR] MASK[10] DEST[AR] NORM $
23m0138                               	          ;GET PI IN PROG BITS
23m0138 04643 640710000175020440000000	        D[AR] ROT[10] ALU[DORQ] DEST[AR Q] NORM $
23m0138 04644 640710064571044102400000	        D[15] SPEC[A-MEM-APR] ROT[18.] MASK[10] DEST[AR] NORM $
23m0138                               	          ;GET WAITING RQ BITS, AND RETURN IN LEFT HALF.
23m0138 04645 640310000175044440000000	        D[AR] ROT[18.] ALU[DORQ] DEST[AR Q] NORM POPJ $
23m0138                               	
23m0138                               	PI-RESET:
23m0138 04646 640701000615000442600000	        ALU[0] DEST[4] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
23m0138 04647 640701200615000442600000	        ALU[0] DEST[5] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
23m0138 04650 640301400215000442600000	        ALU[0] DEST[6 Q] SPEC[A-MEM-APR&DEST-A-MEM] NORM POPJ $
23m0138                               	
23m0138                               	;;;     ALU[0] DEST[1] SPEC[A-MEM-APR&DEST-A-MEM] NORM POPJ $
23m0138                               	;;; This is an obsolete bug trap -- DWP 9/80
23m0138                               	
23m0138                               	END-OF-PI-CODE:
23m0138                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

24m0138                               	;; MBOOT MOVED TO PAGE WITH REST OF TAPE STUFF
24m0138                               	
24m0138                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

25m0138                               	;MAPIOT MAPIO1 MAPCO0 MAPCOB MAPCOC MFT1 MFT1A MFT1D MFRD MFOTH MBLT3 SETHLF QORCRY
25m0138                               	 SETHFU BWRTA1 MBLT2 MAPCWT MAPCW1 MAPCW2
25m0138                               	;------------------------------------------------------------------------------
25m0138                               	;
25m0138                               	;       BBN Pager - Map CONO Dispatch Table
25m0138                               	;
25m0138                               	;*** What these things do should documented here.  It's hard enough to find it
25m0138                               	;*** elsewhere!  TVR-Apr80
25m0138                               	;
25m0138                               	;       This code is all BBN dependent.  It will be replaced for other pagers.
25m0138                               	;
25m0138                               	;------------------------------------------------------------------------------
25m0138                               	
25m0138                               	        .ORG[XLIST
25m0138                               	 LIST ];$*$*$ This should be fixed
25m0138                               	
25m0138 05200 640140000571000440000000	        JUMP[MAPCO0] NORM $               ;CONO 0
25m0138 05201 640145000571000440000000	        DEST[CLR-MAP] JUMP[MAPCO1] NORM $ ;CONO 1 -- START MAP CLEARING
25m0138 05202 640150020171000440002125	        UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$                               ;CONO 2
25m0138                               	 -- Ill. Instruction
25m0138 05203 640145000571000440000000	        DEST[CLR-MAP] JUMP[MAPCO1] NORM $ ;CONO 3 -- START MAP CLR
25m0138 05204 640141614571000010000000	        D[CONST 1] DEST[DEV-ADR] JUMP[MAPCO4] NORM $; CONO 4
25m0138 05205 640141614571000010000000	        D[CONST 1] DEST[DEV-ADR] JUMP[MAPCO4] NORM $; CONO 5
25m0138 05206 640140000571000440000000	        JUMP[MAPCO6] NORM $               ;CONO 6
25m0138 05207 640145000571000440000000	        DEST[CLR-MAP] JUMP[MAPCO7] NORM $ ;CONO 7
25m0138                               	
25m0138                               	        .USE[25m0138                               	XLIST
25m0139                               	 LIST ]                 ;$*$*$  This is truely silly.  The CTY code appears
25m0139                               	                        ;       after the map dispatch and the map code
25m0139                               	                        ;       after the CTY dispatch!
25m0139                               	        .PAIR
25m0139                               	. \ 2 + .
25m0140                               	]       UIOTRP[25m0140 05140 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
25m0140                               	]$
25m0140 05141 531140034571022440002026	MAPIOT: D[IR] ROT[9.] COND[-OBUS<0] JUMP[MAIN] C550 $ ;NOP IF DEV. 20
25m0140 05142 510140014735000140000000	        D[CONST 14] ALU[D#Q] COND[OBUS=0] JUMP[MAPIO1] C550 $; IS IT CONO ?
25m0140 05143 510140014735000130000000	        D[CONST 13] ALU[D#Q] COND[OBUS=0] JUMP[MAPDO] C550 $; NO IS IT DATAO?
25m0140                               	        ILGIOT 25m0140 05144 000140000571000440002026	 JUMP [MAIN] ]$   ;ELSE ILLEGAL
25m0140 05145 640700034171000030000000	MAPIO1: D[IR] MASK[3] DEST[Q] NORM $
25m0140 05146 440540014575014520000000	        D[CONST 52] ROT[6] ALU[DORQ] SDISP C600 $
25m0140 05147 640041614571000010000000	MAPCO0: D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $
25m0140 05150 640700050171000440000000	        D[12] DEST[Q] NORM $; GET SIGN BIT = ENBL FOR EXEC 0-77777
25m0140 05151 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
25m0140 05152 640702234571000023600000	        D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] SHORT $
25m0140 05153 440745014571000200100000	        MAPF[10] CYLEN[IOB-OUT] DEST[CLR-MAP] D[CONST 20] LLOAD $; TURN OFF MAPPING &
25m0140                               	 START CLEARING MAP
25m0140 05154 500240000571000440005154	        LOOP [.] C550 $  ;WAIT FOR MAP CLR TO FINISH -- OTHERWISE THE
25m0140                               	                ; READS OF 71 AND 72 BELOW DON'T HAPPEN (ON F2 #1).
25m0140 05155 640720014571000710000000	        D[CONST 71] DEST[MA] SHORT $; FETCH MAGIC LOC
25m0140 05156 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] CYLEN[FIXM]  $; WAIT FOR DATA
25m0140 05157 640710004571000130000000	        D[MEM] MASK[13] DEST[AR] SHORT $
25m0140 05160 640701000571022443000000	        D[AR] ROT[11] DEST-A-MEM DEST[4] NORM $; MBR
25m0140 05161 640710004571044130000000	        D[MEM] ROT[18.] MASK[13] DEST[AR] SHORT $
25m0140 05162 640700200571022443000000	        D[AR] ROT[11] DEST-A-MEM DEST[1] NORM $; UBR
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

25m0140                               	.REPEAT 1 - WAITS [
25m0140 05163 640710004571056050000000	        D[MEM] ROT[27] MASK[5] DEST[AR] SHORT $
25m0140 05164 640700600571010443000000	        D[AR] ROT[4] DEST-A-MEM DEST[3] NORM $; AC BASE REG
25m0140                               	].REPEAT 1 - WAITS
25m0140 05165 450150004473016030000000	        D[MEM] ROT[7] MASK[3] ALU[0-D] DEST[AR] COND[OBUS=0] JUMP[MAPCOB] C600 $; ADDRS
25m0140                               	 LIMIT, J IF 0
25m0140 05166 640710000571000030000000	        D[AR] MASK[3] DEST[AR] SHORT $
25m0140 05167 640150000571034440000000	        D[AR] ROT[16] DEST[AR] JUMP[MAPCOC] NORM $; FORM SMALLEST ILLEGAL ADDRESS
25m0140 05170 640710014571034200000000	MAPCOB: D[CONST 20] ROT[16] DEST[AR] SHORT $
25m0140 05171 640700014235106010000000	MAPCOC: D[CONST 1] ROT[43] ALU[D&Q] DEST[Q] SHORT $; GET SIGN BIT = ENBL FOR EXEC 0-77777
25m0140                               	
25m0140 05172 640710400575000443000000	        D[AR] ALU[DORQ] DEST-A-MEM DEST[AR 2] NORM $; ADDRS LIMIT
25m0140                               	.REPEAT WAITS [
25m0140                               	.REPEAT WAITS
25m0140 05173 640720014571000720000000	        D[CONST 72] DEST[MA] SHORT $; GET NEXT WORD
25m0140 05174 000700004171000440000000	        D[MEM] DEST[Q] LONG $   ;LONG to wait for data to arrive.
25m0140 05175 640141214675064013000000	        D[CONST 1] ROT[32] ALU[-D&Q] DEST-A-MEM DEST[5] JUMP[MAPCOE] NORM $; AGE &
25m0140                               	 PROCESS BITS
25m0140                               	
25m0140                               	;------------------------------------------------------------------------------
25m0140                               	;
25m0140                               	;       MAP FAULT DISPATCHES COME HERE (6100 + MAPF*4 )
25m0140                               	;
25m0140                               	;       MAP traps happen on next micro instruction after a MEMSTO or STRT-WRT.
25m0140                               	;       They also happen after micro instruction containing a DEST[FIXMAC...],
25m0140                               	;       as in FIXM1 for example.  The trap happens by forcing an unconditional
25m0140                               	;       jump to an address determined by MAP-DISP register and the MAPF of
25m0140                               	;       field of the failing micro instruction.  Otherwise, that micro
25m0140                               	;       instruction is executed normally.
25m0140                               	;       
25m0140                               	;       This code should be the same for all kinds of maps.  However, it will
25m0140                               	;       be necessary to define symbolically the trap code, i.e. the thing that
25m0140                               	;       is usually being loaded left half of Q.  After doing that, and updating
25m0140                               	;       necessary state of PC and flags, the code leave by jumping to MFT1B,
25m0140                               	;       the map dependent page fault/page fill code, with fault code in Q and
25m0140                               	;       failing address in the MA.
25m0140                               	;
25m0140                               	; ***   As you will notice, there are NO spare trap codes.  If you need one,
25m0140                               	; ***   talk to me about a scheme for fixing this and improving page fault
25m0140                               	; ***   recovery.  TVR-Apr80
25m0140                               	;
25m0140                               	;------------------------------------------------------------------------------
25m0140                               	        .ORG[XLIST
25m0140                               	 LIST ];Fixed by hardware to xx100
25m0140 06100 000140000571000440006100	        JUMP[.] $   ;ILLEGAL MAP FAULT -- MICROCODE BUG IF YOU GET HERE
25m0140                               	.REPEAT XUCODE [
25m0140                               	:16100  ;copy for high mem
25m0140 16100 000140000571000440006100	        JUMP[6100] $
25m0140                               	]XUCODE
25m0140                               	        ;**** Consider looking at STOP switch in the future.    TVR - Mar80
25m0140                               	        ;
25m0140                               	        ;To find out non-destructively how you lost, start at 2003 (on an F2)
25m0140                               	        ;you will be stopped at PC+1, assuming you lose trying to display
25m0140                               	        ;that instruction in the lights (i.e. (PC) not mapped in)
25m0140                               	        ;
25m0140                               	        ;You can get here by examining/depositing a location in the
25m0140                               	        ;hardware map (i.e. it may only be asking for a page-fill cycle).
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

25m0140                               	: 6104  ;EXECUTE (&INDIRECT) FAULTS HERE
25m0140 06104 640700014171044020000000	MFT1:   D[CONST 2] ROT[18.] DEST[Q] NORM $; CODE FOR EXECUTE
25m0140 06105 640701614571000010000000	MFT1A:  D[CONST 1] DEST[DEV-ADR] NORM $
25m0140 06106 640702400571000443400000	MFT1D:  DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
25m0140 06107 140150230571000030040000	        D[IOD] MASK[3] DEST[AR IR-ADR] JUMP[MFT1B] MAPF[4] CYLEN[IOB-IN] $
25m0140                               	: 6110  ;NORMAL READ FAULT
25m0140 06110 640700014171044100000000	MFRD:   D[CONST 10] ROT[18.] DEST[Q] NORM $;CODE FOR RD
25m0140 06111 640144620531000440006105	MFOTH:  D[PC] ALU[D-1] DEST[PC] JUMP[MFT1A] NORM $
25m0140                               	.REPEAT XUCODE [
25m0140                               	:16110  ;NORMAL READ FAULT -High mem duplicate instr.
25m0140 16110 640700014171044100000000	        D[CONST 10] ROT[18.] DEST[Q] NORM $;CODE FOR RD
25m0140                               	]XUCODE
25m0140                               	: 6114  ;RMW HERE, DECREMENTS PC
25m0140 06114 640140014171044140006111	        D[CONST 14] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $
25m0140                               	.REPEAT XUCODE [
25m0140                               	:16114  ;RMW -High mem duplicate instr.
25m0140 16114 640140014171044140006111	        D[CONST 14] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $
25m0140                               	]XUCODE
25m0140                               	: 6120  ;WRITES (NORMAL) HERE (NO DECREMENT PC)
25m0140 06120 640702414171044040000000	        D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $
25m0140 06121 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
25m0140 06122 640701600571000443000000	        D[AR] DEST-A-MEM DEST[7] NORM $;SAVE STORE DATA
25m0140 06123 640160034571000220006106	        D[IR] MASK[18.] DEST[MA] NORM JUMP[MFT1D] $; RESTORE MA
25m0140                               	.REPEAT XUCODE * VID [
25m0140                               	XUCODE * VID
25m0140                               	: 6124 ; 5-- BLT-RD
25m0140 06124 640704621171000220000000	        D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC] NORM $; RESTORE PC & DEST ADR
25m0140 06125 640700014171044100000000	        D[CONST 10] ROT[18.] DEST[Q] SHORT $; CODE FOR RD
25m0140 06126 640140001561044000206111	MBLT3:  D[AR] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC] JUMP[MFOTH] NORM $; GET
25m0140                               	 SRC ADR
25m0140                               	.REPEAT XUCODE * VID [
25m0140                               	XUCODE * VID
25m0140                               	: 6130 ;6-- BLT-WRT
25m0140 06130 640724621171000220600000	        D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC MA] SPEC[MA_PC] NORM $; RESTORE PC, GET
25m0140                               	 DEST ADR
25m0140 06131 640710000455000440000000	        ALU[Q-1] DEST[AR] NORM $;  ADJUST SRC ADR
25m0140 06132 640140014171044040006126	        D[CONST 4] ROT[18.] DEST[Q] JUMP[MBLT3] NORM $; CODE FOR WRT
25m0140                               	: 6134 ;7-- BLT-RDA
25m0140 06134 640700001571000440000000	        ACSEL[AC] D[AR] DEST[AC] NORM $; NEW DEST ADR
25m0140 06135 640140014171044100006111	        D[CONST 10] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $; CODE FOR RD
25m0140                               	: 6140 ; 10-- BLT-WRTA
25m0140 06140 640702414171044040000000	        D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; CODE FOR WRT
25m0140 06141 640040024171000220000000	        D[MA] MASK[18.] DEST[Q] PUSHJ[BWRTA1] NORM $; GET MA, SAVE STORE DAT
25m0140 06142 510140000735000220000000	        D[AR] MASK[18.] ALU[D#Q] COND[OBUS=0] JUMP[MBLT2] C550 $
25m0140 06143 640160000055000440000000	        ALU[Q-1] DEST[Q MA] JUMP[MBLT2] NORM $; CORRECT MA
25m0140                               	: 6144 ;11-- BYTE-ILD
25m0140 06144 640040000571000440000000	        PUSHJ[SETHLF] NORM $; SET HALF
25m0140 06145 640140000571000440006110	        JUMP[6110] NORM $; NORMAL READ
25m0140                               	;Page fault in the middle of a interruptable instruction.  Set HALF (BIS)
25m0140                               	;flag as part of page fault processing so that instruction gets restarts in
25m0140                               	;the proper way.
25m0140 06146 645140014171074020000000	SETHLF: D[CONST 2] ROT[36] DEST[Q] COND[USER] JUMP[SETHFU] NORM $;BIT 4--HALF
25m0140                               	                ;Get ready to set HALF (BIS) flag.
25m0140                               	                ;Watch for special case of User page fault from Exec. TVR-May80
25m0140 06147 640305420575000440000000	QORCRY: D[PC] ALU[DORQ] DEST[CRYOV] POPJ NORM $;SET HALF
25m0140                               	: 6150 ;12 -- BYTE-IDP
25m0140 06150 640040000571000440006146	        PUSHJ[SETHLF] NORM $; SET HALF
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

25m0140 06151 640140000571000440006114	        JUMP[6114] NORM $;NORMAL RMW
25m0140                               	;When a DEST[CRYOV] is done, the EXEC shift register is cleared (set) to
25m0140                               	;whatever the user bit in the new CRYOV is.  This destroys the information
25m0140                               	;about which space a page fault came from on XCTR (XCT mapped) instruction.
25m0140                               	;We turn it on explicitly here.  Note that since a user cannot do a XCTR,
25m0140                               	;we only have to worry about the case of being in EXEC mode and getting a
25m0140                               	;user mode page fault.  TVR-May80
25m0140 06152 640705420575000440000000	SETHFU: D[PC] ALU[DORQ] DEST[CRYOV] NORM $
25m0140                               	                ;Set the half flag.
25m0140                               	                ;Don't return yet, we need to reset EXEC-SR
25m0140 06153 640305614571022170000000	        SET-TEMP-USER POPJ $
25m0140                               	                ;Remember that the page fault was from a user page!!
25m0140                               	: 6154 ;13 -- BYTE-IND
25m0140 06154 640040000571000440006146	        PUSHJ[SETHLF] NORM $; SET HALF
25m0140 06155 640140000571000440006104	        JUMP[6104] NORM $; NORMAL INDIRECT
25m0140                               	: 6160 ;BLT-WRTB -- XCT MAPPED BLT STORES
25m0140 06160 640702414171044040000000	        D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; CODE FOR WRT
25m0140 06161 640040024171000220000000	        D[MA] MASK[18.] DEST[Q] PUSHJ[BWRTA1] NORM $; GET MA, SAVE STORE DAT
25m0140 06162 640700014171044040000000	        D[CONST 4] ROT[18.] DEST[Q] NORM $
25m0140 06163 640140001571000440006111	        D[AR] ACSEL[AC] DEST[AC] JUMP[MFOTH] NORM $; RESTORE AC
25m0140                               	: 6164 ;-- MAPFTR -- TRAP WHIILE FETCHING JSYS TARGET
25m0140 06164 640702414171044500000000	        D[CONST 50] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; PI CODE
25m0140 06165 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
25m0140 06166 640141600571000443006111	        D[AR] DEST-A-MEM DEST[7] JUMP[MFOTH] NORM $
25m0140                               	: 6170 ;PPOP-- 16 -- POP & POPJ FETCH- RE-INCR PDL PNTR -- THEN LIKE READ FAULT
25m0140 06170 640140015421001000006110	        D[CONST 1,,1] ACSEL[AC] ALU[D+AC] DEST[AC] JUMP[MFRD] NORM $
25m0140                               	: 6174 ;17-- WRITES WITH RELEVANT ADRS IN MA (NO DECR PC)
25m0140 06174 640702414171044040000000	        D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $
25m0140 06175 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $
25m0140 06176 640141604571000443006106	        D[MEM] DEST-A-MEM DEST[7] JUMP[MFT1D] NORM $;SAVE STORE DATA
25m0140 06177 640701614571000010000000	BWRTA1: D[CONST 1] DEST[DEV-ADR] NORM $
25m0140 06200 640301604571000443000000	        D[MEM] DEST-A-MEM DEST[7] POPJ NORM $
25m0140 06201 640700000077000220000000	MBLT2:  D[AR] MASK[18.] ALU[Q-D] DEST[Q] SHORT $; COUNT HOW MANY WORDS MOVED
25m0140 06202 640710000435044440000000	        D[AR] ROT[18.] ALU[Q+D] DEST[AR] SHORT $;FORM NEW SRC
25m0140 06203 640700025571000220000000	        ACSEL[AC] D[MA] MASK[18.] DEST[AC] SHORT $;NEW DEST
25m0140 06204 640700014171044040000000	        D[CONST 4] ROT[18.] DEST[Q] NORM $
25m0140 06205 640140001561044000206111	        D[AR] ACSEL[AC] ROT[18.] SPEC[LEFT] ALU[DORAC] DEST[AC] JUMP[MFOTH] NORM $; OR IN
25m0140                               	 NEW SRC
25m0140                               	
25m0140       6206	OTHER = .       ;$*$*$ This is the end of the fix areas, In'Sh'Allah  TVR-Apr80
25m0140                               	
25m0140                               	: 5340  ;$*$*$ The APR dispatch ends at 5340.
25m0140                               	
25m0140                               	;*$*$* Fudge area accounting
25m0140       5340	AREA53 = .
25m0140                               	        .USE[25m0140                               	XLIST
25m0141                               	 LIST ]
25m0141 05340 640740000555000440000000	MAPCWT: ALU[Q] LLOAD NORM $
25m0141 05341 000240000571000440005341	        LOOP[.] CYLEN[LONG] $; WAIT FOR MAP TO CLEAR
25m0141 05342 640702214571000043600000	        D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $;TURN ON MAP
25m0141 05343 151140000571000440100000	        MAPF[10] D[AR] COND[OBUS<0] JUMP[MAPCW9] CYLEN[MAX,IOB-OUT,C550] $; J IF WHOLE
25m0141                               	 MAP ON (INCLUDING EXEC 0-77777)- DONE
25m0141 05344 640740014571000770100000	MAPCW1: D[CONST 77]  MAPF[10] LLOAD NORM $
25m0141 05345 640710020571000440000000	MAPCW2: D[PC]  DEST[AR] SHORT $;SAVE FLAGS
25m0141 05346 640725400615000440000000	        ALU[0] DEST[MA CRYOV] SHORT $;INIT MA, SET EXEC
25m0141 05347 640700014171014100000000	        D[CONST 10] ROT[6]  DEST[Q] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

25m0141                               	
25m0141                               	 .REPEAT NEWMAP [
25m0141                               	; NEWMAP
25m0141                               	
25m0141                               	 .REPEAT 1 - NEWMAP [
25m0141 05350 640705224571000220000000	        D[MA] MASK[18.] DEST[STO-MAP] NORM $;SET FIRST PART OF EXEC MAP TO POINT TO "NULL
25m0141                               	 MAP" LOCS(UNMAPPED)
25m0141 05351 640260024435000440005350	        D[MA] ALU[D+Q] DEST[MA] LOOP[. - 1] NORM $;LOOP
25m0141                               	  ]; 1 - NEWMAP
25m0141                               	
25m0141 05352 640702234571000033600000	        D[IR] MASK[3]  DEST[IOD] SPEC[IOB-OUT] SHORT $; RESTORE MAP
25m0141 05353 440145400571000440102026	        D[AR]  DEST[CRYOV] JUMP[MAIN] MAPF[10] CYLEN[IOB-OUT] $; RESTORE FLAGS, DONE
25m0141                               	;------------------------------------------------------------------------------
25m0141                               	;       End map trap code which is common to all maps.
25m0141                               	;------------------------------------------------------------------------------
25m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

26m0141                               	;MAPCOA MAPCOE MAPCO1 MAPCOG MAPCO4 MPOFF1 MAPOFF MAPCO6 MAPCO7 MAPCW9 MAPDO MFUS MFA3
26m0141                               	 MFA7 MFA6 MFA4 MFT1B MFHIEX MFA1 MFA2 MFB3 MFTYP1 MFTYP0
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	;       BBN MAP CONO, continued
26m0141                               	;
26m0141                               	;       This code will need to be rewritten for another kind of map.
26m0141                               	;
26m0141                               	;------------------------------------------------------------------------------
26m0141 05354 640702400571000443400000	MAPCOA: DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
26m0141 05355 140300230571000030040000	        D[IOD]  MASK[3] DEST[IR-ADR] MAPF[4] POPJ CYLEN[IOB-IN] $;GET MAP, ECC & OV ENBL
26m0141                               	 BITS
26m0141 05356 640701600615000440000000	MAPCOE: ALU[0] DEST[DEV-ADR] SHORT $
26m0141 05357 640702234571000033600000	        D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE MAP STATE
26m0141 05360 440140014171000010105340	        MAPF[10] D[CONST 1] DEST[Q] JUMP[MAPCWT] CYLEN[IOB-OUT] $
26m0141 05361 640041614571000010005354	MAPCO1: D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $;GET ENABLE BITS IN IR
26m0141 05362 640710050571000440000000	        D[12] DEST[AR] NORM $; GET SIGN BIT = ENBL EXEC 0-77777
26m0141 05363 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
26m0141 05364 640140014171000050005340	        D[CONST 5] DEST[Q] JUMP[MAPCWT] NORM $
26m0141 05365 640701614571000010000000	MAPCOG: D[CONST 1] DEST[DEV-ADR] NORM $
26m0141 05366 640700050171000430000000	        D[12] MASK[43] DEST[Q] NORM $
26m0141 05367 640710034571000010000000	        D[IR] MASK[1] DEST[AR] SHORT $;GET LOW BIT OF CONO
26m0141 05370 640700400575106443000000	        D[AR] ROT[43] ALU[DORQ] DEST-A-MEM DEST[2] NORM $;GET SIGN BIT = EXEC 0-77777 MAP
26m0141                               	 ENBL
26m0141 05371 640700000571000443400000	        SPEC[IOB-IN] SHORT $
26m0141 05372 140700030171000030040000	        MAPF[4] D[IOD] MASK[3] DEST[Q] CYLEN[IOB-IN] $
26m0141 05373 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
26m0141 05374 640702214575000043600000	        D[CONST 4] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] SHORT $
26m0141 05375 440300214575000040100000	        D[CONST 4] ALU[DORQ] DEST[IR-ADR] MAPF[10] POPJ CYLEN[IOB-OUT] $;TURN ON MAP
26m0141 05376 640042400571000443400000	MAPCO4: DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] NORM PUSHJ[MAPOFF] $
26m0141                               	
26m0141 05377 440140000571000440102026	MPOFF1: MAPF[10] CYLEN[IOB-OUT] JUMP[MAIN] $; DONE
26m0141 05400 140700230571000030040000	MAPOFF: D[IOD] MASK[3] DEST[IR-ADR] MAPF[4] CYLEN[IOB-IN] $
26m0141 05401 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
26m0141 05402 640302234571000023600000	        D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM POPJ $
26m0141                               	
26m0141 05403 640042400571000440005365	MAPCO6: DEST[CLR-DEV-FROM-INTR] PUSHJ[MAPCOG] NORM $
26m0141 05404 640140000571000440005344	        JUMP[MAPCW1] NORM $
26m0141 05405 000042400571000440005365	MAPCO7: DEST[CLR-DEV-FROM-INTR] PUSHJ[MAPCOG] CYLEN[LONG] $
26m0141 05406 000700000571000440000000	        CYLEN[LONG] $; WAIT FOR MAP TO CLEAR
26m0141 05407 000700000571000440000000	        CYLEN[LONG] $
26m0141 05410 640740000615000440000000	MAPCW9: ALU[0] LLOAD NORM $; SET UP ONLY PAGE 0
26m0141 05411 640140000571000440005345	        JUMP[MAPCW2] NORM $
26m0141                               	
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	;DATAO CLEARS THE "ASSOCIATIVE" REGISTER MAPPING THE ADDRESS OF THE DATAO
26m0141                               	; THIS REPLACES CONO 2.
26m0141                               	;------------------------------------------------------------------------------
26m0141 05412 640041614571000010005354	MAPDO:  D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $;GET MAP BITS
26m0141                               	 .REPEAT 1 - NEWMAP [ 26m0141 05413 640701600615000440000000	ALU[0] DEST[DEV-ADR] NORM $ ]   D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $;TURN ON MAP
26m0141 05414 640702214571000043600000	
26m0141 05415 440700000571000440100000	        MAPF[10] CYLEN[IOB-OUT] $
26m0141                               	 .REPEAT NEWMAP [
26m0141                               	
26m0141                               	 .REPEAT 1 - NEWMAP [
26m0141 05416 640705214571064010000000	        D[CONST 1] ROT[32] DEST[STO-MAP] NORM $ ]         ;CLR MAP ENTRY ASSOCIATED WITH
26m0141                               	 MA
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

26m0141 05417 240702234571000033600000	        D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] C800 $; RESTORE ENABLES
26m0141 05420 440140000571000440102026	        MAPF[10] CYLEN[IOB-OUT] JUMP[MAIN] $
26m0141                               	
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	;
26m0141                               	;       BBN MAP - Handle map trap and page fill cycles.
26m0141                               	;
26m0141                               	;       This code will need to be rewritten for another kind of map.
26m0141                               	;
26m0141                               	;------------------------------------------------------------------------------
26m0141 05421 640700050171000400000000	MFUS:   D[12] MASK[40] DEST[Q] NORM $;GET LIMIT REG
26m0141 05422 471140024537000440000000	        D[MA] ALU[D-Q] COND[-OBUS<0] JUMP[MTRPAL] C600 $;J IF MA PAST ADDRS LIMIT
26m0141 05423 640140044171000440000000	        D[11] DEST[Q] JUMP[MFA1] NORM $;GET USER BASE REG.
26m0141                               	
26m0141 05424 530140004571024010000000	MFA3:   D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFA4] C550 $ ;J IF MODIF. BIT ON
26m0141 05425 640700600571000440000000	MFA7:   D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
26m0141 05426 640701400571000443000000	        D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
26m0141 05427 640710014575056010000000	        D[CONST 1] ROT[27] ALU[DORQ] DEST[AR] SHORT $; TURN ON WRT-PREVENT, SAVE NEW MAP
26m0141                               	 WORD
26m0141 05430 640140004171000330000000	MFA6:   D[MEM] MASK[33] DEST[Q] JUMP[MFA5] NORM $; GET CST ENTRY, GO DO
26m0141 05431 510140034571054010005425	MFA4:   D[IR] ROT[26] MASK[1] COND[OBUS=0] JUMP[MFA7] C550 $; J IF NO WRT-PERMIT
26m0141 05432 640700600571000440000000	        D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
26m0141 05433 640701400571000443000000	        D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
26m0141 05434 640150010635060430005430	        D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] JUMP[MFA6] NORM $; CLEAR WRT-PREVENT
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	; Enter here with fault code in Q and address in MA to handle page fault or
26m0141                               	; page fill cycle.  MAP-EXEC-SR (i.e. USER condition) is still undisturbed.
26m0141                               	;------------------------------------------------------------------------------
26m0141 05435 645150024575000220005421	MFT1B:  D[MA] MASK[18.] ALU[DORQ] DEST[AR] COND[USER] JUMP[MFUS] NORM $;GET FAILED ADDRS,
26m0141                               	 J IF USER
26m0141 05436 640700024171050020000000	        D[MA] ROT[24] MASK[2] DEST[Q] NORM $; HIGH ORDER 2 BITS
26m0141 05437 450140014537000030000000	        D[CONST 3] ALU[D-Q] COND[OBUS=0] JUMP[MFHIEX] C600 $; J IF PRIVATELY MAPPED PART
26m0141                               	
26m0141 05440 640140014171014300000000	        D[CONST 30] ROT[6] DEST[Q] JUMP[MFA1] NORM $; PAGE TAB @ 3000
26m0141 05441 640700060171000440000000	MFHIEX: D[14] DEST[Q] NORM $
26m0141 05442 640701600615000440000000	MFA1:   ALU[0] DEST[DEV-ADR] NORM $
26m0141 05443 640702234571000023600000	        D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM $ ;CLEAR MAPPING
26m0141 05444 440701634571000033100000	        D[IR] MASK[3] DEST-A-MEM DEST[APRENB] MAPF[10] CYLEN[IOB-OUT] $
26m0141                               	                ;SAVE AR, ECC INT
26m0141 05445 640722624435066110000000	        D[MA] ROT[33] MASK[11] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE ENTRY
26m0141                               	
26m0141 05446 640700214571030160000000	        D[CONST 16] ROT[14] DEST[IR-ADR] NORM $; PREPARE INITIAL PERMIT BITS
26m0141 05447 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
26m0141 05450 640700014171000030000000	MFA2:   D[CONST 3] DEST[Q] CYLEN[FIXM] $; DON'T CLEAR IND PNTR. COUNT, WAIT FOR FETCH
26m0141 05451 640700004175044440000000	        D[MEM] ROT[18.] ALU[DORQ] DEST[Q] CYLEN[FIXM+1] $;GET PERMIT BITS
26m0141 05452 640700234635000440000000	        D[IR] ALU[D&Q] DEST[IR-ADR] SHORT $; AND THEM IN
26m0141 05453 530140004571026030000000	        D[MEM] ROT[13] MASK[3] COND[-OBUS=0] JUMP[MFTR1] C550 $; CHECK FOR TRAP BITS
26m0141 05454 510140004571032010000000	MFB3:   D[MEM] ROT[15] MASK[1] COND[OBUS=0] JUMP[MFTR2] C550 $; J IF NO ACCESS PERMIT
26m0141 05455 510140004171004020000000	        D[MEM] ROT[2] MASK[2] DEST[Q] COND[OBUS=0] JUMP[MFTYP0] C550 $; GET TYPE CODE, J
26m0141                               	 IF 0
26m0141 05456 510140000055000440000000	        ALU[Q-1] DEST[Q] COND[OBUS=0] JUMP[MFTYP1] C550 $; J IF 1
26m0141 05457 530140000055000440000000	        ALU[Q-1] DEST[Q] COND[-OBUS=0] JUMP[MFTR3] C550 $; J IF NOT 2
26m0141 05460 530140034571106010000000	        D[IR] ROT[43] MASK[1] COND[-OBUS=0] JUMP[MFTR41] C550 $; TYPE 2, J IF >2 INDR.
26m0141                               	 PNTRS
26m0141 05461 640700234433000440000000	        D[IR] ALU[D+1] DEST[IR-ADR] SHORT $; COUNT IND. PNTRS
26m0141 05462 640700004171066150000000	        D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET PAGE TABLE #
26m0141 05463 640701404571000443000000	        D[MEM] DEST-A-MEM DEST[6] NORM $; SAVE PNTR
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

26m0141 05464 640722614435030020000000	        D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE PNTR
26m0141 05465 640700070171000110000000	        D[16] MASK[11] DEST[Q] CYLEN[FIXM] $; GET PAGE #, WAIT FOR MEM
26m0141 05466 530140004571044040000000	        D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR4] C550 $; PAGE OUT-OF-CORE?
26m0141 05467 640704404571000130000000	        D[MEM] MASK[13] DEST[HOLD] NORM $
26m0141 05470 640162604575022440005450	        D[MEM] ROT[11] ALU[DORQ] DEST[MA HI-ABS-MA] JUMP[MFA2] NORM $; LOOP
26m0141 05471 640700004171066150000000	MFTYP1: D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET SHARED PAGE #
26m0141 05472 640722614435030020000000	        D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH SHARED PNTR
26m0141 05473 640700014171030120000000	MFTYP0: D[CONST 12] ROT[14] DEST[Q] CYLEN[FIXM] $; GET R-X MASK
26m0141 05474 450140034635000440005476	        D[IR] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C600 $; J IF NEITHER R NOR X
26m0141 05475 640700234575000440000000	        D[IR] ALU[DORQ] DEST[IR-ADR] NORM $; TURN ON R AND X
26m0141 05476 640700034371056030000000	        D[IR] ROT[27] MASK[3] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX ENBL BITS,
26m0141                               	 INVERTED
26m0141 05477 530140004571044040000000	        D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR5] CYLEN [C550] $; J IF
26m0141                               	 OUT-OF-CORE
26m0141 05500 530140000235042030000000	        D[AR] ROT[21] MASK[3] ALU[D&Q] DEST[Q] COND[-OBUS=0] JUMP[MFTR6] C550 $; J IF
26m0141                               	 ILLEGAL ACCESS TYPE (RWX)
26m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

27m0141                               	;MFA5 JSMFR MFTR1 MFTR10 MFB5 MFB4 MFC1 MFTR2 MTRPAL MFTR3 MFTR4 MFTR5 MFTR6 MFTR7 MFTR9
27m0141                               	 MFTR41 MAPRST MAPRSS MAPRSL
27m0141 05501 640700004171000130000000	        D[MEM] MASK[13] DEST[Q] SHORT $; GET ABS PAGE #
27m0141 05502 640722614575014400000000	        D[CONST 40] ROT[6] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; GET CORE STATUS ENTRY
27m0141 05503 640700034371024440000000	        D[IR] ROT[12] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX DISABLES
27m0141 05504 640700014235052240000000	        D[CONST 24] ROT[25] ALU[D&Q] DEST[Q] SHORT $; GET ONLY R & X
27m0141 05505 640700014035052040000000	        D[CONST 4] ROT[25] ALU[D+Q] DEST[Q] SHORT $; MOVE X BIT LEFT 1
27m0141 05506 640700024175022240000000	        D[MA] ROT[11] MASK[24] ALU[DORQ] DEST[Q] SHORT $; OR IN PAGE ADDRS
27m0141 05507 510140004571006030000000	        D[MEM] ROT[3] MASK[3] COND[OBUS=0] JUMP[MFTR7] C550 $; J IF CST AGE SAYS TRAP
27m0141 05510 510140000571040010005424	        D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFA3] C550 $;J IF NO WRT RQ
27m0141 05511 640700200571000440000000	        D[AR] DEST[IR-ADR] SHORT $; SAVE ORRIGINAL MA
27m0141 05512 640701400571000443000000	        D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
27m0141 05513 640710010635060430000000	        D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] SHORT $; TURN OFF WRT PREVENT, SAVE NEW MAP
27m0141                               	 WORD
27m0141 05514 640700014171064010000000	        D[CONST 1] ROT[32] DEST[Q] SHORT $; GET MODIFICATION BIT
27m0141 05515 640700004175000320000000	        D[MEM] MASK[32] ALU[DORQ] DEST[Q] SHORT $; OR INTO CST WORD
27m0141 05516 640704464575000440000000	MFA5:   D[15] ALU[DORQ] DEST[HOLD] NORM $;OR IN AGE, ETC
27m0141 05517 640700024171000440000000	        D[MA] DEST[Q] SHORT $; SAVE CST ADDRS
27m0141                               	
27m0141 05520 640722634571000220000000	        D[IR] MASK[18.] DEST[MA HI-ABS-MA] NORM $; GET ORIGINAL MA
27m0141                               	
27m0141                               	 .REPEAT NEWMAP [
27m0141                               	; NEWMAP
27m0141                               	
27m0141                               	 .REPEAT 1 - NEWMAP [
27m0141 05521 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $ ;NOW TURN MAP ON.
27m0141 05522 640702214571000043600000	        D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $
27m0141 05523 440700000571000440100000	        MAPF[10] CYLEN[IOB-OUT] $
27m0141 05524 640705200571000440000000	        D[AR] DEST[STO-MAP] NORM $; LOAD MAP
27m0141                               	  ]; 1-NEWMAP
27m0141                               	
27m0141 05525 240702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] C800 $ ;MAP OFF
27m0141 05526 465140000571000440105530	        MAPF[10] CYLEN[IOB-OUT] COND[-USER] JUMP[. + 2] $
27m0141                               	
27m0141 05527 640705614571022170000000	        D[CONST 17] ROT[11] DEST[MAP-EXEC-SR] NORM $
27m0141 05530 640724000555000440000000	        ALU[Q] DEST[MA STRT-WRT] NORM $; STORE CST
27m0141                               	
27m0141                               	.REPEAT 1 - WAITS [;27m0141                               	Damnit. TENEX isn't the only operating system for a PDP-10!
27m0141                               	   ;Now add 1 to abs. loc. 30 of main mem (for statistics keeping)
27m0141 05531 640720014571000300000000	        D[CONST 30] DEST[MA] NORM $
27m0141 05532 640700000571000440000000	        NORM $
27m0141 05533 640704204433000440000000	        D[MEM] ALU[D+1] DEST[MEMSTO] NORM $
27m0141                               	].REPEAT 1 - WAITS
27m0141                               	
27m0141 05534 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
27m0141 05535 640710070571000440000000	        D[16] DEST[AR] NORM $
27m0141 05536 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
27m0141 05537 640702274571000443600000	        D[10 + APRENB] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN MAP BACK ON, ETC.
27m0141                               	        MAPF[10] CYLEN[MAX,IOB-OUT,C550]
27m0141 05540 170140000571032010100000	                        D[AR] ROT[15] MASK[1] COND[-OBUS=0] JUMP[JSMFR] $
27m0141                               	                ; DO SPECIAL JSYS STUFF IF APPROPRIATE
27m0141 05541 510140000571040010002026	        D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MAIN]  C550 $; DONE IF NO WRT
27m0141 05542 530140000571036010002026	        D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MAIN] C550 $; DONE IF READ
27m0141 05543 640720000571000220000000	        D[AR] MASK[18.] DEST[MA] SHORT $;GET ORRIG. MA
27m0141 05544 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $
27m0141 05545 640144274571000440002033	        D[17] DEST[MEMSTO] JUMP[MSMAIN1] NORM $; STORE THE STORE DATA, & PROCEDE
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

27m0141 05546 640720000571000220000000	JSMFR:  D[AR] MASK[18.] DEST[MA] NORM $
27m0141 05547 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
27m0141 05550 640150074571000440004465	        D[17] DEST[AR] JUMP[MUJSM1] NORM $; RESTORE STORE DATA
27m0141                               	
27m0141 05551 530140004571022010000000	MFTR1:  D[MEM] ROT[11] MASK[1] COND[-OBUS=0] JUMP[MFTR9] C550 $; J IF TRAP TO USER
27m0141 05552 530140004571024010000000	        D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFTR10] C550 $;J IF WRT TRAP
27m0141 05553 640140004571000440000000	        D[MEM] JUMP[MFTR2] NORM $; TREAT BOTH "TRAP-TO-MON" CODES AS IMMEDIATE
27m0141 05554 510140000571040010005454	MFTR10: D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFB3] C550 $; WRT RQ? J IF NO
27m0141 05555 640700014171074440000000	        D[CONST 44] ROT[36] DEST[Q] SHORT $; GET ERROR CODE BITS -- WRT TRAP
27m0141                               	MFB5:
27m0141 05556 645150000175000440005560	MFB4:   D[AR] ALU[DORQ] DEST[AR Q] COND[USER] JUMP[. + 2] NORM $; OR ERROR BITS IN, J IF
27m0141                               	 USER MODE
27m0141 05557 640710014575044010000000	        D[CONST 1] ROT[18.] ALU[DORQ] DEST[AR] NORM $; TURN ON EXEC BIT
27m0141 05560 640700014171014050000000	        D[CONST 5] ROT[6] DEST[Q] SHORT $
27m0141 05561 640700014175000710000000	        D[CONST 71] ALU[DORQ] DEST[Q] SHORT $; FORM 571
27m0141 05562 640722660575000440000000	        D[14] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; ADD PSB (MON BASE TAB)
27m0141 05563 640704200571000440000000	        D[AR] DEST[MEMSTO] CYLEN[FIXM] $; STORE ERROR BITS THERE
27m0141 05564 510140000571040010000000	        D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFC1] C550 $; J IF NO WRT RQ
27m0141 05565 530140000571036010000000	        D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MFC1] C550 $; J IF RD RQ
27m0141 05566 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] SHORT $; GO TO 572
27m0141 05567 640704274571000440000000	        D[17] DEST[MEMSTO] NORM $; SAVE STORE DATA
27m0141 05570 640701600615000440000000	MFC1:   ALU[0] DEST[DEV-ADR] CYLEN[MEMSTO] $
27m0141 05571 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN OFF MAP
27m0141 05572 440702600615000440100000	        MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $
27m0141 05573 640720014571000700000000	        D[CONST 70] DEST[MA] SHORT $; FETCH TRAP INSTR
27m0141 05574 640701600615000440000000	        ALU[0] DEST[DEV-ADR] CYLEN[FIXM] $
27m0141 05575 640702274571000443600000	        D[10 + APRENB] DEST[IOD] SPEC[IOB-OUT] SHORT $; TURN ON MAP
27m0141 05576 440710020171000440100000	        D[PC] DEST[Q AR] MAPF[10] CYLEN[IOB-OUT] $
27m0141 05577 640705410635076430000000	        D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $;CLR USER
27m0141 05600 640140014171004550002106	        D[CONST 55] ROT[2] DEST[Q] JUMP[MUUO44] NORM $
27m0141 05601 640140014171074410005556	MFTR2:  D[CONST 41] ROT[36] DEST[Q] JUMP[MFB5] NORM $; ASCCESS PERMISSION TRAP
27m0141                               	MTRPAL:
27m0141 05602 640700014171074400000000	MFTR3:  D[CONST 40] ROT[36] DEST[Q] SHORT $
27m0141 05603 640140014175066010005556	        D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB5] NORM $; ILLEGAL PT ENTRY TYPE,
27m0141                               	 ADDRESS LIMIT
27m0141                               	MFTR4:  ;ALL THESE ARE NOT-IN-CORE
27m0141 05604 640140014171074220005556	MFTR5:  D[CONST 22] ROT[36] DEST[Q] JUMP[MFB5] NORM $; NOT-IN-CORE
27m0141 05605 510140014635000050005610	MFTR6:  D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[. + 3] C550 $; J IF NO R OR X ERROR
27m0141 05606 640700014175066040000000	        D[CONST 4] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN "R OR X ERROR" BIT
27m0141 05607 510140014635000020005611	        D[CONST 2] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C550 $; J IF NO W ERROR
27m0141 05610 640700014175066020000000	        D[CONST 2] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN W ERROR BIT
27m0141 05611 640700014275000070000000	        D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
27m0141 05612 640140014175074400005556	        D[CONST 40] ROT[36] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; GROUP 2
27m0141 05613 640140014171074100005556	MFTR7:  D[CONST 10] ROT[36] DEST[Q] JUMP[MFB4] NORM $; AGE ERR -- GROUP 0
27m0141 05614 640140014171074420005556	MFTR9:  D[CONST 42] ROT[36] DEST[Q] JUMP[MFB4] NORM $; USER TRAP
27m0141 05615 640700014171074200000000	MFTR41: D[CONST 20] ROT[36] DEST[Q] NORM $; GROUP 1
27m0141 05616 640140014175066010005556	        D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; TOO MANY INDR. PNTRS
27m0141                               	;------------------------------------------------------------------------------
27m0141                               	;Reset map.  Clear entire map to zero.  This is because even though the map
27m0141                               	;will stop stores from happening, fetches still happen irregardless of state
27m0141                               	;of map and if map points at non-existent memory (on for example, an immediate
27m0141                               	;mode instruction), the machine will get a spurious ECC interrupt.
27m0141                               	;
27m0141                               	;It is assumed that the device address is set to 1 when this thing is called.
27m0141                               	;------------------------------------------------------------------------------
27m0141 05617 640705614571022000000000	MAPRST: SET-TEMP-EXEC $
27m0141                               	                ;Begin at the beginning of EXEC space.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

27m0141 05620 640700014171022010000000	        D[CONST 1] ROT[9.] DEST[Q] SHORT $
27m0141                               	                ;Increment for MA
27m0141 05621 640720014537044010000000	MAPRSS: D[CONST 1] ROT[18.] ALU[D-Q] DEST[MA] NORM $
27m0141                               	                ;Start at the top and work down.
27m0141                               	MAPRSL:
27m0141                               	.REPEAT 1 - NEWMAP [
27m0141 05622 640705214571064010000000	        D[CONST 1] ROT[35. - 9.] DEST[STO-MAP] NORM $
27m0141                               	                ;Set mapping to zero, Invalid
27m0141 05623 522160024537000440005622	        D[MA] ALU[D-Q] DEST[MA] COND[-MA-AC] JUMP[. - 1] C550 $
27m0141                               	                ;Repeat for each page in this space.
27m0141                               	].REPEAT 1 - NEWMAP
27m0141                               	.REPEAT NEWMAP [
27m0141                               	.REPEAT NEWMAP
27m0141 05624 665145614571022170005621	        SET-TEMP-USER COND[-USER] JUMP[MAPRSS] $
27m0141                               	                ;Repeat once more if currently doing EXEC space. This
27m0141                               	                ;time for USER space.  We can do this because EXEC-SR is
27m0141                               	                ;latched at the end of the cycle.
27m0141 05625 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
27m0141 05626 640702214571000013600000	        D[CONST 1] DEST[IOD] SPEC[IOB-OUT] NORM $
27m0141 05627 440702014571000030140000	        MAPF[14] CYLEN[IOB-OUT] D[CONST 3] DEST[MAP-DISP] $
27m0141 05630 000303600571000440000000	        DEST[CLR-MI-ERR] POPJ $ ;Done
27m0141                               	
27m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

28m0141                               	;JSYS1 JSYS2 UMOVX XCT1 XCTUMV XCT5 XCT4 XCT6 XCT3 XCT13 XCT18 XCT12 XCT11 XDISP XCT2
28m0141                               	 XCTAC XCTSTK XCTS1 XCTS2 XCT10 XCTBLG XCTBYT XBY1 XBY4 XBY15 XBY14 XBY13 XBY3
28m0141                               	;------------------------------------------------------------------------------
28m0141                               	;
28m0141                               	;       BBN added instructions.  Sometimes used by other than TENEX
28m0141                               	;
28m0141                               	;------------------------------------------------------------------------------
28m0141 05631 640706000550400440020000	JSYS1:  FIXM1 $
28m0141 05632 640710020571000440000000	        D[PC] DEST[AR] NORM $   ;SAVE PC & FLAGS
28m0141 05633 640704604571000220000000	        D[MEM] MASK[18.] DEST[PC] NORM $; JUMP TO RIGHT HALF
28m0141 05634 640720004571044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $
28m0141 05635 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
28m0141 05636 510140014635074010005640	JSYS2:  C550 D[CONST 1] ROT[36] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] $; J IF EXEC MODE
28m0141 05637 640705600615000440000000	        ALU[0] DEST[MAP-EXEC-SR]  NORM $; TEMP TURN OFF USER
28m0141 05640 640700014171014100000000	        D[CONST 10] ROT[6] DEST[Q] SHORT $
28m0141 05641 640720024575000440000000	        D[MA] ALU[DORQ] DEST[MA] SHORT $; FETCH POINTER WORD
28m0141 05642 640706000550400440020000	        FIXM1  $
28m0141 05643 640704604571000220000000	        D[MEM] MASK[18.] DEST[PC] NORM $; J TO RIGHT HALF
28m0141 05644 640700020171000440000000	        D[PC] DEST[Q] SHORT $
28m0141 05645 511140000571012440005647	        D[AR] ROT[5] C550 COND[OBUS<0] JUMP[. + 2] $
28m0141                               	                ;If we came from exec mode, then we...
28m0141 05646 640700014175070010000000	        D[CONST 1] ROT[34] ALU[DORQ] DEST[Q] SHORT $
28m0141                               	                ; ...TURN ON FLAG BIT 7
28m0141 05647 640705414675074010000000	        D[CONST 1] ROT[36] ALU[-D&Q] DEST[CRYOV] SHORT $; TURN OFF USER
28m0141 05650 640720004571044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $; LEFT HALF
28m0141 05651 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$; STORE PC
28m0141                               	
28m0141                               	  .DEFINE JCFM 28m0141                               	
28m0141 05652 645140000571000440002100	UMOVX:  COND[USER] JUMP[MUUO] NORM $
28m0141 05653 640700004171000440000000	        D[MEM] DEST[Q] NORM $
28m0141 05654 640704414435102010000000	        D[CONST 1] ROT[41] ALU[D+Q] DEST[HOLD] NORM $
28m0141 05655 640140014171000050000000	        D[CONST 5] DEST[Q] JUMP[XCTUMV] NORM $
28m0141                               	
28m0141                               	;------------------------------------------------------------------------------
28m0141                               	;
28m0141                               	;       XCTR - Execute Relocated
28m0141                               	;
28m0141                               	;       If in Exec mode and the AC field of the XCT instruction is non-zero,
28m0141                               	;       it means do some of the references from User mode if PC bit (?),
28m0141                               	;       meaning JSYS from Moniter, is not set.
28m0141                               	;
28m0141                               	;       This code is not map dependent, although other maps (like ITS) may code
28m0141                               	;       the bits in the AC field differently, requiring some rewriting.
28m0141                               	;
28m0141                               	;       Warning:  This code is complex and prone to bugs.  Many probably lurk
28m0141                               	;                 in the cracks.  If you find one, please document it even if
28m0141                               	;                 no solution seems to appear.
28m0141                               	;------------------------------------------------------------------------------
28m0141 05656 640704620531000440000000	XCT1:   D[PC] ALU[D-1] DEST[PC] NORM $
28m0141 05657 645140000571000440000000	        COND[USER] JUMP[XCT2] NORM $
28m0141 05660 640700034171032040000000	        D[IR] ROT[15] MASK[4] DEST[Q] SHORT $; SAVE XCT AC FLD
28m0141 05661 664170604571000440000000	XCTUMV: D[MEM] DEST[AR IR-ALL MA] COND[-MEM-IDX-IND] JUMP[XCT3] NORM $
28m0141 05662 510140034571044040020000	XCT5:   D[IR] ROT[18.] MASK[4] COND[OBUS=0] JUMP[XCT4] C550 MAPF[2] $; J IF NO IDX FLD
28m0141 05663 000730234420400220000000	        D[IR] MASK[18.] ALU[IX+D] DEST[MA IR-ADR AR] $; DO INDEX
28m0141 05664 510140034571034010020000	XCT4:   D[IR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XCT3] C550 MAPF[2] $; J IF NO INDR
28m0141 05665 530040014635000100000000	        D[CONST 10] ALU[D&Q] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF ADDR CALC USER
28m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

28m0141                               	XCT6:
28m0141 05666 640706000550400440010000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-IND] CYLEN[FIXM] $
28m0141                               	;;;     FIXM1 $
28m0141                               	;;;             ;It was overdecrementing PC  TVR-Mar80
28m0141 05667 640705614571022000000000	        SET-TEMP-EXEC $
28m0141 05670 644170404571000440005662	        D[MEM] DEST[AR IR-23 MA] COND[MEM-IDX-IND] JUMP[XCT5] NORM $
28m0141 05671 640700200555000440020000	XCT3:   ALU[Q] DEST[IR-ADR] SHORT  MAPF[2] $; SAVE XCT AC FLD
28m0141 05672 640700034171016070000000	        D[IR] ROT[7] MASK[7] DEST[Q] SHORT $; GET HO 7 BITS OF OPCODE
28m0141 05673 510140014735000540000000	        D[CONST 54] ALU[D#Q] COND[OBUS=0] JUMP[XCTSTK] C550 $; J IF STACK GROUP
28m0141 05674 510140014735000270000000	        D[CONST 27] ALU[D#Q] COND[OBUS=0] JUMP[XCTBYT] C550 $; J IF BYTE GROUP
28m0141 05675 510140014735000520000000	        D[CONST 52] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLG] C550 $; J IF GROUP WITH BLT IN IT
28m0141                               	
28m0141 05676 640700034171000040000000	XCT13:  D[IR] MASK[4] DEST[Q] SHORT $; GET XCT AC FLD
28m0141 05677 510140014635000050000000	XCT18:  D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[XDISP] C550 $; J IF NEITHER RELEVANT BIT
28m0141 05700 642140000571000440000000	        COND[MA-AC] JUMP[XCT10] NORM $; J IF EF ADR IS AC
28m0141                               	        JCFM[28m0141 05701 530140020571020010000000	D[PC] ROT[10] MASK[1] COND[-OBUS=0] JUMP[XDISP] C550 $;J IF CALL FM MON];J IF CALL FM MON
28m0141                               	
28m0141 05702 510140014635000010000000	        D[CONST 1] ALU[D&Q] COND[OBUS=0] JUMP[XCT11] C550 $;J IF BIT OFF
28m0141 05703 510140014635000040000000	        D[CONST 4] ALU[D&Q] COND[OBUS=0] JUMP[XCT12] C550 $; J IF OTHER BIT OFF
28m0141 05704 640145614571022030000000	        D[CONST 03] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET SRC & DEST TO USER
28m0141                               	
28m0141 05705 640145614571022020000000	XCT12:  D[CONST 02] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET DEST TO USER
28m0141 05706 640705614571022010000000	XCT11:  D[CONST 01] ROT[11] DEST[MAP-EXEC-SR] NORM $; SET SRC TO USER
28m0141 05707 540520224571000441602000	XDISP:  D[MA] DEST[MA IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
28m0141 05710 540530604571000441602174	XCT2:   D[MEM] DEST[IR-ALL AR MA] DISP[2174] SPEC[PC+1-IF] CYLEN[DISP] $
28m0141                               	XCTAC:
28m0141                               	.REPEAT 1 - WAITS [
28m0141 05711 640704400551000440000000	        ACSEL[AC] ALU[AC] DEST[HOLD]  SHORT $; SAVE AC
28m0141 05712 640702425571000440000000	        ACSEL[AC] DEST[CLR-DEV-FROM-INTR AC] D[MA] SHORT $; GET AC ADDRS
28m0141 05713 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $
28m0141 05714 640700055421000440000000	        ACSEL[AC] D[13] ALU[D+AC] DEST[AC] SHORT $; ADD IN AC BASE REG.
28m0141 05715 640700015421022750000000	        ACSEL[AC] D[CONST 75] ROT[11] ALU[D+AC] DEST[AC] SHORT $
28m0141 05716 640700015421036070000000	        ACSEL[AC] D[CONST 7] ROT[17] ALU[D+AC] DEST[AC] NORM $
28m0141 05717 640320005171000440000000	        D[MEM] ACSEL[AC] DEST[O_AC MA] POPJ NORM $
28m0141                               	].REPEAT 1 - WAITS
28m0141                               	.REPEAT WAITS [
28m0141                               	.REPEAT WAITS
28m0141                               	XCTSTK:
28m0141                               	;;;     COND[-MA-AC] JUMP[XCT13] NORM $; J IF EF ADR NOT AC (TREAT NORMALLY)
28m0141 05720 510140034171022020005676	        D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LOW ORDER
28m0141                               	 BITS OF OP CODE, J IF PUSHJ
28m0141 05721 510140014735000030005676	        D[CONST 3] ALU[D#Q] COND[OBUS=0] JUMP[XCT13] C550 $; J IF POPJ
28m0141                               	.repeat 0[
28m0141                               	.repeat 0
28m0141 05722 510140014735000020000000	        D[CONST 2] ALU[D#Q] COND[OBUS=0] JUMP[XPOP1] C550 $; J IF POP
28m0141 05723 640140000571000440000000	        JUMP[XPUSH1] NORM $
28m0141                               	                ;Someday, move code over here (when we have space)
28m0141                               	
28m0141 05724 640040000571000440005711	XCT10:  PUSHJ[XCTAC] NORM $; FIX EF ADR
28m0141 05725 540500224571000041622000	        MAPF[2] D[MA] MASK[4] DEST[IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
28m0141 05726 510140034171022020005676	XCTBLG: D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LO BITS OF
28m0141                               	 OPCODE, J IF EXCH
28m0141 05727 510140014735000010000000	        D[CONST 1] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLT] C550 $; J IF BLT
28m0141 05730 640140034171000040005677	        D[IR] MASK[4] DEST[Q] JUMP[XCT18] NORM $; GET XCT AC FLD, PROCEDE
28m0141                               	
28m0141 05731 530040034571104012000000	XCTBYT: D[IR] ROT[42] MASK[1] SPEC[PC+1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF
28m0141                               	 B.P. FETCH IS NOT EXEC
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

28m0141 05732 510140034571022010020000	XBY1:   D[IR] ROT[11] MASK[1] COND[OBUS=0] JUMP[XBY3] C550 MAPF[2] $;J IF BP WILL BE INCR
28m0141                               	
28m0141 05733 640706000550400440020000	        FIXM1 $
28m0141 05734 640710004171000440000000	        D[MEM] DEST[AR Q] NORM $; GET BP
28m0141 05735 640705614571022000000000	XBY4:   SET-TEMP-EXEC $
28m0141 05736 664160000571000220000000	        D[AR] MASK[18.] DEST[MA] COND[-MEM-IDX-IND] JUMP[XBY13] NORM $; J IF BP HAS NO
28m0141                               	 IDX OR INDR
28m0141 05737 510141000571044040020000	XBY15:  D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[XBY14] C550 MAPF[2] $; J IF
28m0141                               	 NO IX FLD
28m0141 05740 640700010235044220000000	        D[MASK 22] ROT[18.] ALU[D&Q] DEST[Q] NORM $
28m0141 05741 640710000420000220000000	        D[AR] MASK[18.] ACSEL[REG] ALU[D+AC] DEST[AR] SHORT $
28m0141 05742 640730000175000220000000	        D[AR] MASK[18.] ALU[DORQ] DEST[Q AR MA] SHORT $
28m0141 05743 510140000571034010020000	XBY14:  D[AR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XBY13] C550 MAPF[2] $; J IF NO INDR
28m0141 05744 530040034571106010000000	        D[IR] ROT[43] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF BP ADR CALC IS
28m0141                               	 USER
28m0141 05745 640706000550400440020000	        FIXM1 $
28m0141 05746 640705614571022000000000	        SET-TEMP-EXEC $
28m0141 05747 640710000571030140000000	        D[AR] ROT[14] MASK[14] DEST[AR] SHORT $
28m0141 05750 640700000171060440000000	        D[AR] ROT[30] DEST[Q] SHORT $
28m0141 05751 644170004175000270005737	        D[MEM] MASK[27] ALU[DORQ] DEST[Q AR MA] COND[MEM-IDX-IND] JUMP[XBY15] NORM $
28m0141 05752 030040034571000010020000	XBY13:  D[IR] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] MAPF[2] $; MAKE MA OK
28m0141 05753 510140034571020010022625	        D[IR] ROT[10] MASK[1] COND[OBUS=0] JUMP[LDB5] C550 MAPF[2] $; DISTINGUISH LOADS
28m0141                               	 FROM DEPOSITS, J IF LOAD
28m0141 05754 640140000571000440002637	        JUMP[DPB5] NORM $
28m0141                               	
28m0141 05755 640706200550400440030000	XBY3:   FIXM2 $
28m0141 05756 656150004171000440005735	        D[MEM] DEST[AR Q] COND[HALF] JUMP[XBY4] NORM $;GET BP, J IF NO INCR
28m0141 05757 657051400571030060004035	        D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $; GET S
28m0141                               	 FLD, HANDLE OVERFLOW
28m0141 05760 662154200077074440005762	        D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $; SUB S
28m0141                               	 FROM P
28m0141 05761 640700005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] NORM $
28m0141 05762 640040000571000440006146	        PUSHJ[SETHLF] NORM $; SET HALF
28m0141 05763 640140000571000440005735	        JUMP[XBY4] NORM $; (IN CASE OF MAP FAULTS)
28m0141                               	
28m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

29m0141                               	;XFIXMA XCTBLT XBLTL XPUSH1 XPDLO2 XPOP1 XPOP2 XPOP3
29m0141 05764 642140000571000440005711	XFIXMA: COND[MA-AC] JUMP[XCTAC] NORM $; J IF ADDRS IS AC
29m0141 05765 530300020571020010020000	        D[PC] ROT[10] MASK[1] COND[-OBUS=0] POPJ C550 MAPF[2] $; LEAVE IF CALL FM MON
29m0141 05766 640705614571022170000000	        SET-TEMP-USER $
29m0141 05767 640320024571000440000000	        D[MA] DEST[MA] POPJ NORM $
29m0141                               	
29m0141                               	;;;;;.USE[OTHER]  DWP 9-19-80
29m0141                               	
29m0141 05770 640710025171000442000000	XCTBLT: D[MA] SPEC[PC+1] DEST[O_AC AR] NORM $; END ADR IN AC, AC IN AR
29m0141 05771 640720000571044220000000	XBLTL:  D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $; GET WORD
29m0141 05772 530040034571104010005764	        D[IR] ROT[42] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; FIX IF USER ADDRS
29m0141 05773 640706000550400440070000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BLT-RDA] CYLEN[FIXM] $
29m0141 05774 640700004171000440000000	        D[MEM] DEST[Q] SHORT $; GET DATA WORD
29m0141 05775 640720000571000220000000	        D[AR] MASK[18.] DEST[MA] SHORT $; GET DEST ADR
29m0141 05776 530045634571000010005764	        D[IR] MASK[1] DEST[MAP-EXEC-SR] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $;FIX MA ADDRS
29m0141 05777 640704200555000440000000	        ALU[Q] DEST[MEMSTO] SHORT $
29m0141 06000 471140000523000220144344	        D[AR] MASK[18.] ALU[D-AC] MAPF[BLT-WRTB] COND[-OBUS<0] JUMP[BLTA12] C600 $
29m0141 06001 662145614171001000006003	        D[CONST 1,,1] DEST[Q MAP-EXEC-SR] COND[-MA-AC] JUMP[. + 2] NORM $
29m0141 06002 640700005570400440000000	        D[MEM] ACSEL[MA] DEST[AC] SHORT $
29m0141 06003 640150000435000440005771	        D[AR] ALU[D+Q] DEST[AR] JUMP[XBLTL] NORM $; TEST FOR INTERPT HERE ? *****
29m0141                               	
29m0141                               	;Special case for PUSH.  Check for AC reference from stack pointer
29m0141 06004 510140034571000010005676	XPUSH1: D[IR] MASK[1] COND[OBUS=0] JUMP[XCT13] C550 $
29m0141                               	                ;If not mapping stack references, it's simple
29m0141 06005 530040034571104012005764	        D[IR] ROT[36. - 2] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] SPEC[PC+1] C550$
29m0141                               	                ;Make sure we're referring to the right place here.
29m0141                               	                ;Also, we're now executing the instruction (PC+1)
29m0141 06006 640706000550400440020000	        FIXM1 $ ;Check page faults for effective address part.
29m0141 06007 640710004571000440000000	        D[MEM] DEST[AR] NORM $
29m0141                               	                ;Copy away the thing that we want to push
29m0141 06010 515160015421001000000000	        D[CONST 1,,1] ALU[D+AC] DEST[AC MA] COND[CRY0] JUMP[XPDLO2] C550 $
29m0141                               	                ;Advance frame pointer and check for overflow
29m0141 06011 640040000571000440005764	        PUSHJ[XFIXMA] NORM $
29m0141                               	                ;Decide whether to map destination.
29m0141 06012 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
29m0141                               	                ;Finish instruction. We're done
29m0141 06013 640040000571000440005764	XPDLO2: PUSHJ[XFIXMA] NORM $
29m0141                               	                ;Fixup AC references
29m0141 06014 640140000571000440000000	        JUMP[PDLO2] NORM $
29m0141                               	                ;Done.  Take stack overflow trap
29m0141                               	
29m0141                               	;Special case for POP.  Check for AC reference from stack pointer
29m0141 06015 640700034171022442000000	XPOP1:  D[IR] ROT[11] DEST[Q] NORM SPEC[PC+1] $
29m0141                               	                ;Save bit meaning 'source from user' in format that can
29m0141                               	                ;be fed easily to EXEC-SR
29m0141                               	                ;Now we're executing the PUSH (implied by PC+1)
29m0141 06016 640700224571000440000000	        D[MA] DEST[IR-ADR] NORM $
29m0141                               	                ;Restore normal effective address 
29m0141 06017 640720015063001000000000	        ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC] NORM $
29m0141                               	                ;Update AC and MA for stack reference
29m0141 06020 530040014635022040005764	        D[CONST 4] ROT[11] ALU[D&Q] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $
29m0141                               	                ;Fixup stack addressing if user AC
29m0141 06021 640706000550400440160000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
29m0141                               	                ;Check for page faults
29m0141 06022 640710004571000440000000	        D[MEM] DEST[AR] NORM $
29m0141                               	                ;Find somewhere safer for thing to push
29m0141                               	        D[CONST 1] ROT[11] ALU[D&Q] DEST[MAP-EXEC-SR]
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

29m0141 06023 510145614635022010000000	                        COND[OBUS=0] JUMP[XPOP3] C550 $
29m0141                               	                ;Set appropriate mode to do store in
29m0141 06024 640720034571000220000000	        D[IR] MASK[22] DEST[MA] NORM $
29m0141                               	                ;Extract address and fetch it from the appropriate page.
29m0141 06025 642040000571000440005711	        COND[MA-AC] PUSHJ[XCTAC] NORM $
29m0141                               	                ;Fixup AC addressing if needed.  (We can't combine this and
29m0141                               	                ;previous instruction because MA is strobed at end of cycle.
29m0141                               	                ;We can't call XFIXMA because it uses SET-TEMP-USER which
29m0141                               	                ;would affect the next instruction fetch. Sigh...)
29m0141 06026 515140014421001000000000	XPOP2:  D[CONST 1,,1] ALU[D+AC] COND[CRY0] JUMP[PDLO5] C550 $
29m0141                               	                ;Try for overflow again.  Take it if you need it.
29m0141 06027 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
29m0141                               	                ;Write out thing we POP'ped
29m0141 06030 640160034571000220006026	XPOP3:  D[IR] MASK[22] DEST[MA] NORM JUMP[XPOP2] $
29m0141                               	                ;Extract address and don't do anything special about it
29m0141                               	
29m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

30m0141                               	;APRDSP PIDSP AREA53 APRCO APRCO2 APRCO3 APRIEN APRC1 APRC2 APRCHK APRCK1 APDINT APRCI
30m0141                               	 APRCII APRDI APIOT
30m0141                               	;------------------------------------------------------------------------------
30m0141                               	;
30m0141                               	;       APR and PI instructions
30m0141                               	;
30m0141                               	;------------------------------------------------------------------------------
30m0141                               	        .ORG[XLIST
30m0141                               	 LIST ] ;APR & PI IOT DISP TABLE
30m0141                               	APRDSP: ILGIOT 30m0141 05300 000140000571000440002026	 JUMP [MAIN] ]$; BLKI APR
30m0141 05301 000700000571000440000000	        NOP $
30m0141 05302 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $; DATAI -- RD SW
30m0141 05303 640142400571000443400000	        DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] JUMP[APRDI] NORM $
30m0141                               	        ILGIOT 30m0141 05304 000140000571000440002026	 JUMP [MAIN] ]$ ;BLKO APR
30m0141 05305 000700000571000440000000	        NOP $
30m0141 05306 000140000571000440002026	        JUMP[MAIN] $; DATAO
30m0141 05307 000700000571000440000000	        NOP $
30m0141 05310 640700034171000130000000	        D[IR] MASK[13] DEST[Q] NORM $; GET CONO BITS
30m0141 05311 640140014275012330000000	        D[CONST 33] ROT[5] ALU[-D&Q] DEST[Q] JUMP[APRCO] NORM $
30m0141 05312 640040000571000440000000	        PUSHJ[APRCI] NORM $; CONI -- GET BITS IN AR & Q
30m0141 05313 662104200571000220002032	        D[AR] MASK[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
30m0141 05314 640040000571000440000000	        PUSHJ[APRCI] NORM $; CONSZ -- GET BITS IN AR & Q
30m0141 05315 640140034171000220004472	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
30m0141 05316 640040000571000440000000	        PUSHJ[APRCI] NORM $; CONSO -- GET BITS IN AR & Q
30m0141 05317 640140034171000220004474	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
30m0141                               	PIDSP:  .REPEAT 3[ 30m0141                               	ILGIOT 30m0141 05320 000140000571000440002026	 JUMP [MAIN] ]$
30m0141 05321 000700000571000440000000	        NOP $
30m0141                               	]ILGIOT 30m0141 05322 000140000571000440002026	 JUMP [MAIN] ]$
30m0141 05323 000700000571000440000000	        NOP $
30m0141                               	]ILGIOT 30m0141 05324 000140000571000440002026	 JUMP [MAIN] ]$
30m0141 05325 000700000571000440000000	        NOP $
30m0141                               	]       ;DATAO PI -- Set lights
30m0141 05326 640041614571000000004445	        D[CONST 0] DEST[DEV-ADR] PUSHJ[SETLTS] NORM $   ;Just like examine...?
30m0141 05327 640140000571000440002026	        JUMP[MAIN] SHORT $
30m0141 05330 640140000571000440004610	        JUMP[PICONO] NORM $; PI CONO
30m0141 05331 000700000571000440000000	        NOP $
30m0141 05332 640040000571000440004641	        PUSHJ[PICONISUB] NORM $; CONI -- GET BITS IN AR & Q
30m0141 05333 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
30m0141 05334 640040000571000440004641	        PUSHJ[PICONISUB] NORM $; CONSZ -- GET BITS IN AR & Q
30m0141 05335 640140034171000220004472	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
30m0141 05336 640040000571000440004641	        PUSHJ[PICONISUB] NORM $; CONSO -- GET BITS IN AR & Q
30m0141 05337 640140034171000220004474	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
30m0141                               	
30m0141                               	
30m0141                               	   .USE[30m0141                               	XLIST
30m0142                               	 LIST ]
30m0142 04651 640710014675006010000000	APRCO:  D[CONST 1] ROT[3] ALU[-D&Q] DEST[AR] SHORT $
30m0142 04652 640700034371106210000000	        D[IR] ROT[43] MASK[21] ALU[NOTD] DEST[Q] SHORT $
30m0142                               	                ; GET CLR BITS
30m0142 04653 640700014275000070000000	        D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

30m0142                               	                ; Remove PI assignment
30m0142 04654 640702450235000442400000	        D[10 + APRSTS] SPEC[A-MEM-APR] ALU[D&Q] DEST[Q CLR-DEV-FROM-INTR] SHORT $
30m0142                               	                ; CLEAR INDICATED BITS
30m0142 04655 640710400575000442600000	        D[AR] ALU[DORQ] SPEC[A-MEM-APR&DEST-A-MEM] DEST[APRSTS AR] NORM $
30m0142                               	                ; SET INDICATED BITS & CHAN
30m0142 04656 510140034571102010000000	        D[IR] ROT[41] MASK[1] COND[OBUS=0] JUMP[APRCO2] C550 $
30m0142                               	                ; J IF NO CLR OVERFLOW BIT
30m0142 04657 640705420571000430000000	        D[PC] MASK[43] DEST[CRYOV] SHORT $; CLR OV
30m0142                               	                ; Remove overflow bit from current PC flags
30m0142 04660 510140034571074010000000	APRCO2: D[IR] ROT[36] MASK[1] COND[OBUS=0] JUMP[APRCO3] C550 $
30m0142                               	                ; J IF NO CLR FLT OV
30m0142 04661 640700010171102430000000	        D[MASK 43] ROT[41] DEST[Q] SHORT $
30m0142                               	                ; Remove bit from current PC flags
30m0142 04662 640705420635000440000000	        D[PC] ALU[D&Q] DEST[CRYOV] SHORT $
30m0142                               	                ; CLR FLT OV
30m0142 04663 530040034571066010004512	APRCO3: D[IR] ROT[33] MASK[1] COND[-OBUS=0] PUSHJ[CLKCLR] C550 $
30m0142                               	                ; CLR CLOCK FLAG IF INDICATED
30m0142                               	;       ---
30m0142                               	
30m0142                               	; TEMP **** APRCI:
30m0142 04664 640042400571000440000000	APRIEN: PUSHJ[APRCII] DEST[CLR-DEV-FROM-INTR] NORM $
30m0142                               	                ; GET APR CONI BITS
30m0142 04665 640701614571000013400000	        D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
30m0142                               	                ; Select and read MAP and ECC enablings
30m0142 04666 140700030171000030040000	        D[IOD] MAPF[4] MASK[3] DEST[Q] CYLEN[IOB-IN] $
30m0142 04667 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
30m0142                               	                ; For some pecular reason, the thing we read from device 1 is
30m0142                               	                ; written in device 0???
30m0142 04670 510140000571000030000000	        D[AR] MASK[3] COND[OBUS=0] JUMP[APRC1] C550 $
30m0142                               	                ; Jump if no PI channel.  We don't want to enable arithmetic
30m0142                               	                ; micro-interrupts in that case.
30m0142 04671 510140000571100010000000	        D[AR] ROT[40] MASK[1] COND[OBUS=0] JUMP[APRC1] C550 $
30m0142                               	                ; J IF NO OV INT ENBL
30m0142                               	                ; *** Don't both enables need to be checked???
30m0142 04672 640142214575000023600000	        D[CONST 2] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] JUMP[APRC2] NORM $; ENABLE OV INT
30m0142                               	                ; Turn on arithmetic interrupts
30m0142 04673 640702214675000023600000	APRC1:  D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
30m0142                               	                ; Turn off arithmetic interrupts
30m0142 04674 440140000171000440100000	APRC2:  MAPF[10] CYLEN[IOB-OUT] D[AR] DEST[Q] JUMP[APRCK1] $
30m0142                               	                ; Finish turning arithmetic interrupts off or on, and we're done
30m0142                               	
30m0142                               	;Check for clock interrupts (and other things)
30m0142 04675 640040000571000440000000	APRCHK: PUSHJ[APRCI] NORM $; GET CONI BITS IN AR & Q
30m0142                               	
30m0142                               	APRCK1:
30m0142                               	.REPEAT 1 - WAITS [
30m0142 04676 510140000571000030002026	        D[AR] MASK[3] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF PI=0
30m0142 04677 530140000571040010000000	        D[AR] ROT[20] MASK[1] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF PDLOV INT
30m0142 04700 640700000235106440000000	        D[AR] ROT[43] ALU[D&Q] DEST[Q] SHORT $; AND MASK WITH FLAG
30m0142 04701 530140014635006110000000	        D[CONST 11] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF OV INT
30m0142 04702 510140014635014100002026	        D[CONST 10] ROT[6] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF NO CLOCK INT
30m0142                               	
30m0142                               	;       \ /
30m0142                               	].REPEAT 1 - WAITS
30m0142                               	.REPEAT WAITS [
30m0142                               	.REPEAT WAITS
30m0142                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

30m0142                               	;       \ /     (Falls thru from APRCK1)
30m0142 04703 640150000171000030004564	APDINT: D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; GET CHAN #, CAUSE INTERRUPT
30m0142                               	
30m0142                               	APRCI:  ;TEMP -- LATER WE FIX OV
30m0142 04704 640040000571000440000000	APRCII: PUSHJ[CLKRDFLG] NORM $
30m0142                               	         ;Get CLOCK FLAG in AR 35, rest of AR = 0
30m0142                               	        .DEFINE APRGBT 30m0142                               	        APRGBT[30m0142 04705 640700020171002010000000	D[PC] ROT[1] MASK[1] DEST[Q] SHORT $
30m0142 04706 640710000575014440000000	        D[AR] ROT[6] ALU[DORQ] DEST[AR] SHORT $
30m0143                               	]       APRGBT[30m0143 04707 640700020171010010000000	D[PC] ROT[4] MASK[1] DEST[Q] SHORT $
30m0143 04710 640710000575102440000000	        D[AR] ROT[41] ALU[DORQ] DEST[AR] SHORT $
30m0144                               	]       APRGBT[30m0144 04711 640700020171016010000000	D[PC] ROT[7] MASK[1] DEST[Q] SHORT $
30m0144 04712 640710000575066440000000	        D[AR] ROT[33] ALU[DORQ] DEST[AR] SHORT $
30m0145 04713 640700000171036440000000	]       D[AR] ROT[17] DEST[Q] SHORT $; SET FLAGS
30m0145                               	.REPEAT 1 - WAITS [
30m0145 04714 640310050175000442400000	        D[10 + APRSTS] SPEC[A-MEM-APR] ALU[DORQ] DEST[Q AR] NORM POPJ $
30m0145                               	].REPEAT 1 - WAITS
30m0145                               	
30m0145                               	.REPEAT WAITS [
30m0145                               	.REPEAT WAITS
30m0145                               	
30m0145 04715 162104230571000440022032	APRDI:  MAPF[2] D[IOD] DEST[MEMSTO] COND[-MA-AC] LBJUMP[MSMAIN] CYLEN[IOB-IN] $
30m0145                               	
30m0145                               	        .PAIR
30m0145                               	. \ 2 + .
30m0146                               	]       UIOTRP[30m0146 04716 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
30m0146                               	]$                      ;Trap if not IOT-USER Mode
30m0146                               	APIOT:  IOTDIS[30m0146 04717 640700034171034050000000	D[IR] ROT[16] MASK[5] DEST[Q] NORM $
30m0146 04720 540540014575014530000000	        D[CONST 53] ROT[6] ALU[DORQ] SDISP CYLEN[C500] $
30m0147                               	]
30m0147                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

31m0147                               	;PDLO1 PDLO2 PDLO5 PDLO3 PDLO4 PDLO6 PDLMEM PDLOE PDLO SOED STOPS SOVRS SECCS SOEDOV
31m0147                               	
31m0147 04721 640040000571000440000000	PDLO1:  PUSHJ[PDLO] NORM $ ;SET PDLO BIT
31m0147 04722 640714220571000440000000	        D[PC] DEST[AR MEMSTO] NORM $
31m0147 04723 662104634571000222370000	        MAPF[MASTO] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] COND[-MA-AC] LBJUMP[PDLMEM]
31m0147                               	 NORM $
31m0147 04724 640040000571000440000000	PDLO2:  PUSHJ[PDLO] NORM $; SET FLAG
31m0147 04725 662104200571000440000000	PDLO5:  D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PDLMEM] NORM $
31m0147 04726 640706000550400440160000	PDLO3:  ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
31m0147 04727 640050004571000440000000	        D[MEM] DEST[AR] PUSHJ[PDLO] NORM $
31m0147 04730 640160034571000220004725	        D[IR] MASK[18.] DEST[MA] JUMP[PDLO5] NORM $
31m0147 04731 640706000550400440160000	PDLO4:  ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
31m0147 04732 640040000571000440000000	        PUSHJ[PDLO] NORM $
31m0147 04733 640144604571000220000000	        D[MEM] MASK[18.] DEST[PC] JUMP[PDLOE] NORM $
31m0147                               	;PDLOV from ADJSP
31m0147 04734 640040000571000440000000	PDLO6:  PUSHJ[PDLO] NORM $
31m0147 04735 640140000571000440000000	        JUMP[PDLOE] NORM $
31m0147                               	
31m0147                               	        .PAIR
31m0147                               	. \ 2 + .
31m0148 04736 640700005570400440170000	]PDLMEM:        ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] MAPF[MASTO] $
31m0148                               	PDLOE:  MAPF[MASTO] D[10 + APRSTS] MASK[3] DEST[AR] SPEC[A-MEM-APR]
31m0148 04737 640150050571000032574564	        JUMP[PIGEN] NORM $; CHAN # IN AR, TRY INTERRUPT
31m0148                               	
31m0148 04740 640700050171000442400000	PDLO:   D[10 + APRSTS] SPEC[A-MEM-APR] DEST[Q] NORM $; APR CONI WORD
31m0148                               	        D[CONST 1] ROT[20] ALU[DORQ] SPEC[A-MEM-APR&DEST-A-MEM] DEST[APRSTS]
31m0148 04741 640300414575040012600000	                        NORM POPJ $
31m0148                               	                ;SET PDLOV BIT
31m0148                               	
31m0148                               	        .USE[31m0148                               	XLIST
31m0149                               	 LIST ]
31m0149                               	.REPEAT F3SW [
31m0149                               	 ;; END OF .REPEAT F3SW
31m0149                               	
31m0149                               	;(ECC-UNC moved to bottom of page)
31m0149                               	
31m0149                               	 .REPEAT F2SW [ 31m0149                               	
31m0149                               	
31m0149 06031 640141614571000010004367	STOPS:  D[CONST 1] DEST[DEV-ADR] JUMP[DOHALT] NORM $
31m0149                               	
31m0149 06032 531142420571000443406035	SOVRS:  D[PC] COND[-OBUS<0] SPEC[IOB-IN] JUMP[. + 3] DEST[CLR-DEV-FROM-INTR] C550 $
31m0149                               	                ; J IF NO OV
31m0149 06033 140702430171000440040000	        D[IOD] MAPF[4] DEST[Q CLR-DEV-FROM-INTR] CYLEN[IOB-IN] $
31m0149 06034 530140014635000020000000	        D[CONST 2] ALU[D&Q] COND[-OBUS=0] JUMP[SOEDOV] C550 $ ;J IF OV INT EN
31m0149 06035 000140000571000440006035	        JUMP[.] $ ; HOW COULD WE GET HERE?
31m0149                               	
31m0149 06036 640701614571000013400000	SECCS:  D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
31m0149 06037 140704430171000440020000	        D[IOD] MAPF[2] DEST[Q HOLD] CYLEN[IOB-IN] $
31m0149 06040 640700054171000042400000	        D[10 + ECCSVP] SPEC[A-MEM-APR] MASK[4] DEST[Q] NORM $
31m0149                               	.REPEAT 1 - XUCODE [
31m0149                               	.REPEAT 1 - XUCODE
31m0149                               	.REPEAT XUCODE [
31m0149                               	        D[MASK 9.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
31m0149 06041 640712410575010113400000	          NORM SPEC[IOB-IN] $  ;;17760 IS NEW LOC. OF ERROR LOG.
31m0149                               	].REPEAT XUCODE
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

31m0149 06042 140700030171000440040000	        MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
31m0149                               	 ;;;;;  D[CONST 1] ROT[7] ALU[D&Q] COND[-OBUS=0] JUMP[.] C550 $
31m0149                               	
31m0149 06043 140707400615000440000000	        ALU[0] DEST[MUCODE-HI] CYLEN[MUSTO] $
31m0149 06044 640700004171000440000000	        D[MEM] DEST[Q] NORM $
31m0149 06045 140707610635052420000000	        D[MASK 42] ROT[25] ALU[D&Q] DEST[MUCODE-LO] CYLEN[MUSTO] $
31m0149 06046 640700600433000442600000	        D[AR] ALU[D+1] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
31m0149 06047 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
31m0149 06050 640702400571000443400000	        DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
31m0149 06051 140700230571000440040000	        D[IOD] DEST[IR-ADR]  MAPF[4] CYLEN[IOB-IN] $
31m0149 06052 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
31m0149                               	;NOTE:  This conflicts with the use of the lights by diagnostics.
31m0149 06053 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;PUT JUNK IN LIGHTS
31m0149 06054 440700000555000443620000	        MAPF[2] ALU[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ;LTS_OBUS
31m0149 06055 440703600571000440100000	        MAPF[10] DEST[CLR-MI-ERR] CYLEN[IOB-OUT] $; TURN OFF MAP
31m0149 06056 640700200555000443000000	        ALU[Q] DEST[A-MEM-ECC-DATA] DEST-A-MEM NORM $
31m0149                               	          ;Save info for reading via opcode 750.  
31m0149 06057 640722604571000440000000	        D[MEM] DEST[MA HI-ABS-MA] NORM $; GET DATA
31m0149 06060 540700000571000440000000	        CYLEN[C500] $;WAIT
31m0149 06061 640704204571000440000000	        D[MEM] DEST[MEMSTO] NORM $; RE-STORE IT
31m0149 06062 640700000571000440000000	        NORM $; WAIT -- FOR LUCK
31m0149 06063 640702234571000443600000	        D[IR] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE STATE OF MAP, ETC.
31m0149 06064 440702600615000440100000	         MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $;
31m0149 06065 640143600571000440002026	        DEST[CLR-MI-ERR] JUMP[MAIN] NORM $
31m0149                               	
31m0149                               	  ];; END OF .REPEAT F2SW
31m0149                               	
31m0149 06066 640701600615000440000000	SOEDOV: ALU[0] DEST[DEV-ADR] NORM $
31m0149 06067 640702214675000023600000	        D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
31m0149 06070 440040000571000440104704	        MAPF[10] CYLEN[IOB-OUT] PUSHJ[APRCII] $; GET CONI BITS
31m0149 06071 640150000171000030004564	        D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; DO INTR.
31m0149                               	
31m0149                               	;$*$*$*$ No space left in NORMAL by now...
31m0149                               	        .USE[31m0149                               	XLIST
31m0150                               	 LIST ]
31m0150                               	ECC-UNC:  ;SEE IF WE SHOULD GIVE INTERRUPT FOR HARD ECC ERR
31m0150                               	          ;RETURN TO CALLER IF NOT, BUT STILL SET PAR ERR FLAG.
31m0150 06206 640700060171000440000000	        D[14] DEST[Q] NORM $
31m0150                               	         ;FIRST, SET PAR ERR FLAG IN PI CONI BITS.
31m0150                               	        D[CONST 1] ROT[35. - 19.] ALU[DORQ] 
31m0150 06207 640711014575040013000000	                DEST[AR 4] DEST-A-MEM NORM $
31m0150 06210 531300000571036440000000	        D[AR] ROT[35. - 20.] C550 COND[-OBUS<0] POPJ $
31m0150                               	         ;IF PAR ERR INTRPT ENABLE OFF, DO NO MORE.
31m0150 06211 510310050171000030000000	        D[10 + APRSTS] MASK[3] DEST[Q AR] C550 COND[OBUS=0] POPJ $
31m0150                               	         ;IF APR PI CHAN IS 0, DON'T GIVE INTRPT.
31m0150 06212 640343600571000440004564	        DEST[CLR-MI-ERR] NORM JPOP[PIGEN] $ 
31m0150                               	         ;CLEAR ERR FF AND GIVE INTERRUPT ON APR CHANNEL.
31m0150                               	
31m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

32m0150                               	;; 60 HZ CLOCK READING AND INTERRUPT ROUTINES
32m0150                               	
32m0150                               	 .REPEAT OTP [
32m0150                               	 ;OTP
32m0150                               	
32m0150                               	
32m0150                               	 .REPEAT NTP [ 32m0150                               	;We branch here from CTYINT if intrpt. is really 60HZ CLK.
32m0150                               	
32m0150 06213 640702200615000443600000	CLKINT: START-OUT ALU[0] DEST[IOD] NORM $
32m0150                               	          ;Clear hardware int. enb. for 60HZ CLK.
32m0150 06214 440700000571000440060000	        MAPF[6] C600 $
32m0150                               	  ];NTP
32m0150                               	
32m0150                               	.REPEAT TYMNET [
32m0150                               	TYMNET
32m0150 06215 440142400571000440004675	        DEST[CLR-DEV-FROM-INTR] JUMP[APRCHK] C600 $     
32m0150                               	          ;Cause PI on APR channel if enabled, and exit.
32m0150                               	
32m0150                               	CLKRDFLG:  ;Put hardware 60HZ CLK FLAG into AR35.
32m0150 06216 640701614571000063400000	        START-IN D[CONST 6] DEST[DEV-ADR] NORM $
32m0150                               	          ;Select device 6.
32m0150 06217 140310030571106010050000	        MAPF[5] D[IOD] ROT[34. + 1] MASK[1] DEST[AR] CYLEN[IOB-IN] POPJ $
32m0150                               	          ;Get bit and return.
32m0150                               	
32m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

33m0150                               	.REPEAT NTP [ 33m0150                               	;Ucode for KENNEDY or PERTEC formatter and DMA tape controller.
33m0150                               	
33m0150                               	  .REPEAT 1 - TAPE [
33m0150                               	
33m0150                               	  .REPEAT TAPE [ 33m0150                               	 ;New (DMA tape controller, Pertec compatible fmtr )
33m0150                               	.INSERT TAPE.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- SCI

01m0001                               	;-------------------------------------------------------------------------------
01m0001                               	;
01m0001                               	;       Ucode for KENNEDY or PERTEC formatter and DMA tape controller.
01m0001                               	;
01m0001                               	;-------------------------------------------------------------------------------
01m0001                               	.REPEAT XUCODE [
01m0001                               	        .USE[XLIST
01m0001                               	 LIST ];If 8K u-mem present, put tape code there.
01m0001                               	   ]
01m0001                               	;TAPE READING AND WRITING CODE
01m0001                               	; A-MEM USEAGE:
01m0001                               	;               0       DISPATCH ADDR.
01m0001       0	TPMODE =        0       ;DATA PACKING MODE 
01m0001                               	;                        BIT 0: 0=PDP-10 CORE-DUMP, 1=INDUSTRY (32-bit mode)
01m0001                               	;                        BIT 1: NRZI Kluge Mode (to read old CCRMA & SCI tapes)
01m0001                               	;               1       Used by FMNBWT and TRCHECK for NRZI Kluge Mode info.
01m0001                               	;               2       Used by KNYGOA and TRCHECK for NRZI Kluge Mode info.
01m0001                               	;               3       DON'T USE... Storing into it clobbers IR left !
01m0001                               	;               4       Next mem adr of xfer (STRTDC) -- 0 during non-data ops
01m0001                               	;               5       Remaining word count in current WCMA (STRTDC)
01m0001                               	;               6       Not currently used-- will be  Data Channel PC
01m0001                               	;               7       RETRY COUNT (WRITE); 400000,,STARTING-MA (READ)
01m0001                               	
01m0001                               	;MAPF values
01m0001                               	
01m0001       4	TP.RS = 4       ;read status (from formatter)
01m0001       2	TP.RC = 2       ;read control (controller status and un-fifo'd read data)
01m0001                               	
01m0001       2	TP.WF = 2       ;write formatter (send ctrl bits to formatter)
01m0001       4	TP.WM = 4       ;write mode control reg.
01m0001       1	TP.WC = 1       ;write control reg.
01m0001       5	TP.MR = 5       ;give Master Reset
01m0001       3	TP.WMA = 3      ;write (load) the CNTMA reg. (count and MA)
01m0001                               	
01m0001                               	KNYCLR:  ;RESET the formatter and drive.
01m0001                               	
01m0001 10001 000702200615000443600000	KNYRS1: START-OUT ALU[0]  DEST[IOD] $
01m0001                               	                ;Turn off "FORMATTER ENABLE"
01m0001 10002 000300000571000440020000	        MAPF[TP.WF] LONG POPJ $
01m0001                               	
01m0001                               	   ;725 - OBSOLETE VERSION OF READ
01m0001                               	
01m0001                               	  .PAIR
01m0001                               	. \ 2 + .
01m0002                               	]  UIOTRP[01m0002 10004 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0002                               	]$
01m0002                               	
01m0002 10005 640040214571014140000000	TAPERD: D[CONST 14] ROT[6] DEST[IR-ADR] NORM PUSHJ[KNYRGO] $
01m0002                               	                ;Fake a word count of 1400
01m0002 10006 640041024571000443000000	        D[MA] DEST[4] DEST-A-MEM NORM PUSHJ[TRP2] $
01m0002 10007 640140001555000440000000	        ALU[Q] DEST[AC] ACSEL[AC] NORM JUMP[GOMAIN] $
01m0002                               	                ;Move status into AC.
01m0002                               	
01m0002                               	; KNYRGO -- Called to start tape motion on reads.
01m0002 10010 640040000571000440000000	KNYRGO: NORM PUSHJ[DCINIT] $
01m0002                               	                ;Init the data channel.
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- SCI

01m0002 10011 640710040571002010000000	        D[10 + TPMODE]  ROT[1] MASK[1] DEST[AR] NORM $
01m0002                               	                ;Get the 32-bit mode flag.
01m0002 10012 640702200571014443600000	        START-OUT D[AR] ROT[35. - 29.] DEST[IOD] NORM $
01m0002                               	                ;Position it for the hardware.
01m0002 10013 440140014171000000040000	        MAPF[TP.WM] D[CONST 0] DEST[Q]   C-OUT JUMP[KNYGOA] $
01m0002                               	                ;Send command to formatter.
01m0002                               	
01m0002                               	  ;Send a tape-motion command to the formatter.  Call with command bits
01m0002                               	  ;  (except for FMTR ENABLE and GO) in Q.  Clobbers Q, HOLD, AR
01m0002 10014 000040014175022013400000	KNYGOA: START-IN D[CONST 1] ROT[35. - 26.] ALU[DORQ] DEST[Q] PUSHJ[FMNBWT] $
01m0002                               	          ;Add the FMTR ENBL bit to the command word.
01m0002                               	          ;Wait for FORMATTER NOT BUSY.
01m0002 10015 640700404571000443000000	        D[MEM] DEST[2] DEST-A-MEM NORM $
01m0002                               	          ;Save status bits returned by FMNBWT for use by TRCHECK
01m0002 10016 440702214735004013600000	        START-OUT D[CONST 1] ROT[35. - 33.] ALU[D#Q] DEST[IOD] C-OUT $
01m0002                               	          ;Set the GO bit to fmtr (except: on RWD, CLEAR the bit !)
01m0002 10017 000702214675004013620000	        MAPF[TP.WF] START-OUT D[CONST 1] ROT[35. - 33.] ALU[-D&Q] DEST[IOD] $
01m0002                               	          ;Send command word again, without GO bit.
01m0002 10020 000300000571000440020000	        MAPF[TP.WF] LONG POPJ $
01m0002                               	
01m0002                               	
01m0002                               	FMNBWT:   ;Wait for formatter to be not busy.
01m0002                               	          ;Return tape status in MEM;  timeout in 164 msec.
01m0002                               	          ;Duration of loop should be 10 usec. (for TRCHECK).
01m0002 10021 640710014571034013400000	        START-IN D[CONST 1] ROT[14.] DEST[AR] NORM $
01m0002 10022 240704430571000440040000	FMNBW1: MAPF[TP.RS] D[IOD] DEST[HOLD] C800 $ ;GET STATUS BITS.
01m0002 10023 511350000531000440000000	        D[AR] ALU[D-1] DEST[AR] C550 OBUS<0 JPOP[FMTHNG] $
01m0002 10024 440740014571000160000000	        D[CONST 14.] LLOAD C600 $
01m0002 10025 540240000571000440000025	        C500 LOOP[.] $
01m0002                               	          ;We execute this instr. 15. times, for a 7.5 usec delay.
01m0002 10026 531140004571016443400022	        START-IN D[MEM] ROT[7] C550 -OBUS<0 JUMP[FMNBW1] $
01m0002                               	          ;check for 'BUSY'
01m0002 10027 640300200571000443000000	        D[AR] DEST[1] DEST-A-MEM NORM POPJ $
01m0002                               	          ;Save ending timeout count (for TRCHECK)
01m0002 10030 640040000571000440000001	FMTHNG: NORM PUSHJ[KNYRS1] $
01m0002                               	                ;Blast the formatter.
01m0002 10031 000340015571074420000000	        D[CONST 42] ROT[30.] DEST[AC] JPOP[GOMAIN] $
01m0002                               	                ;Return error code for 'hung fmtr' and abort.
01m0002                               	
01m0002                               	NCNTWT:   ;Wait for TP CNT GO to be off.
01m0002                               	          ;Return tape status in MEM;  timeout in 164 msec.
01m0002                               	          ;Duration of loop should be 10 usec. (for TRCHECK).
01m0002 10032 240704430571000440020000	NCNTW1: MAPF[TP.RC] D[IOD] DEST[HOLD] C800 $ ;GET STATUS BITS.
01m0002 10033 511310000531000440000000	        D[AR] ALU[D-1] DEST[AR] C550 OBUS<0 POPJ $
01m0002                               	          ;Exit if we time out-- probably just a short record.
01m0002 10034 440740014571000160000000	        D[CONST 14.] LLOAD C600 $
01m0002 10035 540240000571000440000035	        C500 LOOP[.] $
01m0002                               	          ;We execute this instr. 15. times, for a 7.5 usec delay.
01m0002 10036 511140004571046443400032	        START-IN D[MEM] ROT[19.] C550 OBUS<0 JUMP[NCNTW1] $
01m0002                               	          ;check for not TP CNT GO
01m0002 10037 640300200571000443000000	        D[AR] DEST[1] DEST-A-MEM NORM POPJ $
01m0002                               	          ;Save ending timeout count (for TRCHECK)
01m0002                               	
01m0002                               	
01m0002                               	;INITIALIZE DATA CHANNEL
01m0002                               	
01m0002 10040 640740014571000103600000	DCINIT: START-OUT D[CONST 8.] LLOAD NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- SCI

01m0002                               	                ;Give TP MR
01m0002 10041 440702200615000443650000	        MAPF[TP.MR] START-OUT ALU[0] DEST[IOD] C600 $
01m0002                               	                ;Load 0 into cntma (the COUNT and MA registers)
01m0002 10042 440702210571054143630000	        MAPF[TP.WMA] START-OUT D[MASK 12.] ROT[35. - 13.] DEST[IOD] C600 $
01m0002                               	                ;Load cntma again-- since COUNT is currently  0, this will 
01m0002                               	                ; force BUF CNT to be 0.  But, we put -1 into COUNT this
01m0002                               	                ; time, which, with BUF CNT = 0, will make BUF CNT load
01m0002                               	                ; properly when STARTDC loads cntma.
01m0002 10043 440702214571000023630000	        MAPF[TP.WMA] START-OUT D[CONST 2] DEST[IOD] C600 $
01m0002                               	                ;Set MBUSY
01m0002 10044 500240000571000440010044	        MAPF[TP.WC] C550 LOOP[.] $
01m0002                               	                ;Wait for a few usec.  This clears mem rq.
01m0002 10045 640702200615000443600000	        START-OUT ALU[0] DEST[IOD] NORM $
01m0002                               	                ;Clr MBUSY
01m0002 10046 440300000571000440010000	        MAPF[TP.WC] C600 POPJ $
01m0002                               	
01m0002                               	;START DATA CHANNEL to write or read a record.  Transfer up to C(IR-ADR) words;
01m0002                               	;  starting address is in A-MEM[4].
01m0002                               	
01m0002 10047 640701234571000223000000	STRTDC: D[IR] MASK[18.] NORM DEST[5] DEST-A-MEM $
01m0002                               	                ;Initialize word count
01m0002 10050 640700214571034013000000	        D[CONST 1] ROT[14.] DEST[1] DEST-A-MEM NORM $
01m0002                               	                ;Initialize timeout count (for NCNTWT and FMNBWT)
01m0002 10051 440040000571000440000000	STDC1:  MAPF[0] C600 PUSHJ[DCGO] $
01m0002                               	          ;start xfer -- MAPF is relevant if we looped back here on READ
01m0002 10052 440050044571000443400032	        MAPF[0] START-IN D[11] DEST[AR] C600 PUSHJ[NCNTW1] $
01m0002                               	          ;Wait for TP CNT GO to be off (continue with current timeout count)
01m0002                               	          ;MAPF is relevant if we came from DCGWR below.
01m0002 10053 531140074571000440000051	        D[17] C550 -OBUS<0 JUMP[STDC1] $
01m0002                               	          ;Jump if this is a WRITE operation.
01m0002 10054 531140000571000443600051	        START-OUT D[AR] C550 -OBUS<0 JUMP[STDC1] $
01m0002                               	          ;READ op, so set MEM RQ to store last word.
01m0002                               	          ;Jump unless we timed out waiting for end of last COUNT.
01m0002 10055 440150044571000443400022	WCDONE: MAPF[0] START-IN D[11] DEST[AR] C600 JUMP[FMNBW1] $
01m0002                               	          ;Enter FMNBWT with the timeout count left from NCNTWT.
01m0002                               	          ;The MAPF sets MEM RQ if we have fallen in from previous instr.
01m0002 10056 510354464171000440000055	DCGO:   D[15] DEST[Q AR HOLD] C550 OBUS=0 JPOP[WCDONE] $
01m0002                               	                ;Get remaining word count. If =0, we are done.
01m0002 10057 511140014477014140000000	        D[CONST 14] ROT[6] ALU[Q-D] C550 OBUS<0 JUMP[DCG1] $
01m0002                               	                ;Jump if it is less than 1400
01m0002 10060 640710014171014140000000	         D[CONST 14] ROT[6] DEST[Q AR] NORM $   
01m0002                               	                ;It is not. Use 1400 instead.
01m0002 10061 640701204537000443000000	DCG1:   D[MEM] ALU[D-Q] DEST[5] DEST-A-MEM NORM $
01m0002                               	                ;Decrement remaining WC by amount of current WC.
01m0002 10062 640704460571000440000000	        D[14] DEST[HOLD] SHORT $
01m0002                               	                ;Get current starting adr
01m0002 10063 640701004435000443000000	        D[MEM] ALU[D+Q] DEST[4] DEST-A-MEM NORM $
01m0002                               	                ;Increment it by current WC.
01m0002 10064 511140040571000440000066	        D[10 + TPMODE] C550 OBUS<0 JUMP[. + 2] $
01m0002                               	                ;Are we in 32-bit mode ?  Jump if so.
01m0002 10065 640150000435004440000067	         D[AR] ROT[2] ALU[D+Q] DEST[AR] NORM JUMP[. + 2] $
01m0002                               	                ;Form byte count (=5*word count).
01m0002 10066 640710000571004440000000	         D[AR] ROT[2] ALU[D] DEST[AR] NORM $
01m0002                               	                ;Form byte count (=4*word count).
01m0002 10067 640710000531000440000000	        D[AR] ALU[D-1] DEST[AR] NORM $
01m0002                               	                ;Adjust count to be right for hdwr.
01m0002 10070 640700000171054440000000	        D[AR] ROT[35. - 13.] DEST[Q] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- SCI

01m0002                               	                ;Align count at bit 13.
01m0002 10071 640702204575000243600000	        START-OUT D[MEM] MASK[20.] ALU[DORQ] DEST[IOD] NORM $
01m0002                               	                ;Include mem addr and load into COUNT, MA
01m0002                               	                ;Also sets BUF CNT to 0 (if IN) or 5 (if OUT)-- this
01m0002                               	                ; depends on COUNT not =0 and BUF CNT not = 4 or 5
01m0002 10072 440702214571000023630000	        MAPF[TP.WMA] START-OUT D[CONST 2] DEST[IOD] C600 $
01m0002                               	                ;Set M BUSY
01m0002 10073 440700000571000443610000	        MAPF[TP.WC] START-OUT C600 $
01m0002                               	                ;Set CNT GO
01m0002 10074 451300074571000440130000	        MAPF[13] D[17] C600 OBUS<0 POPJ $
01m0002                               	                ;Return if this is a READ op.
01m0002 10075 530300064571000443600000	DCGWR:  START-OUT D[15] C550 -OBUS=0 POPJ $
01m0002                               	                ;Set MEM RQ to fetch first word.
01m0002                               	                ;Return unless this is the last WCMA in the record.
01m0002 10076 440702214571000123600000	        MAPF[0] START-OUT D[CONST 12] DEST[IOD] C600  $
01m0002                               	                ;Last one.  Set TP ENB LAST BYTE as well as M BUSY
01m0002 10077 440300000571000440010000	        MAPF[TP.WC] C600 POPJ $
01m0002                               	
01m0002                               	
01m0002                               	  ;Here to do the data xfer for a read operation.
01m0002 10100 640700060171000440000000	TRP2:   D[14] DEST[Q] SHORT $
01m0002                               	          ;We must save initial mem. adr. for NRZI KLUGE stuff..
01m0002 10101 640041614575106013000047	        D[CONST 1] ROT[35.] ALU[DORQ] DEST[7] DEST-A-MEM NORM PUSHJ[STRTDC] $
01m0002                               	          ;Flag op. as a READ, start the data channel
01m0002 10102 000140000571000440000000	        JUMP[TRCHKB] $
01m0002                               	
01m0002                               	TRCHECK:        
01m0002 10103 000040000571000440000021	        PUSHJ[FMNBWT] $
01m0002                               	          ;wait for formatter not busy.
01m0002 10104 531140004571100440000000	TRCHKB: D[MEM] ROT[32.] C550 -OBUS<0 JUMP[TRERR] $
01m0002                               	          ;check for hard error status.
01m0002 10105 531140004571102440000000	TRCHA:  D[MEM] ROT[33.] C550 -OBUS<0 JUMP[TREOF] $
01m0002                               	          ;Jump if EOF seen by formatter
01m0002 10106 640700000215000440000000	        ALU[0] DEST[Q] NORM $
01m0002                               	                ;Flag no errors.
01m0002 10107 640700000571000443400000	TRDONE: START-IN NORM $
01m0002 10110 440710030571000443420000	        MAPF[TP.RC] START-IN D[IOD] DEST[AR] C600  $  
01m0002                               	          ;Get data channel status bits.
01m0002 10111 240701230175000253030000	        MAPF[3] D[IOD] MASK[21.] ALU[DORQ] DEST[Q 5] DEST-A-MEM C800 $
01m0002                               	          ;Include ending MA value in status info.
01m0002 10112 531140000571046440000000	        D[AR] ROT[19.] C550 -OBUS<0 JUMP[TPMAOK] $
01m0002                               	          ;If TP CNT GO is off,
01m0002 10113 530140000531060033400000	        START-IN D[AR] ROT[24.] MASK[3] ALU[D-1] C550 -OBUS=0 JUMP[TPMAOK] $
01m0002                               	          ;  or if BUF CNT is not =1, then right no. of words were stored.
01m0002 10114 640701200055000443000000	         ALU[Q-1] DEST[Q 5] DEST-A-MEM NORM $
01m0002                               	           ;Otherwise, 1 extra word was stored, so decrement ending MA.
01m0002 10115 511140004571014440000000	TPMAOK: D[MEM] ROT[6] C550 OBUS<0 JUMP[TRCRET] $        
01m0002                               	          ;Done if not in NRZI mode.
01m0002 10116 531140040571002440000000	        D[10 + TPMODE] ROT[1] C550 -OBUS<0 JUMP[TRCRET] $
01m0002                               	          ;Also done if not in NRZI Kluge Mode,
01m0002 10117 510140060571000440000000	        D[14] C550 OBUS=0 JUMP[TRCRET] $
01m0002                               	          ; or if this was not a data-xfer operation.
01m0002 10120 531140050571030440000000	        D[12] ROT[12.] C550 -OBUS<0 JUMP[TRCRET] $
01m0002                               	          ;Neither do we check for EOF if we started at BOT (see KNYGOA)
01m0002                               	
01m0002                               	    ;In NRZI Kluge Mode, detect EOF by timing.
01m0002 10121 640704474077000240000000	        D[17] MASK[20.] ALU[Q-D] DEST[Q HOLD] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- SCI

01m0002                               	          ;Get number of words xferred (= ending MA minus starting MA )
01m0002 10122 640700004035004440000000	        D[MEM] ROT[2] ALU[D+Q] DEST[Q] NORM $
01m0002                               	          ;Get no. of bytes (=5* no. of words)
01m0002 10123 640700044035000240000000	        D[11] MASK[20.] ALU[D+Q] DEST[Q] NORM $
01m0002                               	          ;Add remaining timeout count from FMNBWT
01m0002 10124 640700014137034010000000	        D[CONST 1] ROT[14.] ALU[D-Q] DEST[Q] NORM $
01m0002                               	          ;Get no. of byte-times not accounted for by bytes xfrd.
01m0002                               	  .REPEAT 1 - 75IPS [
01m0002 10125 533140014537014110000000	        D[CONST 11] ROT[6.] ALU[D-Q] C550 COND[-OBUS18] JUMP[TRCRET] $
01m0002                               	       ]  .REPEAT 75IPS [
01m0002                               	          ;Jump if it is not more than appropriate for a record gap.
01m0002 10126 640040000571000440000000	        NORM PUSHJ[TAPEBR] $
01m0002                               	          ;Too long.  Assume an EOF was passed.  Back up over record read.
01m0002 10127 000040000571000440000021	        PUSHJ[FMNBWT] $
01m0002 10130 640300014171074600000000	        D[CONST 60] ROT[30.] DEST[Q] NORM POPJ $
01m0002                               	          ;Return EOF status.
01m0002                               	
01m0002 10131 511140060131000220000000	TRCRET: D[14] MASK[18.] ALU[D-1] DEST[Q] C550 OBUS<0 JUMP[TRCX] $
01m0002                               	          ;Get last loc. of input buffer (<0 iff non-data xfer operation)
01m0002 10132 640704400615000440000000	        ALU[0] DEST[HOLD] NORM $
01m0002                               	          ;Prepare to clear the part of the input buffer we didn't use.
01m0002                               	  .REPEAT NEWMAP [
01m0002                               	  .REPEAT 1 - NEWMAP [
01m0002 10133 640701614571000013400000	        START-IN D[CONST 1] DEST[DEV-ADR] NORM $
01m0002 10134 140700230571000030040000	        D[IOD] MASK[3] DEST[IR-ADR] MAPF[4] CYLEN[IOB-IN] $
01m0002 10135 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
01m0002 10136 640702234571000023600000	        D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM $
01m0002 10137 240701614571000070100000	        MAPF[10] D[CONST 7] DEST[DEV-ADR] C800 $
01m0002 10140 640720064531000440000000	         ]      D[15] ALU[D-1] DEST[MA] NORM $
01m0002 10141 511140024475000440000143	        D[MA] ALU[Q-D-1] C550 OBUS<0 JUMP[. + 2] $
01m0002 10142 640164024433000440000141	        D[MA] ALU[D+1] DEST[MA STRT-WRT] NORM JUMP[. - 1] $
01m0002                               	  .REPEAT NEWMAP [
01m0002                               	  .REPEAT 1 - NEWMAP [
01m0002 10143 640702234571000030000000	        D[IR] MASK[3] DEST[IOD] NORM $
01m0002 10144 640701600615000443600000	        ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
01m0002 10145 240701614571000070100000	        MAPF[10] D[CONST 7] DEST[DEV-ADR] C800 $
01m0002 10146 640300064171000440000000	         ]TRCX: D[15] DEST[Q] NORM POPJ $       
01m0002                               	          ;Recover ending status and return.
01m0002                               	
01m0002 10147 640140014171074600000107	TREOF:  D[CONST 60] ROT[30.] DEST[Q]  NORM JUMP[TRDONE] $
01m0002 10150 511140004571014440000152	TRERR:  D[MEM] ROT[6] C550 OBUS<0 JUMP[. + 2] $ 
01m0002                               	          ;Always check hard error if not in NRZI mode.
01m0002 10151 511140040571002440000105	        D[10 + TPMODE] ROT[1] C550 OBUS<0 JUMP[TRCHA] $
01m0002                               	          ;If NRZI, don't check if in kluge mode.
01m0002 10152 640140014171074500000107	        D[CONST 50] ROT[30.] DEST[Q] NORM JUMP[TRDONE] $
01m0002                               	          ;Flag hard read error to progm.
01m0002                               	
01m0002                               	        .PAIR
01m0002                               	. \ 2 + .
01m0003                               	]       UIOTRP[01m0003 10154 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0003                               	]$
01m0003                               	TAPEMT: ;OPCODE 726 -- MTAPE FUNCTIONS.
01m0003 10155 640040000571000440000157	        NORM PUSHJ[. + 2] $
01m0003 10156 640140000571000440000000	        NORM JUMP[GOMAIN] $
01m0003                               	
01m0003 10157 510140024171000440000000	        D[MA] DEST[Q] COND[OBUS=0] JUMP[TAPERW] C550 $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- SCI

01m0003 10160 510040014537000010000000	        D[CONST 1] ALU[D-Q] COND[OBUS=0] PUSHJ[TWREOF] C550 $
01m0003 10161 510040014537000130000000	        D[CONST 13] ALU[D-Q] COND[OBUS=0] PUSHJ[TERASE] C550 $
01m0003 10162 510140014537000500000000	        D[CONST 50] ALU[D-Q] COND[OBUS=0] JUMP[TPSETIND] C550 $
01m0003                               	          ;Code ?, set industry compatable mode.
01m0003 10163 510140014537000510000000	        D[CONST 51] ALU[D-Q] COND[OBUS=0] JUMP[TPSETDMP] C550 $
01m0003                               	          ;Code ?, set PDP-10 dump mode.
01m0003 10164 510140014537000600000000	        D[CONST 60] ALU[D-Q] COND[OBUS=0] JUMP[TPSETNK] C550 $
01m0003                               	          ;Code ?, set NRZI KLUGE mode.
01m0003 10165 510140014537000610000000	        D[CONST 61] ALU[D-Q] COND[OBUS=0] JUMP[TPCLRNK] C550 $
01m0003                               	          ;Code ?, clear NRZI KLUGE mode.
01m0003 10166 510040014537000050000000	        D[CONST 5] ALU[D-Q] COND[OBUS=0] PUSHJ[TAPEFR] C550 $
01m0003 10167 510040014537000060000000	        D[CONST 6] ALU[D-Q] COND[OBUS=0] PUSHJ[TAPEBR] C550 $
01m0003 10170 640041000615000443000103	        ALU[0] DEST[4] DEST-A-MEM NORM PUSHJ[TRCHECK] $
01m0003                               	            ;Wait for op. to finish and get ending status in Q.
01m0003                               	            ; The 0 in A-MEM[4] prevents TRCHECK from clearing read buf !
01m0003 10171 640340001555000440000000	        ALU[Q] DEST[AC] NORM JPOP[GOMAIN] $
01m0003                               	            ;Return status to caller in his AC (same as READ)
01m0003                               	
01m0003                               	
01m0003                               	TWREOF:  ;WRITE AN END OF FILE (TAPE MARK)
01m0003 10172 640700014171016010000000	        D[CONST 1] ROT[35. - 28.] DEST[Q] NORM $ 
01m0003                               	          ;Get WFM (WRITE EOF) cmd bit for formatter
01m0003 10173 640144414575032010000000	TERAS1: D[CONST 1] ROT[35. - 22.] ALU[DORQ] DEST[HOLD] NORM JUMP[KNYMTP] $  
01m0003                               	          ;Add WRT CMD bit and start command.
01m0003                               	
01m0003 10174 640140014171014030000173	TERASE: D[CONST 3] ROT[35. - 29.] DEST[Q] NORM JUMP[TERAS1] $
01m0003                               	          ;ERASE A 3.75" GAP ON THE TAPE (get WFM and ERASE bits for formatter)
01m0003                               	
01m0003 10175 640700000571000443600000	KNYMTP: START-OUT NORM $
01m0003                               	          ;Give TP MR to clear mode, error status
01m0003 10176 440040004171000440050014	        MAPF[TP.MR] D[MEM] DEST[Q] C-OUT PUSHJ[KNYGOA] $
01m0003                               	          ;Put command bits in Q and start formatter.
01m0003 10177 640702214571022013600000	        START-OUT D[CONST 1] ROT[35. - 26.] DEST[IOD] NORM $
01m0003                               	                ;Clear all command bits except FORMATTER ENABLE.
01m0003 10200 000300000341000440020000	        MAPF[TP.WF] ALU[-1] DEST[Q] LONG POPJ $
01m0003                               	                ;Put -1 in Q in case we are returning to TAPEMT.
01m0003                               	
01m0003                               	TAPERW: ;REWIND
01m0003 10201 640144414571000240000175	        D[CONST 24] DEST[HOLD] NORM JUMP[KNYMTP] $
01m0003                               	          ;RWD AND GO BITS -- KNYGOA WILL DELETE THE GO BIT !
01m0003                               	
01m0003                               	TAPEFR: ;SKIP FORWARD ONE RECORD.
01m0003 10202 640144414571000000000175	        D[CONST 0] DEST[HOLD] NORM JUMP[KNYMTP] $
01m0003                               	          ;START A READ, BUT IGNORE THE DATA.
01m0003                               	
01m0003                               	TAPEBR: ;SKIP BACKWARD ONE RECORD.
01m0003 10203 640144414571020010000175	        D[CONST 1] ROT[35. - 27.] DEST[HOLD] NORM JUMP[KNYMTP] $
01m0003                               	          ;JUST A READ BACKWARD, WITH THE DATA IGNORED.
01m0003                               	
01m0003                               	TPSETIND:       ;Set industry compatable mode
01m0003 10204 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10205 000140014575106013000000	        D[CONST 1] ROT[35.] ALU[DORQ] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	          ;Set appropriate bit and done
01m0003                               	TPSETDMP:       ;Set PDP-10 Dump Mode
01m0003 10206 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10207 000140014675106013000000	        D[CONST 1] ROT[35.] ALU[-D&Q] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	          ;Clear industry compatable mode and done.
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- SCI

01m0003                               	
01m0003                               	TPSETNK:        ;Enter NRZI KLUGE mode.
01m0003 10210 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10211 000140014575104013000000	        D[CONST 1] ROT[34.] ALU[DORQ] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	          ;Set appropriate bit and done
01m0003                               	TPCLRNK:          ;Leave NRZI KLUGE mode.
01m0003 10212 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10213 000140014675104013000000	        D[CONST 1] ROT[34.] ALU[-D&Q] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	
01m0003                               	TAPERS: ;OPCODE 727 -- READ STATUS BITS FROM TAPE DRIVE.
01m0003                               	
01m0003                               	.DEFINE TSS[01m0003                               	
01m0003 10214 640702200615000443600000	        START-OUT ALU[0] DEST[IOD] NORM $
01m0003                               	          ;CLEAR THE MODE CTRL REGISTER.
01m0003                               	        MAPF[TP.WM] START-OUT 
01m0003 10215 440702214571022013640000	         D[CONST 1] ROT[35. - 26.] DEST[IOD] C-OUT $
01m0003                               	          ;ENABLE THE FORMATTER.
01m0003 10216 240700000215000443420000	        MAPF[TP.WF] START-IN ALU[0] DEST[Q] C800 $
01m0003                               	          ;READ STATUS BITS.
01m0003 10217 240710030771000440040000	        MAPF[TP.RS] D[IOD] ALU[NOTD] DEST[AR] C800 $
01m0003                               	          ;NOW RE-ARRANGE THE BITS
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 3 OF AR TO BIT 30. OF Q.
01m0003 10220 640704400571010010000000	        D[AR] ROT[1 + 3] MASK[1] DEST[HOLD] NORM $
01m0003 10221 640700004175012440000000	        D[MEM] ROT[35. - 30.] ALU[DORQ] DEST[Q] NORM $ ];ON LINE
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 11. OF AR TO BIT 31. OF Q.
01m0003 10222 640704400571030010000000	        D[AR] ROT[1 + 11.] MASK[1] DEST[HOLD] NORM $
01m0003 10223 640700004175010440000000	        D[MEM] ROT[35. - 31.] ALU[DORQ] DEST[Q] NORM $ ];REWINDING
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 4 OF AR TO BIT 32. OF Q.
01m0003 10224 640704400571012010000000	        D[AR] ROT[1 + 4] MASK[1] DEST[HOLD] NORM $
01m0003 10225 640700004175006440000000	        D[MEM] ROT[35. - 32.] ALU[DORQ] DEST[Q] NORM $ ];FILE PROTECT
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 12. OF AR TO BIT 33. OF Q.
01m0003 10226 640704400571032010000000	        D[AR] ROT[1 + 12.] MASK[1] DEST[HOLD] NORM $
01m0003 10227 640700004175004440000000	        D[MEM] ROT[35. - 33.] ALU[DORQ] DEST[Q] NORM $ ];LOAD POINT
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 10. OF AR TO BIT 34. OF Q.
01m0003 10230 640704400571026010000000	        D[AR] ROT[1 + 10.] MASK[1] DEST[HOLD] NORM $
01m0003 10231 640700004175002440000000	        D[MEM] ROT[35. - 34.] ALU[DORQ] DEST[Q] NORM $ ];READY
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 34. OF AR TO BIT 35. OF Q.
01m0003 10232 640704400571106010000000	        D[AR] ROT[1 + 34.] MASK[1] DEST[HOLD] NORM $
01m0003 10233 640700004175000440000000	        D[MEM] ROT[35. - 35.] ALU[DORQ] DEST[Q] NORM $ ];END OF TAPE
01m0003                               	        ALU[Q] DEST[MEMSTO] NORM
01m0003 10234 662104200555000440000000	                COND[-MA-AC] LBJUMP[HIGHSMAIN] $
01m0003                               	
01m0003                               	
01m0003                               	        .PAIR
01m0003                               	. \ 2 + .
01m0004                               	]       UIOTRP[01m0004 10236 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0004                               	]$
01m0004                               	TAPENR: ;730, AC/COUNT.  READ WHOLE RECORD, STORING UP TO COUNT WORDS STARTING AT EFF
01m0004                               	 ADR.
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- SCI

01m0004                               	         ;SWAP AC AND IR, THEN DO TAPERX.
01m0004 10237 640140235171000440000000	        D[IR] DEST[O_AC IR-ADR] ACSEL[AC]  NORM JUMP[TAPERX] $ 
01m0004                               	
01m0004                               	        .PAIR
01m0004                               	. \ 2 + .
01m0005                               	]       UIOTRP[01m0005 10240 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0005                               	]$
01m0005                               	TAPERX: ;732 - (AC) IS START ADDR., E IS # OF WORDS TO READ.
01m0005 10241 640040000571000440000010	        NORM PUSHJ[KNYRGO] $ ;GET TAPE STARTED.
01m0005 10242 640041000551000443000100	        ALU[AC] ACSEL[AC] DEST[4] DEST-A-MEM PUSHJ[TRP2] NORM $ ;READ REC.
01m0005 10243 031140000571040440000000	        D[AR] ROT[16.] -OBUS<0 JUMP[TNRP3] $
01m0005                               	                ;Was record longer than word count ?
01m0005                               	                ;Jump unless FIFO RDY FOR BUF is on, indicating
01m0005                               	                ;  that tape supplied more bytes after count ran out.
01m0005 10244 640700014175074440000000	        D[CONST 44] ROT[30.] ALU[DORQ] DEST[Q] NORM $ ;YES, SET BIT 3.
01m0005 10245 640340001555000440000000	TNRP3:  ALU[Q] DEST[AC] ACSEL[AC] JPOP[GOMAIN] NORM $  ;NO, NOT TOO LONG.
01m0005                               	                ;MOVE STATUS INTO AC.
01m0005                               	
01m0005                               	
01m0005                               	UTAPWR: UIOTRP[01m0005 10246 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0005                               	]$
01m0005                               	
01m0005                               	TAPEWR: ;731, AC/ADR, E/+COUNT.  WRITE RECORD OF +COUNT
01m0005                               	        ; WORDS, DATA FROM ADR.
01m0005                               	        ;SET AC:=0 IF OPERATION COMPLETED SUCCESSFULLY.
01m0005                               	        ; SET AC:=<SETZ> + HIGHEST ADR READ IF REACHED
01m0005                               	        ; EOT DURING OPERATION (CURRENTLY THIS IS THE ONLY
01m0005                               	        ; ERROR CONDITION.)  OPERATION IS COMPLETED EVEN
01m0005                               	        ; IF EOT IS PASSED.
01m0005                               	
01m0005 10247 640701614571000123000000	        D[CONST 10.] DEST[7] DEST-A-MEM NORM $
01m0005                               	          ;SET UP ERROR RETRY COUNT.
01m0005 10250 640040000571000440000040	TWRTRY: NORM PUSHJ[DCINIT] $
01m0005                               	                ;Init. the data channel
01m0005 10251 640710040571002010000000	        D[10 + TPMODE]  ROT[1] MASK[1] DEST[AR] NORM $
01m0005                               	                ;Get the 32-bit mode flag.
01m0005 10252 640700000171014440000000	        D[AR] ROT[35. - 29.] DEST[Q] NORM $
01m0005                               	                ;Position it for the hardware.
01m0005 10253 640702214575016013600000	        START-OUT D[CONST 1] ROT[35. - 28.] ALU[DORQ] DEST[IOD] NORM $
01m0005                               	                ;Set the OUT bit.
01m0005 10254 000040014171032010040014	        MAPF[TP.WM] D[CONST 1] ROT[35. - 22.] DEST[Q] PUSHJ[KNYGOA] $
01m0005                               	                ;Issue WRITE command to formatter.
01m0005 10255 640041000551000443000047	        ALU[AC] DEST[4] DEST-A-MEM NORM PUSHJ[STRTDC] $
01m0005                               	                ;Get word count and start the channel.
01m0005 10256 031140004571100440000000	        D[MEM] ROT[32.] -OBUS<0 JUMP[TWERR] $ ;Test HARD ERR.
01m0005 10257 640700001615000440000000	        ALU[0] DEST[AC] NORM $ ;We return 0 in AC if no EOT.
01m0005 10260 511140004571104440000000	        D[MEM] ROT[34.] C550 OBUS<0 JUMP[GOMAIN] $
01m0005                               	         ;If no EOT seen, all done.
01m0005 10261 640140015561074600000000	        D[CONST 60] ROT[35. - 5] ALU[DORAC] DEST[AC] NORM JUMP[GOMAIN] $
01m0005                               	         ;Turn on bit 0 to indicate EOT seen during operation.
01m0005                               	
01m0005                               	TWERR:  ;;Error occurred during write. Backspace, erase gap, and retry.
01m0005 10262 640040000571000440000001	        NORM PUSHJ[KNYRS1] $ 
01m0005                               	          ;Blast the tape formatter and drive 
01m0005 10263 531140074131000440000000	        D[17] ALU[D-1] DEST[Q] C550 -OBUS<0 JUMP[TWER1] $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- SCI

01m0005                               	          ;See if we have had to many retry's already...
01m0005 10264 000140015571074500000000	        D[CONST 50] ROT[30.] DEST[AC] JUMP[GOMAIN] $
01m0005                               	           ;Hopeless. Give error return to prgm.
01m0005 10265 640041600555000443000203	TWER1:  ALU[Q] DEST[7] DEST-A-MEM NORM PUSHJ[TAPEBR] $
01m0005                               	         ;Start a BACKSPACE RECORD command.
01m0005 10266 640040000571000443400021	        START-IN NORM PUSHJ[FMNBWT] $ 
01m0005                               	         ;Wait for completion.
01m0005 10267 000040000571000440000174	        PUSHJ[TERASE] $
01m0005                               	         ;Start erasing a 3.75" gap.
01m0005 10270 640040000571000443400021	        START-IN NORM PUSHJ[FMNBWT] $ 
01m0005                               	         ;Wait for completion.
01m0005 10271 640140000571000440000250	        NORM JUMP[TWRTRY] $
01m0005                               	          ;Start write op again.
01m0005                               	
01m0005                               	
01m0005                               	;BOOTSTRAP LOADER FOR MACROCODE.
01m0005                               	
01m0005                               	 .ORG[01m0005                               	XLIST
01m0006                               	 LIST ]
01m0006 05000 000340000571000440005001	MBOOT:  JPOP[. + 1] $
01m0006                               	         ;The . + 1 is to make the lights look familiar for the operator...
01m0006 05001 000140000571000440000000	        JUMP[MBOOTA] $
01m0006                               	         ;MBOOTA takes us to MBOOTH, whether or not that is in high u-mem.
01m0006                               	
01m0006                               	.REPEAT XUCODE [ 01m0006                               	;If 8K u-mem, put this code in upper 4K
01m0006       5002	AREA50 = .
01m0006                               	 .USE[01m0006                               	XLIST
01m0006                               	 LIST ] ];XUCODE
01m0006                               	
01m0006 10272 000041614571000070000001	MBOOTH: D[CONST 7] DEST[DEV-ADR] PUSHJ[KNYCLR] $ ;RESET TAPE CTRL
01m0006 10273 640042600615000440000000	        ALU[0] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
01m0006 10274 640042614571044010000000	        D[CONST 1] ROT[18.] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
01m0006 10275 000041614571000070000010	        D[CONST 7] DEST[DEV-ADR] CYLEN[LONG] PUSHJ[KNYRGO] $
01m0006                               	                ;SELECT DEVICE 7, START READ.
01m0006 10276 640040000571000440000000	        NORM PUSHJ[KNYWAIT] $
01m0006 10277 240044430771000443420000	        MAPF[TP.RC] START-IN D[IOD] ALU[NOTD] DEST[HOLD] C800 PUSHJ[MBTBYX] $ 
01m0006                               	                ;Read 1st byte of new record.
01m0006 10300 640162600615000440000000	        ALU[0] DEST[MA HI-ABS-MA] NORM JUMP[P2A] $
01m0006                               	                ;Clear high-order MA and enter reading loop.
01m0006                               	
01m0006 10301 640060024433000440000000	P2:     D[MA] ALU[D+1] DEST[MA] PUSHJ[MBTBYTE] NORM $
01m0006 10302 640040004171070440000000	P2A:    D[MEM] ROT[34] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10303 640040004175050440000000	        D[MEM] ROT[24] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10304 640040004175030440000000	        D[MEM] ROT[14] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10305 640040004175010440000000	        D[MEM] ROT[4] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10306 640144204575000040000301	        D[MEM] MASK[4]  ALU[DORQ] DEST[MEMSTO] NORM JUMP[P2] $
01m0006                               	
01m0006 10307 640720000615000440000000	CCLR:   ALU[0] DEST[MA] NORM $
01m0006 10310 640704200615000440000000	        ALU[0] DEST[MEMSTO] NORM $
01m0006 10311 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
01m0006 10312 470140024571000220000310	        D[MA] MASK[18.] COND[-OBUS=0] JUMP[. - 2] C600 $
01m0006 10313 640300000571000440000000	        POPJ NORM $
01m0006                               	
01m0006                               	MBTBYTE:
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- SCI

01m0006 10314 640740014571002353400000	        START-IN D[CONST 35] ROT[1] LLOAD NORM $
01m0006                               	                ;Ask tape for a byte and status thereof
01m0006                               	                ;Set loop counter to do timeout
01m0006                               	                ;(TIMEOUT ABOUT 78 USEC)
01m0006 10315 240244430571000440020000	MBTBY1: MAPF[TP.RC] D[IOD] DEST[HOLD] C800 LOOP[MBTBY2] $
01m0006                               	                ;Read byte and status.  Byte comes complemented.
01m0006                               	                ;Result is put in HOLD to avoid synchronizer problems
01m0006                               	                ;Do timeout check and branch if still waiting
01m0006 10316 640040000571000443400000	        START-IN NORM PUSHJ[MBTCHECK] $
01m0006                               	                ;Byte wasn't ready in time.  Go find out why
01m0006 10317 000040000571000440000010	        PUSHJ[KNYRGO] $ ;START NEXT RECORD.
01m0006 10320 640040000571000440000000	        NORM PUSHJ[KNYWAIT] $
01m0006 10321 240044430771000443420000	        MAPF[TP.RC] START-IN D[IOD] ALU[NOTD] DEST[HOLD] C800 PUSHJ[MBTBYX] $ 
01m0006                               	                ;Read 1st byte of new record.
01m0006 10322 640340000571000440000302	        NORM JPOP[P2A] $
01m0006                               	                ;Go for another record
01m0006                               	;       ---
01m0006                               	MBTBY2:
01m0006 10323 531140004571064443400315	        START-IN D[MEM] ROT[26.] -OBUS<0 C550 JUMP[MBTBY1] $
01m0006                               	                ;Check for byte ready (this is a two instruction loop)
01m0006                               	                ;Start getting byte and status again in case we have
01m0006                               	                ;  to loop
01m0006 10324 240704430771000443420000	        START-IN MAPF[TP.RC] D[IOD] ALU[NOTD] DEST[HOLD] C800 $
01m0006                               	                ;READ THE DATA AGAIN (NOW THAT IT'S STABLE !)
01m0006 10325 500304404571000100010000	MBTBYX: MAPF[1] D[MEM] MASK[10] DEST[HOLD] C550 POPJ $
01m0006                               	                ;MAPF[1] clears byte ready
01m0006                               	                ;Extract data byte from other status information
01m0006                               	
01m0006                               	;       ---
01m0006                               	
01m0006                               	KNYWAIT: ;Wait for first byte of read data (BOOTSTRAP mode only)
01m0006 10326 640700000571000443400000	        START-IN SHORT $
01m0006 10327 640710014571030773410000	        MAPF[1] START-IN D[CONST 77] ROT[12.] DEST[AR] NORM $
01m0006                               	                ;Clear read data ready flag
01m0006 10330 440704430571000440020000	KNYW1:  MAPF[TP.RC] D[IOD] DEST[HOLD] C600 $
01m0006 10331 511300004571064443400000	        START-IN D[MEM] ROT[26.] OBUS<0 POPJ C550 $
01m0006                               	                ;Return if READ DATA RDY is now on.
01m0006 10332 530150000531000443400330	        START-IN D[AR] ALU[D-1] DEST[AR] C550 -OBUS=0 JUMP[KNYW1] $
01m0006 10333 640300000571000440000000	        NORM POPJ $
01m0006                               	
01m0006 10334 640040000571000443400021	MBTCHECK:       START-IN NORM PUSHJ[FMNBWT] $
01m0006                               	          ;WAIT FOR FORMATTER IDLE.
01m0006 10335 531140004571100440000000	        D[MEM] ROT[32.] C550 -OBUS<0 JUMP[MBTERR] $
01m0006                               	          ;CHECK FOR ERROR STATUS.
01m0006 10336 511300004571102440000000	        D[MEM] ROT[33.] C550 OBUS<0 POPJ $
01m0006                               	          ;IF END OF FILE NOT SEEN, RETURN FOR MORE, ELSE DONE.
01m0006 10337 640700000215000440000000	        ALU[0] DEST[Q] NORM $ ;CLEAR LIGHTS TO INDICATE NO ERRORS.
01m0006 10340 000341600615000443600341	MBTDNX: START-OUT ALU[0] DEST[DEV-ADR] JPOP[. + 1] $
01m0006                               	                ;Setup to display code in lights
01m0006 10341 000340000555000443620342	        START-OUT MAPF[2] ALU[Q] JPOP[. + 1] $  ;LOAD LIGHTS FROM Q, CLR SW FF'S
01m0006 10342 000700000571000443440000	D1:     MAPF[4] START-IN $
01m0006                               	           ;CHECK START AND CONT SWITCHES.  RD NEXT FILE ON CONT
01m0006 10343 000710030571000440040000	        MAPF[4] D[IOD] DEST[AR] $
01m0006                               	        D[AR]  ROT[5] MASK[2] DEST[AR]
01m0006 10344 010150000571012020000342	                COND[OBUS=0] JUMP[D1] CYLEN[LONG] $
01m0006                               	                ;WAIT FOR A SWITCH.
01m0006 10345 530140000571000010000000	        D[AR] MASK[1] COND[-OBUS=0] JUMP[GOMSTART] C550 $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- SCI

01m0006                               	           ;  ... START MAIN MICROCODE ON START SWITCH.
01m0006 10346 640700000571000443600000	        START-OUT NORM $  ;CLEAR SWITCH FF'S
01m0006 10347 000340000571000440040272	        MAPF[4] JPOP[MBOOTH] CYLEN[LONG] $
01m0006                               	
01m0006                               	GOMSTART: ;Branch to MSTART
01m0006                               	        GETADR[ ;Place the 12-bit value of MSTART in Q.
01m0006 10350 640700014171014400000000	        D[CONST (77 & (MSTART / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
01m0006 10351 440140014175000000000000	        D[CONST (MSTART \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOLOW] $
01m0006                               	
01m0006 10352 000140014371000000000340	MBTERR: D[CONST 0] ALU[NOTD] DEST[Q] JUMP[MBTDNX] $
01m0006                               	;       ---
01m0006                               	
01m0006                               	  .ORG[01m0006                               	XLIST
01m0007                               	 LIST ]
01m0007 02150 000140000571000440002150	        JUMP[.] $       ;Hang if any interrupts from device 7 occur.
01m0007                               	
01m0007                               	    .USE[XLIST
01m0007                               	 LIST ] ;RETURN TO OLD LOC. CTR.
01m0007                               	
01m0007                               	MBOOTA: GETADR[ ;Place the 12-bit value of MBOOTH in Q.
01m0007 06220 640700014171014020000000	        D[CONST (77 & (MBOOTH / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
01m0007 06221 440140014175000720000000	        D[CONST (MBOOTH \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOHIGH] $
01m0007                               	        

SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

33m0150                               	  ]
33m0150                               	  ];NTP
33m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

34m0150                               	.REPEAT KNYTAPE [ 34m0150                               	;ENDX OF KENNEDY TAPE CODE
34m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

35m0150                               	.REPEAT TLXTAPE [ 35m0150                               	;ENDX OF TELEX TAPE CODE
35m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

36m0150                               	.REPEAT SLOWTAPE [ 36m0150                               	;END OF SLOW TAPE CODE
36m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

37m0150                               	.REPEAT 125TAPE [ 37m0150                               	;END OF SLOW 125 IPS TAPE CODE
37m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

38m0150                               	;TAPE DISPATCH
38m0150                               	
38m0150                               	 .REPEAT 1 - XUCODE [ 38m0150                               	;1 - XUCODE
38m0150                               	
38m0150                               	
38m0150                               	 .REPEAT XUCODE [ 38m0150                               	;If we don't have extended ucode memory, these are different.
38m0150                               	
38m0150                               	.OPCODE[LIST 
38m0150                               	 LIST            ];TAPE IOTS
38m0150                               	
38m0150                               	;725 - Obsolete version of read (no word count, E = core address.)
38m0150                               	        GETADR[ ;Place the 12-bit value of TAPERD in Q.
38m0150 03652 640700014171014000000000	        D[CONST (77 & (TAPERD / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03653 440140014175000050000000	        D[CONST (TAPERD \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;726 - MTAPE
38m0150                               	        GETADR[ ;Place the 12-bit value of TAPEMT in Q.
38m0150 03654 640700014171014010000000	        D[CONST (77 & (TAPEMT / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03655 440140014175000550000000	        D[CONST (TAPEMT \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;727 - READ STATUS
38m0150                               	        GETADR[ ;Place the 12-bit value of TAPERS in Q.
38m0150 03656 640700014171014020000000	        D[CONST (77 & (TAPERS / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03657 440140014175000140000000	        D[CONST (TAPERS \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;730 - OBSOLETE ! --read 1 record, store up to (AC) words starting at E.
38m0150                               	        GETADR[ ;Place the 12-bit value of TAPENR in Q.
38m0150 03660 640700014171014020000000	        D[CONST (77 & (TAPENR / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03661 440140014175000370000000	        D[CONST (TAPENR \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;731 - WRITE 1 record of E words starting from CORE LOC IN AC.
38m0150                               	        GETADR[ ;Place the 12-bit value of TAPEWR in Q.
38m0150 03662 640700014171014020000000	        D[CONST (77 & (TAPEWR / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03663 440140014175000470000000	        D[CONST (TAPEWR \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;732 - READ 1 record, store up to E words starting at (AC).
38m0150                               	        GETADR[ ;Place the 12-bit value of TAPERX in Q.
38m0150 03664 640700014171014020000000	        D[CONST (77 & (TAPERX / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03665 440140014175000410000000	        D[CONST (TAPERX \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	
38m0150                               	  ];XUCODE
38m0150                               	
38m0150                               	.RELOC
38m0150                               	USE[38m0150                               	XLIST
38m0151                               	 LIST ]]
38m0151 06222 025141614571000070000000	TAPDSP: D[CONST 7] DEST[DEV-ADR] COND[-USER] JUMP[GOHIGH] $
38m0151                               	         ;Load device code for tape, test for user mode.
38m0151                               	        UIOTRP[38m0151 06223 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
38m0151                               	]$
38m0151                               	         ;In user mode-- trap unless IOT USER
38m0151                               	
38m0151                               	GOHIGH:  ;Jump into high part of umemory, using 12-bit addr. in Q
38m0151 06224 440540014433022120000000	        D[CONST (XUCODE * 10) + 2] ROT[9.] ALU[D+1] C600 SDISP $
38m0151                               	          ;This takes us to loc. 2001 and pre-sets the 10000 bit.
38m0151                               	 .ORG[38m0151                               	XLIST
38m0152 02001 000540014575030010000000	 LIST ] D[CONST XUCODE] ROT[12.] ALU[DORQ] SDISP $
38m0152                               	          ;This finally takes us to loc. 10000+[Q] 
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

38m0152                               	
38m0152                               	 .RELOC
38m0152                               	USE[38m0152                               	XLIST
38m0153                               	 LIST ]]
38m0153                               	  .REPEAT XUCODE [
38m0153                               	.USE[XLIST
38m0153                               	 LIST ]$
38m0153                               	     ]
38m0153                               	 .PAIR
38m0153                               	. \ 2 + .
38m0154                               	]HIGHSMAIN:
38m0154 10354 640140005570400440000000	        D[MEM] ACSEL[MA] DEST[AC] NORM JUMP[GOMAIN] $
38m0154 10355 640140000571000440000000	        NORM JUMP[GOMAIN] $
38m0154                               	
38m0154                               	GOMAIN: GETADR[ ;Place the 12-bit value of MAIN in Q.
38m0154 10356 640700014171014200000000	        D[CONST (77 & (MAIN / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0154 10357 440700014175000260000000	        D[CONST (MAIN \ 100)] ALU[DORQ] DEST[Q] C600 ] $        ;Do extended mode jump to
38m0154                               	 MAIN.
38m0154                               	
38m0154                               	GOLOW:   ;Jump to loc. in lower 4K indicated by contents of Q.
38m0154                               	
38m0154                               	   .REPEAT XUCODE [
38m0154 10360 440540000615000440000000	        ALU[0] C600 SDISP $
38m0154                               	         ;This goes to loc. 10000 and pre-clears the 10000 bit.
38m0154                               	 .ORG[38m0154                               	XLIST
38m0154                               	 LIST ]   ];XUCODE
38m0154                               	
38m0154 10000 440540000555000440000000	        C600 ALU[Q] SDISP $
38m0154                               	         ;Now we actually go to low u-mem.
38m0154                               	
38m0154                               	.USE[38m0154                               	XLIST
38m0155                               	 LIST ]
38m0155                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

39m0155                               	
39m0155                               	
39m0155                               	;------------------------------------------------------------------------------
39m0155                               	;
39m0155                               	;       FooVision
39m0155                               	;
39m0155                               	;------------------------------------------------------------------------------
39m0155                               	.REPEAT VID [
39m0155                               	VID
39m0155                               	        .OPCODE[39m0155                               	LIST 
39m0156                               	 LIST            ].REPEAT ((1 - VID) * (773 - 766 + 1)) [
39m0156                               	        ILGIOT 39m0156 03754 000140000571000440002026	 JUMP [MAIN] ]$                 ;OPS 766:773
39m0156 03755 000700000571000440000000	        NOP $
39m0156                               	]39m0156                               	        ILGIOT 39m0156 03756 000140000571000440002026	 JUMP [MAIN] ]$                 ;OPS 766:773
39m0156 03757 000700000571000440000000	        NOP $
39m0156                               	]39m0156                               	        ILGIOT 39m0156 03760 000140000571000440002026	 JUMP [MAIN] ]$                 ;OPS 766:773
39m0156 03761 000700000571000440000000	        NOP $
39m0156                               	]39m0156                               	        ILGIOT 39m0156 03762 000140000571000440002026	 JUMP [MAIN] ]$                 ;OPS 766:773
39m0156 03763 000700000571000440000000	        NOP $
39m0156                               	]39m0156                               	        ILGIOT 39m0156 03764 000140000571000440002026	 JUMP [MAIN] ]$                 ;OPS 766:773
39m0156 03765 000700000571000440000000	        NOP $
39m0156                               	]39m0156                               	        ILGIOT 39m0156 03766 000140000571000440002026	 JUMP [MAIN] ]$                 ;OPS 766:773
39m0156 03767 000700000571000440000000	        NOP $
39m0156                               	]1-VID
39m0156                               	.REPEAT VID [
39m0156                               	VID
39m0156                               	        .RELOC
39m0156                               	USE[39m0156                               	XLIST
39m0157                               	 LIST ]]
39m0157                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

40m0157                               	
40m0157                               	;FLOATING POINT, KA10 STYLE.
40m0157                               	;NONDISPATCH CODE.
40m0157                               	.DEFINE CFPLOW[40m0157                               	.DEFINE JINSEXP[40m0157                               	.DEFINE CINSEXP[40m0157                               	.DEFINE CFDS[40m0157                               	
40m0157                               	;***** DON'T USE A-MEM 0 FOR ANYTHING BESIDES DISPATCHES!!!     TVR-Sep80  *****
40m0157                               	;***** This must be fixed!!!!                                   TVR-Sep80  *****
40m0157 06225 640050000551000443000000	UFA1:   ALU[AC] DEST[0 AR] DEST-A-MEM PUSHJ[FADSUB] NORM $
40m0157 06226 640710041171000440000000	        D[10] DEST[AR O_AC] SHORT $
40m0157 06227 000160001571400440602027	        D[AR] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] $
40m0157                               	
40m0157                               	        .PAIR   . \ 2 + .
40m0157                               	];: 6460                ;.PAIR
40m0157 06230 640140001751000440006232	DFN1:   ALU[NOTAC] DEST[AC] JUMP[. + 2] NORM $
40m0157 06231 640700001513000440000000	        ALU[0-AC] DEST[AC] SHORT $
40m0157 06232 640700004171000440000000	        D[MEM] DEST[Q] SHORT $
40m0157 06233 640700010235066110000000	        D[MASK 9] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
40m0157 06234 662104200575000330002032	        D[AR] MASK[27.] ALU[DORQ] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157                               	
40m0157                               	
40m0157 06235 640160001615000440602027	FSCZAP: ALU[0] DEST[MA AC] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0157 06236 640710000171022110000000	FSC1:   D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
40m0157 06237 531140011661066100000000	        D[MASK 8] ROT[27.] ALU[-D&AC] DEST[AC] COND[-OBUS<0] JUMP[FSC2] C550 $
40m0157 06240 640710010335000110000000	        D[MASK 9] ALU[D#Q] DEST[Q AR] SHORT $
40m0157 06241 640700011561066100000000	        D[MASK 8] ROT[27.] ALU[DORAC] DEST[AC] SHORT $
40m0157 06242 640700224435000220000000	FSC2:   D[MA] MASK[18.] ALU[D+Q] DEST[IR-ADR] SHORT $
40m0157 06243 640040000215000440000000	        ALU[0] DEST[Q] PUSHJ[NRMLIZ] NORM $
40m0157 06244 640040000171066440000000	        CINSEXP [AR] ROT[27.] DEST[Q] PUSHJ[INSEX1] NORM ]$
40m0157 06245 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0157                               	
40m0157                               	FAOS1:
40m0157                               	FAOS5:
40m0157 06246 640050000551000440000000	        ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
40m0157 06247 640160000571000440602027	        DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0157 06250 640050000551000440000000	FAOS2:  ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
40m0157 06251 640140001571400440000000	        CFPLOW [AR] ACSEL[AC+1] DEST[AC] JUMP[FPLOW] NORM ]$
40m0157 06252 640710000551000440000000	FAOS3:  ALU[AC] DEST[AR] NORM $
40m0157 06253 640701614571000110000000	        D[CONST 11] DEST[DEV-ADR] SHORT $
40m0157 06254 640040000551000443000000	        ALU[AC] DEST[0] DEST-A-MEM PUSHJ[FADSUB] NORM $
40m0157 06255 662104241171000440002032	        D[10] DEST[MEMSTO O_AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157 06256 640050000551000440000000	FAOS4:  ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
40m0157 06257 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157                               	
40m0157                               	FMP1:
40m0157                               	FMP5:
40m0157 06260 640050000551000440000000	        ALU[AC] DEST[AR] PUSHJ[FM] NORM $
40m0157 06261 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0157 06262 640050000551000440000000	FMP2:   ALU[AC] DEST[AR] PUSHJ[FM] NORM $
40m0157 06263 640140001571400440000000	        CFPLOW [AR] ACSEL[AC+1] DEST[AC] JUMP[FPLOW] NORM ]$
40m0157 06264 640710000551000440000000	FMP3:   ALU[AC] DEST[AR] NORM $
40m0157 06265 640701614571000110000000	        D[CONST 11] DEST[DEV-ADR] SHORT $
40m0157 06266 640040000551000443000000	        ALU[AC] DEST-A-MEM PUSHJ[FM] DEST[0] NORM $
40m0157 06267 662104241171000440002032	        D[10] DEST[MEMSTO O_AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157 06270 640050000551000440000000	FMP4:   ALU[AC] DEST[AR] PUSHJ[FM] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

40m0157 06271 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157                               	
40m0157                               	;Macro to test for divide by zero
40m0157                               	.DEFINE DIVTST[40m0157                               	
40m0157                               	;;;FD5: D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] NORM $     ;Not needed.  TVR-Apr80
40m0157                               	
40m0157                               	;FDV,FDVR
40m0157 06272 510140004571000330000000	FD1:    DIVTST [MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$ ;Check for divide by zero
40m0157                               	
40m0157 06273 640050004721000440000000	        CFDS [MEM] ALU[D#AC] DEST[AR] PUSHJ[FDS1] NORM]$
40m0157 06274 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0157                               	
40m0157                               	;------------------------------------------------------------------------------
40m0157                               	;LONG MODE FLOATING DIVIDE.
40m0157                               	;------------------------------------------------------------------------------
40m0157 06275 510140004571000330000000	FD2:    DIVTST [MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$
40m0157                               	 ;AR.0,IR.35:=XOR(DIVIDEND SIGN,DIVISOR SIGN).
40m0157 06276 640710004721000440000000	        D[MEM] ALU[D#AC] DEST[AR] SHORT $
40m0157 06277 640700200571002010000000	        D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
40m0157                               	 ;Flush sign & exponent from Dividend Low
40m0157 06300 640710010621400330000000	        D[MASK 27.] ALU[D&AC] ACSEL[AC+1] DEST[AR] SHORT $
40m0157 06301 640700001571422440000000	        D[AR] ROT[9] DEST[AC] ACSEL[AC+1] SHORT $
40m0157                               	 ;Positive form of Dividend to AC, AR; original form to AMEM[1]
40m0157 06302 631150200551000443000000	        ALU[AC] DEST[AR 1] DEST-A-MEM COND[-OBUS<0] JUMP[FD2A] CYLEN[C450] $
40m0157 06303 510140001513400440006305	        ALU[0-AC] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[. + 2] C550 $
40m0157 06304 640150001751000440006306	        ALU[NOTAC] DEST[AC AR] JUMP[. + 2] SHORT $
40m0157 06305 640710001513000440000000	        ALU[0-AC] DEST[AC AR] NORM $
40m0157 06306 640710014421066010000000	FD2A:   D[CONST 1] ROT[27.] ALU[AC+D] DEST[AR] NORM $
40m0157                               	         ;Add 1 to exp. of dividend, since we will do only a 27-bit divide.
40m0157 06307 640701400551400443000000	        ALU[AC] ACSEL[AC+1] DEST[6] DEST-A-MEM NORM $
40m0157                               	         ;Put low-order mantissa in AMEM[6] for FD.
40m0157 06310 640740014571000330000000	        D[CONST 27.] LLOAD NORM $ 
40m0157                               	         ;Do only a 27-bit divide, so remainder will come out right.
40m0157 06311 640040000571000440000000	        PUSHJ[FD] NORM $        
40m0157                               	         ;Perform the divide (returns: AC=quotient, AMEM[6]=remainder)
40m0157                               	 ;AC+1 gets 0 if remainder = 0.
40m0157 06312 510140071571400440000000	        D[16] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[FD2D] C550 $
40m0157                               	 ;Calculate exponent of remainder.
40m0157 06313 531140044171000440006316	        D[11]  DEST[Q] C550 -OBUS<0 JUMP[. + 3] $
40m0157                               	         ;Check sign of dividend, jump if positive.
40m0157 06314 640700200517000443000000	         ALU[0-Q] DEST[1] DEST-A-MEM NORM $
40m0157                               	          ;Negate the dividend (so the exponent will be in pos. form)
40m0157 06315 640700001513400440000000	         ACSEL[AC+1] ALU[0-AC] DEST[AC] NORM $
40m0157                               	          ;Negate the remainder.
40m0157 06316 640700044171022100000000	        D[11] ROT[9.] MASK[8] DEST[Q] NORM $
40m0157                               	         ;Recover exp. of dividend.
40m0157                               	 ;A-MEM[7] has (dividend HOW)-(divisor).
40m0157 06317 531140074571000440006321	        D[17] COND[-OBUS<0] JUMP[. + 2] C550 $
40m0157 06320 640700014077000010000000	         D[CONST 1] ALU[Q-D] DEST[Q] SHORT $
40m0157 06321 453140014077000320000000	        D[CONST 26.] ALU[Q-D] DEST[Q] COND[OBUS18] JUMP[FD2C] C600 $
40m0157                               	         ;Jump if exponent underflow.
40m0157                               	.DEFINE SWAPAC[40m0157                               	
40m0157                               	 ;SWAP QUOTIENT (AC) AND REMAINDER (AC+1)
40m0157                               	        SWAPAC
40m0157                               	;Interchange (AC) and (AC+1)
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

40m0157 06322 640710000551400440000000	        ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
40m0157 06323 640710001171000440000000	        D[AR] DEST[AR O_AC] SHORT $
40m0157 06324 640700001571400440000000	        D[AR] ACSEL[AC+1] DEST[AC] SHORT $
40m0158                               	  ] ;INSERT EXPONENT INTO REMAINDER.
40m0158 06325 640050000555000440000000	        ALU[Q] DEST[AR] PUSHJ[INSEXP] NORM $
40m0158                               	        SWAPAC
40m0158                               	;Interchange (AC) and (AC+1)
40m0158 06326 640710000551400440000000	        ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
40m0158 06327 640710001171000440000000	        D[AR] DEST[AR O_AC] SHORT $
40m0158 06330 640700001571400440000000	        D[AR] ACSEL[AC+1] DEST[AC] SHORT $
40m0159 06331 640160000571000440602027	  ]FD2D:        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0159                               	
40m0159 06332 640160001615400440602027	FD2C:   ALU[0] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0159                               	
40m0159 06333 510140004571000330000000	FD3:    DIVTST [MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$
40m0159 06334 640040000551000443000000	        ALU[AC] DEST[0] DEST-A-MEM PUSHJ[FDS] NORM $
40m0159 06335 662104241171000440002032	        D[10] DEST[MEMSTO O_AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0159 06336 510140004571000330000000	FD4:    DIVTST [MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$
40m0159 06337 640050004721000440000000	        CFDS [MEM] ALU[D#AC] DEST[AR] PUSHJ[FDS1] NORM]$
40m0159 06340 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0159                               	
40m0159                               	;HERE ON DIVISOR=0.  SET NO DIVIDE, OVF,FLOV,RETURN.
40m0159 06341 640700020171000440000000	FPNDIV: D[PC] DEST[Q] SHORT $
40m0159 06342 640040014175056010000000	        D[CONST 1] ROT[23.] ALU[DORQ] DEST[Q] PUSHJ[SETFOV] NORM $
40m0159 06343 640160000571000440602027	        DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;NORMALIZE DOUBLE PRECISION NUMBER IN AC,Q WHOSE EXPONENT
40m0159                               	; IS IN IR-ADR.  LEAVE EXPONENT IN AR, NORMALIZED NUMBER IN AC,Q.
40m0159                               	; IF NUMBER IS 0, LEAVE 0 IN AR,AC, AND Q.
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	.DEFINE CNORM[40m0159                               	
40m0159                               	;A. Return immediately if 0.
40m0159 06344 510310000545000440000000	NRMLIZ: ALU[QORAC] DEST[AR] COND[OBUS=0] POPJ C550 $
40m0159                               	;B. Check for mantissa overflow, move exponent to AR.
40m0159 06345 640050000551000440000000	        ALU[AC] DEST[AR] PUSHJ[NORMOV] NORM $
40m0159                               	                ;Check mantissa and shift right if necessary
40m0159 06346 530300034571000220000000	        D[IR] MASK[18.] COND[-OBUS=0] POPJ C550 $
40m0159                               	                ;If we adjusted right, then we definitely don't have to
40m0159                               	                ;shift left.  We're done here.
40m0159                               	;C. Left shift until normalized.
40m0159 06347 611140000551000440000000	        ALU[AC] COND[OBUS<0] JUMP[NEGNOR] CYLEN[C450] $
40m0159                               	                ;Separate into two cases, positive and negative
40m0159 06350 530300014621064010000000	POSNOR: D[CONST 1] ROT[26.] ALU[D&AC] COND[-OBUS=0] POPJ C550 $
40m0159                               	                ;If high order bit of mantissa is one, we're done
40m0159 06351 640710000531000440000000	        D[AR] ALU[D-1] DEST[AR] SHORT $
40m0159                               	                ;Decrement the exponent
40m0159 06352 640140003145000020006350	        ALU[SH-AC] MASK[2] DEST[D6] JUMP[POSNOR] NORM $
40m0159                               	                ;Shift left and try again.
40m0159 06353 510140014621064010000000	NEGNOR: D[CONST 1] ROT[26.] ALU[D&AC] COND[OBUS=0] JUMP[NN1] C550 $
40m0159                               	                ;If high order bit of mantissa is zero, we're done
40m0159 06354 640710000531000440000000	        D[AR] ALU[D-1] DEST[AR] SHORT $
40m0159                               	                ;Decrement the exponent
40m0159 06355 640140003145000020006353	        ALU[SH-AC] MASK[2] DEST[D6] JUMP[NEGNOR] NORM $
40m0159                               	                ;Shift left and try again.
40m0159 06356 530300010621000330000000	NN1:    D[MASK 27.] ALU[D&AC] COND[-OBUS=0] POPJ C550 $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

40m0159                               	                ;Check for case of exactly -(2^n).  If it isn't, we're done
40m0159 06357 640700015561064010000000	        D[CONST 1] ROT[26.] ALU[DORAC] DEST[AC] SHORT $
40m0159                               	                ;We went one too far, backup by simply OR'ing in the relevant
40m0159                               	                ;bit in the same manner as shifting would. 
40m0159                               	                ;(*** What about Q??  TVR-Jul80)
40m0159 06360 640310000433000440000000	        D[AR] ALU[D+1] DEST[AR] POPJ NORM $
40m0159                               	                ;Increment exponent to account for simulated left shift.
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;CHECK FOR MANTISSA OVERFLOW INTO EXPONENT FIELD.  CALL WITH
40m0159                               	; AR&AC,Q: # TO NORMALIZE, IR-ADR: ITS EXPONENT.
40m0159                               	; LEAVE EXPONENT IN AR.  SET IR-ADR=0 IF NO OVERFLOW.  SET IR-ADR<>0
40m0159                               	; IF OVERFLOW, AND NORMALIZE.
40m0159                               	;
40m0159                               	;M.O. <=> [AR0<>AR8] OR [(AR8=1) AND (AR9-35=0)]
40m0159                               	;------------------------------------------------------------------------------
40m0159 06361 511140000721020440000000	NORMOV: D[AR] ROT[8] ALU[D#AC] COND[OBUS<0] JUMP[NOVYES] C550 $
40m0159                               	                ;Check to make sure AR<0>=AR<8>.  If they don't, the mantissa
40m0159                               	                ;clearly overlaps the exponent field.
40m0159 06362 530140010621000330000000	        D[MASK 27.] ALU[D&AC] COND[-OBUS=0] JUMP[NOVNO] C550 $
40m0159                               	                ;Check for AR<9:35> for zero.  If not zero, we're OK
40m0159 06363 510140014621066010000000	        D[CONST 1] ROT[27.] ALU[D&AC] COND[OBUS=0] JUMP[NOVNO] C550 $
40m0159                               	                ;Check AR<8>.  If zero, we're OK
40m0159                               	;       \ /
40m0159                               	;Mantissa has overflowed, adjust it.  Right by one should be enough.
40m0159 06364 640700002145000010000000	NOVYES: ALU[SH-AC] MASK[1] DEST[D4] SHORT $
40m0159                               	                ;Shift mantissa right (i think?)
40m0159 06365 640310234433000220000000	        D[IR] MASK[18.] ALU[D+1] DEST[AR IR-ADR] POPJ NORM $
40m0159                               	                ;Increment mantissa and flag that we changed it by setting
40m0159                               	                ;IR<18:35> to be non-zero.
40m0159                               	
40m0159                               	;Mantissa has not overflowed.
40m0159 06366 640710034571000220000000	NOVNO:  D[IR] MASK[18.] DEST[AR] SHORT $
40m0159                               	                ;Save exponent in AR
40m0159 06367 640300200615000440000000	        ALU[0] DEST[IR-ADR] POPJ NORM $
40m0159                               	                ;Zero IR<18:35> to signify success
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;INSERT EXPONENT IN AR INTO WORD IN AC.
40m0159                               	;SET FLOV,FLUN,OVF FLAGS AS REQUIRED.
40m0159                               	;PRESERVES AR, CLOBBERS Q.
40m0159                               	;------------------------------------------------------------------------------
40m0159 06370 640700000171066440000000	INSEXP: D[AR] ROT[27.] DEST[Q] NORM $
40m0159                               	                ;Move exponent into position
40m0159 06371 640700010235066100000000	INSEX1: D[MASK 8.] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
40m0159                               	                ;Flush stuff in mantissa area
40m0159 06372 640700001705000440000000	        ALU[Q#AC] DEST[AC] SHORT $
40m0159                               	                ;Fill in exponent (complementing it if (AC) is negative !)
40m0159 06373 513140000571000440000000	        D[AR] COND[OBUS18] JUMP[EXPUF] C550 $
40m0159                               	                ;Check for underflow (i.e. below range of exponent offset)
40m0159 06374 510300000571070120000000	        D[AR] MASK[10.] ROT[28.] COND[OBUS=0] POPJ C550 $
40m0159                               	                ;Check for overflow (i.e. above range of exponent offset)
40m0159 06375 640700020171000440000000	        D[PC] DEST[Q] SHORT $
40m0159                               	                ;Setup to set floating overflow
40m0159 06376 640305414575100110000000	SETFOV: D[CONST 11] ROT[32.] ALU[DORQ] DEST[CRYOV] POPJ NORM $
40m0159                               	                ;Turn on overflow and floating overflow
40m0159 06377 640700020171000440000000	EXPUF:  D[PC] DEST[Q] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

40m0159                               	                ;Setup to set no divide and floating overflow
40m0159 06400 640140014175060010006376	        D[CONST 1] ROT[24.] ALU[DORQ] DEST[Q] JUMP[SETFOV] NORM$
40m0159                               	                ;Turn on no divide, then do overflows
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;FLOATING ADD AC&AR TO MEM.  RESULT, NORMALIZED AND ROUNDED
40m0159                               	; IF REQUIRED IN AC,Q.
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	.DEFINE BLEXPS[40m0159                               	BLEXPS
40m0159                               	        ;A. + FORM EXPONENT OF AC,MEM RTO AR,Q RESP.
40m0159 06401 640710000171022110000000	FADSUB: D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
40m0159 06402 510140014635020010000000	FADSU1: D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS1] C550 $
40m0159 06403 640710010735000110000000	        D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
40m0159 06404 640700004171022110000000	FS1:    D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
40m0159 06405 510140014635020010000000	        D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS2] C550 $
40m0159 06406 640700010335000110000000	        D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
40m0159                               	        ;B. COMPUTE DIFFERENCE, SWAP OPRANDS IF AC HAS LARGER EXP.
40m0159                               	        ;   LEAVE + DIFFERENCE IN Q, DIFF -1 IN LOOP CTR.
40m0159                               	        ;   LEAVE LARGER EXPONENT IN IR-ADR.
40m0159 06407 640700200555000440000000	FS2:    ALU[Q] DEST[IR-ADR] SHORT $
40m0159 06410 471140000077000440000000	        D[AR] ALU[Q-D] DEST[Q] COND[-OBUS<0] JUMP[FS3] C600 $
40m0159 06411 640700200571000440000000	        D[AR] DEST[IR-ADR] SHORT $
40m0159 06412 640704405171000440000000	        D[MEM] DEST[HOLD O_AC] NORM $
40m0159 06413 640700000117000440000000	        ALU[0-Q] DEST[Q] NORM $
40m0159 06414 640750000455000440000000	FS3:    ALU[Q-1] DEST[AR] LLOAD NORM $
40m0159                               	        ;C. BLANK EXPONENTS.
40m0159                               	        BLEXPS[40m0159 06415 511140011561066100006417	        D[MASK 8] ROT[27.] ALU[DORAC] DEST[AC] COND[OBUS<0] JUMP[. + 2] C550 $
40m0159 06416 640700011661066100000000	        D[MASK 8] ROT[27.] ALU[-D&AC] DEST[AC] SHORT $
40m0159 06417 511140004171000440006421	        D[MEM] DEST[Q] COND[OBUS<0] JUMP[. + 2] C550 $
40m0159 06420 640144410675066100006422	        D[MASK 8] ROT[27.] ALU[-D&Q] DEST[HOLD] JUMP[. + 2] NORM $
40m0159 06421 640704410575066100000000	        D[MASK 8] ROT[27.] ALU[DORQ] DEST[HOLD] CYLEN[NORM] $
40m0160                               	]       ;D. IF DELTA EXPONENTS >62., AC GOES TO OBLIVION.
40m0160 06422 450140000033000440000000	        D[AR] ALU[D+1] DEST[Q] COND[OBUS=0] JUMP[FS5] C600 $
40m0160 06423 451140014477000770000000	        D[CONST 63.] ALU[Q-D] COND[OBUS<0] JUMP[FS4] C600 $
40m0160 06424 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
40m0160 06425 640140000215000440000000	        ALU[0] DEST[Q] JUMP[FS5] NORM $
40m0160 06426 640700000215000440000000	FS4:    ALU[0] DEST[Q] SHORT $
40m0160 06427 640240002145000010006427	        ALU[SH-AC] DEST[D4] MASK[1] LOOP [.] NORM $
40m0160                               	        ;E. ADD.
40m0160 06430 640710004421000440000000	FS5:    D[MEM] ALU[D+AC] DEST[AR] SHORT $
40m0160                               	        ;F. NORMALIZE RESULT.
40m0160 06431 640700035571000440000000	        D[IR] DEST[AC] SHORT $  ;CHECK FOR UFA
40m0160 06432 510140014621100010000000	        D[CONST 1] ROT[40] ALU[D&AC] COND[OBUS=0] JUMP[UFANOR] C550 $
40m0160                               	
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;ENTER HERE WITH RESULT IN AR,Q, EXP IN IR-ADR.
40m0160                               	;------------------------------------------------------------------------------
40m0160 06433 640040001571000440006344	FPNAR:  CNORM [AR] DEST[AC] PUSHJ[NRMLIZ] NORM]$                                ;NOPE,
40m0160                               	 NORMALIZE
40m0160                               	;(Calls NRMLIZ which changes register usage from above and adjusts various
40m0160                               	;things.  "LEAVE EXPONENT IN AR, NORMALIZED NUMBER IN AC,Q.")
40m0160                               	;G. ROUND IF NECESSARY, INSERT EXPONENT INTO HIGH ORDER WORD OF RESULT.
40m0160 06434 631144400555000440000000	        ALU[Q] COND[-OBUS<0] DEST[HOLD] JUMP[NORND] CYLEN[C450] $
40m0160                               	                ;Save Q in HOLD (i.e. MEM)
40m0160                               	                ;If Q<0> is zero, don't round
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

40m0160 06435 640700034171000440000000	        D[IR] DEST[Q] NORM $
40m0160                               	                ;Get Q so we check bit meaning rounding (??? Can't this be
40m0160                               	                ;done with D[IR] ROT[7] COND[OBUS<0]... ???)
40m0160 06436 510140014635072010000000	        D[CONST 1] ROT[35] ALU[D&Q] COND[OBUS=0] JUMP[NORND] C550 $
40m0160                               	                ;Check opcode to see if rounding is requested.
40m0160                               	                ;If not, we're done
40m0160 06437 640700004171000440000000	        D[MEM] DEST[Q] SHORT $
40m0160                               	                ;Restore Q
40m0160 06440 530140010635000430000000	        D[MASK 43] ALU[D&Q] COND[-OBUS=0] JUMP[YESRND] C550 $
40m0160                               	                ;Round if Q<1:35> is non-zero (? what does this signify???)
40m0160 06441 611140000551000440006370	        ALU[AC] COND[OBUS<0] JUMP[INSEXP] CYLEN[C450] $
40m0160                               	                ;If mantissa is negative, we don't round (???)
40m0160                               	;       \ /
40m0160 06442 640700200571000440000000	YESRND: D[AR] DEST[IR-ADR] SHORT $
40m0160                               	                ;Setup IR for NRMLIZ
40m0160 06443 640040001413000440006344	        ALU[AC+1] DEST[AC] PUSHJ[NRMLIZ] NORM $
40m0160                               	                ;Increment high order word and normalize once more (???)
40m0160 06444 640140000171066440006371	        JINSEXP [AR] ROT[27.] DEST[Q] JUMP[INSEX1] NORM ]$
40m0160                               	                ;Now stick in exponent
40m0160                               	;       ---
40m0160 06445 640140004171000440006370	NORND:  D[MEM] DEST[Q] JUMP[INSEXP] NORM $
40m0160                               	                ;Restore Q and insert exponent(?)
40m0160                               	
40m0160                               	;UFA NORMALIZATION -- ONLY ON MANTISSA OVERFLOW.
40m0160 06446 450300001575000440000000	UFANOR: D[AR] ALU[DORQ] DEST[AC] COND[OBUS=0] POPJ C600 $
40m0160 06447 640040001571000440006361	        D[AR] DEST[AC] PUSHJ[NORMOV] NORM $
40m0160 06450 640140000171066440006371	        JINSEXP [AR] ROT[27.] DEST[Q] JUMP[INSEX1] NORM ]$
40m0160                               	;       ---
40m0160                               	
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;SETUP LOW ORDER FP RESULT, STORE BOTH IN AC,AC+1
40m0160                               	;ENTER WITH LOW WORD IN MEM, HIGH WORD IN AC, HIGH
40m0160                               	;WORD'S EXPONENT IN AR&AC+1.
40m0160                               	;------------------------------------------------------------------------------
40m0160 06451 640710015463400330000000	FPLOW:  D[CONST 27.] ACSEL[AC+1] ALU[AC-D] DEST[AC AR] SHORT $
40m0160 06452 530140014621416010000000	        D[CONST 1] ROT[7] ACSEL[AC+1] ALU[D&AC] COND[-OBUS=0] JUMP[ZLOW] C550 $
40m0160 06453 510140004171066330000000	        D[MEM] ROT[27.] MASK[27.] DEST[Q] COND[OBUS=0] JUMP[ZLOW] C550 $
40m0160 06454 640700001571466440000000	        D[AR] ROT[27.] ACSEL[AC+1] DEST[AC] SHORT $
40m0160 06455 640700011621466100000000	        D[MASK 8] ROT[27.] ALU[D&AC] ACSEL[AC+1] DEST[AC] SHORT $
40m0160 06456 640160001545400440602027	        ACSEL[AC+1] ALU[QORAC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0160 06457 640160001615400440602027	ZLOW:   ACSEL[AC+1] ALU[0] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0160                               	
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;
40m0160                               	;       FLOATING MULTIPLY.  AC&AR BY MEM.
40m0160                               	;
40m0160                               	;*** This code produces non-zero results if MEM=-1.0 and AC=0  !!!    TVR-Jun80
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;A. SUM OF + FORM EXPONENTS -128.+1 TO IR-ADR.  +1 BECAUSE 28
40m0160                               	; STEPS ARE USED TO PROVIDE ONE GUARD DIGIT.
40m0160 06460 640710000171022110000000	FM:     D[AR] MASK[9] ROT[9] DEST[Q AR] NORM$
40m0160                               	                ;Extract the exponent from AC (which was copied into AR)
40m0160 06461 510140014635020010000000	        D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM1] C550 $
40m0160                               	                ;Check sign bit of number.  Nothing special if positive
40m0160 06462 640710010735000110000000	        D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
40m0160                               	                ;Sign is negative, we want the one-complement of the exponent
40m0160                               	                ;field to get the actual exponent.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

40m0160 06463 640700004171022110000000	FM1:    D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
40m0160                               	                ;Extract the exponent from MEM
40m0160 06464 510140014635020010000000	        D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM2] C550 $
40m0160                               	                ;Check sign bit of number.  Nothing special if positive
40m0160 06465 640700010335000110000000	        D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
40m0160                               	                ;Sign is negative, we want the one-complement of the exponent
40m0160                               	                ;field to get the actual exponent.
40m0160 06466 640700000037000440000000	FM2:    D[AR] ALU[D+Q] CARRY DEST[Q] SHORT $
40m0160                               	                ;Add the two exponents
40m0160                               	                ;+1. FOR GUARD DIGIT.
40m0160 06467 640700214477016010000000	        D[CONST 1] ROT[7] ALU[Q-D] DEST[IR-ADR] SHORT $
40m0160                               	                ;Account for exponent bias.  Put exponent in a safe place.
40m0160                               	;B. BLANK EXPONENTS.
40m0160                               	        BLEXPS[40m0160 06470 511150010561066100006472	        D[MASK 8] ROT[27.] ALU[DORAC] DEST[AR] COND[OBUS<0] JUMP[. + 2] C550 $
40m0160 06471 640710010661066100000000	        D[MASK 8] ROT[27.] ALU[-D&AC] DEST[AR] SHORT $
40m0160 06472 511140004171000440006474	        D[MEM] DEST[Q] COND[OBUS<0] JUMP[. + 2] C550 $
40m0160 06473 640140010275066100006475	        D[MASK 8] ROT[27.] ALU[-D&Q] DEST[Q] JUMP[. + 2] NORM $
40m0160 06474 640700010175066100000000	        D[MASK 8] ROT[27.] ALU[DORQ] DEST[Q] CYLEN[SHORT] $
40m0161                               	]               ;Extend the sign to blank out the exponent field.  We will
40m0161                               	                ;now have perfectly good integers here, of 27 bit magnitude
40m0161                               	                ;(assuming that the numbers were normalized to begin with).
40m0161 06475 640040001615000440000000	        ALU[0] DEST[AC] PUSHJ[TESMUL] NORM $ ;28. STEPS.
40m0161                               	;;;     ALU[Q] DEST[AR] SHORT $ ;FLUSH SIGN IN LO WD.
40m0161 06476 640710010275000070000000	        D[MASK 7] ALU[-D&Q] DEST[Q AR] SHORT $  ;FLUSH SIGN IN LO WD.
40m0161                               	                ;Flush remenants of multiplier in low order part of
40m0161                               	                ;word.  MASK field determined empirically (35-28???)
40m0161 06477 640700000035000440000000	        D[AR] ALU[D+Q] DEST[Q] SHORT $
40m0161                               	                ;Make low order word unsigned.
40m0161 06500 640150000551000440006433	        ALU[AC] DEST[AR] JUMP[FPNAR] NORM $
40m0161                               	
40m0161                               	;28. STEP INTEGER MULTIPLY FOR USE BY FM.
40m0161 06501 640740014571000330000000	TESMUL: D[CONST 27.] LLOAD NORM $       ;LOOP 28 TIMES
40m0161 06502 640140000571000440004067	        JUMP[DOMUL1] NORM $     ;TEST.
40m0161                               	
40m0161                               	;------------------------------------------------------------------------------
40m0161                               	;SHORT STYLE FLOATING DIVIDE AC BY MEM.
40m0161                               	; XOR OF DIVISOR&DIVIDEND SIGNS IN AR BIT 0.
40m0161                               	;------------------------------------------------------------------------------
40m0161 06503 640710004721000440000000	FDS:    D[MEM] ALU[D#AC] DEST[AR] SHORT $
40m0161 06504 640700200571002010000000	FDS1:   D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
40m0161 06505 531150000551000440006507	        ALU[AC] DEST[AR] COND[-OBUS<0] JUMP[. + 2] C550 $
40m0161 06506 640710001513000440000000	        ALU[0-AC] DEST[AC AR] SHORT $
40m0161 06507 640701400615000443000000	        ALU[0] DEST[6] DEST-A-MEM NORM $
40m0161 06510 640740014571000340000000	        D[CONST 28.] LLOAD NORM $ 
40m0161                               	                ;Do only a 28-bit divide.
40m0161                               	
40m0161                               	;------------------------------------------------------------------------------
40m0161                               	;       Floating Divide
40m0161                               	;
40m0161                               	; DIVIDEND HIGH ORDER WORD IN AR, LOW IN A-MEM[6]. DIVISOR IN MEM.
40m0161                               	; BOTH IN POSITIVE FORM.  IR.35=XOR(DIVIDEND SIGN,DIVISOR SIGN).
40m0161                               	;------------------------------------------------------------------------------
40m0161                               	FD:
40m0161                               	;A. PUT DIVISOR IN + FORM, GET DIVISOR EXPONENT.
40m0161                               	;.1 Shuffle IR.35 into A-MEM[4].
40m0161 06511 640701034571000223000000	        D[IR] MASK[18.] DEST[4] DEST-A-MEM NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

40m0161                               	                ;Save IR-ADR in A-MEM
40m0161 06512 531140004171000440006514	        D[MEM] DEST[Q] COND[-OBUS<0] JUMP[. + 2] C550 $
40m0161                               	                ;Check for negative divisor
40m0161 06513 640704404073000440000000	        D[MEM] ALU[0-D] DEST[Q HOLD] NORM $
40m0161                               	                ;Negate divisor
40m0161 06514 640700204571022100000000	        D[MEM] ROT[9] MASK[8] DEST[IR-ADR] NORM $
40m0161                               	                ;Extract exponent from divisor, store in IR<18:35>
40m0161 06515 640704410675066100000000	        D[MASK 8] ROT[27.] ALU[-D&Q] DEST[HOLD] NORM $
40m0161                               	                ;Extract mantissa from divisor
40m0161                               	;B. Fetch and blank HOW Dividend exponent.
40m0161 06516 640700000171022100000000	        D[AR] ROT[9] MASK[8] DEST[Q] NORM $
40m0161                               	                ;Extract dividend exponent.
40m0161 06517 640700001571000330000000	        D[AR] MASK[27.] DEST[AC] SHORT $
40m0161                               	                ;Extract mantissa from dividend
40m0161                               	;C. Compute resultant exponent.
40m0161 06520 640700034077000220000000	        D[IR] MASK[18.] ALU[Q-D] DEST[Q] SHORT $
40m0161                               	                ;Subtract divisor exponent from dividend exponent
40m0161 06521 640700214435016010000000	        D[CONST 1] ROT[7] ALU[D+Q] DEST[IR-ADR] NORM $
40m0161                               	                ;Include exponent offset
40m0161                               	;D. Move LOW Dividend to Q.
40m0161 06522 640700070171000440000000	        D[16] DEST[Q] SHORT $
40m0161                               	;E. If divisor<=dividend,  shift dividend right, increment the
40m0161                               	        ; resultant exponent.  save diff. in A-MEM[7] for long mode.
40m0161 06523 471141604463000443000000	        D[MEM] ALU[AC-D] DEST[7] DEST-A-MEM COND[-OBUS<0] JUMP[FDAD] C600 $
40m0161                               	;F. Save exp in A-MEM[5]
40m0161 06524 640701234571000443000000	FDSHFT: D[IR] DEST[5] DEST-A-MEM NORM $
40m0161 06525 640040000571000440002170	        PUSHJ[DODIV4] NORM $    
40m0161                               	         ;Do the divide. Result DOES NOT have signs adjusted.
40m0161                               	;G. Save remainder in A-MEM[6], put quotient in AC, AR; put 0 in Q.
40m0161 06526 640701400551000443000000	        ALU[AC] DEST[6] DEST-A-MEM NORM $
40m0161 06527 640710001555000440000000	        ALU[Q] DEST[AC AR] SHORT $
40m0161 06530 640700000215000440000000	        ALU[0] DEST[Q] SHORT $
40m0161                               	;H. Prepare to round 28. bit result.
40m0161 06531 640700002145000010000000	        ALU[SH-AC] MASK[1] DEST[D4] SHORT $
40m0161                               	         ;Shift AC,Q rt 1 bit
40m0161 06532 640040264531000440006433	        D[15] ALU[D-1] DEST[IR-ADR] NORM PUSHJ[FPNAR] $ 
40m0161                               	         ;Move exp for FPNAR, normalize and insert exponent into quotient.
40m0161 06533 510300060571000010000000	        D[14] MASK[1] C550 OBUS=0 POPJ $
40m0161                               	         ;Done if positive result.
40m0161 06534 640300001513000440000000	        ALU[0-AC] DEST[AC] NORM POPJ $
40m0161                               	         ;Negate quotient.
40m0161                               	;------------------------------------------------------------------------------
40m0161                               	;HERE WHEN DIVIDEND IS >= DIVISOR.  SHIFT DIVIDEND RIGHT
40m0161                               	; AND INCREMENT RESULTANT AC.  THIS WILL ALLOW DIVIDE TO
40m0161                               	; SUCCEED IF BOTH DIVISOR & DIVIDEND WERE NORMALIZED
40m0161                               	; AND DIVISOR <> 0.
40m0161                               	;------------------------------------------------------------------------------
40m0161 06535 640700002145000020000000	FDAD:   ALU[SH-AC] MASK[2] DEST[D4] SHORT $
40m0161 06536 640140234433000220006524	        D[IR] MASK[18.] ALU[D+1] DEST[IR-ADR] JUMP[FDSHFT] NORM $
40m0161                               	
40m0161                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

41m0161                               	;ADJSP1 ADJSP2 DMOVE2 DMOVN2 DMOVM2 DMVNM2 DMVNM3 DMVNM4 DMVNM5 KAFIXP KAFIXN FIXR1
41m0161                               	 KIFIX1 FIXRN KIFIXN FIXER FIXER1 FIXER2 FIXER3
41m0161                               	;
41m0161                               	;Strays from KI instructions
41m0161                               	;
41m0161                               	
41m0161                               	.REPEAT XUCODE [
41m0161                               	 .USE[XLIST
41m0161                               	 LIST ] ;Squeeze this stuff into the space vacated by MBOOT.
41m0161                               	    ]
41m0161                               	;(ADJSP continued)
41m0161                               	;Left result is negative.  Check right side.
41m0161 05002 640710034421000220000000	ADJSP1: D[IR] MASK[22] ALU[D+AC] DEST[AR] NORM $
41m0161                               	                ;Add right half
41m0161 05003 640700010275000220000000	        D[MASK 22] ALU[-D&Q] DEST[Q] SHORT $
41m0161                               	                ;Isolate left half
41m0161 05004 640710001175000220000000	        D[AR] MASK[22] ALU[DORQ] DEST[O_AC AR] NORM $
41m0161                               	                ;Merge halves and store
41m0161 05005 533160034571000440602027	        D[IR] COND[-OBUS18] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] C550 $
41m0161                               	                ;If E was positive, it wasn't an overflow (just a bad idea)
41m0161                               	                ;Start fetching next instruction
41m0161 05006 511140000571000440002026	        D[AR] COND[OBUS<0] JUMP[MAIN] C550 $
41m0161                               	                ;If original was negative, we're OK.  Start doing next
41m0161                               	                ;instruction if no sign changed in left half
41m0161 05007 640140000571000440004734	        JUMP[PDLO6] NORM $
41m0161                               	                ;ADJSP got a PDLOV
41m0161                               	;ADJSP left result positive
41m0161 05010 640700010275000220000000	ADJSP2: D[MASK 22] ALU[-D&Q] DEST[Q] SHORT $
41m0161                               	                ;Isolate left half
41m0161 05011 000710001175000220000000	        D[AR] MASK[22] ALU[DORQ] DEST[O_AC AR] $
41m0161                               	                ;Merge halves and store
41m0161 05012 513720034571000440600000	        D[IR] COND[OBUS18] SPEC[MA_PC] DEST[MA] C550 $
41m0161                               	                ;If E was negative, it wasn't an overflow (just a bad idea)
41m0161                               	                ;Start fetching next instruction
41m0161 05013 531140000571000440002027	        D[AR] COND[-OBUS<0] JUMP[MAIN1] C550 $
41m0161                               	                ;If original was positive, we're OK.  Start doing next
41m0161                               	                ;instruction if no sign changed in left half
41m0161 05014 640140000571000440004734	        JUMP[PDLO6] NORM $
41m0161                               	                ;ADJSP got a PDLOV
41m0161                               	
41m0161                               	;(DMOVE continued)
41m0161 05015 640720024433000440000000	DMOVE2: D[MA] ALU[D+1] DEST[MA] NORM $  ;Fetch second word
41m0161 05016 640706000550400440020000	        FIXM1 $                 ;Complete fetch
41m0161 05017 640160005571400440602027	        ACSEL[AC+1] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
41m0161                               	                ;Put it in the second AC and start next instruction
41m0161                               	
41m0161                               	;(DMOVN continued)
41m0161 05020 640720024433000440000000	DMOVN2: D[MA] ALU[D+1] DEST[MA] NORM $  ;Fetch second word
41m0161 05021 640706000550400440020000	        FIXM1 $ ;Complete fetch
41m0161 05022 640720005473400440600000	        ACSEL[AC+1] D[MEM] ALU[0-D] DEST[AC MA] SPEC[MA_PC] CYLEN[FIXM+1] $
41m0161                               	                ;Negate low order word and put it in the second AC
41m0161                               	                ;Start next instruction fetch (Note that DEST[MA] is
41m0161                               	                ;really associated with SPEC[MA_PC])
41m0161                               	                ;*** Is FIXM+1 really the right thing???
41m0161                               	        ACSEL[AC+1] D[MASK 1] ROT[35.] ALU[-D&AC] DEST[AC]
41m0161 05023 670140011661506010002027	                        COND[-OBUS=0] JUMP[MAIN1] NORM $
41m0161                               	                ;Clear stupid bit 0.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

41m0161                               	                ;If the low order part is non-zero, we're done
41m0161 05024 500140001413000441202027	        ACSEL[AC] ALU[AC+1] DEST[AC] SPEC[CRYOV] JUMP[MAIN1] C550 $
41m0161                               	                ;Increment high order word and we're finally done.
41m0161                               	
41m0161                               	;(DMOVEM continued)
41m0161                               	        .PAIR
41m0161                               	. \ 2 + .
41m0162 05026 640700005571000440000000	]DMOVM2:        CYLEN[MEMSTO] ACSEL[AC] D[MEM] DEST[AC] NORM $
41m0162                               	                ;Write it also in the AC
41m0162 05027 640720024433000440000000	        CYLEN[MEMSTO] D[MA] ALU[D+1] DEST[MA] $
41m0162                               	                ;Setup to write second word
41m0162 05030 662104200551400440002032	        ACSEL[AC+1] ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
41m0162                               	                ;Write secord word.
41m0162                               	
41m0162                               	;(DMOVNM continued)
41m0162 05031 640700000113400440000000	DMVNM2: ACSEL[AC+1] ALU[0-AC] DEST[Q] SHORT $
41m0162                               	                ;Negate low order word.
41m0162                               	        ACSEL[AC+1] D[MASK 1] ROT[35.] ALU[-D&Q] DEST[Q]
41m0162 05032 670140010275506010000000	                        COND[-OBUS=0] JUMP[DMVNM4] NORM $
41m0162                               	                ;Clear stupid bit 0.
41m0162                               	                ;If the low order part is non-zero, no change needed to
41m0162                               	                ;high order word.
41m0162                               	        D[AR] ALU[AC+1] DEST[AR STRT-WRT] SPEC[CRYOV]
41m0162 05033 662154000413000441200000	                COND[-MA-AC] JUMP[DMVNM5] NORM $
41m0162                               	                ;Increment high order word and start first store
41m0162 05034 000140005570400440000000	DMVNM3: ACSEL[MA] D[MEM] DEST[AC] JUMP[DMVNM5] $
41m0162                               	                ;Store is to an AC, write into 2901.
41m0162 05035 002144000571000440005034	DMVNM4: DEST[STRT-WRT] COND[MA-AC] JUMP[DMVNM3] $
41m0162                               	                ;Start first store.  Jump if to an AC
41m0162 05036 640720024433000440000000	DMVNM5: D[MA] ALU[D+1] DEST[MA] NORM $
41m0162                               	                ;Finish write.  Note that due to FIXM2, we don't have to
41m0162                               	                ;worry about map faults.
41m0162                               	                ;Prepare for secord write
41m0162 05037 662104200555000440002032	        ALU[Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
41m0162                               	                ;Do final write (low order word into (E+1))
41m0162                               	
41m0162                               	;KAFIX (Opcode 247) continued
41m0162                               	;Positive number to fix
41m0162 05040 030040034171066110000000	KAFIXP: D[IR] ROT[27.] MASK[9.] DEST[Q] COND[-OBUS=0] PUSHJ[FIXER] $
41m0162                               	                ;Extract exponent adjustment factor and do fixing
41m0162 05041 640160001555000440602027	        ACSEL[AC] ALU[Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Put result into AC and we're done
41m0162                               	;Negative number to fix
41m0162 05042 030040034171066110000000	KAFIXN: D[IR] ROT[27.] MASK[9.] DEST[Q] COND[-OBUS=0] PUSHJ[FIXER] $
41m0162                               	                ;Extract exponent adjustment factor and do fixing
41m0162                               	;;;     ACSEL[AC] D[MASK R] ALU[D/#Q] DEST[AC MA]       ;*** Assembler loses!
41m0162                               	        ACSEL[AC] D[2] MASK[R] ALU[D/#Q] DEST[AC MA]    ;Sigh...
41m0162 05043 640160011775001000602027	                        SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Put sign extended result into AC and we're done
41m0162                               	
41m0162                               	;(FIXR continued)
41m0162 05044 511140004571000440000000	FIXR1:  D[MEM] COND[OBUS<0] JUMP[FIXRN] C550 $
41m0162                               	                ;Round different directions
41m0162 05045 640050015435074200006401	        D[CONST 20] ROT[30.] ALU[D+Q] DEST[AC AR] PUSHJ[FADSUB] NORM $
41m0162                               	                ;Positive. Finish making constant 0.5 and add it
41m0162 05046 640700014171000330000000	        D[CONST 33] DEST[Q] SHORT $
41m0162                               	                ;Start making magic constant
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

41m0162 05047 640154400551000440000000	        ALU[AC] DEST[AR HOLD] JUMP[FIXR2] NORM $
41m0162                               	                ;Setup for FIXER.  Rest is same as KIFIX
41m0162                               	;       ---
41m0162 05050 640050015537074600006401	FIXRN:  D[CONST 60] ROT[30.] ALU[D-Q] DEST[AC AR] PUSHJ[FADSUB] NORM $
41m0162                               	                ;Negative. Finish making constant -0.5 and add it
41m0162 05051 640700014171000330000000	        D[CONST 33] DEST[Q] SHORT $
41m0162                               	                ;Start making magic constant
41m0162 05052 640700014175014020000000	        D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] SHORT $
41m0162                               	                ;Finish making magic constant
41m0162 05053 640054400513000440000000	        ALU[0-AC] DEST[AR HOLD] PUSHJ[FIXER] NORM $
41m0162                               	                ;Setup for FIXER
41m0162 05054 640160001517000440602027	        ACSEL[AC] ALU[0-Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Negate it back again and start next instruction
41m0162                               	;       ---
41m0162                               	;(KIFIX continued)
41m0162 05055 511150004571000440000000	KIFIX1: D[MEM] DEST[AR] COND[OBUS<0] JUMP[KIFIXN] C550 $
41m0162                               	                ;Load up things for FIXER, check for positive mantissa
41m0162 05056 640040014175014020000000	FIXR2:  D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] PUSHJ[FIXER] NORM $
41m0162                               	                ;Finish making magic constant and do fix.
41m0162 05057 640160001555000440602027	        ACSEL[AC] ALU[Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Put result into AC and we're done
41m0162                               	;       ---
41m0162                               	;       ---
41m0162 05060 640700014175014020000000	KIFIXN: D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] SHORT $
41m0162                               	                ;Finish making magic constant
41m0162 05061 640054404473000440000000	        D[MEM] ALU[0-D] DEST[HOLD AR] PUSHJ[FIXER] NORM $
41m0162                               	                ;ABS to both MEM and AR.  Fix the number
41m0162 05062 640160001517000440602027	        ACSEL[AC] ALU[0-Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Negate it back again and start next instruction
41m0162                               	
41m0162                               	
41m0162                               	;Fix a number (without sign extension) in MEM, AR=ABS(MEM), Q=magic number
41m0162                               	;(233 for normal fix)
41m0162                               	FIXER:  D[AR] ROT[9] MASK[9] ALU[D-Q] DEST[ROTR Q]
41m0162 05063 511141200137022110000000	                        COND[OBUS<0] JUMP[FIXER2] C550 $
41m0162                               	                ;Calculate number of positions to move
41m0162                               	                ;Jump if we'll be shifting right (n<2^26)
41m0162 05064 640701414435000330000000	        D[CONST 27.] ALU[D+Q] DEST[MASKR] NORM $
41m0162                               	                ;Construct appropriate mask
41m0162 05065 640704404571000330000000	        D[MEM] MASK[27.] DEST[HOLD] NORM $
41m0162                               	                ;Flush exponent, our mask won't reach.
41m0162 05066 511140014477000110000000	        D[CONST 9.] ALU[Q-D] COND[OBUS<0] JUMP[FIXER1] C550 $
41m0162                               	                ;Check for overflow
41m0162                               	;;; Set overflow here.  What kind?  (We can live without it for KAFIX, since it
41m0162                               	;;; never did check, but when KIFIX is done, this will have to be corrected.)
41m0162 05067 640040014555106010006147	        D[CONST 1] ROT[35.] ALU[Q] PUSHJ[QORCRY] NORM $
41m0162                               	                ;Set overflow flag.
41m0162 05070 640701414571000440000000	        D[CONST 44] DEST[MASKR] NORM $
41m0162                               	                ;For those losers who want to see some of the number...
41m0162                               	;Now that we know how much to shift things, do it and return.
41m0162 05071 640300004171201000000000	FIXER1: D[MEM] ROT[R] MASK[R] DEST[Q] NORM POPJ $
41m0162                               	                ;Gee, that was fast.
41m0162                               	;Negative, shift count, the easy case.
41m0162 05072 011141414435000330000000	FIXER2: D[CONST 27.] ALU[D+Q] DEST[MASKR] COND[OBUS<0] JUMP[FIXER3] $
41m0162                               	                ;Construct appropriate mask.  If !x!<1, return zero
41m0162 05073 640141214435000440005071	        D[CONST 36.] ALU[D+Q] DEST[ROTR] JUMP[FIXER1] NORM $
41m0162                               	                ;Hardware doesn't believe in negative shift counts
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

41m0162                               	;Number is fractional, i.e. shift would go off the end.  Return zero
41m0162 05074 640301400215000440000000	FIXER3: ALU[0] DEST[Q MASKR] SHORT POPJ $
41m0162                               	                ;Just return zero.  Set mask just in case
41m0162                               	
41m0162                               	.REPEAT XUCODE [
41m0162                               	  .USE[41m0162                               	XLIST
41m0162                               	 LIST ]   ];FLTR, continued
41m0162 06537 640700014171000330000000	FLTR1:  D[CONST 33] DEST[Q] SHORT $
41m0162 06540 640700214575014020000000	        D[CONST 2] ROT[6] ALU[DORQ] DEST[IR-ADR] NORM $
41m0162                               	                ;Make magic constant for exponent
41m0162 06541 000040000215000440006433	        ALU[0] DEST[Q] PUSHJ[FPNAR] $
41m0162                               	                ;Clear low order word
41m0162                               	                ;Normalize and round (happens to have same bit on as FxxR)
41m0162                               	                ;Result goes to AC
41m0162 06542 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
41m0162                               	                ;Start next instruction fetch
41m0162                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

42m0162                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

43m0162                               	.REPEAT TYMNET [.43m0162                               	;;;FOOLIST
43m0162                               	
43m0162       7600	TYMORG = 7600   ;Where to assemble fixed part of TYMNet code.
43m0162                               	
43m0162                               	  .REPEAT OTP [
43m0162                               	;OTP
43m0162                               	
43m0162                               	  .REPEAT NTP [
43m0162       17	TNODIFS = 17    ;OUTPUT DONE INTERRUPT FF SUBSEL = REQ B
43m0162       16	TNIRIFS = 16    ;INPUT READY INTERRUPT FF SUBSEL = REQ A.
43m0162       15	TYM.LD = 15     ;MAPF value for loading output register.
43m0162       5	TYM.RD = 5      ;MAPF value for reading input register.
43m0162                               	  ];NTP
43m0162                               	
43m0162                               	.REPEAT TYMNET [
43m0162                               	TYMNET
43m0162                               	
43m0162                               	LIST  ;matches the XLIST at top of page.
43m0162                               	
43m0162       6543	TYMFOO = .
43m0162                               	;$*$*$  I think this is the only way it will work for now.
43m0162                               	
43m0162                               	;$*$*$* Grrr...
43m0162                               	        .ORG[XLIST
43m0162                               	        .ENDORG
43m0162       6543	THER = .
43m0163                               	]       :2141
43m0163                               	        .DEFINE .ENDORG 43m0163                               	.ENDORG
43m0162                               	 LIST ];DISP HERE ON TYMNET INTERFACE INTERRUPT.
43m0162                               	                        ; PREPARE TO CALL MAPOFF BY RE-LOADING DEV-ADR.
43m0162 02141 640141614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM JUMP[TNI] $       
43m0162                               	
43m0162                               	        .USE[XLIST
43m0162                               	        .ENDORG
43m0162       2142	STORG = .
43m0163                               	]       :TYMFOO
43m0163                               	        .DEFINE .ENDORG 43m0163                               	.ENDORG
43m0163                               	        .DEFINE .RELOC 43m0163                               	.RELOC
43m0162                               	 LIST ]
43m0162                               	
43m0162                               	.REPEAT 1 - TYMNET [
43m0162 06543 000142400571000440002026	TNI:    DEST[CLR-DEV-FROM-INTR] JUMP[MAIN] $            ;"It can't happen here"
43m0162                               	]1 - TYMNET
43m0162                               	
43m0162                               	
43m0162                               	;What is 'device 6'?  Document!  TVR-Apr80 - THIS IS TYMNET (CLEAR AND STORE)
43m0162                               	DEV6CL:   ;CLEAR SOME DEV 6 BITS (SEE COMMENT BELOW).
43m0162 06544 640150000615000440000000	        ALU[0] DEST[AR] NORM JUMP[DEV6ST] $
43m0162                               	
43m0162                               	DEV6ST:    ;SET SOME OF THE BITS IN DEVICE 6'S OUTPUT REGISTER, A COPY
43m0162                               	           ;OF WHICH IS MAINTAINED IN A-MEM(1).
43m0162                               	           ;ENTER WITH MASK FOR UNCHANGED BITS IN IN Q, DATA IN AR.
43m0162                               	           ; $$$$ ON RETURN, Q HAS NEW VALUE OF AMEM(1) $$$$$
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

43m0162 06545 640701614571000060000000	        D[CONST 6] DEST[DEV-ADR] NORM $
43m0162                               	DEV6ST1:        ;ENTER HERE IF YOU'VE ALREADY SET DEVADR:=6
43m0162 06546 640700044235000440000000	        D[11] ALU[D&Q] DEST[Q] NORM $ ;GET AMEM(1), MASK IT.
43m0162 06547 640702200175000443600000	DEV6ST2: D[AR] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] NORM $ 
43m0162                               	                ;OR IN NEW DATA
43m0162 06550 440300200555000443150000	        MAPF[TYM.LD] ALU[Q] DEST[1] DEST-A-MEM CYLEN[IOB-OUT] POPJ $
43m0162                               	
43m0162                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

44m0162                               	;INTERVAL TIMER CODE.
44m0162                               	
44m0162                               	;a-mem useage:
44m0162                               	;       0       dispatch addr for interrupts
44m0162                               	;       1       pi chn (33: 35) and intrpt waiting flag (32)
44m0162                               	;               (BITS 0,19 ARE ON FOR USE BY TAPE CODE)
44m0162                               	;       2       CONSTANT W/ ONLY BIT 19 ON (USED BY TAPE CODE)
44m0162                               	;       3       INTERVAL TIMER REGISTER.
44m0162                               	
44m0162                               	  .REPEAT OTP [
44m0162                               	;OTP
44m0162                               	
44m0162                               	  .REPEAT NTP [
44m0162       0	        TIM.CLR.ROT = 0
44m0162       11	        TIM.DO = 11
44m0162       1	        TIM.DI = 1
44m0162       10	        TIM.ENB = 10
44m0162       5	        TIM.DEV = 5
44m0162       2134	        TIM.LOC = 2134
44m0162                               	    ];NTP
44m0162                               	
44m0162                               	
44m0162                               	        .ORG[XLIST
44m0162                               	        .ENDORG
44m0162       6551	YMFOO = .
44m0163                               	]       :TIM.LOC
44m0163                               	        .DEFINE .ENDORG 44m0163                               	.ENDORG
44m0162                               	 LIST ] ;$*$*$ INTRPTS FROM DEVICE COME HERE.
44m0162                               	   .REPEAT 1 - TIMER [
44m0162 02134 000142400571000440002026	        DEST[CLR-DEV-FROM-INTR] JUMP[MAIN] $ ;FLUSH DEV INTERRUPTS 
44m0162                               	     ]
44m0162                               	   .REPEAT TIMER [
44m0162                               	
44m0162                               	        .RELOC
44m0162                               	USE[44m0162                               	XLIST
44m0162                               	        .ENDORG
44m0162       2135	STORG = .
44m0163                               	]       :TYMFOO
44m0163                               	        .DEFINE .ENDORG 44m0163                               	.ENDORG
44m0163                               	        .DEFINE .RELOC 44m0163                               	.RELOC
44m0163                               	 LIST ]]
44m0163                               	TIMINT:   ;ALL DEV 5 INTS COME FROM INTERVAL TIMER...
44m0163 06551 640702214571000013600000	        START-OUT D[CONST 1] ROT[TIM.CLR.ROT] DEST[IOD] NORM $
44m0163                               	           ;Clear the TIMER OVERFLOW FLAG.
44m0163 06552 240700054171000440100000	        MAPF[TIM.ENB] D[13] DEST[Q] C800 $
44m0163                               	           ;Get TIMER REGISTER.
44m0163                               	        D[CONST 1] ROT[12.] ALU[D+Q] DEST[Q 3] DEST-A-MEM
44m0163 06553 535140614035030013002026	                  C550 COND[-CRY0] JUMP[MAIN] $
44m0163                               	           ;Increment the count by 2^12, exit if no overflow.
44m0163 06554 510150044571000030002026	        D[11] MASK[3] DEST[AR] C550 COND[OBUS=0] JUMP[MAIN] $
44m0163                               	           ;Timer overflowed. ignore if no PI CHANNEL assigned.
44m0163 06555 640700044171000440000000	        D[11] DEST[Q] NORM $
44m0163                               	           ;Get full contents of A-MEM[1].
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

44m0163 06556 640140214575000103004564	        D[CONST 10] ALU[DORQ] DEST[1] DEST-A-MEM NORM JUMP[PIGEN] $
44m0163                               	           ;Set the "interrupting" status bit and generate a PI.
44m0163                               	
44m0163                               	   .OPCODE[LIST 
44m0163                               	        .ENDORG
44m0163       6557	YMFOO = .
44m0164                               	]       :INST-DISP + 2 * 760
44m0164                               	        .DEFINE .ENDORG 44m0164                               	.ENDORG
44m0163                               	 LIST            ];TIMER PSEUDO-IOT DISPATCH TABLE ENTRIES.
44m0163                               	
44m0163                               	; TCONO -- 760
44m0163 03740 640701614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] SHORT $
44m0163 03741 640140044171000440000000	        D[11] DEST[Q] NORM JUMP[TCNO1]$
44m0163                               	; TCONI -- 761
44m0163 03742 640041614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
44m0163 03743 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$ ;store them and
44m0163                               	 return.
44m0163                               	; TCONSO -- 762
44m0163 03744 640041614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
44m0163 03745 530100010635000220000000	        D[MASK 22] ALU[D&Q] C550 COND[-OBUS=0] LBJUMP[DSKP1] $ ;Skip if on.
44m0163                               	; TCONSZ -- 763
44m0163 03746 640041614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
44m0163 03747 510100010635000220000000	        D[MASK 22] ALU[D&Q] C550 COND[OBUS=0] LBJUMP[DSKP1] $ ;Skip if off.
44m0163                               	; TDATAO -- 764  LOAD THE 36-BIT TIMER
44m0163 03750 640701614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM $
44m0163 03751 640146000550400440020000	        FIXM1 JUMP[TDATO] $
44m0163                               	; TDATAI  --  765    READ TIMER REGISTER
44m0163 03752 640041614571000053400000	        START-IN D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TDTI] $ ;get bits.
44m0163 03753 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$ ;Store them and
44m0163                               	 return.
44m0163                               	
44m0163                               	   .RELOC
44m0163                               	USE[44m0163                               	XLIST
44m0163                               	        .ENDORG
44m0163       3754	LASTORG = .
44m0164                               	]       :TYMFOO
44m0164                               	        .DEFINE .ENDORG 44m0164                               	.ENDORG
44m0164                               	        .DEFINE .RELOC 44m0164                               	.RELOC
44m0164                               	 LIST ]]
44m0164 06557 640700010235010400000000	TCNO1:  D[MASK 32.] ROT[4] ALU[D&Q] DEST[Q] NORM $
44m0164 06560 000140234575000033002026	        D[IR] MASK[3] ALU[DORQ] DEST[1] DEST-A-MEM JUMP[MAIN] $
44m0164                               	           ;Put new PI CHAN. in bits 33-35 of A-MEM[1].
44m0164                               	
44m0164 06561 640710044171000040000000	TCNI1:  D[11] MASK[4] DEST[Q AR] NORM $ ;get intrpt flag and pi chn
44m0164 06562 640300034235000440000000	        D[IR] ALU[D&Q] DEST[Q] NORM POPJ $ ;this is for conso, z
44m0164                               	
44m0164 06563 640700004171000140000000	TDATO:  D[MEM] MASK[12.] DEST[Q] NORM $
44m0164                               	           ;Get low 12 bits of new timer value...
44m0164 06564 640702214575070013600000	        START-OUT D[CONST 1] ROT[35. - 7] ALU[DORQ] DEST[IOD] NORM $
44m0164                               	           ;Place in hardware counter (the "TP TIMER").
44m0164 06565 240700010171030300110000	        MAPF[TIM.DO] D[MASK 24.] ROT[12.] DEST[Q] C800 $
44m0164 06566 640140604635000443002026	        D[MEM] ALU[D&Q] DEST[3] DEST-A-MEM NORM JUMP[MAIN] $
44m0164                               	           ;Put other 24 bits into A-MEM[3] (the "TIMER REGISTER").
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

44m0164                               	
44m0164 06567 440710030571030143410000	TDTI:   MAPF[TIM.DI] START-IN D[IOD] ROT[12.] MASK[12.] DEST[AR] C600 $
44m0164                               	           ;Read hardware timer.
44m0164 06570 440700030171030140010000	        MAPF[TIM.DI] D[IOD] ROT[12.] MASK[12.] DEST[Q] C600 $
44m0164                               	           ;Read it again.
44m0164 06571 530140000735000443406567	        START-IN D[AR] ALU[D#Q] C550 COND[-OBUS=0] JUMP[TDTI] $
44m0164                               	           ;If it changed, try again (to ensure that we don't get a garbaged
44m0164                               	           ; value because of reading it while it is changing).
44m0164 06572 640310054575000440000000	        D[13] ALU[DORQ] DEST[AR] NORM POPJ $
44m0164                               	           ;Combine high-order bits from A-MEM[3] with
44m0164                               	           ; low-order bits from hardware counter.
44m0164                               	
44m0164                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

45m0164                               	;       IMP,VID,PAN,GRN,DLS,LPT,VC etc.
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	;
45m0164                               	;       Packet Switching Network Interface (IMP)
45m0164                               	;
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	.REPEAT IMP [
45m0164                               	
45m0164                               	;Insert main code body here
45m0164                               	.INSERT IMP.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

01m0001                               	COMMENT %
01m0001                               	
01m0001                               	The IMP interface is device number 16.
01m0001                               	
01m0001                               	The INPUT subselect MAPFs are:
01m0001                               	2       Status Register
01m0001                               	4       Data Register
01m0001                               	
01m0001                               	The OUTPUT subselect MAPFs are:
01m0001                               	0       Clear Input (Reset)
01m0001                               	1       Clear Input Full        (this clears the input interrupt condition)
01m0001                               	2       Clear Output (Reset)
01m0001                               	3       Data Output
01m0001                               	4       Control Register
01m0001                               	
01m0001                               	The Status Register is divided into the following fields:
01m0001                               	0:5     Output Counter
01m0001                               	6:11    Input Counter
01m0001                               	12      Output Empty
01m0001                               	13      Output Ready (maintenence use only)
01m0001                               	14      Output Needs Data
01m0001                               	15      Last IMP Bit
01m0001                               	16      Last IMP Bit Seen
01m0001                               	17      Input Ready (maintenence use only)
01m0001                               	18      Input Full
01m0001                               	19      -IMP Ready [DWP was confused]
01m0001                               	
01m0001                               	The Control Register is divided as follows:
01m0001                               	32      Host Ready
01m0001                               	33      Last Output Word
01m0001                               	34      Input Interrupt Enable
01m0001                               	35      Ouput Interrupt Enable
01m0001                               	
01m0001                               	
01m0001                               	The relevant Status Register information is as follows:
01m0001                               	
01m0001                               	Input Counter:  This is an UP counter which tells how many places to left
01m0001                               	shift the Input Data.
01m0001                               	
01m0001                               	Output Needs Data:  This indicates the interface is ready to accept more
01m0001                               	output, and causes an interrupt if Output Interrupt is enabled.  Note that
01m0001                               	if Last Host Bit is being sent, Output Empty will be true, but Output Needs
01m0001                               	Data will be false (and if you try to send a word at this time, you will
01m0001                               	lose).
01m0001                               	
01m0001                               	Last Imp Bit Seen and Input Full both indicate the IMP has finished input
01m0001                               	to the interface.  These cause an interrupt if Input Interrupt is enabled.
01m0001                               	
01m0001                               	Output Ready and Input Ready change dynamically during transmission and
01m0001                               	and on when hardware is ready to transfer a bit.  They may change during
01m0001                               	micro-instruction and should not be depended on.
01m0001                               	
01m0001                               	The Control register cannot be read, so a copy of it is kept in the A-MEM.
01m0001                               	
01m0001                               	
01m0001                               	The (scanty) information on the BBN Standard IMP-10 interface, which we are
01m0001                               	emulating, specify the following CONI and CONO bit assignments:
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

01m0001                               	
01m0001                               	 ----------- ----------- ----------- ----------- ----------- -----------
01m0001                               	                                                            
01m0001                               	   DEVIMPERR      EIB  PI CHAN  OUT  PI CHAN  INP  PI CHAN  
01m0001                               	   ON DWN                                                   
01m0001                               	------------------------------------------------------
01m0001                               	18       20           24         27                  3233       35
01m0001                               	
01m0001                               	CONI:   Means:                  Emulated with:
01m0001                               	19      Interface is powered    On if interface responds with other than -1
01m0001                               	20      IMP is now down         - IMP Ready
01m0001                               	21      IMP has been down       (flip-flop simulated in firmware)
01m0001                               	24      End of Input            Last IMP bit seen (16)
01m0001                               	25:27   PI Channel for Bit 24
01m0001                               	28      Ready for Output        Output Needs Data (14)
01m0001                               	29:31   PI Channel for Bit 28
01m0001                               	32      Input Ready             Input Full (18)
01m0001                               	33:35   PI Channel for Bit 32
01m0001                               	
01m0001                               	(Note: by special dispensation, if the Status Register is -1 (meaning the IMP
01m0001                               	is not connected or something) a CONI returns all bits zero.)
01m0001                               	
01m0001                               	(*This code may need to read back END OUT (bit 22) and the PI channels???*)
01m0001                               	
01m0001                               	 ----------- ----------- ----------- ----------- ----------- -----------
01m0001                               	                                                               
01m0001                               	   CLRHSTCLRENDCLRSET LAST BIT  SETOUTPUT RDY SET INPUT RDY 
01m0001                               	   ERRDWNOUTOUTIEB    PI CHAN       PI CHAN       PI CHAN   
01m0001                               	------------------------------------------------------
01m0001                               	18       2021       2324       2627       2930       3233       35
01m0001                               	
01m0001                               	CONO:   Means:                  Emulated with:
01m0001                               	19      Clear IMP has been down (simulated in firmware)
01m0001                               	20      Host Down               - Host Ready (32)
01m0001                               	21      Stop Output             Clear Output MAPF
01m0001                               	22      End of Output           Last Output Word (33)
01m0001                               	23      Clear EIB               Clear Input, Clear Input Full MAPFs
01m0001                               	24      set PI channel in bits 25:27
01m0001                               	25:27   PI channel for End of Input (See note below)
01m0001                               	28      set PI channel in bits 29:31
01m0001                               	29:31   PI channel for Ready for Output
01m0001                               	32      set PI for Input Ready channel from bits 33:35
01m0001                               	33:35   PI channel for Input Ready
01m0001                               	
01m0001                               	(Note: "IMP has been down" is also referred to as the "Error Flop")
01m0001                               	
01m0001                               	END OF COMMENT  %
01m0001                               	
01m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

02m0001                               	;------------------------------------------------------------------------------
02m0001                               	; Definitions for IMP
02m0001                               	;------------------------------------------------------------------------------
02m0001       16	IMPUDEV = 16            ;uDevice code for first IMP.  Second (for Packet Radio)
02m0001                               	                        ;must be IMPUDEV+1 for this code to work.
02m0001                               	
02m0001                               	;       Input MAPFs
02m0001       2	IMPI-CONTROL    = 2
02m0001       4	IMPI-DATA       = 4
02m0001                               	
02m0001                               	;       Output MAPFs
02m0001       0	IMPO-CLEAR-INPUT        = 0
02m0001       1	IMPO-CLEAR-FULL         = 1
02m0001       2	IMPO-CLEAR-OUTPUT       = 2
02m0001       3	IMPO-DATA               = 3
02m0001       4	IMPO-CONTROL            = 4
02m0001                               	
02m0001                               	;       A-Memory
02m0001       0	IMPA-VECTOR     = 0
02m0001       1	IMPA-CONTROL    = 1
02m0001                               	;Skip 2 - DEST-A-MEM clobbers IR on 2 and 3
02m0001       3	IMPA-MASK       = 3
02m0001       4	IMPA-STATUS     = 4
02m0001       5	IMPA-HALF       = 5     ;First Part Done flag for BLKO
02m0001                               	
02m0001                               	.DEFINE D-AMEM[02m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

03m0001                               	;------------------------------------------------------------------------------
03m0001                               	;Instruction Decode
03m0001                               	;------------------------------------------------------------------------------
03m0001                               	IMPIO2:         ;;;Save current location
03m0001                               	:IMP-IOT        ;;;Fill in main instruction decode
03m0001 03732 640700034171024010000000	        D[IR] ROT[9. + 1] MASK[1] DEST[Q] NORM $
03m0001                               	                ;Get type of IMP interface (0 - normal, 1 - packet radio)
03m0001 03733 640141614435000160006573	        D[CONST IMPUDEV] ALU[D+Q] DEST[DEV-ADR] JUMP[IMPIO2] NORM $
03m0001                               	                ;Select aproprate device code
03m0001                               	        ;(Only two instructions allowed above)
03m0001                               	:IMPIO2         ;;;Resume regular code
03m0001 06573 640700034171034040000000	        D[IR] ROT[12. + 1 + 1] MASK[4] DEST[Q] NORM $
03m0001                               	                ;Get IOT instruction decode
03m0001                               	                ;Extra rotation means two micro-instructions per decode.  We
03m0001                               	                ;can do this because indirection and indexing is complete and
03m0001                               	                ;their bits cleared by the time we get here.
03m0001 06574 540540040435044200000000	        D-AMEM[D[IMPA-VECTOR + 8.] ]ROT[18.] MASK[16.] ALU[D+Q] SDISP CYLEN[DISP] $
03m0001                               	                ;Dispatch according to instruction
03m0001                               	
03m0001                               	;------------------------------------------------------------------------------
03m0001                               	;IOT dispatch for IMP (and IMP2)
03m0001                               	;------------------------------------------------------------------------------
03m0001                               	IMPDSP:
03m0001                               	;BLKI IMP,
03m0001 06575 640046200550400440030000	        FIXM2 PUSHJ[BLKI1] $
03m0001                               	                ;Do first part of BLKI
03m0001 06576 640160004571000443400000	        D[MEM] DEST[MA] SPEC[IOB-IN] JUMP[IMPBKI] NORM $
03m0001                               	                ;Set MA for writing new data (i.e. finish first part of BLKI).
03m0001                               	                ;Start reading data from IMP
03m0001                               	                ;*** This instruction have the same function as IMPIN
03m0001                               	        ;(Continued below)
03m0001                               	;DATAI IMP,
03m0001 06577 640046200550400440030000	        FIXM2 PUSHJ[IMPIN] $
03m0001                               	                ;Read word from IMP interface
03m0001                               	                ;While we're at it, make sure we don't page fault later
03m0001 06600 662104000571000440002032	        DEST[STRT-WRT] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
03m0001                               	                ;Write data into memory.  We're done.
03m0001                               	;BLKO IMP,
03m0001 06601 640046200550400440030000	        FIXM2 PUSHJ[BLKO1] $
03m0001                               	                ;Do first part of a BLKO instruction
03m0001 06602 640140044171000440000000	        D-AMEM[D[IMPA-CONTROL + 8.] ]DEST[Q] JUMP[IMPBKO] NORM $
03m0001                               	                ;Copy into Q so we can manipulate control word
03m0001                               	                ;*** This instruction should be same as at IMPOUT
03m0001                               	        ;(Continued below)
03m0001                               	
03m0001                               	;DATAO IMP,
03m0001 06603 640046000550400440020000	        FIXM1 PUSHJ[IMPOUT] $
03m0001                               	                ;Send word to IMP interface
03m0001 06604 640160000571000440602027	        DONTSKIP NORM $
03m0001                               	                ;Start next instruction fetch
03m0001                               	;CONO IMP,
03m0001 06605 531140034571046440000000	        D[IR] ROT[19.] COND[-OBUS<0] JUMP[IMPCO2] C550 $
03m0001                               	                ;Jump if not clearing Imp Has Been Down (error flop)
03m0001 06606 640140060171000440000000	        D-AMEM[D[IMPA-STATUS + 8.] ]DEST[Q] JUMP[IMPCNO] NORM $
03m0001                               	                ;Get status so we can remove that bit
03m0001                               	        ;(Continued below)
03m0001                               	;CONI IMP,
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

03m0001 06607 640046200550400443430000	        FIXM2 PUSHJ[IMPSTS] SPEC[IOB-IN] $
03m0001                               	                ;Get device status.  Make sure we don't page fault later.
03m0001 06610 662104200555000440002032	        ALU[Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
03m0001                               	                ;Write result into memory.  We're done.
03m0001                               	;CONSZ IMP,
03m0001 06611 640040000571000443400000	        PUSHJ[IMPSTS] SPEC[IOB-IN] NORM $
03m0001 06612 510100034635000440003424	        D[IR] ALU[D&Q] COND[OBUS=0] LBJUMP[SKMAIN] C550 $
03m0001                               	                ;Decide whether to skip.  Start next instruction.
03m0001                               	;CONSO IMP,
03m0001 06613 640040000571000443400000	        PUSHJ[IMPSTS] SPEC[IOB-IN] NORM $
03m0001 06614 530100034635000440003424	        D[IR] ALU[D&Q] COND[-OBUS=0] LBJUMP[SKMAIN] C550 $
03m0001                               	                ;Decide whether to skip.  Start next instruction.
03m0001                               	
03m0001                               	;------------------------------------------------------------------------------
03m0001                               	;BLKI IMP,      (continued)
03m0001                               	;------------------------------------------------------------------------------
03m0001 06615 140050030571000440020000	IMPBKI: MAPF[IMPI-CONTROL] CYLEN[IOB-IN] D[IOD] DEST[AR] PUSHJ[IMPIN1] $
03m0001                               	                ;Read control register and save it (i.e. second inst. of IMPIN)
03m0001                               	                ;Do second instruction of IMPIN and begin IMPIN
03m0001                               	                ;*** This instruction should be same as at IMPIN+1
03m0001 06616 662104204571000440002032	        D[MEM] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
03m0001                               	                ;Write data.  We're done
03m0001                               	
03m0001                               	;------------------------------------------------------------------------------
03m0001                               	;BLKO IMP,      (continued)
03m0001                               	;------------------------------------------------------------------------------
03m0001 06617 640042214275000043600000	IMPBKO: D[CONST 4] ALU[-D&Q] DEST[Q IOD] SPEC[IOB-OUT] PUSHJ[IMPOU1] NORM $
03m0001                               	                ;Turn off LAST BIT before doing output
03m0001                               	                ;*** This instruction should be same as at IMPOUT+1
03m0001                               	                ;Finish doing output
03m0001 06620 650140000571000000202026	        D[AR] SPEC[LEFT] COND[OBUS=0] JUMP[MAIN] NORM $
03m0001                               	                ;Check for skip.  If not, we're done
03m0001 06621 640164620433000440002027	        DOSKIP $
03m0001                               	                ;Skip return
03m0001                               	
03m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

04m0001                               	;------------------------------------------------------------------------------
04m0001                               	;CONO IMP,      (continued)
04m0001                               	;------------------------------------------------------------------------------
04m0001                               	IMPCNO: D[CONST 1] ROT[35. - 21.] ALU[-D&Q]
04m0001 06622 640701014275034013000000	                        DEST[Q IMPA-STATUS] SPEC[DEST-A-MEM] NORM $
04m0001                               	                ;Clear Imp Has Been Down
04m0001 06623 640710034433052010000000	IMPCO2: D[IR] ROT[20. + 1] MASK[1] ALU[D+1] DEST[AR] NORM $
04m0001                               	                ;Extract host down bit.  Complement it, sort of.
04m0001 06624 640700044171000030000000	        D-AMEM[D[IMPA-CONTROL + 8.] ]MASK[3] DEST[Q] NORM $
04m0001                               	                ;Extract all but host ready bit.
04m0001                               	                ;*** Note, if other control bits are added, this code will lose
04m0001 06625 640700000175006040000000	        D[AR] ROT[3] MASK[4] ALU[DORQ] DEST[Q] NORM $
04m0001                               	                ;Turn on host ready bit.  Note MASK[4] allow complementing of
04m0001                               	                ;single bit, i.e. 0->01->1, 1->10->0
04m0001 06626 531140034571052440000000	        D[IR] ROT[21.] COND[-OBUS<0] JUMP[IMPCO3] C550 $
04m0001                               	                ;Stop output?
04m0001 06627 640700014275000013600000	        D[CONST 1] ALU[-D&Q] DEST[Q] SPEC[IOB-OUT] NORM $
04m0001                               	                ;Yes.  Stop it from interrupting.  Start clearing output
04m0001                               	        MAPF[IMPO-CLEAR-OUTPUT] CYLEN[IOB-OUT]
04m0001 06630 471140034571054440020000	                D[IR] ROT[22.] COND[-OBUS<0] JUMP[IMPC3A] $
04m0001                               	                ;Finish clearing output.
04m0001                               	                ;If not also clearing output, go clear Output Empty.
04m0001 06631 031140034571054440000000	IMPCO3: D[IR] ROT[22.] COND[-OBUS<0] JUMP[IMPCO4] $
04m0001                               	                ;End of output (message)?
04m0001 06632 640700014175000053400000	        D[CONST 5] ALU[DORQ] DEST[Q] SPEC[IOB-IN] NORM $
04m0001                               	                ;Turn on Last Bit and interrupt enable.  (Turned off by next
04m0001                               	                ;DATAO).  We'll pass it to the hardware later.
04m0001                               	                ;Read status of device
04m0001 06633 140710030571000440020000	        MAPF[IMPI-CONTROL] CYLEN[IOB-IN] D[IOD] DEST[AR] $
04m0001                               	                ;Latch state of interface, 'cause we can't condition off IOD
04m0001                               	;;;     D[AR] ROT[12.] COND[OBUS<0] JUMP[IMPC3A] C550 $
04m0001                               	;;;             ;Jump if interface isn't done.  (We should be here in that case
04m0001                               	;;;             ;as the programmer is supposed to wait for things to finish.)
04m0001 06634 511140000571034440000000	        D[AR] ROT[14.] COND[OBUS<0] JUMP[IMPC3A] C550 $
04m0001                               	                ;Jump if there's a word already in progress
04m0001 06635 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $
04m0001                               	                ;Interface can't send last bit without having something to
04m0001                               	                ;attach it to.  We send a word of zeros, which shouldn't
04m0001                               	                ;matter, as this feature is used only to clear out any stale
04m0001                               	                ;packets when bringing up host.
04m0001                               	                ;MAPF and CYLEN are in case we had to deflower the interface.
04m0001 06636 440700200555000443030000	IMPC3A: MAPF[IMPO-DATA] CYLEN[IOB-OUT] ALU[Q] DEST[IMPA-CONTROL] DEST-A-MEM $
04m0001                               	                ;Save state of control register
04m0001 06637 640700060171000440000000	        D-AMEM[D[IMPA-STATUS + 8.] ]DEST[Q] NORM $
04m0001                               	                ;Get status of device into Q where we can use it.
04m0001 06640 640701014675016013000000	        D[CONST 1] ROT[35. - 28.] ALU[-D&Q] DEST[IMPA-STATUS] DEST-A-MEM NORM $
04m0001                               	                ;Turn off Output Ready
04m0001 06641 000140044171000440000000	        D-AMEM[D[IMPA-CONTROL + 8.] ]DEST[Q] JUMP[IMPC4A] $
04m0001                               	                ;Restore Q from CONTROL
04m0001                               	IMPCO4: MAPF[IMPO-DATA] CYLEN[IOB-OUT]
04m0001 06642 440700200555000443030000	                        ALU[Q] DEST[IMPA-CONTROL] SPEC[DEST-A-MEM] $
04m0001 06643 531140034571056440000000	IMPC4A: D[IR] ROT[23.] COND[-OBUS<0] JUMP[IMPCO5] C550 $
04m0001                               	                ;Clear input?
04m0001 06644 640710014575000023600000	        D[CONST 2] ALU[DORQ] DEST[AR] SPEC[IOB-OUT] NORM $
04m0001                               	                ;Yes.  Set input enable.  Clear input buffer.
04m0001                               	        MAPF[IMPO-CLEAR-INPUT] CYLEN[IOB-OUT]
04m0001 06645 440700060171000443600000	                        D-AMEM[D[IMPA-STATUS + 8.] ]DEST[Q] SPEC[IOB-OUT] $
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

04m0001                               	                ;Clear input done.  Get firmware status
04m0001                               	        MAPF[IMPO-CLEAR-FULL] CYLEN[IOB-OUT] 
04m0001 06646 440700200571000443010000	                        D[AR] DEST[IMPA-CONTROL] SPEC[DEST-A-MEM] $
04m0001                               	                ;Remember new control value.  Don't set it yet, let DMA happen
04m0001                               	                ;(We'll pass it to the hardware later.)
04m0001 06647 640700014275026010000000	        D[CONST 1] ROT[35. - 24.] ALU[-D&Q] DEST[Q] NORM $
04m0001                               	                ;Remove Last Bit from status.  Finally send out control word
04m0001                               	                ;to hardware! (Remember we set IOD above?)
04m0001                               	        D[CONST 1] ROT[35. - 32.] ALU[-D&Q]
04m0001 06650 640701014675006013000000	                        DEST[IMPA-STATUS] SPEC[DEST-A-MEM] NORM $
04m0001                               	                ;Remove Input Full from status.
04m0001 06651 640701614571000023000000	        D[CONST 2] DEST[7] DEST-A-MEM SHORT $
04m0001                               	                ;Set debugging flag for intrpt. routine
04m0001 06652 640700054171000440000000	IMPCO5: D-AMEM[D[IMPA-MASK + 8.] ]DEST[Q] NORM $
04m0001                               	                ;Get special mask
04m0001 06653 650150034235000440000000	        D[IR] ALU[D&Q] DEST[Q AR] COND[OBUS=0] JUMP[IMPCOX] NORM $
04m0001                               	                ;Extract channel selection
04m0001 06654 640710000077102440000000	        D[AR] ROT[36. - 3] ALU[Q-D] DEST[Q AR] NORM $
04m0001                               	                ;Make into masks for PI setting.  Three separate three
04m0001                               	                ;bit masks, i.e. .xxx.yyy.zzz from x...y...z...
04m0001 06655 640704434635000440000000	        D[IR] ALU[D&Q] DEST[HOLD] NORM $
04m0001                               	                ;Extract new fields
04m0001 06656 640700060171000440000000	        D-AMEM[D[IMPA-STATUS + 8.] ]DEST[Q] NORM $      ;Stupid 2901
04m0001 06657 640700000275000440000000	        D[AR] ALU[-D&Q] DEST[Q] NORM $
04m0001                               	                ;Remove old PI channel settings
04m0001 06660 640701004575000443000000	        D[MEM] ALU[DORQ] DEST[IMPA-STATUS] SPEC[DEST-A-MEM] NORM $
04m0001                               	                ;Finally, put away PI channel settings to make it easy for CONI
04m0001 06661 000700044171000440000000	        D-AMEM[D[IMPA-CONTROL + 8.] ]DEST[Q] $
04m0001                               	                ;Cause interrupts if needed
04m0001 06662 010140004571010030000000	        D[MEM] ROT[35. - 31.] MASK[3] COND[OBUS=0] JUMP[IMPCO6] $
04m0001                               	                ;Enable output interrupts if we turned that channel on.
04m0001 06663 640700214175000013000000	        D[CONST 1] ALU[DORQ] DEST[Q IMPA-CONTROL] SPEC[DEST-A-MEM] NORM $
04m0001                               	                ;Yes, enable it.  We'll pass it to the hardware later.
04m0001 06664 010140004571010030000000	IMPCO6: D[MEM] ROT[35. - 31.] MASK[3] COND[OBUS=0] JUMP[IMPCOX] $
04m0001                               	                ;Enable input interrupts if we turned that channel on.
04m0001 06665 640700214175000023000000	        D[CONST 2] ALU[DORQ] DEST[Q IMPA-CONTROL] SPEC[DEST-A-MEM] NORM $
04m0001                               	                ;Yes, enable it.  We'll pass it to the hardware later.
04m0001 06666 640702244571000443600000	IMPCOX: D-AMEM[D[IMPA-CONTROL + 8.] ]DEST[IOD] SPEC[IOB-OUT] NORM $
04m0001                               	                ;Update hardware.
04m0001 06667 440160000571000440642027	        MAPF[IMPO-CONTROL] CYLEN[IOB-OUT] DEST[MA] SPEC[MA_PC] JUMP[MAIN1] $
04m0001                               	                ;Complete output and start next instruction fetch.
04m0001                               	
04m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

05m0001                               	;------------------------------------------------------------------------------
05m0001                               	;IMPSTS         Get status from IMP
05m0001                               	;
05m0001                               	;Description:
05m0001                               	;   Updates IMP down bits and returns firmware status.
05m0001                               	;
05m0001                               	;Returns:
05m0001                               	;       Q:      Status
05m0001                               	;Called by:     IMPCONI,IMPCONSZ,IMPCONSO
05m0001                               	;Calls:         Nothing
05m0001                               	;Clobbers:      Q,IOD,AR
05m0001                               	;------------------------------------------------------------------------------
05m0001 06670 640700060171000443400000	IMPSTS: D-AMEM[D[IMPA-STATUS + 8.] ]DEST[Q] SPEC[IOB-IN] NORM $
05m0001                               	                ;Copy firmware status into Q
05m0001 06671 140050030571000440020000	        MAPF[IMPI-CONTROL] CYLEN[IOB-IN] D[IOD] DEST[AR] PUSHJ[IMPDWC] $
05m0001                               	                ;Obtain hardware status in AR
05m0001                               	                ;Check IMP down status
05m0001 06672 530300000771000440000000	        D[AR] ALU[NOTD] COND[-OBUS=0] POPJ C550 $
05m0001                               	                ;If we read -1 from device, it isn't really here.
05m0001                               	                ;Otherwise, we're done.
05m0001 06673 640300000215000440000000	        ALU[0] DEST[Q] POPJ NORM $
05m0001                               	                ;Device just plain isn't there.  This is what is returned on
05m0001                               	                ;a non-existent device.
05m0001                               	
05m0001                               	;Subroutine to check for host down
05m0001 06674 000300000571000440000000	IMPDWC: POPJ $ ;;;;;;;;#####D[AR] ROT[19.] COND[-OBUS<0] POPJ C550 $
05m0001                               	                ;Return if not down
05m0001                               	        D[CONST 1] ROT[35. - 21.] ALU[DORQ]
05m0001 06675 640701014175034013000000	                        DEST[Q IMPA-STATUS] SPEC[DEST-A-MEM] NORM $
05m0001                               	                ;Set error flip-flop
05m0001 06676 640300014175036010000000	        D[CONST 1] ROT[35. - 20.] ALU[DORQ] DEST[Q] NORM POPJ $
05m0001                               	                ;Set host down and return.
05m0001                               	
05m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

06m0001                               	;------------------------------------------------------------------------------
06m0001                               	;IMPIN          Read word from IMP
06m0001                               	;
06m0001                               	;Returns:
06m0001                               	;       MEM:    Data
06m0001                               	;Called by:     IMPDATAI,IMPBLKI
06m0001                               	;Calls:         Nothing
06m0001                               	;Clobbers:      Q,IOD,AR,HOLD,ROTR,MASKR
06m0001                               	;
06m0001                               	;Note:  To save time at no expense in space, first two instruction here are
06m0001                               	;       functionally replicated for BLKI IMP,
06m0001                               	;------------------------------------------------------------------------------
06m0001 06677 640700000571000443400000	IMPIN:  SPEC[IOB-IN] CYLEN[FIXM] $
06m0001                               	                ;A write cycle happens here on BLKI
06m0001                               	                ;*** Don't change this without changing BLKI IMP,
06m0001 06700 140710030571000440020000	        MAPF[IMPI-CONTROL] CYLEN[IOB-IN] D[IOD] DEST[AR] $
06m0001                               	                ;Read control register and save it.
06m0001                               	                ;*** Don't change this without changing BLKI IMP,
06m0001 06701 640701200473030063400000	IMPIN1: D[AR] ROT[11. + 1] MASK[6] ALU[0-D] DEST[ROTR] SPEC[IOB-IN] NORM $
06m0001                               	                ;Setup Rotator.  Start reading data
06m0001 06702 140704430171200440040000	        MAPF[IMPI-DATA] CYLEN[IOB-IN] D[IOD] ROT[R] DEST[Q HOLD] $
06m0001                               	                ;Put adjusted data into HOLD (MEM).  Save also in Q
06m0001 06703 531140000571040440000000	        D[AR] ROT[16.] COND[-OBUS<0] JUMP[IMPIN3] C550 $
06m0001                               	                ;Jump if not Last Bit Seen, that is, the easy case
06m0001 06704 650140014531200010000000	        D[CONST 1] ROT[R] ALU[D-1] COND[OBUS=0] JUMP[IMPIN3] NORM $
06m0001                               	                ;*** If we read exactly one word, don't mess with it!  Note
06m0001                               	                ;*** that we still have to OR in a bit at the bottom (i think)
06m0001 06705 640701400473030060000000	        D[AR] ROT[11. + 1] MASK[6] ALU[0-D] DEST[MASKR] NORM $
06m0001                               	                ;Setup Masker
06m0001                               	        ;;;D[MASK R] ALU[-D&Q] DEST[Q] NORM $   ;*** Assembler blows this one
06m0001 06706 640700010275001000000000	        D[2] MASK[R] ALU[-D&Q] DEST[Q] NORM $   ;Sigh...
06m0001                               	                ;Pad with zeros, that is, get rid of extra junk
06m0001 06707 640704414175200010000000	IMPIN2: D[CONST 1] ROT[R] ALU[DORQ] DEST[Q HOLD] NORM $
06m0001                               	                ;Last bit implies last bit is a one (1).  Force it
06m0001 06710 640700044171000443600000	IMPIN3: D-AMEM[D[IMPA-CONTROL + 8.] ]DEST[Q] SPEC[IOB-OUT] NORM $
06m0001                               	                ;Get control information into more convenient place
06m0001                               	                ;Setup for next input.
06m0001                               	        MAPF[IMPO-CLEAR-FULL] CYLEN[IOB-OUT] D[CONST 2] ALU[DORQ]
06m0001 06711 440700214175000023010000	                        DEST[Q IMPA-CONTROL] SPEC[DEST-A-MEM] $
06m0001                               	                ;Turn on input interrupt enable
06m0001 06712 640702200555000443600000	        ALU[Q] DEST[IOD] SPEC[IOB-OUT] SHORT $
06m0001                               	                ;Tell hardware about this
06m0001 06713 440700060171000440040000	        MAPF[IMPO-CONTROL] CYLEN[IOB-OUT] D-AMEM[D[IMPA-STATUS + 8.] ]DEST[Q] $
06m0001                               	                ;Finish setting hardware control register.
06m0001                               	                ;Get firmware status
06m0001                               	        D[CONST 1] ROT[35. - 32.] ALU[-D&Q] DEST[IMPA-STATUS] SPEC[DEST-A-MEM]
06m0001 06714 640301014675006013000000	                        POPJ NORM $
06m0001                               	                ;Turn off input ready, and return.
06m0001                               	
06m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

07m0001                               	;------------------------------------------------------------------------------
07m0001                               	;IMPOUT         Output data in MEM to IMP
07m0001                               	;
07m0001                               	;Description:
07m0001                               	;   Sends data in MEM to IMP interface.  Enables micro-interrupts for
07m0001                               	;completion of transfer.
07m0001                               	;
07m0001                               	;Called by:     IMPDATAO,IMPBLKO
07m0001                               	;Calls:         Nothing
07m0001                               	;Clobbers:      Q,IOD
07m0001                               	;
07m0001                               	;Note:  To save time at no expense in space, first two instruction here are
07m0001                               	;       functionally replicated for BLKO IMP,
07m0001                               	;------------------------------------------------------------------------------
07m0001 06715 640700044171000440000000	IMPOUT: D-AMEM[D[IMPA-CONTROL + 8.] ]DEST[Q] NORM $
07m0001                               	                ;Copy into Q so we can manipulate control word
07m0001                               	                ;*** Don't change this without changing BLKO IMP,
07m0001 06716 640702214275000043600000	        D[CONST 4] ALU[-D&Q] DEST[Q IOD] SPEC[IOB-OUT] NORM $
07m0001                               	                ;Turn off LAST BIT before doing output
07m0001                               	                ;*** Don't change this without changing BLKO IMP,
07m0001 06717 440702204571000443640000	IMPOU1: MAPF[IMPO-CONTROL] CYLEN[IOB-OUT] D[MEM] DEST[IOD] SPEC[IOB-OUT] $
07m0001                               	                ;Output data ...
07m0001                               	        MAPF[IMPO-DATA] CYLEN[IOB-OUT]
07m0001 06720 440702214175000013630000	                        D[CONST 1] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
07m0001                               	                ;Enable output interrupts
07m0001                               	        MAPF[IMPO-CONTROL] CYLEN[IOB-OUT]
07m0001 06721 440700200555000443040000	                        ALU[Q] DEST[IMPA-CONTROL] SPEC[DEST-A-MEM] $
07m0001                               	                ;Remember we turned it on.
07m0001 06722 640700060171000440000000	        D-AMEM[D[IMPA-STATUS + 8.] ]DEST[Q] NORM $
07m0001                               	                ;Turn off bit in status
07m0001                               	        D[CONST 1] ROT[35. - 28.] ALU[-D&Q] DEST[IMPA-STATUS] SPEC[DEST-A-MEM]
07m0001 06723 640301014675016013000000	                        POPJ NORM $
07m0001                               	                ;Write it back and we're done
07m0001                               	
07m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

08m0001                               	;------------------------------------------------------------------------------
08m0001                               	;IMP Interrupt Code
08m0001                               	;------------------------------------------------------------------------------
08m0001 06724 640700060171000443400000	IMPINT: D-AMEM[D[IMPA-STATUS + 8.] ]DEST[Q] SPEC[IOB-IN] NORM $
08m0001                               	                ;Get firmware status while waiting for hardware status.
08m0001 06725 140704430571000440020000	        MAPF[IMPI-CONTROL] CYLEN[IOB-IN] D[IOD] DEST[HOLD] $
08m0001                               	                ;Get hardware status
08m0001                               	;;;     D[CONST 21] ROT[3] ALU[-D&Q] DEST[Q] NORM $
08m0001                               	;;;             ;Remove old Input Full and Output Done status bits
08m0001 06726 531140004571046440000000	        D[MEM] ROT[19.] COND[-OBUS<0] JUMP[IMPNT1] C550 $
08m0001                               	                ;Check for IMP down
08m0001                               	        D[CONST 1] ROT[35. - 21.] ALU[DORQ]
08m0001 06727 640701014175034013000000	                        DEST[Q IMPA-STATUS] SPEC[DEST-A-MEM] NORM $
08m0001                               	                ;Set error flip-flop
08m0001 06730 531140004571034440000000	IMPNT1: D[MEM] ROT[14.] COND[-OBUS<0] JUMP[IMPNT2] C550 $
08m0001                               	                ;Jump if output not waiting.
08m0001 06731 510140044571000010000000	        D-AMEM[D[IMPA-CONTROL + 8.] ]MASK[1] C550 OBUS=0 JUMP[IMPNT2] $
08m0001                               	                ;Ignore if output ints. not enabled !!
08m0001                               	        D[CONST 1] ROT[35. - 28.] ALU[DORQ]
08m0001 06732 640701014175016013000000	                        DEST[Q IMPA-STATUS] SPEC[DEST-A-MEM] NORM $
08m0001                               	                ;Turn on Ready for Output
08m0001 06733 640710060571100030000000	        D-AMEM[D[IMPA-STATUS + 8.] ]ROT[31. + 1] MASK[3] DEST[AR] NORM $
08m0001                               	                ;Extract PI channel for use by IMPNTS
08m0001 06734 640040014171000010000000	        D[CONST 1] DEST[Q] PUSHJ[IMPDIS] NORM $
08m0001                               	                ;Turn off output interrupts and take macro interrupt if enabled
08m0001 06735 531140004571044440000000	IMPNT2: D[MEM] ROT[18.] COND[-OBUS<0] JUMP[IMPNT5] C550 $
08m0001                               	                ;Jump if input not ready
08m0001 06736 511140004571040440000000	        D[MEM] ROT[16.] COND[OBUS<0] JUMP[IMPNT6] C550 $
08m0001                               	                ;Jump if both input and last bit at same time.  We'll want two
08m0001                               	                ;macro interrupts
08m0001                               	IMPNT3: D[CONST 1] ROT[35. - 32.] ALU[DORQ]
08m0001 06737 640701014175006013000000	                        DEST[Q IMPA-STATUS] SPEC[DEST-A-MEM] NORM$
08m0001                               	                ;Turn on Input Full
08m0001 06740 640710060571110030000000	        D-AMEM[D[IMPA-STATUS + 8.] ] ROT[35. + 1] MASK[3] DEST[AR] NORM $
08m0001                               	                ;Extract PI channel for use by IMPNTS
08m0001 06741 640040014171000020000000	IMPNT4: D[CONST 2] DEST[Q] PUSHJ[IMPDIS] NORM $
08m0001                               	                ;Turn off input interrupts and take macro interrupt if enabled
08m0001 06742 640162400571000440602027	IMPNTX: DEST[CLR-DEV-FROM-INTR MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
08m0001                               	                ;Nothing more to check.  Dismiss micro-interrupt
08m0001 06743 531140004571040440006742	IMPNT5: D[MEM] ROT[16.] COND[-OBUS<0] JUMP[IMPNTX] C550 $
08m0001                               	                ;Done if not last bit seen
08m0001 06744 670140014635026010000000	IMPNT6: D[CONST 1] ROT[35. - 24.] ALU[D&Q] COND[-OBUS=0] JUMP[IMPNT7] NORM $
08m0001                               	                ;If this is our second time thru, take interrupt for Last Bit
08m0001                               	        D[CONST 1] ROT[35. - 24.] ALU[DORQ]
08m0001 06745 640701014175026013000000	                        DEST[Q IMPA-STATUS] SPEC[DEST-A-MEM] NORM $
08m0001                               	                ;Turn on Last Bit Seen
08m0001                               	                ;Input is one and Last Bit is off (or are different)
08m0001                               	;;; Always give input full, once only
08m0001                               	;;;     D[MEM] ROT[5 + 1] MASK[6] DEST[Q] NORM $
08m0001                               	;;;             ;Get input bit counter
08m0001                               	;;;     D[CONST 34] ALU[D-Q] COND[OBUS=0] JUMP[IMPNT7] C550 $
08m0001                               	;;;             ;Jump if just last bit on
08m0001                               	;;;     D-AMEM[IMPA-STATUS] DEST[Q] NORM $
08m0001                               	;;;             ;Get new firmware status and mark input buffer full
08m0001                               	        D[CONST 1] ROT[35. - 32.] ALU[DORQ]
08m0001 06746 640701014575006013000000	                        DEST[IMPA-STATUS] SPEC[DEST-A-MEM] NORM $
08m0001                               	        D-AMEM[D[IMPA-STATUS + 8.] ] ROT[35. + 1] MASK[3] DEST[AR]
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

08m0001 06747 030150060571110030004564	                        COND[-OBUS=0] JUMP[PIGEN] $
08m0001                               	                ;Extract PI channel and take interrupt here and now if enabled
08m0001                               	                ;DON'T disable micro input interrupts until we make a second
08m0001                               	                ;PI Request for the Last Bit!
08m0001 06750 640150060571070030006741	IMPNT7: D-AMEM[D[IMPA-STATUS + 8.] ] ROT[27. + 1] MASK[3] DEST[AR] JUMP[IMPNT4] NORM $
08m0001                               	                ;Extract PI channel for use by IMPNTS
08m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

09m0001                               	;------------------------------------------------------------------------------
09m0001                               	;IMPDIS         Disable IMP micro-interrupts and take PI if enabled.
09m0001                               	;
09m0001                               	;Arguments:
09m0001                               	;       AR:     Channel number
09m0001                               	;       Q:      Enable bit (in IMPA-CONTROL)
09m0001                               	;
09m0001                               	;Note:  Restores Q to control IMPA-STATUS.  May not return if interrupt is
09m0001                               	;       taken.
09m0001                               	;------------------------------------------------------------------------------
09m0001 06751 510140044635000440000000	IMPDIS: D-AMEM[D[IMPA-CONTROL + 8.] ]ALU[D&Q] COND[OBUS=0] JUMP[IMPDSX] C550 $
09m0001                               	                ;If interrupt disabled, forget it.  Restore Q and return
09m0001 06752 640702244137000443600000	        D-AMEM[D[IMPA-CONTROL + 8.] ]ALU[D-Q] DEST[Q IOD] SPEC[IOB-OUT] NORM $
09m0001                               	                ;Disable interrupt
09m0001                               	                ;We can do subtract since we've already established there's
09m0001                               	                ;a bit to turn off
09m0001                               	        MAPF[IMPO-CONTROL] CYLEN[IOB-OUT]
09m0001 06753 440700200555000443040000	                        ALU[Q] DEST[IMPA-CONTROL] SPEC[DEST-A-MEM] $
09m0001                               	                ;Remember enablings as well.
09m0001 06754 670140000571000440004564	        D[AR] COND[-OBUS=0] JUMP[PIGEN] NORM $
09m0001                               	                ;Try to take macro interrupt if channel supplied
09m0001 06755 640300060171000440000000	IMPDSX: D-AMEM[D[IMPA-STATUS + 8.] ]DEST[Q] POPJ NORM $
09m0001                               	                ;Get back firmware status and return
09m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

10m0001                               	;------------------------------------------------------------------------------
10m0001                               	;IMPRST         IMP initialization routine
10m0001                               	;
10m0001                               	;Called by:     Reset
10m0001                               	;Calls:         Nothing
10m0001                               	;Clobbers:      AMEM[0:7],Q,IOD,DEV-ADR
10m0001                               	;
10m0001                               	;Note:  This code appear after IMPINT and IMPDSP due to forward reference
10m0001                               	;       problems in CONST expressions.
10m0001                               	;------------------------------------------------------------------------------
10m0001 06756 000701614571000160000000	IMPRST: D[CONST IMPUDEV] DEST[DEV-ADR] $
10m0001                               	                ;Set device code for initialization
10m0001                               	;Entry point for second IMP
10m0001 06757 640700200615000443000000	IMPRS2: ALU[0] DEST[IMPA-CONTROL] SPEC[DEST-A-MEM] NORM $
10m0001                               	                ;Reset saved control register
10m0001 06760 640700014171040010000000	        D[CONST 1] ROT[35. - 19.] DEST[Q] NORM $
10m0001 06761 640701014575016013000000	        D[CONST 1] ROT[35. - 28.] ALU[DORQ] DEST[IMPA-STATUS] DEST-A-MEM NORM $
10m0001                               	                ;Initially, have just interface present and output ready.
10m0001                               	                ;If harware isn't there, then IMPSTS will return zero.
10m0001 06762 640702244571000443600000	        D-AMEM[D[IMPA-CONTROL + 8.] ]DEST[IOD] SPEC[IOB-OUT] NORM $
10m0001                               	                ;Clear the device registers ...
10m0001 06763 440702200615000443640000	        MAPF[IMPO-CONTROL] CYLEN[IOB-OUT] ALU[0] DEST[IOD] SPEC[IOB-OUT] $
10m0001                               	                ;Reset control register
10m0001 06764 440700000571000443620000	        MAPF[IMPO-CLEAR-OUTPUT] CYLEN[IOB-OUT] SPEC[IOB-OUT] $
10m0001                               	                ;Clear output side
10m0001                               	        MAPF[IMPO-CLEAR-INPUT] CYLEN[IOB-OUT]
10m0001                               	;;;                     SPEC[IOB-OUT]
10m0001                               	;;;             ;I don't think we want to start input until we're told via CONO
10m0001 06765 440702214171014420000000	                        D[CONST 42] ROT[6] DEST[Q] DEST[IOD] $
10m0001                               	                ;Start construction of mask for PI's and status bits
10m0001                               	                ;Clear input side
10m0001                               	                ;NOTE: input MAPFs must go in this order
10m0001                               	        MAPF[IMPO-CLEAR-FULL] CYLEN[IOB-OUT]
10m0001 06766 440700614575000103010000	                        D[CONST 10] ALU[DORQ] DEST[IMPA-MASK] SPEC[DEST-A-MEM]$
10m0001                               	                ;Finish and store mask for PI's and status bits
10m0001                               	;Setup entry vectors: IOT vector in left half, interrupt vector in right half
10m0001 06767 640700014171060650000000	        D[CONST (IMPDSP / 100)] ROT[18. + 6.] DEST[Q] NORM $    ;hi 6 iot bits
10m0001 06770 640700014175044750000000	        D[CONST (IMPDSP \ 100)] ROT[18.] ALU[DORQ] DEST[Q] NORM $
10m0001                               	                ;low order 6 iot bits
10m0001 06771 640700014175014670000000	        D[CONST (IMPINT / 100)] ROT[6.] ALU[DORQ] DEST[Q] NORM $
10m0001                               	                ;high order 6 interrupt bits
10m0001                               	        D[CONST (IMPINT \ 100)] ROT[0] ALU[DORQ]                ;lo 6 intr bits
10m0001 06772 640300014575000243000000	                        SPEC[DEST-A-MEM] DEST[IMPA-VECTOR] POPJ NORM $
10m0001                               	                ;Finish setting up vectors and return.
10m0001                               	
10m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:IMP.SLO  --  of -- SCI

11m0001                               	;------------------------------------------------------------------------------
11m0001                               	;BLKI1,BLKI2    Two parts of a BLKI instruction
11m0001                               	;------------------------------------------------------------------------------
11m0001 06773 640700004171000440000000	BLKI1:  D[MEM] DEST[Q] NORM $
11m0001                               	                ;Put IOWD pointer into Q to do incrementing.  No HALF test,
11m0001                               	                ;we don't worry about page faults here.
11m0001 06774 662144214035001000000000	        D[CONST 1,,1] ALU[D+Q] DEST[Q MEMSTO] COND[-MA-AC] JUMP[BLKI1A] NORM $
11m0001                               	                ;Increment both halves. (Note: overflow will from right half
11m0001                               	                ;will be added to left half.  People who wrap around memory
11m0001                               	                ;deserve what they get!)
11m0001 06775 640700005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] $
11m0001                               	                ;Also write into AC if needed
11m0001 06776 650300004571000000200000	BLKI1A: D[MEM] SPEC[LEFT] COND[OBUS=0] POPJ CYLEN[MEMSTO] $
11m0001                               	                ;Finish writing back IOWD pointer. No MAPF needed because of
11m0001                               	                ;FIXM2.
11m0001                               	                ;Return if not skip return
11m0001 06777 640304620433000440000000	                D[PC] ALU[D+1] DEST[PC] POPJ NORM $
11m0001                               	                ;Skip return, take it here
11m0001                               	.REPEAT 0 [;11m0001                               	.REPEAT 0
11m0001                               	;------------------------------------------------------------------------------
11m0001                               	;BLKO1,BLKO2    Two parts of a BLKO instruction
11m0001                               	;------------------------------------------------------------------------------
11m0001 07000 640710004171000440000000	BLKO1:  D[MEM] DEST[Q AR] NORM $
11m0001 07001 530140064571000440000000	        D-AMEM[D[IMPA-HALF + 8.] ] COND[-OBUS=0] JUMP[BLKO1A] C550 $
11m0001                               	                ;Put IOWD pointer into Q to do incrementing
11m0001                               	                ;Also, put a copy in AR for testing after fetch (page fault)
11m0001                               	                ;Have we been here before? (If so, don't increment)
11m0001                               	        D[CONST 1,,1] ALU[D+Q] DEST[Q AR MEMSTO]
11m0001 07002 662154214035001000000000	                        COND[-MA-AC] JUMP[BLKO1A] NORM $
11m0001                               	                ;Increment both halves. (Note: overflow will from right half
11m0001                               	                ;will be added to left half.  People who wrap around memory
11m0001                               	                ;deserve what they get!)
11m0001                               	                ;Also, put a copy in AR for testing after fetch (page fault)
11m0001 07003 640700005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] $
11m0001                               	                ;Also write into AC
11m0001 07004 640701200741000443000000	BLKO1A: ALU[-1] DEST[IMPA-HALF] DEST-A-MEM CYLEN[MEMSTO] $
11m0001                               	                ;Finish previous write cycle (if not AC).  Note that we don't
11m0001                               	                ;need a MAPF field because we've already (should have) done a
11m0001                               	                ;FIXM2
11m0001                               	                ;Set the First Part Done flag, in case we take a page trap.
11m0001 07005 640720004571000440000000	        D[MEM] DEST[MA] CYLEN[MEMSTO] $
11m0001                               	                ;Set MA for reading new data
11m0001 07006 640706000550400440110000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BYTE-ILD]  CYLEN[FIXM] $
11m0001                               	                ;Finish reading and go off to output it.  This instruction can
11m0001                               	                ;get a page fault.  If it does, the PC will be backed up and
11m0001                               	                ;the HALF flag set, which will prevent an extra increment.  We
11m0001 07007 640301200615000443000000	        ALU[0] DEST[IMPA-HALF] DEST-A-MEM NORM POPJ $
11m0001                               	                ;also clear it here if we don't page fault.
11m0001                               	.repeat 0 [;11m0001                               	;;.repeat 0

SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

45m0164                               	
45m0164                               	]IMP
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	;
45m0164                               	;       Panofsky-Samson Interface
45m0164                               	;
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	.REPEAT STANSW [
45m0164                               	.REPEAT STANSW
45m0164                               	
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	;
45m0164                               	;       Data Line Scanner (TTY scanner)
45m0164                               	;
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	.REPEAT DLS [
45m0164                               	
45m0164                               	.DEFINE ASRC[45m0164                               	.DEFINE ADEST[45m0164                               	
45m0164                               	.REPEAT DLS2 [
45m0164                               	.INSERT DLS.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- SCI

01m0001                               	;#####################################################################
01m0001                               	;   Let's make the dls be macro device 370;  so the
01m0001                               	;   iot's will have opcode 737, dispatch table
01m0001                               	;   entry loc. 3676
01m0001                               	;#########################################################################
01m0001                               	
01m0001                               	;-----------------------------------------------------------------------
01m0001                               	;DLS definitions
01m0001                               	;-----------------------------------------------------------------------
01m0001       37	DLS = 37        ;MACRODEVICE CODE 370
01m0001       7010	DLSORG = .  ;; DWP 1/27/80 %%% DLSORG = 7000    ;UCODE ORIGIN
01m0001       2137	DLSVECTOR = 2137        ;Interrupt dispatch address
01m0001                               	
01m0001                               	.REPEAT DLS2 [D01m0001       20	LSWEBIT = 16.   ;ASTRO write enable bit
01m0001       37	DLSNLINES = 37  ;Highest line number
01m0001       5	DLSLNSIZE = 5   ;Number of bits in line-number field
01m0001                               	.DEFINE DLSIRQ 01m0001                               	.DEFINE DLSNOIRQ .REPEAT 1 - DLS2 [D01m0001                               	
01m0001                               	;
01m0001                               	;A-MEM definitions
01m0001                               	;
01m0001       0	DLSINTAD = 0    ;Interrupt service routine
01m0001       1	DLSPICHN = 1    ;PI channel for DLS
01m0001       2	DLSLINE = 2     ;Line number which the scanner is simulated to have
01m0001                               	                ;stopped on
01m0001       3	DLSACT = 3      ;Active line flags
01m0001                               	                ;   DLSCNI1
01m0001       4	DLSTMP = 4      ;SCRATCH
01m0001                               	;
01m0001                               	;MAPF fields (IO SUBSEL)
01m0001                               	;
01m0001       0	DLSCR1 = 0      ;ASTRA CR1 (Control Register 1)
01m0001                               	;               Async                   Sync
01m0001                               	;       Bit 28          Normal mode (NOT looped)
01m0001                               	;       Bit 29  Send break              Xmit transparent
01m0001                               	;       Bit 30  Single stop bit         Transmit parity
01m0001                               	;                 if xmit enabled         if bit 29 is zero
01m0001                               	;         else  Not MISC OUT = 0        Force DLE
01m0001                               	;       Bit 31  Auto-echo (1/2 duplex)  Not MISC OUT = 0 (bit 29=0)
01m0001                               	;                                       DLE stripping (bit 29=1)
01m0001                               	;       Bit 32  Parity enable           Recieve parity enable
01m0001                               	;       Bit 33          Reciever enabled
01m0001                               	;       Bit 34          not RTS OUT = 0
01m0001                               	;       Bit 35          not DTR OUT = 0
01m0001                               	;
01m0001       1	DLSCR2 = 1      ;ASTRA CR2 (Control Register 2)
01m0001                               	;   Bits 28:29          Character length
01m0001                               	;               00  8 bits      10  6 Bits
01m0001                               	;               01  7 bits      11  5 Bits
01m0001                               	;       Bit 30  0  Asynchronous         1  Synchronous
01m0001                               	;       Bit 31  0  Odd parity           1  Even parity
01m0001                               	;       Bit 32  Rcv clk = xmt clk       SYN strip (CR1 bit 29=0)
01m0001                               	;               else Rcv clk = Rate 1   DEL-SYN strip (CR1 bit 29=1)
01m0001                               	;   Bits 33:35  Transmit clock select
01m0001                               	;       000     Ext. clock (EIA pins:  Xmt=15, Rcv=17 [???])
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- SCI

01m0001                               	;       001     Rate 1          150 baud
01m0001                               	;       010     Rate 2          300 baud
01m0001                               	;       011     Rate 3          109.9 baud      *** 1200 baud Temp.
01m0001                               	;       100     Rate 4          9600 baud
01m0001                               	;       101     Rate 4 / 2      4800 baud
01m0001                               	;       110     Rate 4 / 4      2400 baud
01m0001                               	;       111     Rate 4 / 8      1200 baud
01m0001                               	;
01m0001       2	DLSSTAT = 2     ;ASTRA Status register
01m0001                               	;       Bit 28  Data Set Change (DSR or CD changed while DTR=1, or RI
01m0001                               	;                 changed while DTR=0)
01m0001                               	;       Bit 29  DSR (Data Set Ready)
01m0001                               	;       Bit 30  CD (Carrier Detect)
01m0001                               	;       Bit 31  Framing error or SYN detect
01m0001                               	;       Bit 32  Parity error [Async, too???] or DLE detect
01m0001                               	;       Bit 33  Overrun error
01m0001                               	;       Bit 34  Data recieved
01m0001                               	;       Bit 35  Transmit holding register empty  (Note: this does NOT
01m0001                               	;                 necessarily mean the transmitter is off)
01m0001                               	;On write, this sets the SYN register, and if immediately followed by
01m0001                               	;another write, that write sets the DLE register.
01m0001       3	DLSHOLD = 3     ;ASTRA xmt/rcv Hold register
01m0001       10	DLSCSR = 10     ;Interface Command/Status Register
01m0001       4	DLSIACK = 4     ;Interrupt acknowledge (also, interrupting line)
01m0001       14	DLSNOSEL = 14   ;Don't select anything
01m0001                               	
01m0001                               	;Macros for reading ASTRA registers.  They are macros because the
01m0001                               	;control logic on the prototype didn't have the timing correct for the
01m0001                               	;ASTRA and the problem was pushed onto the microcode.
01m0001                               	
01m0001                               	.DEFINE DLSREAD[01m0001                               	.DEFINE
01m0001                               	
01m0001                               	.DEFINE DLSWRITE[01m0001                               	DEFINE DLSWRITE
01m0001                               	
01m0001                               	.DEFINE DLSRINT[01m0001                               	DEFINE DLSRINT
01m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- SCI

02m0001                               	;-----------------------------------------------------------------------
02m0001                               	;Default configuration.  Lines are reset to this on initialization.
02m0001                               	;See DLS definition page for meaning of this bits.  Three groups of
02m0001                               	;lines may be initialized, allowing for local terminal, 300 buad modems
02m0001                               	;and split speed modems.
02m0001                               	
02m0001                               	;Caution:  Only lower 6 bits are permissible here.  This means you
02m0001                               	;          can't start out with looped, in break mode, or with character
02m0001                               	;          length other than 8.  You must use macro code to set those.
02m0001                               	;
02m0001                               	;Note:  Groups can be omitted by setting DLSGRPxN to zero.
02m0001                               	;-----------------------------------------------------------------------
02m0001                               	;*****  THIS SHOULD BE IN THE SITE DEPENDENT FILE  *****
02m0001                               	.DEFINE DLSINI 02m0001                               	;DLSINI
02m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- SCI

03m0001                               	;-----------------------------------------------------------------------
03m0001                               	; DLS Dispatch
03m0001                               	;-----------------------------------------------------------------------
03m0001       3676	DLSDISP = 3600 + DLS + DLS      ;Dispatch for DLS instructions
03m0001                               	:DLSDISP
03m0001 03676 640141614571000200003677	        D[CONST DLSDEV] DEST[DEV-ADR] JUMP[. + 1] NORM $
03m0001 03677 640140014171014700000000	        D[CONST DLSORG / 100] ROT[6] DEST[Q] JUMP[DLSIOT] NORM $
03m0001                               	:DLSORG         ;DISPATCH ON DLS IOT CODES
03m0001                               	
03m0001                               	DLSDISP2:
03m0001                               	.REPEAT DLSDEB [
03m0001                               	:DLSDISP2 + 40
03m0001                               	].REPEAT 1 - DLSDEB [
03m0001                               	DLSDEB
03m0001                               	
03m0001       10	DLSLOW = DLSORG \ 100
03m0001                               	DLSIOT:
03m0001                               	
03m0001 07050 640700014175000100000000	                D[CONST DLSLOW] ALU[DORQ] DEST[Q] NORM $
03m0001 07051 640700034035032040000000	        D[IR] ROT[13.] MASK[4] ALU[D+Q] DEST[Q] NORM $
03m0001 07052 500540034435032040000000	        D[IR] ROT[13.] MASK[4] ALU[D+Q] SDISP CYLEN[C550] $
03m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- SCI

04m0001                               	;-----------------------------------------------------------------------
04m0001                               	;BLKI DLS,
04m0001                               	DLSBLKI:
04m0001                               	.REPEAT 1 - DLSDEB [
04m0001                               	DLSDEB
04m0001                               	;-----------------------------------------------------------------------
04m0001                               	;DATAI DLS,
04m0001                               	;
04m0001                               	;       Bit 12  This is a modem control line
04m0001                               	;   Bits 13:17  Line number
04m0001                               	;       Bit 27  Interrupt from reciever (always true for modem control)
04m0001                               	;   Bits 28:35  Character (Note: 5 bit characters do NOT use bit 27 for
04m0001                               	;                          flag.  Use TRNN x,777 to test for rcv. int.)
04m0001                               	;Modem control use of bits 28:35
04m0001                               	;       Bit 28  Unused
04m0001                               	;       Bit 29  DTR (Data Terminal Ready)
04m0001                               	;   Bits 30:32  ACU bits (unimplemented - no auto-dialer)
04m0001                               	;       Bit 33  CD (Carrier Detect)
04m0001                               	;       Bit 34  RI (Ring Indicator)
04m0001                               	;       Bit 35  Unused
04m0001                               	;
04m0001                               	;-----------------------------------------------------------------------
04m0001                               	DLSDI1: ;Prepare to insert into dispatch table
04m0001                               	:DLSDISP2 + 2           ;Two instructions here and the rest elsewhere
04m0001 07012 640150050171000440007013	        ASRC[[10 + DLSLINE]]DEST[AR Q] JUMP[. + 1] NORM $
04m0001 07013 640140414675020013007053	        D[CONST 1] ROT[8.] ALU[-D&Q] ADEST[EST[DLSLINE] DEST-A-MEM]JUMP[DLSDI1] NORM $
04m0001                               	:DLSDI1
04m0001 07053 510140014635020010000000	        D[CONST 1] ROT[8.] ALU[D&Q] COND[OBUS=0] JUMP[DLSDI2] C550 $
04m0001                               	                ;Did scanner stop on a receiver?
04m0001 07054 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
04m0001                               	                ;Yes.  Enable interrupt
04m0001 07055 440700044171000440100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] ASRC[[10 + DLSPICHN]]DEST[Q] $
04m0001                               	                ;Clear RCVR flag.
04m0001 07056 640700214675006013000000	        D[CONST 1] ROT[3] ALU[-D&Q] ADEST[EST[DLSPICHN] DEST-A-MEM]NORM $
04m0001 07057 662104200571000440002032	DLSDI2: D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
04m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- SCI

05m0001                               	
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	;BLKO DLS,
05m0001                               	DLSBLKO:
05m0001                               	.REPEAT 1 - DLSDEB [
05m0001                               	DLSDEB
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	;DATAO DLS,
05m0001                               	;
05m0001                               	;       Bit 11  Use this line
05m0001                               	;   Bits 12:17  Line number if bit 11 is on (else interrupting line)
05m0001                               	;       Bit 27  Turn off transmitter (if this bit is on, then scanner is
05m0001                               	;                 restarted, but termination of transmission is not
05m0001                               	;                 implemented.)  Note: bit 30 is NOT used as alternative
05m0001                               	;                 to bit 27 in 5-bit character mode.)
05m0001                               	;Modem Control usage for bits 27:35
05m0001                               	;       Bit 27  Unused
05m0001                               	;       Bit 28  Set Status Flag (request interrupt).  Not implemented;
05m0001                               	;                  causes bug trap.
05m0001                               	;       Bit 29  DTR (Data Terminal Ready)
05m0001                               	;   Bits 30:35  ACU bits (Not implemented - no auto-dialer)
05m0001                               	;DC10 escape - Bit 0 = 1
05m0001                               	;   Bits 20:27  ASTRA Control Register 1
05m0001                               	;   Bits 28:31  ASTRA Control Register 2
05m0001                               	;
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	DLSDO1: ;Prepare to insert into dispatch table
05m0001                               	:DLSDISP2 + 6           ;Two instructions here and the rest elsewhere
05m0001 07016 640706000550400440020000	          FIXM1 $       ;Fetch operand
05m0001 07017 000140000571000440007060	        JUMP[DLSDO1] $
05m0001                               	:DLSDO1
05m0001 07060 531140004571026440000000	        D[MEM] ROT[11.] COND[-OBUS<0] JUMP[DLSNTHIS] C550 $
05m0001                               	                ;Is "use this line" on?
05m0001 07061 531140044571076440000000	        ASRC[[10 + DLSPICHN]]ROT[31.] COND[-OBUS<0] JUMP[DLSTHIS] C550 $
05m0001                               	                ;Yes.  Use it if scanner not stopped on xmitter.
05m0001 07062 640700004171044050000000	        D[MEM] ROT[18.] MASK[DLSLNSIZE] DEST[Q] NORM $
05m0001                               	                ;It has stopped...
05m0001 07063 510140050735044050000000	        ASRC[[10 + DLSLINE]]ROT[18.] MASK[DLSLNSIZE] ALU[D#Q] COND[OBUS=0] JUMP[DLSSCNR]
05m0001                               	 C550 $
05m0001                               	                ;If it stopped on the line to use, ignore the "use this"
05m0001 07064 640150004171044050000000	DLSTHIS:        D[MEM] ROT[18.] MASK[DLSLNSIZE] DEST[AR Q] JUMP[DLSOUT] NORM $
05m0001                               	                ;Set line # from data.
05m0001 07065 531140044571076440002026	DLSNTHIS:       ASRC[[10 + DLSPICHN]]ROT[31.] COND[-OBUS<0] JUMP[MAIN] C550 $
05m0001                               	                ;No "use this" - NOP if scanner not stopped.
05m0001 07066 640700044171000030000000	DLSSCNR:        ASRC[[10 + DLSPICHN]]MASK[3] DEST[Q] NORM $
05m0001 07067 640700214575006043000000	        D[CONST 4] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]NORM $
05m0001                               	                ;Clear XMIT flag.
05m0001 07070 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
05m0001                               	                ;Enable interrupt.
05m0001 07071 440710050171044050100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] ASRC[[10 + DLSLINE]]ROT[18.] MASK[DLSLNSIZE] DEST[AR
05m0001                               	 Q] $
05m0001                               	                ;Use line # from scanner.
05m0001 07072 640701214537000430000000	DLSOUT: D[CONST 35.] ALU[D-Q] DEST[ROTR] NORM $
05m0001 07073 640700054171000440000000	        ASRC[[10 + DLSACT]]DEST[Q] NORM $       ;Prepare to twiddle active bit
05m0001 07074 511140004571066440000000	        D[MEM] ROT[27.] COND[OBUS<0] JUMP[DLSOFF] C550 $
05m0001                               	                ;"turn off transmitter"?
05m0001 07075 640700614575200013000000	        D[CONST 1] ROT[R] ALU[DORQ] ADEST[EST[DLSACT] DEST-A-MEM]NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- SCI

05m0001                               	                ;No.  Turn it on.
05m0001 07076 640700004171000100000000	        D[MEM] MASK[8] DEST[Q] NORM $
05m0001 07077 640700000175052440000000	        D[AR] ROT[21.] ALU[DORQ] DEST[Q] NORM $
05m0001                               	        DLSWRITE[05m0001 07100 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
05m0001                               	                ;Set TTY number
05m0001 07101 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
05m0001                               	                ;SET CS
05m0001 07102 000702214575046013630000	        MAPF[DLSHOLD] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
05m0001                               	
05m0001                               	                ;DROP CS, SET WE
05m0001 07103 000702200555000443630000	        MAPF[DLSHOLD] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
05m0001                               	                ;DROP WE.
05m0001 07104 000700000571000443770000	        MAPF[DLSHOLD + DLSNOSEL] SPEC[IOB-OUT] $
05m0001                               	        MAPF[DLSHOLD + DLSNOSEL]                ;Finish the last IOB-OUT
05m0001 07105 640140000571000440172026	]JUMP[MAIN] NORM $
05m0001 07106 640140614675200013002026	DLSOFF: D[CONST 1] ROT[R] ALU[-D&Q] ADEST[EST[DLSACT] DEST-A-MEM]JUMP[MAIN] NORM $
05m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- SCI

06m0001                               	;-----------------------------------------------------------------------
06m0001                               	;CONO DLS,
06m0001                               	
06m0001                               	;
06m0001                               	;       Bit 30  Clear DC10
06m0001                               	;       Bit 31  Ready Hold (Not implemented, DTR switch is simulated as
06m0001                               	;                       being on.)
06m0001                               	;       Bit 32  Reset Scanner (more accurately, restart scanner. Allows
06m0001                               	;                        interrupts)
06m0001                               	;   Bits 33:35  PI channel
06m0001                               	;
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	DLSCNO1:
06m0001                               	:DLSDISP2 + 10
06m0001 07020 511040034571074440000000	        D[IR] ROT[30.] COND[OBUS<0] PUSHJ[DLSRST] C550 $
06m0001 07021 640140014171000700007107	        D[CONST 70] DEST[Q] JUMP[DLSCNO1] NORM $
06m0001                               	:DLSCNO1
06m0001 07107 640700044235000440000000	        ASRC[[10 + DLSPICHN]]ALU[D&Q] DEST[Q] NORM $
06m0001 07110 640140234575000033002026	        D[IR] MASK[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[MAIN] NORM $
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	;CONI DLS,
06m0001                               	;
06m0001                               	;    Bits 0:7   ASTRA Control Register 1
06m0001                               	;    Bits 8:13  ASTRA Control Register 2
06m0001                               	;    Bits 14:20 ASTRA Status Register
06m0001                               	;       Bit 30  DTR Distend (Simulated as always on)
06m0001                               	;       Bit 31  Transmit interrupt
06m0001                               	;       Bit 32  Recieve interrupt
06m0001                               	;               (Both bits 31 and 32 will not be on at the same time.
06m0001                               	;                Recieve will take priority.)
06m0001                               	;   Bits 33:35  PI channel
06m0001                               	;
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	DLSCNISV:
06m0001                               	:DLSDISP2 + 12
06m0001                               	                ;Get CONI information
06m0001 07022 662104244571000440002032	        ASRC[[10 + DLSPICHN]]DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0001 07023 000700000571000440000000	        NOP $
06m0001                               	                ;Store and fetch next instruction
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	;CONSZ DLS,
06m0001                               	;-----------------------------------------------------------------------
06m0001 07024 640710044571000440000000	        ASRC[[10 + DLSPICHN]]DEST[AR] NORM $
06m0001 07025 640140034171000220004472	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
06m0001                               	                ;Do standard skip off AR and IR
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	;CONSO DLS,
06m0001                               	;-----------------------------------------------------------------------
06m0001 07026 640710044571000440000000	        ASRC[[10 + DLSPICHN]]DEST[AR] NORM $
06m0001 07027 640140034171000220004474	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
06m0001                               	                ;Do standard skip off AR and IR
06m0001                               	:DLSCNISV
06m0001                               	
06m0001 07111 000144620531000440004367	DLSBAD: d[pc] alu[d-1] dest[pc] jump[dohalt] $
06m0001                               	                ;Halt macro machine on this lossage...
06m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- SCI

07m0001                               	;-----------------------------------------------------------------------
07m0001                               	;Reset DLS
07m0001                               	;
07m0001                               	;Clear PI assignment and A-MEM registers.
07m0001                               	;Turn off interrupts
07m0001                               	;Setup defaults for lines 0:7, 8:5
07m0001                               	;
07m0001                               	;-----------------------------------------------------------------------
07m0001                               	.DEFINE DLSGRP[07m0001                               	;DLSGRP
07m0001                               	DLSRST:
07m0001 07112 640702214571060013600000	        D[CONST 1] ROT[24.] DEST[IOD] SPEC[IOB-OUT] NORM $
07m0001                               	                ;Hit MASTER RESET on all ASTRAs
07m0001 07113 000700214571000403100000	        MAPF[DLSCSR] LONG D[CONST 40] ADEST[EST[DLSPICHN] DEST-A-MEM]$ ;Clear PIA
07m0001 07114 000700400615000443000000	        ALU[0] ADEST[EST[DLSLINE] DEST-A-MEM]LONG $ ;Clear receiver flag
07m0001 07115 000700600615000443000000	        ALU[0] ADEST[EST[DLSACT] DEST-A-MEM]LONG $ ;All transmitters off
07m0001 07116 000712200615000443600000	        ALU[0] DEST[IOD AR] SPEC[IOB-OUT] LONG $ ;Let go of MR
07m0001                               	        MAPF[DLSCSR] LONG
07m0001                               	DLSINI
07m0001                               	DLSGRP[07m0001 07117 000740014571000000100000	        D[CONST 0 - 0] LLOAD $
07m0001 07120 640040014171000320000000	        D[CONST 32] DEST[Q] PUSHJ[DLSSCR2] NORM $
07m0001 07121 640700014171014020000000	        D[CONST 247 / 100] ROT[6] DEST[Q] NORM $
07m0001 07122 640040014175000470000000	        D[CONST 247 & 77] ALU[DORQ] DEST[Q] PUSHJ[DLSSCR1] NORM $
07m0001 07123 640250000433000440007120	        D[AR] ALU[D+1] DEST[AR] LOOP[. - 3] NORM $
07m0001                               	];Line 0 300 baud
07m0001                               	DLSGRP[07m0001 07124 000740014571000020000000	        D[CONST 3 - 1] LLOAD $
07m0001 07125 640040014171000230000000	        D[CONST 23] DEST[Q] PUSHJ[DLSSCR2] NORM $
07m0001 07126 640700014171014020000000	        D[CONST 247 / 100] ROT[6] DEST[Q] NORM $
07m0001 07127 640040014175000470000000	        D[CONST 247 & 77] ALU[DORQ] DEST[Q] PUSHJ[DLSSCR1] NORM $
07m0001 07130 640250000433000440007125	        D[AR] ALU[D+1] DEST[AR] LOOP[. - 3] NORM $
07m0001                               	];Lines 1-3 150/1200    *** Temp.
07m0001                               	DLSGRP[07m0001 07131 000740014571000330000000	        D[CONST DLSNLINES - 4] LLOAD $
07m0001 07132 640040014171000340000000	        D[CONST 34] DEST[Q] PUSHJ[DLSSCR2] NORM $
07m0001 07133 640700014171014020000000	        D[CONST 247 / 100] ROT[6] DEST[Q] NORM $
07m0001 07134 640040014175000470000000	        D[CONST 247 & 77] ALU[DORQ] DEST[Q] PUSHJ[DLSSCR1] NORM $
07m0001 07135 640250000433000440007132	        D[AR] ALU[D+1] DEST[AR] LOOP[. - 3] NORM $
07m0001                               	];Lines 4-LAST 9600
07m0002 07136 640040014171000000000000	]       D[CONST 0] DEST[Q] PUSHJ[DLSCINT] NORM $
07m0002                               	.REPEAT DLS2 [
07m0002 07137 640040014171052200000000	        D[CONST 20] ROT[21.] DEST[Q] PUSHJ[DLSCINT] NORM $
07m0002                               	];DLS2
07m0002 07140 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
07m0002 07141 440300000571000440100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] POPJ $
07m0002                               	DLSCINT:
07m0002                               	.REPEAT DLS2 [
07m0002                               	        D[CONST 1] ROT[26.] ALU[DORQ] DEST[IOD Q] SPEC[IOB-OUT]
07m0002 07142 640702214175064013600000	                        NORM $
07m0002 07143 440700000571000443540000	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
07m0002 07144 000701030571000443140000	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM $
07m0002 07145 011300060571022440000000	        D[10 + DLSTMP] DLSNOIRQ OT[9.] COND[OBUS<0]]POPJ LONG $
07m0002                               	];DLS2
07m0002                               	DLSCINT1:       DLSRINT 07m0002                               	        MAPF[DLSNOSEL] SPEC[IOB-OUT]
07m0002 07146 640702200417000443740000	                ALU[Q+1] DEST[IOD] NORM $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

07m0002                               	        MAPF[DLSIACK] CYLEN[IOB-OUT] SPEC[IOB-OUT] 
07m0002 07147 440702214437050013640000	                D[CONST 1] ROT[20.] ALU[D+Q+1] DEST[IOD] $
07m0002 07150 000702200555000443640000	        MAPF[DLSIACK] SPEC[IOB-OUT] ALU[Q] DEST[IOD] LONG $
07m0002 07151 000700000571000443440000	        MAPF[DLSIACK] SPEC[IOB-IN] LONG $
07m0002 07152 240701030571000443040000	        MAPF[DLSIACK] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002 07153 011300060571022440000000	        D[10 + DLSTMP] ]DLSNOIRQ OT[9.] COND[OBUS<0]]POPJ $
07m0002 07154 000700000571000440000000	        NOP LONG $
07m0002 07155 000140000571000440007146	        JUMP[DLSCINT1] $
07m0002 07156 640700000175052440000000	DLSSCR1:        D[AR] ROT[21.] ALU[DORQ] DEST[Q] NORM $
07m0002                               	        DLSWRITE[07m0002 07157 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
07m0002                               	                ;Set TTY number
07m0002 07160 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;SET CS
07m0002 07161 000702214575046013600000	        MAPF[DLSCR1] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;DROP CS, SET WE
07m0002 07162 000702200555000443600000	        MAPF[DLSCR1] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;DROP WE.
07m0002 07163 000700000571000443740000	        MAPF[DLSCR1 + DLSNOSEL] SPEC[IOB-OUT] $
07m0002                               	        MAPF[DLSCR1 + DLSNOSEL]                 ;Finish the last IOB-OUT
07m0002 07164 640300000571000440140000	]POPJ NORM $
07m0002 07165 640700000175052440000000	DLSSCR2:        D[AR] ROT[21.] ALU[DORQ] DEST[Q] NORM $
07m0002                               	        DLSWRITE[07m0002 07166 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
07m0002                               	                ;Set TTY number
07m0002 07167 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;SET CS
07m0002 07170 000702214575046013610000	        MAPF[DLSCR2] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;DROP CS, SET WE
07m0002 07171 000702200555000443610000	        MAPF[DLSCR2] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;DROP WE.
07m0002 07172 000700000571000443750000	        MAPF[DLSCR2 + DLSNOSEL] SPEC[IOB-OUT] $
07m0002                               	        MAPF[DLSCR2 + DLSNOSEL]                 ;Finish the last IOB-OUT
07m0002 07173 640300000571000440150000	]POPJ NORM $
07m0002                               	
07m0002                               	;-----------------------------------------------------------------------
07m0002                               	;DLS interrupts are fairly straight-forward.  The micro-interrrupt
07m0002                               	;is turned off, the status of the line is obtained, and if enabled, a
07m0002                               	;macro interrupt is requested.  The macro interrupt is responsible for
07m0002                               	;executing some CONO,DATAI,DATAO which restarts the scanner by enabling
07m0002                               	;micro interrupts again.
07m0002                               	;-----------------------------------------------------------------------
07m0002                               	DLSINT:
07m0002                               	: DLSVECTOR     ;Entry to interrupt
07m0002 02137 640142200615000443607174	        ALU[0] DEST[IOD] SPEC[IOB-OUT] JUMP[DLSINT] NORM $ ;Disable int.
07m0002                               	: DLSINT
07m0002                               	.REPEAT DLS2 [
07m0002                               	        MAPF[DLSCSR] D[CONST 3] ROT[25.] DEST[Q IOD] SPEC[IOB-OUT]
07m0002 07174 440702214171062033700000	                        CYLEN[IOB-OUT] $
07m0002 07175 440700000571000443540000	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
07m0002 07176 240701030571000443140000	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002 07177 031140060571022440000000	        D[10 + DLSTMP] DLSIRQ OT[9.] COND[-OBUS<0]]JUMP[DLSINT1] $
07m0002 07200 640702214171062023600000	        D[CONST 2] ROT[25.] DEST[Q IOD] SPEC[IOB-OUT] NORM $
07m0002 07201 440700000571000443540000	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
07m0002 07202 240701030571000443140000	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002 07203 511140060571022440000000	        D[10 + DLSTMP] C550 DLSNOIRQ OT[9.] COND[OBUS<0]]JUMP[DLSIGNORE] $
07m0002                               	];DLS2
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

07m0002                               	DLSINT1:        DLSRINT 07m0002                               	        MAPF[DLSNOSEL] SPEC[IOB-OUT]
07m0002 07204 640702200417000443740000	                ALU[Q+1] DEST[IOD] NORM $
07m0002                               	        MAPF[DLSIACK] CYLEN[IOB-OUT] SPEC[IOB-OUT] 
07m0002 07205 440702214437050013640000	                D[CONST 1] ROT[20.] ALU[D+Q+1] DEST[IOD] $
07m0002 07206 000702200555000443640000	        MAPF[DLSIACK] SPEC[IOB-OUT] ALU[Q] DEST[IOD] LONG $
07m0002 07207 000700000571000443440000	        MAPF[DLSIACK] SPEC[IOB-IN] LONG $
07m0002 07210 240701030571000443040000	        MAPF[DLSIACK] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002 07211 000704460571000440000000	        D[10 + DLSTMP] ]DEST[HOLD] $
07m0002                               	.REPEAT 1 - DLS2 [
07m0002 07212 640710004571102040000000	        D[MEM] ROT[33.] MASK[4] DEST[AR] NORM $
07m0002 07213 640710000575052440000000	        D[AR] ROT[21.] ALU[DORQ] DEST[AR] NORM $
07m0002 07214 640711200571036050000000	        D[AR] ROT[15.] MASK[DLSLNSIZE] DEST[AR ROTR] NORM $
07m0002 07215 640710000571044440000000	        D[AR] ROT[18.] DEST[AR] NORM $
07m0002 07216 511140004571102440000000	        D[MEM] ROT[33.] COND[OBUS<0] JUMP[DLSRCVINT] C550 $
07m0002 07217 531140054571200440000000	        ASRC[[10 + DLSACT]]ROT[R] COND[-OBUS<0] JUMP[DLSIGNORE] C550 $
07m0002 07220 640700400571000443000000	        D[AR] ADEST[EST[DLSLINE] DEST-A-MEM]NORM $
07m0002 07221 650150044171000440000000	        ASRC[[10 + DLSPICHN]]DEST[AR Q] COND[OBUS=0] JUMP[DLSCH0] NORM $
07m0002 07222 640140214575006063004564	        D[CONST 6] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[PIGEN] NORM $
07m0002 07223 640140214575006063002026	DLSCH0: D[CONST 6] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[MAIN] NORM $
07m0002 07224 640700000171006440000000	DLSRCVINT:      D[AR] ROT[3] DEST[Q] NORM $
07m0002                               	        DLSREAD[07m0002 07225 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
07m0002                               	                ;Set TTY number  -- FBUS 9
07m0002 07226 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
07m0002                               	                ;Assert CS
07m0002 07227 440700000571000440020000	        MAPF[DLSSTAT] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
07m0002 07230 000702214171064013420000	        MAPF[DLSSTAT] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
07m0002                               	                ;Setup to drop CS, start read
07m0002 07231 000704430571000103760000	        MAPF[DLSSTAT + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[HOLD] SPEC[IOB-OUT] $
07m0002                               	                ;Finish read, drop CS
07m0002 07232 000700000571000440160000	        MAPF[DLSSTAT + DLSNOSEL] $
07m0002                               	        MAPF[DLSSTAT + DLSNOSEL]  ]D[MEM] ROT[34.]
07m0002 07233 531140004571104440160000	                COND[-OBUS<0] JUMP[DLSIGNORE] C550 $
07m0002 07234 640700000171006440000000	        D[AR] ROT[3] DEST[Q] NORM $
07m0002                               	        DLSREAD[07m0002 07235 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
07m0002                               	                ;Set TTY number  -- FBUS 9
07m0002 07236 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
07m0002                               	                ;Assert CS
07m0002 07237 440700000571000440030000	        MAPF[DLSHOLD] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
07m0002 07240 000702214171064013430000	        MAPF[DLSHOLD] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
07m0002                               	                ;Setup to drop CS, start read
07m0002 07241 000700030171000103770000	        MAPF[DLSHOLD + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[Q] SPEC[IOB-OUT] $
07m0002                               	                ;Finish read, drop CS
07m0002 07242 000700000571000440170000	        MAPF[DLSHOLD + DLSNOSEL] $
07m0002 07243 640704400433070440170000	        MAPF[DLSHOLD + DLSNOSEL]  ]D[AR] ROT[28.] ALU[D+1] DEST[HOLD] NORM $
07m0002 07244 640700404575020443000000	        D[MEM] ROT[8.] ALU[DORQ] ADEST[EST[DLSLINE] DEST-A-MEM]NORM $
07m0002 07245 650150044171000030000000	        ASRC[[10 + DLSPICHN]]MASK[3] DEST[AR Q] COND[OBUS=0] JUMP[DLSRCVIGN] NORM $
07m0002 07246 640140214575006053004564	        D[CONST 5] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[PIGEN] NORM $
07m0002 07247 640140214575006053002026	DLSRCVIGN:      D[CONST 5] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[MAIN]
07m0002                               	 NORM $
07m0002 07250 640702214571066013600000	DLSIGNORE:      D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
07m0002 07251 440150000215000440102026	        MAPF[DLSCSR] CYLEN[IOB-OUT] ALU[0] DEST[AR Q] JUMP[MAIN] $
07m0002                               	

SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

45m0164                               	
45m0164                               	.REPEAT DLSDEB [
45m0164                               	.INSERT DLSDEB.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:DLSDEB.SLO  --  of -- SCI

01m0001                               	;DLS DEBUGGING IOTS
01m0001                               	
01m0001                               	.DEFINE SETLIN 01m0001                               	
01m0001                               	.DEFINE MJUMP[01m0001                               	
01m0001                               	;;;;;  DWP 1/27/80:7600
01m0001                               	DLS.DEB:
01m0001                               	:DLSDISP2 + 20          ;IOT DISPATCH FOR DEVICE 374
01m0001                               	
01m0001 07030 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;BLKI 374 = READ
01m0001                               	 CR1
01m0001 07031 640140000571000440000000	JUMP[DLS.RCR1] NORM $
01m0001                               	
01m0001 07032 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;DATAI 374 = READ
01m0001                               	 CR2
01m0001 07033 640140000571000440000000	JUMP[DLS.RCR2] NORM $
01m0001                               	
01m0001 07034 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;BLKO 374 = READ
01m0001                               	 STAT
01m0001 07035 640140000571000440000000	JUMP[DLS.RSTAT] NORM $
01m0001                               	
01m0001 07036 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;DATAO 374 = READ
01m0001                               	 HOLD
01m0001 07037 640140000571000440000000	JUMP[DLS.RHOLD] NORM $
01m0001                               	
01m0001 07040 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;CONO 374 = WRITE
01m0001                               	 CR1
01m0001 07041 640140000175000440000000	MJUMP[[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WCR1] NORM]$
01m0001                               	
01m0001 07042 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;CONI 374 = WRITE
01m0001                               	 CR2
01m0001 07043 640140000175000440000000	MJUMP[[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WCR2] NORM]$
01m0001                               	
01m0001 07044 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;CONSZ 374 =
01m0001                               	 WRITE STAT (SYN,DLE)
01m0001 07045 640140000175000440000000	MJUMP[[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WSTAT] NORM]$
01m0001                               	
01m0001 07046 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;CONSO 374 =
01m0001                               	 WRITE HOLD
01m0001 07047 640140000175000440000000	MJUMP[[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WHOLD] NORM]$
01m0001                               	
01m0001                               	:DLS.DEB
01m0001                               	
01m0001 07252 640706000550400440020000	DLS.SETLIN:     FIXM1 $                 ;SETUP LINE # IN Q
01m0001 07253 640710004635000440000000	        D[MEM] ALU[D&Q] DEST[AR] NORM $
01m0001 07254 640700010171052050000000	        D[MASK[DLSLNSIZE]] ROT[21.] DEST[Q] NORM $
01m0001 07255 640300004235006440000000	        D[MEM] ROT[3] ALU[D&Q] DEST[Q] POPJ NORM $
01m0001                               	
01m0001                               	DLS.RCR1:       DLSREAD[01m0001 07256 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07257 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07260 440700000571000440000000	        MAPF[DLSCR1] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07261 000702214171064013400000	        MAPF[DLSCR1] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

01m0001 07262 000710030571000103740000	        MAPF[DLSCR1 + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07263 000700000571000440140000	        MAPF[DLSCR1 + DLSNOSEL] $
01m0001 07264 000140000571000440140000	        MAPF[DLSCR1 + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001                               	DLS.RCR2:       DLSREAD[01m0001 07265 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07266 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07267 440700000571000440010000	        MAPF[DLSCR2] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07270 000702214171064013410000	        MAPF[DLSCR2] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
01m0001 07271 000710030571000103750000	        MAPF[DLSCR2 + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07272 000700000571000440150000	        MAPF[DLSCR2 + DLSNOSEL] $
01m0001 07273 000140000571000440150000	        MAPF[DLSCR2 + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001                               	DLS.RSTAT:      DLSREAD[01m0001 07274 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07275 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07276 440700000571000440020000	        MAPF[DLSSTAT] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07277 000702214171064013420000	        MAPF[DLSSTAT] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
01m0001 07300 000710030571000103760000	        MAPF[DLSSTAT + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07301 000700000571000440160000	        MAPF[DLSSTAT + DLSNOSEL] $
01m0001 07302 000140000571000440160000	        MAPF[DLSSTAT + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001                               	DLS.RHOLD:      DLSREAD[01m0001 07303 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07304 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07305 440700000571000440030000	        MAPF[DLSHOLD] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07306 000702214171064013430000	        MAPF[DLSHOLD] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
01m0001 07307 000710030571000103770000	        MAPF[DLSHOLD + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07310 000700000571000440170000	        MAPF[DLSHOLD + DLSNOSEL] $
01m0001 07311 000140000571000440170000	        MAPF[DLSHOLD + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001 07312 640700010171000100000000	DLS.READ:       D[MASK[8.]] DEST[Q] NORM $
01m0001 07313 640700000235000440000000	        D[AR] ALU[D&Q] DEST[Q] NORM $
01m0001 07314 662104204575000000202032	        D[MEM] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
01m0001                               	
01m0001                               	
01m0001                               	DLS.WCR1:       DLSWRITE[01m0001 07315 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07316 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07317 000702214575046013600000	        MAPF[DLSCR1] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP CS, SET WE
01m0001 07320 000702200555000443600000	        MAPF[DLSCR1] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

01m0001                               	                ;DROP WE.
01m0001 07321 000700000571000443740000	        MAPF[DLSCR1 + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSCR1 + DLSNOSEL]                 ;Finish the last IOB-OUT
01m0001 07322 000140000571000440142026	]JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.WCR2:       DLSWRITE[01m0001 07323 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07324 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07325 000702214575046013610000	        MAPF[DLSCR2] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP CS, SET WE
01m0001 07326 000702200555000443610000	        MAPF[DLSCR2] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP WE.
01m0001 07327 000700000571000443750000	        MAPF[DLSCR2 + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSCR2 + DLSNOSEL]                 ;Finish the last IOB-OUT
01m0001 07330 000140000571000440152026	]JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.WSTAT:      DLSWRITE[01m0001 07331 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07332 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07333 000702214575046013620000	        MAPF[DLSSTAT] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	
01m0001                               	                ;DROP CS, SET WE
01m0001 07334 000702200555000443620000	        MAPF[DLSSTAT] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP WE.
01m0001 07335 000700000571000443760000	        MAPF[DLSSTAT + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSSTAT + DLSNOSEL]                ;Finish the last IOB-OUT
01m0001 07336 000140000571000440162026	]JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.WHOLD:      DLSWRITE[01m0001 07337 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07340 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07341 000702214575046013630000	        MAPF[DLSHOLD] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	
01m0001                               	                ;DROP CS, SET WE
01m0001 07342 000702200555000443630000	        MAPF[DLSHOLD] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP WE.
01m0001 07343 000700000571000443770000	        MAPF[DLSHOLD + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSHOLD + DLSNOSEL]                ;Finish the last IOB-OUT
01m0001 07344 000140000571000440172026	]JUMP[MAIN] $
01m0001                               	
01m0001 07345 000140000571000440007345	DLS.INT:        JUMP[.] $
01m0001 07346 000140000571000440007347	        JUMP[. + 1] $
01m0001 07347 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $
01m0001 07350 440700000571000440100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] $
01m0001 07351 000142400571000440002026	        DEST[CLR-DEV-FROM-INTR] JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.RINT:
01m0001                               	: DLSDISP2 + 0  ;BLKI 370 - GET INTERRUPT STATUS
01m0001 07010 000140000571000440007010	        JUMP[.] $
01m0001 07011 000140000571000440007352	        JUMP[DLS.RINT] $
01m0001                               	: DLS.RINT
SLOE   Jan ***, 1859 00:00:03  file DSK:DLSDEB.SLO  --  of -- SCI

01m0001 07352 640700014171064010000000	        D[CONST 1] ROT[26.] DEST[Q] NORM $
01m0001                               	        MAPF[DLSNOSEL] SPEC[IOB-OUT] D[CONST 1] ROT[20.]
01m0001 07353 640702214437050013740000	                ALU[D+Q+1] DEST[IOD] NORM $
01m0001 07354 440700000571000440140000	        MAPF[DLSNOSEL] CYLEN[IOB-OUT] $
01m0001 07355 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07356 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07357 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07360 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07361 000702200555000443640000	        MAPF[DLSIACK] SPEC[IOB-OUT] ALU[Q] DEST[IOD] LONG $
01m0001 07362 000700000571000443440000	        MAPF[DLSIACK] SPEC[IOB-IN] LONG $
01m0001 07363 140700030171000440040000	        MAPF[DLSIACK] CYLEN[IOB-IN] D[IOD] DEST[Q] $
01m0001 07364 662104200555000440002032	        ALU[Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
01m0001                               	
01m0001                               	DLS.EINT:
01m0001                               	: DLSDISP2 + 4  ;BLKO 370 - ENABLE INTERRUPT
01m0001 07014 000140000571000440007014	        JUMP[.] $
01m0001 07015 000140000571000440007365	        JUMP[DLS.EINT] $
01m0001                               	:DLS.EINT
01m0001 07365 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
01m0001 07366 440140000571000440102026	        MAPF[DLSCSR] CYLEN[IOB-OUT] JUMP[MAIN] $

SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

45m0164                               	]DLSDEB
45m0164                               	];DLS2
45m0164                               	.REPEAT 1 - DLS2 [
45m0164                               	;1 - DLS2
45m0164                               	
45m0164                               	]DLS                    9 JAN 80  BO
45m0164                               	
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	;
45m0164                               	;       Line Printer Interface (LPT)
45m0164                               	;
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	.REPEAT LPT [
45m0164                               	LPT
45m0164                               	
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	;
45m0164                               	;       Versatec Interface (VC)
45m0164                               	;
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	.REPEAT VC [
45m0164                               	
45m0164                               	.INSERT VC.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- SCI

01m0001       0	VCDEB = 0       ; Nonzero for debugging microcode
01m0001                               	
01m0001       2026	VCBAD = MAIN
01m0001                               	
01m0001                               	; Versatec now has its own device code 520, with 524 reserved for a second VC.
01m0001                               	VCDSP:  
01m0001                               	:. + 20         ;Reserve space for dispatch table
01m0001                               	;Let's save this for a second VC
01m0001                               	.REPEAT 10 [    01m0001                               	ILGIOT 01m0001 07407 000140000571000440002026	 JUMP [MAIN] ]$
01m0001 07410 000700000571000440000000	                NOP $
01m0001                               	]ILGIOT 01m0001 07411 000140000571000440002026	 JUMP [MAIN] ]$
01m0001 07412 000700000571000440000000	                NOP $
01m0001                               	]ILGIOT 01m0001 07413 000140000571000440002026	 JUMP [MAIN] ]$
01m0001 07414 000700000571000440000000	                NOP $
01m0001                               	]ILGIOT 01m0001 07415 000140000571000440002026	 JUMP [MAIN] ]$
01m0001 07416 000700000571000440000000	                NOP $
01m0001                               	]ILGIOT 01m0001 07417 000140000571000440002026	 JUMP [MAIN] ]$
01m0001 07420 000700000571000440000000	                NOP $
01m0001                               	]ILGIOT 01m0001 07421 000140000571000440002026	 JUMP [MAIN] ]$
01m0001 07422 000700000571000440000000	                NOP $
01m0001                               	]ILGIOT 01m0001 07423 000140000571000440002026	 JUMP [MAIN] ]$
01m0001 07424 000700000571000440000000	                NOP $
01m0001                               	]ILGIOT 01m0001 07425 000140000571000440002026	 JUMP [MAIN] ]$
01m0001 07426 000700000571000440000000	                NOP $
01m0001                               	].REPEAT 10
01m0001                               	
01m0001                               	VCORG:          ; Origin of Versatec code
01m0001                               	
01m0001                               	; Versatec driver definitions and register usage
01m0001                               	;
01m0001                               	; CONO - command out.  Takes (E) as
01m0001                               	;               Bits 0-15: Command to Versatec
01m0001                               	;               Bits 16-29: Unused
01m0001                               	;               Bit 30: Enable interrupt on READY
01m0001                               	;               Bits 31-32: Mode 00 - unused (same as mode 01)
01m0001                               	;                                01 - 7-bit bytes, 5 per word, left justified
01m0001                               	;                                10 - 8-bit bytes, 4 per word, left justified
01m0001                               	;                                11 - 8-bit bytes, 9 per two words
01m0001                               	;               Bits 33-35: PI channel
01m0001                               	;
01m0001                               	; CONI - status in.  Puts in E
01m0001                               	;               Bits 0-17: Zero, except
01m0001                               	;                       3-4, 10-11: State of corresponding
01m0001                               	;                                       command out bits.
01m0001                               	;               Bits 18-23: Status bits from Versatec
01m0001                               	;               Bit 24: Reserved
01m0001                               	;               Bit 25: Versatec READY bit
01m0001                               	;               Bit 26: Data ready bit
SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- SCI

01m0001                               	;               Bits 27-29: zero
01m0001                               	;               Bit 30: ENB-RDY-INT
01m0001                               	;               Bits 31-35: Mode and PI from last command out
01m0001                               	;
01m0001                               	; CONSZ, CONSO - Test right half of above CONI bits.
01m0001                               	;
01m0001                               	; DATAO - Start output.  Takes (E) as
01m0001                               	;               Bits 0-17: 2's complement byte count (0 means 256K bytes)
01m0001                               	;               Bits 18-35: Starting memory address
01m0001                               	;       This operation sets Busy, clears Done, and starts the output.
01m0001                               	;       When output finishes, Busy clears and Done sets.
01m0001                               	;
01m0001                               	; The following are debugging aids
01m0001                               	;
01m0001                               	; BLKI - Enters the interrupt routine.
01m0001                               	; DATAI - Returns the remaining byte count/MA.
01m0001                               	; BLKO - Unused.
01m0001                               	;
01m0001                               	; A-MEM Usage:  0 - Interrupt Dispatch
01m0001                               	;               1 - MA saved between bursts
01m0001                               	;               2 - byte count saved between bursts
01m0001                               	;               3 - Constants depending on Mode
01m0001                               	;                       Bit 35: 0 for modes 1&2, 1 for mode 3
01m0001                               	;                       Bits 32-34: Bytes/Word - 1
01m0001                               	;                       Bits 25-31: Bytes/burst
01m0001                               	;               4 - Command/Status Register
01m0001                               	;               5 - Mask for command bits that are levels.
01m0001                               	;               6 - Saved AC during output burst
01m0001                               	;               7 - Saved PC during output burst
01m0001                               	;
01m0001                               	; Other registers:
01m0001                               	;               PC - Addresses memory during output
01m0001                               	;               AC - Counts bytes during output
01m0001                               	;               Loop Count - counts bytes in a word
01m0001                               	;               Q, AR, HOLD - temporary
01m0001                               	;
01m0001                               	: VCDSP + 0
01m0001                               	.REPEAT 1 - VCDEB [     01m0001                               	; Make debugging ops illegal (NOP)
01m0001                               	.repeat 3 [     01m0001                               	ILGIOT 01m0001 07367 000140000571000440002026	 JUMP [MAIN] ]$ NOP $
01m0001 07370 000700000571000440000000	
01m0001                               	]ILGIOT 01m0001 07371 000140000571000440002026	 JUMP [MAIN] ]$ NOP $
01m0001 07372 000700000571000440000000	
01m0001                               	]ILGIOT 01m0001 07373 000140000571000440002026	 JUMP [MAIN] ]$ NOP $
01m0001 07374 000700000571000440000000	
01m0001                               	]; .REPEAT 3
01m0001                               	]; .REPEAT 1 - VCDEB
01m0001                               	
01m0001                               	.REPEAT VCDEB [ 01m0001                               	
01m0001                               	: VCORG + 2     ; Dispatch base and interrupt entry
01m0001                               	
01m0001                               	; Dispatch for modes 1-3 relative to the vector (2 words/entry)
SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- SCI

01m0001                               	;               Set burst count for the mode
01m0001 07431 640700014171014170000000	        D[CONST 17] ROT[6] DEST[Q] NORM $ ;Mode 1 - 60 bytes/burst, 5 bytes/word
01m0001 07432 640140614575000103000000	        D[CONST 10] ALU[DORQ] DEST[3] SPEC[DEST-A-MEM] JUMP[VCSET2] NORM $
01m0001                               	;
01m0001 07433 640700014171014200000000	        D[CONST 20] ROT[6] DEST[Q] NORM $ ;Mode 2 - 64 bytes/burst, 4 bytes/word
01m0001 07434 640140614575000063000000	        D[CONST 06] ALU[DORQ] DEST[3] SPEC[DEST-A-MEM] JUMP[VCSET2] NORM $
01m0001                               	;
01m0001 07435 640700014171014170000000	        D[CONST 17] ROT[6] DEST[Q] NORM $ ;Mode 3 - 63 bytes/burst, 4 bytes/word
01m0001 07436 640140614575000673000000	        D[CONST 67] ALU[DORQ] DEST[3] SPEC[DEST-A-MEM] JUMP[VCSET2] NORM $
01m0001                               	;
01m0001                               	VCINT:          ;Interrupt routine
01m0001                               	
01m0001                               	: VCORG
01m0001                               	.REPEAT VCDEB [
01m0001 07427 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;Disable interrupts
01m0001                               	        MAPF[4] CYLEN[IOB-OUT] SPEC[IOB-OUT]
01m0001                               	.REPEAT VCDEB [ 
01m0001                               	.REPEAT 1 - VCDEB [ 01m0001 07430 440140000571000443647437	JUMP[VCINT] $
01m0001                               	: VCINT
01m0001 07437 440700000571000443600000	]       MAPF[0] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ; Clear lat-byte bit
01m0001                               	        MAPF[5] CYLEN[IOB-OUT] ; Clear request
01m0001 07440 470140050571000440050000	                D[12] COND[-OBUS=0] JUMP[VCGO] $ ;Output if count/= 0
01m0001                               	
01m0001 07441 640700060171000440000000	        D[14] DEST[Q] NORM $ ; Fetch status register
01m0001 07442 511140060571074440000000	        D[14] ROT[30.] COND[OBUS<0] JUMP[VCINT2] C550 $
01m0001                               	
01m0001                               	; End of data transfer.  Set data ready bit.
01m0001                               	        D[CONST 1] ROT[9.] ALU[DORQ] DEST[4]
01m0001 07443 640141014575022013000000	                SPEC[DEST-A-MEM] JUMP[VCINT3] NORM $
01m0001                               	
01m0001                               	; READY interrupt.  Clear ready int enable bit.
01m0001                               	VCINT2: D[CONST 1] ROT[5] ALU[-D&Q] DEST[4]
01m0001 07444 640701014675012013000000	                SPEC[DEST-A-MEM] NORM $
01m0001                               	 
01m0001                               	VCINT3: D[14] MASK[3] DEST[AR Q CLR-DEV-FROM-INTR]
01m0001 07445 530152460171000030004564	                COND[-OBUS=0] JUMP[PIGEN] C550 $ ; Macro int if enabled
01m0001 07446 640140000571000440002026	        JUMP[MAIN] NORM $
01m0001                               	
01m0001                               	;IOT dispatch
01m0001                               	        .PAIR
01m0001                               	. \ 2 + .
01m0002 07450 010140020571016010002100	]       D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0002                               	                ;Trap if User and not IOT-USER
01m0002 07451 640700034171034040000000	VCIOT:  D[IR] ROT[12. + 1 + 1] MASK[4] DEST[Q] NORM $
01m0002                               	                ;Extract IOT decode * 2.  Note we can do this because the
01m0002                               	                ;machine has already done indexing/indirection and bits
01m0002                               	                ;13:17 are guaranteed zero
01m0002 07452 540540040435044200000000	        D[10] ROT[18.] MASK[16.] ALU[D+Q] SDISP CYLEN[DISP] $
01m0002                               	                ;Dispatch of type of IOT
01m0002                               	
01m0002                               	;
01m0002                               	; Command out to Versatec
01m0002                               	
01m0002                               	VCCMD:
01m0002                               	: VCDSP + 10 ; CONO dispatch
01m0002                               	.REPEAT VCDEB [
SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- SCI

01m0002 07377 640041614571000140000000	        D[CONST VCDEV] DEST[DEV-ADR] PUSHJ[VCONO] NORM $
01m0002 07400 000140000571000440002026	        JUMP[MAIN] $
01m0002                               	.REPEAT 1 - VCDEB [
01m0002                               	: VCCMD
01m0002                               	]; Reset.
01m0002                               	
01m0002 07453 640700014171074060000000	VCRST:  D[CONST 6] ROT[30.] DEST[Q] NORM $ ; mask for VC mode bits
01m0002                               	        D[CONST 3] ROT[24.] ALU[DORQ]
01m0002 07454 640701214575060033000000	                DEST[5] SPEC[DEST-A-MEM] NORM $
01m0002                               	
01m0002 07455 000700014171060730000000	        D[CONST VCDSP / 100] ROT[6 + 18.] DEST[Q] $     ;Setup dispatch
01m0002                               	.IF VCDSP \ 100 /= 0 [
01m0002 07456 000700014175044670000000	        D[CONST VCDSP \ 100] ROT[18.] ALU[DORQ] DEST[Q] $
01m0002                               	]
01m0002                               	        D[CONST VCORG / 100] ROT[6] ALU[DORQ] DEST[0 Q] ;Interrupt base address
01m0002 07457 640700014175014743000000	                SPEC[DEST-A-MEM] NORM $
01m0002                               	.IF VCORG \ 100 /= 0 [
01m0002                               	        D[CONST VCORG \ 100] ALU[DORQ] DEST[0]
01m0002 07460 640700014575000273000000	                SPEC[DEST-A-MEM] NORM $
01m0002                               	]
01m0002 07461 640144414571000100000000	        D[CONST 10] DEST[HOLD] JUMP[VCONO0] NORM $ ; Invent CONO 124,[10]
01m0002                               	
01m0002                               	; CONO routine
01m0002                               	
01m0002 07462 640706000550400440020000	VCONO: FIXM1 $
01m0002                               	
01m0002                               	VCONO0: SPEC[IOB-OUT]
01m0002 07463 640710004571076013600000	        D[MEM] ROT[31.] MASK[1] DEST[AR] NORM $ ; Save int-on-rdy bit
01m0002                               	
01m0002                               	        MAPF[0] SPEC[IOB-OUT] CYLEN[IOB-OUT] ; Clear the FIFO
01m0002 07464 440702204171000443600000	        D[MEM] DEST[IOD Q] $ ;Set up the control bits
01m0002                               	
01m0002                               	        MAPF[1] SPEC[IOB-OUT] LONG ;Output control bits
01m0002 07465 000702264235000443610000	        D[15] ALU[D&Q] DEST[IOD Q] $ ;Clear the ones that pulse.
01m0002                               	
01m0002                               	        MAPF[5] SPEC[IOB-OUT] LONG ; Clear int req
01m0002 07466 000700004175000063650000	        D[MEM] MASK[6] ALU[DORQ] DEST[Q] $ ; Save the mode
01m0002                               	
01m0002                               	        MAPF[1] SPEC[IOB-OUT] LONG ; Clear the pulsed bits
01m0002 07467 000702200571004443610000	        D[AR] ROT[2] DEST[IOD] $ ;Set up the int-on-rdy bit
01m0002                               	
01m0002                               	        MAPF[4] CYLEN[IOB-OUT] ; Set interrupt enablings
01m0002                               	        D[CONST 1] ROT[9.] ALU[DORQ] DEST[4] ;Set data ready bit
01m0002 07470 440701014575022013040000	                SPEC[DEST-A-MEM] $
01m0002                               	
01m0002                               	        D[MEM] ROT[33.] MASK[2] DEST[AR] ;Extract the mode
01m0002 07471 510150004571102020000000	                COND[OBUS=0] JUMP[VCONO1] C550 $
01m0002 07472 640140000171002440000000	        D[AR] ROT[1] DEST[Q] JUMP[VCONO2] NORM $ ; Double mode to Q
01m0002                               	
01m0002 07473 640700014171002010000000	VCONO1: D[CONST 1] ROT[1] DEST[Q] NORM $ ;Change mode 0 to 1 and double
01m0002                               	
01m0002 07474 500540040435000440000000	VCONO2: D[10] ALU[D+Q] SDISP C550 $ ;Set up constants by mode.
01m0002                               	;
01m0002                               	; Back from setup of constants.  Clear byte count.
01m0002                               	;
01m0002 07475 000140400615000443002026	VCSET2: ALU[0] DEST[2] SPEC[DEST-A-MEM] JUMP[MAIN] $
01m0002                               	;
SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- SCI

01m0002                               	; Read status/control bits
01m0002                               	
01m0002                               	VCSTAT:
01m0002                               	: VCDSP + 12 ; CONI dispatch
01m0002                               	
01m0002                               	.REPEAT VCDEB [
01m0002 07401 640041614571000143400000	        D[CONST VCDEV] DEST[DEV-ADR] SPEC[IOB-IN] PUSHJ[VCGST] NORM $
01m0002                               	;               Fetch device status into AR.
01m0002 07402 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
01m0002                               	.REPEAT 1 - VCDEB [
01m0002                               	: VCSTAT
01m0002                               	]VCONSZ:
01m0002                               	: VCDSP + 14 ; CONSZ dispatch
01m0002                               	.REPEAT VCDEB [
01m0002                               	; VCDEB
01m0002 07403 640041614571000143400000	        D[CONST VCDEV] DEST[DEV-ADR] SPEC[IOB-IN] PUSHJ[VCGST] NORM $
01m0002 07404 640140034171000220004472	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
01m0002                               	.REPEAT 1 - VCDEB [
01m0002                               	: VCONSZ
01m0002                               	]VCONSO:
01m0002                               	: VCDSP + 16 ; CONSO dispatch
01m0002                               	.REPEAT VCDEB [
01m0002                               	; VCDEB
01m0002 07405 640041614571000143400000	        D[CONST VCDEV] DEST[DEV-ADR] SPEC[IOB-IN] PUSHJ[VCGST] NORM $
01m0002 07406 640140034171000220004474	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
01m0002                               	.REPEAT 1 - VCDEB [
01m0002                               	: VCONSO
01m0002                               	]
01m0002 07476 140710030571020100020000	VCGST:  MAPF[2] D[IOD] ROT[8.] MASK[8.] DEST[AR] CYLEN[IOB-IN] $
01m0002 07477 640700000171024440000000	        D[AR] ROT[10.] DEST[Q] NORM $ ;Merge status with command.
01m0002 07500 640310060575000440000000	        D[14] ALU[DORQ] DEST[AR] POPJ NORM $
01m0002                               	;
01m0002                               	VCOUNT:
01m0002                               	.REPEAT VCDEB [ 01m0002                               	VCOUT:
01m0002                               	: VCDSP + 6 ; DATAO dispatch
01m0002                               	
01m0002                               	.REPEAT VCDEB [
01m0002                               	.REPEAT 1 - VCDEB [
01m0002 07375 640706000550400440020000	        FIXM1 $
01m0002 07376 640141614571000140007501	        D[CONST VCDEV] DEST[DEV-ADR] JUMP[VCOUT] NORM $
01m0002                               	: VCOUT
01m0002                               	];              Illegal op if BUSY is on.
01m0002 07501 510140060571066010002026	        D[14] ROT[27.] MASK[1] COND[OBUS=0] JUMP[VCBAD] CYLEN[C550] $
01m0002 07502 640700060171000440000000	        D[14] DEST[Q] NORM $
01m0002 07503 640701014675022013000000	        D[CONST 1] ROT[9.] ALU[-D&Q] DEST[4] SPEC[DEST-A-MEM] NORM $ ; Clear DONE
01m0002 07504 640700010171000000200000	        D[MASK 0] SPEC[LEFT] DEST[Q] NORM $ ;Pad byte count with ones in left.
01m0002 07505 640700404575044223000000	        D[MEM] ROT[18.] MASK[18.] ALU[DORQ] DEST[2] SPEC[DEST-A-MEM] NORM $
01m0002 07506 640700204571000223000000	        D[MEM] MASK[18.] DEST[1] SPEC[DEST-A-MEM] NORM $
01m0002                               	;
01m0002                               	VCGO:           ;Q gets 0 for 7-bit bytes, 1 for 8-bit.
01m0002                               	  .REPEAT NEWMAP [
01m0002                               	  .REPEAT 1 - NEWMAP [
01m0002 07507 640702400571000440000000	        DEST[CLR-DEV-FROM-INTR] SHORT $
01m0002 07510 000041614571000013405400	        START-IN D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPOFF] $
01m0002 07511 240701614571000140100000	        MAPF[10] D[CONST VCDEV] DEST[DEV-ADR] C800 $
01m0002 07512 640700060171100010000000	         ]      D[14] ROT[32.] MASK[1] DEST[Q] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- SCI

01m0002 07513 640701214435000070000000	        D[CONST 7] ALU[D+Q] DEST[ROTR] NORM $ ;byte length to rotate and
01m0002 07514 640701414435000070000000	        D[CONST 7] ALU[D+Q] DEST[MASKR] NORM $ ;mask registers.
01m0002 07515 640700014171000000000000	        D[CONST 0] DEST[Q] NORM $ ;Q contains last-byte flag, initially 0.
01m0002 07516 640701400551000443000000	        ALU[AC] DEST[6] SPEC[DEST-A-MEM] NORM $ ;Save AC and PC for scratching.
01m0002 07517 640701620571000443000000	        D[PC] DEST[7] SPEC[DEST-A-MEM] NORM $
01m0002 07520 640704644571000440000000	        D[11] DEST[PC] NORM $ ;PC gets current MA.
01m0002 07521 640700051571000440000000	        D[12] DEST[AC] NORM $ ;AC gets (negative) byte count.
01m0002 07522 640700055421100070000000	        D[13] ROT[32.] MASK[7] ALU[D+AC] DEST[AC] NORM $ ;Add burst count,
01m0002                               	        ALU[AC] DEST[2] SPEC[DEST-A-MEM]
01m0002 07523 511140400551000443000000	                COND[OBUS<0] JUMP[VCBRST] CYLEN[C550] $ ;check for overflow.
01m0002 07524 640700055463100070000000	        D[13] ROT[32.] MASK[7] ALU[AC-D] DEST[AC] NORM $
01m0002                               	;               Ov.  AC gets bytes remaining.
01m0002 07525 640140414571000003000000	        D[CONST 0] DEST[2] SPEC[DEST-A-MEM] JUMP[VCLP] NORM $ ;Clear byte count.
01m0002                               	
01m0002 07526 640700055473100070000000	VCBRST: D[13] ROT[32.] MASK[7] ALU[0-D] DEST[AC] NORM $ ;No. ov.  AC_ burst ct.
01m0002                               	
01m0002 07527 640040000571000440000000	VCLP:   PUSHJ[VCWRD] NORM $ ;Output a word.  If mode 1 or 2 and not last byte,
01m0002                               	;               loop on these two instructions.
01m0002                               	        MAPF[3] D[13] MASK[1] ALU[DORQ] COND[OBUS=0] JUMP[VCLP]
01m0002 07530 010140054575000010037527	                LONG $
01m0002                               	;               go to VCDONE if last byte.
01m0002 07531 530140000555000440000000	        ALU[Q] COND[-OBUS=0] JUMP[VCDONE] CYLEN[C550] $
01m0002                               	;
01m0002                               	;               Mode 3.  Pull high 4 bits of the odd byte.
01m0002 07532 640704404571010040000000	        D[MEM] ROT[4] MASK[4] DEST[HOLD] NORM $
01m0002                               	;               Shift them to proper place in Q and fetch next word.
01m0002 07533 640720004171010440600000	        SPEC[MA_PC] D[MEM] ROT[4] DEST[MA Q] NORM $
01m0002 07534 640706000550400440020000	        FIXM1 $
01m0002 07535 640704404571010440000000	        D[MEM] ROT[4] DEST[HOLD] NORM $ ;Low bits of odd byte to low end.
01m0002                               	;               Check whether this is the last byte of the burst.
01m0002 07536 531140001413000440000000	        ALU[AC+1] DEST[AC] COND[-OBUS<0] JUMP[VCLST] CYLEN[C550] $
01m0002                               	;               No.  Put it out.
01m0002 07537 640702204575000043600000	        SPEC[IOB-OUT] D[MEM] MASK[4] ALU[DORQ] DEST[IOD] NORM $
01m0002                               	;               Set up byte count for second word.
01m0002 07540 440740054571106030030000	        MAPF[3] D[13] ROT[35.] MASK[3] LLOAD CYLEN[IOB-OUT] $
01m0002                               	;               Clear last-byte flag, put out second word.
01m0002 07541 640040014171000000000000	        D[CONST 0] DEST[Q] PUSHJ[VCWRD1] NORM $
01m0002                               	;               Loop for next double word if not end of burst.
01m0002 07542 010140000555000440037527	        MAPF[3] ALU[Q] COND[OBUS=0] JUMP[VCLP] LONG $
01m0002                               	;               End of burst.  Save updated MA and restore AC and PC.
01m0002 07543 640700220571000443030000	VCDONE: MAPF[3] D[PC] DEST[1] SPEC[DEST-A-MEM] NORM $
01m0002 07544 640702214571000103600000	        SPEC[IOB-OUT] D[CONST 10] DEST[IOD] NORM $ ;Enable interrupt
01m0002 07545 440704674571000440040000	        MAPF[4]D[17] DEST[PC] CYLEN[IOB-OUT] $
01m0002                               	  .REPEAT NEWMAP [
01m0002                               	  .REPEAT 1 - NEWMAP [
01m0002 07546 640702234571000030000000	        D[IR] MASK[3] DEST[IOD] NORM $
01m0002 07547 640701600615000443600000	        ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
01m0002 07550 240701614571000140100000	        MAPF[10] D[CONST VCDEV] DEST[DEV-ADR] C800 $
01m0002 07551 640142471571000440002026	         ]      D[16] DEST[CLR-DEV-FROM-INTR AC] JUMP[MAIN] NORM $
01m0002                               	;               Odd byte is the last.  Put it out with the last-byte bit on.
01m0002 07552 640700014175104010000000	VCLST:  D[CONST 1] ROT[34.] ALU[DORQ] DEST Q NORM $
01m0002 07553 640142204575000043607543	        SPEC[IOB-OUT] D[MEM] MASK[4] ALU[DORQ] DEST[IOD] JUMP[VCDONE] NORM $
01m0002                               	
01m0002                               	; Subroutine to output one word.  Instruction following call must have
01m0002                               	; MAPF[3] CYLEN[IOB-OUT].
01m0002                               	;
01m0002                               	;               Entry for modes 1 and 2, and first word of a pair for
SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- SCI

01m0002                               	;               mode 3.  Set loop count to bytes/word.
01m0002 07554 640760054571106030600000	VCWRD:  SPEC[MA_PC] DEST[MA] D[13] ROT[35.] MASK[3] LLOAD NORM $
01m0002 07555 640706000550400440020000	        FIXM1 $
01m0002                               	;               Second entry for other word in mode 3 (it's been fetched).
01m0002                               	;               Add bytes/word to bytes remaining.
01m0002                               	VCWRD1: SPEC[PC+1] D[13] ROT[35.] MASK[3] ALU[D+AC] CARRY DEST[AC]
01m0002 07556 511140055423106032000000	                COND[OBUS<0] JUMP[VCOUT1] CYLEN[C550] $
01m0002                               	;               Overflow.  Change loop count to bytes remaining.
01m0002 07557 640740055523106030000000	        D[13] ROT[35.] MASK[3] ALU[D-AC] DEST[AC] LLOAD NORM $
01m0002                               	;               Set last-byte flag in Q.
01m0002 07560 640140014171104010000000	        D[CONST 1] ROT[34.] DEST[Q] JUMP[VCOUT1] NORM $
01m0002                               	;               This two-instruction loop puts out all but the last byte.
01m0002 07561 000042204571001000000000	VCOLP:  D[MEM] MASK[R] DEST[IOD] PUSHJ[VCODLY] LONG $
01m0002 07562 000244404571200440037561	VCOUT1: MAPF[3] D[MEM] ROT[R] DEST[HOLD] LOOP[VCOLP] LONG $
01m0002                               	;               Last byte here, with the flag bit set if end of burst.
01m0002 07563 000702204575001000000000	        D[MEM] MASK[R] ALU[DORQ] DEST[IOD] LONG $
01m0002 07564 000700000571000440000000	VCODLY: NOP LONG $
01m0002 07565 000300000571000443600000	        SPEC[IOB-OUT] POPJ LONG $
01m0002                               	

SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

45m0164                               	
45m0164                               	]
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

46m0164                               	; dsk stuff
46m0164                               	
46m0164                               	;a-mem useage:
46m0164                               	;       0       dispatch addr for interrupts
46m0164                               	;       1       pi chn (33: 35) and intrpt waiting flag (32)
46m0164                               	;       2       copy of last cmd sent to controller (by opcode 721)
46m0164                               	
46m0164                               	        .OPCODE[LIST 
46m0164                               	        .ENDORG
46m0164       7566	YMFOO = .
46m0165                               	]       :INST-DISP + 2 * 740
46m0165                               	        .DEFINE .ENDORG 46m0165                               	.ENDORG
46m0164                               	 LIST            ];disk pseudo-iot dispatch table entries.
46m0164                               	
46m0164                               	 ; dcono -- 740
46m0164 03700 640701614571000100000000	        d[const 10] dest[dev-adr] short $
46m0164 03701 640140234571000033000000	        d[ir] mask[3] dest[1] DEST-A-MEM norm jump[dcno1]$
46m0164                               	; dconi -- 741
46m0164 03702 640041614571000100000000	        d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
46m0164 03703 662104200571000440002032	        d[ar] dest[memsto] memst OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$ ;store them and
46m0164                               	 return.
46m0164                               	; dconso -- 742
46m0164 03704 640041614571000100000000	        d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
46m0164 03705 530100010635000220000000	        d[mask 22] alu[d&q] c550 cond[-obus=0] lbjump[dskp1] $
46m0164                               	; dconsz -- 743
46m0164 03706 640041614571000100000000	        d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
46m0164 03707 510100010635000220000000	        d[mask 22] alu[d&q] c550 cond[obus=0] lbjump[dskp1] $
46m0164                               	
46m0164                               	        .RELOC
46m0164                               	USE[46m0164                               	XLIST
46m0164                               	        .ENDORG
46m0164       3710	LASTORG = .
46m0165                               	]       :TYMFOO
46m0165                               	        .DEFINE .ENDORG 46m0165                               	.ENDORG
46m0165                               	        .DEFINE .RELOC 46m0165                               	.RELOC
46m0165                               	 LIST ]]
46m0165 07566 550140034571000030002026	dcno1:  d[ir] mask[3]  c500 cond[obus=0] jump[main] $
46m0165                               	         ; if assigned pi channel is not 0, then
46m0165                               	         ;  enable interrupt on "not active", by
46m0165                               	         ;  re-loading last cmd with 10 bit on.
46m0165 07567 640700014171000200000000	        D[CONST 20] DEST[Q] NORM $
46m0165 07570 510140034635000440000000	        D[IR] ALU[D&Q] C550 OBUS=0 JUMP[DCNO2] $
46m0165 07571 640140014171000400000000	        D[CONST 40] DEST[Q] NORM JUMP[DCNO3] $
46m0165 07572 640700014171000100000000	DCNO2:  d[const 10] dest[q] short $
46m0165 07573 640702250575000443600000	DCNO3:  d[12] alu[dorq] dest[iod] spec[iob-out] norm $
46m0165 07574 440140000571000440042026	        mapf[4] cylen[iob-out] jump[main] $
46m0165                               	
46m0165 07575 640710044171000440000000	dcni1:  d[11] dest[q ar] norm $ ;get intrpt flag and pi chn
46m0165 07576 640300034235000440000000	        d[ir] alu[d&q] dest[q] norm popj $ ;this is for conso, z
46m0165                               	
46m0165                               	        .ORG[XLIST
46m0165                               	        .ENDORG
46m0165       7577	YMFOO = .
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- SCI

46m0166                               	]       :2156
46m0166                               	        .DEFINE .ENDORG 46m0166                               	.ENDORG
46m0165                               	 LIST ];$*$*$ 
46m0165                               	
46m0165                               	        ;interrupts from disk (dev 10) come here.
46m0165 02156 640142250571000443600000	        d[12] dest[iod] spec[iob-out] norm jump[dskint] $
46m0165                               	          ;clear interrrupt enable bit (amem[2] has last cmd)
46m0165                               	
46m0165                               	        .RELOC
46m0165                               	USE[46m0165                               	XLIST
46m0165                               	        .ENDORG
46m0165       2157	STORG = .
46m0166                               	]       :TYMFOO
46m0166                               	        .DEFINE .ENDORG 46m0166                               	.ENDORG
46m0166                               	        .DEFINE .RELOC 46m0166                               	.RELOC
46m0166                               	 LIST ]]        .PAIR
46m0166                               	. \ 2 + .
46m0167                               	];$*$*$ This exists elsewhere by another name.  TVR-Apr80
46m0167 07600 640140000571000440002026	dskp1:  jump[main] norm $       ;conso and consz lbjump to here.
46m0167 07601 640164620433000440002027	        doskip $
46m0167                               	
46m0167 07602 510150044171000440040000	dskint: mapf[4] d[11] dest[q ar] c550 cond[obus=0] jump[ddis] $
46m0167                               	        d[const 10] alu[dorq] dest[1] DEST-A-MEM norm
46m0167 07603 640140214575000103004564	                jump[pigen] $ ;set flag and request intrpt.
46m0167 07604 640142400571000440002026	ddis:   dest[clr-dev-from-intr] norm jump[main] $
46m0167                               	
46m0167 07605 640151614571000100000000	DSKWT1: D[CONST 10] DEST[DEV-ADR AR] NORM JUMP[DSKWT4] $
46m0167 07606 511140004571076440000000	DSKWT3: D[MEM] ROT[31.] C550 COND[OBUS<0] JUMP[DSKWDN] $
46m0167 07607 640740014571014010000000	        D[CONST 1] ROT[6] LLOAD NORM $
46m0167 07610 500240000571000440007610	        C550 LOOP[.] $
46m0167 07611 640700000571000443400000	DSKWT4: START-IN NORM $
46m0167 07612 240144430571000440007606	        MAPF[0] D[IOD] DEST[HOLD] C800  JUMP[DSKWT3] $
46m0167 07613 530150000531000440007611	DSKWDN: D[AR] ALU[D-1] DEST[AR] C550 COND[-OBUS=0] JUMP[DSKWT4] $
46m0167 07614 000140000571000440002026	        JUMP[MAIN] $
46m0167                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

47m0167                               	
47m0167                               	;
47m0167                               	;ECC logging area
47m0167                               	;
47m0167                               	.REPEAT 1 - XUCODE [
47m0167                               	.REPEAT 1 - XUCODE
47m0167                               	.REPEAT XUCODE [
47m0167                               	: 17760
47m0167                               	].REPEAT XUCODE
47m0167                               	
47m0167                               	 .REPEAT 20 [N47m0167 17760 000700000571000440000000	OP $
47m0167 17761 000700000571000440000000	]OP $
47m0167 17762 000700000571000440000000	]OP $
47m0167 17763 000700000571000440000000	]OP $
47m0167 17764 000700000571000440000000	]OP $
47m0167 17765 000700000571000440000000	]OP $
47m0167 17766 000700000571000440000000	]OP $
47m0167 17767 000700000571000440000000	]OP $
47m0167 17770 000700000571000440000000	]OP $
47m0167 17771 000700000571000440000000	]OP $
47m0167 17772 000700000571000440000000	]OP $
47m0167 17773 000700000571000440000000	]OP $
47m0167 17774 000700000571000440000000	]OP $
47m0167 17775 000700000571000440000000	]OP $
47m0167 17776 000700000571000440000000	]OP $
47m0167 17777 000700000571000440000000	]OP $
47m0167                               	]
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- SCI

48m0167                               	;; this should be after everything else
48m0167                               	: 0
48m0167 00000 000140000571000440004000	        JUMP[MSTART] $          ;Auto-load micro code tapes someday.
48m0167                               	

SLOE   Jan ***, 1859 00:00:03  file DSK:SCI.SLO  --  of -- SCI

01m0030                               	
01m0030                               	LIST-LABELS

labels
  0   38     0 .               10   21  3103 ACBI1            4    2  2212 ADJSP
 41  161  5002 ADJSP1          41  161  5010 ADJSP2          17  104  2763 ANDCA1          17  104  2764 ANDCA2
 17  104  2765 ANDCA3          30  142  4703 APDINT          30  146  4717 APIOT           30  142  4673 APRC1
 30  142  4674 APRC2           30  142  4675 APRCHK          30  142  4704 APRCI           30  142  4704 APRCII
 30  142  4676 APRCK1          30  142  4651 APRCO           30  142  4660 APRCO2          30  142  4663 APRCO3
 30  145  4715 APRDI           30  141  5300 APRDSP          30  142  4664 APRIEN          20  138  4525 APRRST
  4    2  2161 AREA216          9   15  2602 AREA260          9   15  2623 AREA262          9   15  2642 AREA264
  9   15  2665 AREA266          9   15  2702 AREA270          9   16  2742 AREA274         12   47  3426 AREA342
 12   49  3444 AREA344         12   49  3470 AREA346         12   51  3504 AREA350         12   51  3526 AREA352
 12   53  3544 AREA354         12   53  3566 AREA356         19  134  5140 AREA51          19  136  3572 AREA52
 16   92  4223 ASHC1           16   92  4241 ASHC2           16   92  4235 ASHC4           16   92  4232 ASHC6
 16   93  4244 ASHC7           16   92  4230 ASHC8           16   92  4234 ASHC9           16   92  4203 ASHDO
 16   90  2734 ASHDO1          16   92  4207 ASHDOP          16   91  4174 ASHNEG          16   91  4175 ASHNN1
 16   91  4172 ASHPLS           9   16  2724 ASOS1            9   16  2722 ASOS2            9   16  2762 ASOS3
 14   59  4023 BADPC           16   92  4221 BIGAS2          16   92  4177 BIGASH          16   90  2725 BIGLSH
 14   68  2651 BII             14   67  2645 BII1            14   68  2654 BII2            14   67  2642 BIIH
 11    1  6773 BLKI1           11    1  6776 BLKI1A          11    1  7000 BLKO1           11    1  7004 BLKO1A
 17  103  4255 BLT1            17  103  4264 BLT2            17  103  4263 BLT3            17  103  4274 BLT4
 17  103  4262 BLT5            17  103  4276 BLT6            17  103  4261 BLT7            17  103  4300 BLT8
 17  103  4266 BLT9            17  103  4317 BLTA1           17  103  4331 BLTA10          17  103  4344 BLTA12
 17  103  4254 BLTA2           17  103  4304 BLTA3           17  103  4315 BLTA4           17  103  4326 BLTAL2
 17  103  4312 BLTL1           17  103  4332 BLTL2           18  112  4451 BRPNT           25  140  6177 BWRTA1
  1    6 10307 CCLR            20  138  4512 CLKCLR          20  138  4513 CLKENB          32  150  6213 CLKINT
 32  150  6216 CLKRDFLG        20  138  4512 CLKRST          20  138  4527 CLRDEVINT       18  112  4426 CONSW
 19  136  5235 CTYCI           19  136  5241 CTYCI1          19  136  5240 CTYCI2          19  136  5251 CTYCI3
 19  136  5247 CTYCI8          19  136  5245 CTYCI9          19  136  5233 CTYCO           19  136  5252 CTYCO1
 19  136  5256 CTYCO3          19  136  5261 CTYCO4          19  136  5266 CTYCO5          19  138  4474 CTYCS
 19  138  4472 CTYCZ           19  136  5213 CTYDI           19  136  5222 CTYDO           19  134  5100 CTYDSP
 19  134  2144 CTYIN1          19  134  2130 CTYINT          19  135  5211 CTYIOT          19  136  3566 CTYRS1
 19  136  5270 CTYRST           1    6 10342 D1               1    2 10061 DCG1             1    2 10056 DCGO
  1    2 10075 DCGWR            1    2 10040 DCINIT          46  165  7575 dcni1           46  165  7566 dcno1
 46  165  7572 DCNO2           46  165  7573 DCNO3           46  167  7604 ddis            18  112  4437 DEPNSW
 18  112  4440 DEPSW1          18  112  4436 DEPTSW          43  162  6544 DEV6CL          43  162  6545 DEV6ST
 43  162  6546 DEV6ST1         43  162  6547 DEV6ST2          4    3  2262 DFN             40  157  6230 DFN1
 15   77  4126 DIV1            15   79  4132 DIV2            15   81  4136 DIV3             7   10  2471 DIV9
  1    1  7252 DLS.DEB          1    1  7365 DLS.EINT         1    1  7345 DLS.INT          1    1  7256 DLS.RCR1
  1    1  7265 DLS.RCR2         1    1  7312 DLS.READ         1    1  7303 DLS.RHOLD        1    1  7352 DLS.RINT
  1    1  7274 DLS.RSTAT        1    1  7252 DLS.SETLIN       1    1  7315 DLS.WCR1         1    1  7323 DLS.WCR2
  1    1  7337 DLS.WHOLD        1    1  7331 DLS.WSTAT        6    1  7111 DLSBAD           4    1  7053 DLSBLKI
  5    1  7060 DLSBLKO          7    2  7223 DLSCH0           7    2  7142 DLSCINT          7    2  7146 DLSCINT1
  6    1  7111 DLSCNISV         6    1  7107 DLSCNO1          4    1  7053 DLSDI1           4    1  7057 DLSDI2
  3    1  7010 DLSDISP2         5    1  7060 DLSDO1           7    2  7250 DLSIGNORE        7    2  7174 DLSINT
  7    2  7204 DLSINT1          3    1  7050 DLSIOT           5    1  7065 DLSNTHIS         5    1  7106 DLSOFF
  5    1  7072 DLSOUT           7    2  7247 DLSRCVIGN        7    2  7224 DLSRCVINT        7    1  7112 DLSRST
  5    1  7066 DLSSCNR          7    2  7156 DLSSCR1          7    2  7165 DLSSCR2          5    1  7064 DLSTHIS
  4    3  2240 DMOVE           41  161  5015 DMOVE2           4    3  2250 DMOVEM          41  162  5026 DMOVM2
  4    3  2242 DMOVN           41  161  5020 DMOVN2           4    3  2252 DMOVNM          41  162  5031 DMVNM2
 41  162  5034 DMVNM3          41  162  5035 DMVNM4          41  162  5036 DMVNM5          15   83  4142 DODDIV
 15   83  4147 DODIV           15   83  4151 DODIV1          15   83  4155 DODIV2          15   83  4154 DODIV3
 15   85  2170 DODIV4          15   85  2174 DODIV6          15   84  2161 DODIV7          18  106  4367 DOHALT
 15   70  4055 DOIMUL          15   70  4062 DOMMUL          15   70  4066 DOMUL           15   70  4067 DOMUL1
 15   71  4074 DOMUL4           9   15  2622 DOSKP1           5    3  2276 DPB             14   63  2636 DPB1
 14   66  2671 DPB2            14   66  2672 DPB4            14   63  2637 DPB5            14   64  4024 DPB7
 46  167  7602 dskint          46  167  7600 DSKP1           20  138  4476 DSKRST          46  167  7613 DSKWDN
 46  167  7605 DSKWT1          46  167  7606 DSKWT3          46  167  7611 DSKWT4          31  150  6206 ECC-UNC
 23  138  4651 END-OF-PI-CODE  18  112  4444 EXMNSW          18  112  4446 EXMSW1          18  112  4443 EXMTSW
 40  159  6377 EXPUF            5    3  2300 FAD             40  159  6402 FADSU1          40  159  6401 FADSUB
 40  157  6246 FAOS1           40  157  6250 FAOS2           40  157  6252 FAOS3           40  157  6256 FAOS4
 40  157  6246 FAOS5           40  161  6511 FD              40  157  6272 FD1             40  157  6275 FD2
 40  157  6306 FD2A            40  159  6332 FD2C            40  159  6331 FD2D            40  159  6333 FD3
 40  159  6336 FD4             40  161  6535 FDAD            40  161  6503 FDS             40  161  6504 FDS1
 40  161  6524 FDSHFT           5    3  2360 FDV             41  162  5063 FIXER           41  162  5071 FIXER1
 41  162  5072 FIXER2          41  162  5074 FIXER3           4    3  2254 FIXR            41  162  5044 FIXR1
 41  162  5056 FIXR2           41  162  5050 FIXRN            4    3  2256 FLTR            41  162  6537 FLTR1
 40  160  6460 FM              40  160  6463 FM1             40  160  6466 FM2              1    2 10022 FMNBW1
  1    2 10021 FMNBWT           5    3  2340 FMP             40  157  6260 FMP1            40  157  6262 FMP2
 40  157  6264 FMP3            40  157  6270 FMP4            40  157  6260 FMP5             1    2 10030 FMTHNG
 40  160  6451 FPLOW           40  160  6433 FPNAR           40  159  6341 FPNDIV          40  159  6404 FS1
 40  159  6407 FS2             40  159  6414 FS3             40  160  6426 FS4             40  160  6430 FS5
  5    3  2320 FSB              4    3  2264 FSC             40  157  6236 FSC1            40  157  6242 FSC2
 40  157  6235 FSCZAP          38  151  6224 GOHIGH          38  154 10360 GOLOW           38  154 10356 GOMAIN
  1    6 10350 GOMSTART        18  125  3474 HHS             38  154 10354 HIGHSMAIN       18  114  3427 HLAR
 18  114  3430 HLLEM1          18  120  3454 HLLES1          18  123  3470 HLLES2          18  129  3533 HLLM1
 18  118  3450 HLLOS1          18  113  2774 HLLZS1          18  114  3432 HLREM1          18  129  3534 HLRM1
 18  113  2777 HLRZS1          18  127  3526 HLSZ            18  124  3472 HMV             18  128  3531 HOL
 18  127  3527 HOR             18  114  3426 HRAR            18  114  3431 HRLEM1          18  129  3532 HRLM1
 18  113  2775 HRLZS1          18  114  3433 HRREM1          18  121  3456 HRRES1          18  129  3535 HRRM1
 18  119  3452 HRROS1          18  113  2776 HRRZS1          18  128  3530 HRSZ            18  116  3444 HSMAIN
 18  117  3446 HSMN1            5    3  2266 IBP             14   70  4032 IBP1            14   70  4035 IBT1
 15   71  4076 IDIV1           15   73  4106 IDIV2           15   75  4116 IDIV3            7   10  2461 IDIV9
  5    3  2274 IDPB            14   61  2610 IDPB1           14   61  2614 IDPB2           14   66  2666 IDPB3
  5    3  2270 ILDB            14   60  2602 ILDB1           14   60  2606 ILDB2           14   61  2616 ILDB3
 13   55  3732 IMP-IOT          3    1  6615 IMPBKI           3    1  6617 IMPBKO           4    1  6636 IMPC3A
  4    1  6643 IMPC4A           4    1  6622 IMPCNO           4    1  6623 IMPCO2           4    1  6631 IMPCO3
  4    1  6642 IMPCO4           4    1  6652 IMPCO5           4    1  6664 IMPCO6           4    1  6666 IMPCOX
  9    1  6751 IMPDIS           3    1  6575 IMPDSP           9    1  6755 IMPDSX           5    1  6674 IMPDWC
  6    1  6677 IMPIN            6    1  6701 IMPIN1           6    1  6707 IMPIN2           6    1  6710 IMPIN3
  8    1  6724 IMPINT           3    1  6573 IMPIO2           8    1  6730 IMPNT1           8    1  6735 IMPNT2
  8    1  6737 IMPNT3           8    1  6741 IMPNT4           8    1  6743 IMPNT5           8    1  6744 IMPNT6
  8    1  6750 IMPNT7           8    1  6742 IMPNTX           7    1  6717 IMPOU1           7    1  6715 IMPOUT
 10    1  6757 IMPRS2          10    1  6756 IMPRST           5    1  6670 IMPSTS          15   70  4037 IMUL1
 15   70  4041 IMUL2           15   70  4044 IMUL3           40  159  6371 INSEX1          40  159  6370 INSEXP
 18  133  3546 JFCL1           16   86  4162 JFFO1           16   86  4163 JFFO2           16   86  4166 JFFO3
 16   86  4171 JFFO4           16   86  4167 JFFO5           18  133  3555 JRA1            18  131  3504 JRST1
 18  132  3515 JRST2           18  133  3544 JRST3           18  131  3507 JRST4           18  131  3510 JRST5
 18  131  3514 JRST8           18  131  3513 JRST9           18  133  3553 JSA1            27  141  5546 JSMFR
  8   13  2553 JSP1            18  133  3551 JSR2             4    2  2210 JSYS            28  141  5631 JSYS1
 28  141  5636 JSYS2            4    2  2211 JSYS3           41  162  5042 KAFIXN          41  162  5040 KAFIXP
  4    3  2244 KIFIX           41  162  5055 KIFIX1          41  162  5060 KIFIXN           1    1 10001 KNYCLR
  1    2 10014 KNYGOA           1    3 10175 KNYMTP           1    2 10010 KNYRGO           1    1 10001 KNYRS1
  1    6 10330 KNYW1            1    6 10326 KNYWAIT          5    3  2272 LDB             14   62  2624 LDB1
 14   62  2633 LDB2            14   62  2635 LDB4            14   62  2625 LDB5            17  104  2766 LOG2
 17  104  2767 LOG3            19  134  5120 LPTDSP          16   97  2752 LSHC1           16   99  2735 LSHC2
 16   90  2731 LSHDO           16   90  2733 LSHDO1          16   88  2713 LSHNEG          16   88  2714 LSHNN1
 16   90  2726 LSHPDO          16   88  2711 LSHPLS           4    1  2026 MAIN             4    1  2027 MAIN1
  4    1  2030 MAIN2           25  140  5147 MAPCO0          26  141  5361 MAPCO1          26  141  5376 MAPCO4
 26  141  5403 MAPCO6          26  141  5405 MAPCO7          26  141  5354 MAPCOA          25  140  5170 MAPCOB
 25  140  5171 MAPCOC          26  141  5356 MAPCOE          26  141  5365 MAPCOG          25  141  5344 MAPCW1
 25  141  5345 MAPCW2          26  141  5410 MAPCW9          25  141  5340 MAPCWT          26  141  5412 MAPDO
 25  140  5145 MAPIO1          25  140  5141 MAPIOT          26  141  5400 MAPOFF          27  141  5622 MAPRSL
 27  141  5621 MAPRSS          27  141  5617 MAPRST          25  140  6201 MBLT2           25  140  6126 MBLT3
  1    6  5000 MBOOT            1    7  6220 MBOOTA           1    6 10272 MBOOTH           1    6 10315 MBTBY1
  1    6 10323 MBTBY2           1    6 10314 MBTBYTE          1    6 10325 MBTBYX           1    6 10334 MBTCHECK
  1    6 10340 MBTDNX           1    6 10352 MBTERR          26  141  5442 MFA1            26  141  5450 MFA2
 26  141  5424 MFA3            26  141  5431 MFA4            27  141  5516 MFA5            26  141  5430 MFA6
 26  141  5425 MFA7            26  141  5454 MFB3            27  141  5556 MFB4            27  141  5556 MFB5
 27  141  5570 MFC1            26  141  5441 MFHIEX          25  140  6111 MFOTH           25  140  6110 MFRD
 25  140  6104 MFT1            25  140  6105 MFT1A           26  141  5435 MFT1B           25  140  6106 MFT1D
 27  141  5551 MFTR1           27  141  5554 MFTR10          27  141  5601 MFTR2           27  141  5602 MFTR3
 27  141  5604 MFTR4           27  141  5615 MFTR41          27  141  5604 MFTR5           27  141  5605 MFTR6
 27  141  5613 MFTR7           27  141  5614 MFTR9           26  141  5473 MFTYP0          26  141  5471 MFTYP1
 26  141  5421 MFUS             6    3  2400 MOVE             6    3  2401 MOVE1            6    3  2402 MOVEI
  6    3  2404 MOVEM            6    3  2406 MOVES            6    3  2430 MOVM             6    4  2142 MOVM1
  6    4  2432 MOVMI            6    4  2434 MOVMM            6    4  2436 MOVMS            6    6  2042 MOVMS1
  6   10  2054 MOVMS2           6    7  2044 MOVMS3           6    8  2046 MOVMS4           6    9  2050 MOVMS5
  6   10  2052 MOVMS6           6    3  2420 MOVN             6    3  2422 MOVNI            6    3  2424 MOVNM
  6    3  2426 MOVNS           18  113  2773 MOVNS1           6    3  2410 MOVS             6    3  2412 MOVSI
  6    3  2414 MOVSM            6    3  2416 MOVSS           18  113  2772 MOVSS1          26  141  5377 MPOFF1
 15   70  4060 MSETOV           4    1  2032 MSMAIN           4    1  2033 MSMAIN1         14   58  4000 MSTART
 15   70  4061 MSTOV1          14   59  4001 MSTRT1          27  141  5602 MTRPAL          18  134  4461 MUJSA
 18  134  4465 MUJSM1          18  134  4457 MUJSP           18  134  4454 MUJSR           18  134  4463 MUJSYS
 15   70  4046 MUL1            15   70  4050 MUL2            15   70  4052 MUL3             4    1  2100 MUUO
  4    2  2101 MUUO2            4    2  2103 MUUO3            4    2  2105 MUUO4            4    2  2106 MUUO44
  4    2  2120 MUUO5X           4    2  2124 MUUO5Y           0   38     0*NAF              1    2 10032 NCNTW1
  1    2 10032 NCNTWT          40  159  6353 NEGNOR           4    1  2027 NMAIN1          40  159  6356 NN1
  3    1     0*no-@            40  159  6361 NORMOV          40  160  6445 NORND           18  105  2071 NORSW
 18  106  4412 NORSW2          18  105  2073 NOSW            40  159  6366 NOVNO           40  159  6364 NOVYES
 40  159  6344 NRMLIZ          10   23  3133 OCAI1           10   24  3163 OCBI1           10   24  3153 OCMI1
 17  104  2770 ORCM2           17  104  2771 ORCM3            1    6 10301 P2               1    6 10302 P2A
 31  148  4736 PDLMEM          31  148  4740 PDLO            31  147  4721 PDLO1           31  147  4724 PDLO2
 31  147  4726 PDLO3           31  147  4731 PDLO4           31  147  4725 PDLO5           31  147  4734 PDLO6
 31  148  4737 PDLOE           21  138  4536 PI-CHECK-RQS    22  138  4605 PI-DISMISS      21  138  4530 PI-GET-CHN
 23  138  4646 PI-RESET        23  138  4641 PICONISUB       23  138  4610 PICONO          30  141  5320 PIDSP
 22  138  4564 PIGEN           22  138  4571 PIGEN1          22  138  4576 PIGENWT         21  138  4534 PIGETMASK
 21  138  4555 PIINTGO         21  138  4532 PIL1            21  138  4556 PIL11           23  138  4624 PIL3
 23  138  4626 PIL4            23  138  4630 PIL5            23  138  4632 PIL6            23  138  4615 PIL7
 23  138  4617 PIL8            23  138  4621 PIL9             4    2  2105 PIMUUO          16  102  4247 POP1
 16  102  4252 POPJ1           40  159  6350 POSNOR          16  102  4245 PUSH1           16  102  4253 PUSHJ1
 25  140  6147 QORCRY          18  106  4350 RESET           18  106  4353 RESLOP          18  106  4345 RESW1
 18  112  4421 RESW2           16   94  2742 ROTC1           16   95  2747 ROTC2           16   88  2707 ROTDO
 16   87  2704 ROTNEG          16   87  2705 ROTNN1          16   87  2702 ROTPLS          20  138  4503 SDSKO2
 31  149  6036 SECCS           20  138  4501 SET-DSK-OUT     40  159  6376 SETFOV          25  140  6152 SETHFU
 25  140  6146 SETHLF          18  112  4445 SETLTS          10   17  3030 SETM            16   92  4202 SETOV1
 16  101  2034 SJMAIN           9   15  2663 SKIPX1          12   47  3424 SKMAIN           4    1  2024 SMAIN
  4    1  2025 SMAIN1          31  149  6066 SOEDOV          31  149  6032 SOVRS            1    2 10051 STDC1
 31  149  6031 STOPS           18  106  4370 STPLOP          18  106  4404 STPLP1           1    2 10047 STRTDC
 18  112  4425 STRTSW          18  105  2062 SWINT           38  151  6222 TAPDSP           1    3 10203 TAPEBR
  1    3 10202 TAPEFR           1    3 10155 TAPEMT           1    4 10237 TAPENR           1    2 10005 TAPERD
  1    3 10214 TAPERS           1    3 10201 TAPERW           1    5 10241 TAPERX           1    5 10247 TAPEWR
 20  138  4516 TAPRST          44  164  6561 TCNI1           44  164  6557 TCNO1           44  164  6563 TDATO
 12   51  3525 TDC1            12   53  3565 TDO1            44  164  6567 TDTI            12   49  3466 TDZ1
 12   49  3467 TDZ2             1    3 10173 TERAS1           1    3 10174 TERASE          40  161  6501 TESMUL
 13   55  3740 TIMER-IOTS      44  163  6551 TIMINT          20  138  4521 TIMRST          12   45  3416 TLC1
 12   43  3412 TLO1            12   41  3406 TLZ1            43  162  6543 TNI              1    5 10245 TNRP3
  1    3 10212 TPCLRNK          1    2 10115 TPMAOK           1    3 10206 TPSETDMP         1    3 10204 TPSETIND
  1    3 10210 TPSETNK         12   44  3414 TRC1             1    2 10105 TRCHA            1    2 10103 TRCHECK
  1    2 10104 TRCHKB           1    2 10131 TRCRET           1    2 10146 TRCX             1    2 10107 TRDONE
  1    2 10147 TREOF            1    2 10150 TRERR           12   42  3410 TRO1             1    2 10100 TRP2
 12   40  3404 TRZ1            12   49  3465 TSZ2             1    5 10265 TWER1            1    5 10262 TWERR
  1    3 10172 TWREOF           1    5 10250 TWRTRY          20  138  4510 TYMRST           4    2  2125 UAOP
 20  138  4504 UDSKST           4    3  2260 UFA             40  157  6225 UFA1            40  160  6446 UFANOR
  4    2  2200 UMOVE           28  141  5652 UMOVX            1    5 10246 UTAPWR           4    1  2076 UUO0-7
  4    1  2020 UUO1             4    1  2021 UUO2             4    1  2060 UUOGO            4    2  2117 UUOPJ
  1    2  7526 VCBRST           1    2  7453 VCCMD            1    2  7543 VCDONE           1    1  7367 VCDSP
  1    2  7507 VCGO             1    2  7476 VCGST            1    1  7437 VCINT            1    1  7444 VCINT2
  1    1  7445 VCINT3           1    2  7451 VCIOT            1    2  7527 VCLP             1    2  7552 VCLST
  1    2  7564 VCODLY           1    2  7561 VCOLP            1    2  7462 VCONO            1    2  7463 VCONO0
  1    2  7473 VCONO1           1    2  7474 VCONO2           1    2  7476 VCONSO           1    2  7476 VCONSZ
  1    1  7427 VCORG            1    2  7501 VCOUNT           1    2  7501 VCOUT            1    2  7562 VCOUT1
  1    2  7453 VCRST            1    2  7475 VCSET2           1    2  7476 VCSTAT           1    2  7554 VCWRD
  1    2  7556 VCWRD1           1    2 10055 WCDONE          29  141  5771 XBLTL           28  141  5732 XBY1
 28  141  5752 XBY13           28  141  5743 XBY14           28  141  5737 XBY15           28  141  5755 XBY3
 28  141  5735 XBY4            28  141  5656 XCT1            28  141  5724 XCT10           28  141  5706 XCT11
 28  141  5705 XCT12           28  141  5676 XCT13           28  141  5677 XCT18           28  141  5710 XCT2
 28  141  5671 XCT3            28  141  5664 XCT4            28  141  5662 XCT5            28  141  5666 XCT6
 28  141  5711 XCTAC           28  141  5726 XCTBLG          29  141  5770 XCTBLT          28  141  5731 XCTBYT
 28  141  5720 XCTSTK          28  141  5661 XCTUMV          28  141  5707 XDISP           29  141  5764 XFIXMA
  4    3  2041 XMOVEM1         29  141  6013 XPDLO2          29  141  6015 XPOP1           29  141  6026 XPOP2
 29  141  6030 XPOP3           29  141  6004 XPUSH1          40  160  6442 YESRND          40  160  6457 ZLOW

01m0029                               	LIST-CORMAP


			Storage map


     0	X...............................................................
   100	................................................................
   200	................................................................
   300	................................................................
   400	................................................................
   500	................................................................
   600	................................................................
   700	................................................................
  1000	................................................................
  1100	................................................................
  1200	................................................................
  1300	................................................................
  1400	................................................................
  1500	................................................................
  1600	................................................................
  1700	................................................................
  2000	XXXXXXXXXXX.XXXXXXXXXXXXX.XXXX..XXXXXXXXXXXXX...X.XXXXXXXXXX..XX
  2100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXX..XXXXXXXXXX.....X.XXXXXX..XXXXXX..
  2200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  2300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  2400	XXX.X.XXXXX.XXXXXXX.X.XXXXX.XXXXXXX.XXXXXXX.XXXXXXX.XXXXXXX.XXXX
  2500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  2600	XXXXXXX.XXXXX.XXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXX..
  2700	XXXXXXXXXXXXXX..XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXX
  3000	X.X.X.X.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.X.X.XX
  3200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3400	XXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  3500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..XXXXXXXXXXXXXXXXXXXXXXXXXX......
  3600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.X.
  4000	XXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXX
  4500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..............................
  5000	XXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX...
  5100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  5200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  5300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6000	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX......
  6100	X...XXXXXX..X...XXXXXXX.XXX.XX..XXXXXXXXXXXXXX..XXXXXXX.X...XXXX
  6200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7000	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXX
  7500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.
  7600	XXXXXXXXXXXXX...................................................
  7700	................................................................
 10000	XXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXX
 10200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXX...............
 10400	................................................................
 10500	................................................................
 10600	................................................................
 10700	................................................................
 11000	................................................................
 11100	................................................................
 11200	................................................................
 11300	................................................................
 11400	................................................................
 11500	................................................................
 11600	................................................................
 11700	................................................................
 12000	................................................................
 12100	................................................................
 12200	................................................................
 12300	................................................................
 12400	................................................................
 12500	................................................................
 12600	................................................................
 12700	................................................................
 13000	................................................................
 13100	................................................................
 13200	................................................................
 13300	................................................................
 13400	................................................................
 13500	................................................................
 13600	................................................................
 13700	................................................................
 14000	................................................................
 14100	................................................................
 14200	................................................................
 14300	................................................................
 14400	................................................................
 14500	................................................................
 14600	................................................................
 14700	................................................................
 15000	................................................................
 15100	................................................................
 15200	................................................................
 15300	................................................................
 15400	................................................................
 15500	................................................................
 15600	................................................................
 15700	................................................................
 16000	................................................................
 16100	X.......X...X...................................................
 16200	................................................................
 16300	................................................................
 16400	................................................................
 16500	................................................................
 16600	................................................................
 16700	................................................................
 17000	................................................................
 17100	................................................................
 17200	................................................................
 17300	................................................................
 17400	................................................................
 17500	................................................................
 17600	................................................................
 17700	................................................XXXXXXXXXXXXXXXX
  3083 locations used,  highest used = 17777
%Warn    no-@  is an undefined label 
