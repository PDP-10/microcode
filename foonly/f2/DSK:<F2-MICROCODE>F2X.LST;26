01 0001  	;F2 with 8K micro-memory
01 0002  	
01 0003  	;Initialize switch settings
01 0004  	.INSERT SWINIT.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:SWINIT.SLO  --  of -- F2X

01 0001  	;INIT ALL SWITCHES FOR CF TO 0.
01 0002  	
01 0003  	.DEFINE FOOLIST[01 0004  	
01 0005  0 	!-.INSERT-'SWINIT.SLO'-! = 0  ;ERROR MESSAGE FOR LOSERS
01 0006  	
01 0007  1 	F2SW = 1        ; SET F2SW = 1 FOR F2,  F2SW = 0 FOR F3
01 0008  	
01 0009  1 	FAST = 1        ;IF 0, ALL CYCLES ARE 500NS OR MORE.
01 0010  	
01 0011  1 	SLOW1 = 1       ;MAKES 350NS CYCLES LONGER BY 50*SLOW1 NS. DWP 2/10
01 0012  	
01 0013  0 	SLOW2 = 0       ;MAKES 400NS CYCLES LONGER BY 50*SLOW2 NS.
01 0014  	
01 0015  0 	TYMNET = 0
01 0016  	
01 0017  0 	DR11P = 0
01 0018  	
01 0019  0 	TLXTAPE = 0
01 0020  	
01 0021  0 	125TAPE = 0
01 0022  	
01 0023  0 	SLOWTAPE = 0
01 0024  	
01 0025  0 	KNYTAPE = 0
01 0026  	
01 0027  0 	NTP = 0         ;NEW TAPE CTRL (DMA TYPE)
01 0028  	
01 0029  0 	TAPE = 0        ;New tape ctrl with long records.
01 0030  	
01 0031  0 	75IPS = 0       ;Not 75IPS drive -- implies 125IPS
01 0032  	
01 0033  0 	DLS = 0
01 0034  	
01 0035  0 	IMP = 0
01 0036  	
01 0037  0 	VID = 0         ;FooVision
01 0038  0 	VIC2 = 0        ;Smart video controler (with sysnthsis)
01 0039  	
01 0040  0 	LPT = 0         ;Lineprinter (Printronix, etc.)
01 0041  	
01 0042  0 	VC = 0          ;Versatec/Varian plotter interface.
01 0043  	
01 0044  1 	NEWMAP = 1      ;SET FOR MACHINES F3-3 AND LATER.
01 0045  	
01 0046  1 	CROCK = 1       ;set to 1 to get some old crockish code back
01 0047  	
01 0048  0 	DEBUGSW = 0     ;Set to 1 to get some debugging crocks
01 0049  	
01 0050  0 	TIMER = 0       ;INTERVAL TIMER
01 0051  	
01 0052  0 	STANSW = 0      ;Special Stanford I/O devices
01 0053  	
01 0054  0 	WAITS = 0       ;BBN Pager was modified for WAITS
01 0055  	
01 0056  0 	XUCODE = 0      ;Set to 1 (exactly !) if 8k u-memory present.

SLOE   Jan ***, 1859 00:00:03  file DSK:F2X.SLO  --  of -- F2X

01 0004  	
01 0005  	; F2 VERSION OF MICROCODE
01 0006  	
01 0007  	; SET F2SW = 1 FOR F2,  F2SW = 0 FOR F3
01 0008  	
01 0009  1 	F2SW = 1
01 0010  	
01 0011  1 	XUCODE = 1      ;8K u-mem present
01 0012  	
01 0013  1 	NEWMAP = 1
01 0014  	
01 0015  1 	TIMER = 1
01 0016  	
01 0017  1 	TYMNET = 1      ;For F5 diagnostics
01 0018  	
01 0019  	;;;IMP = 1
01 0020  	
01 0021  20  	DLSDEV = 20     ; udevice code for TTY scanner
01 0022  	
01 0023  1 	DLS = 1
01 0024  	
01 0025  1 	DLSDEB = 1
01 0026  	
01 0027  1 	DLS2 = 1
01 0028  	
01 0029  1 	NTP = 1
01 0030  	
01 0031  1 	TAPE = 1        ; New tape code
01 0032  1 	75IPS = 1 ;75 IPS TAPE SPEED -- USED FOR READING OLD CCRMA TAPES.
01 0033  	
01 0034  1 	VID = 1         ; FooVision video
01 0035  0 	VIC2 = 0        ; No smart video control (with synthesis)
01 0036  36  	DPYDEV = 36
01 0037  2 	DPYDEV2 = 2
01 0038  	
01 0039  	;;VC = 1                ; Set to 1 for Versatec
01 0040  14  	VCDEV = 14      ; udevice code for Versatec
01 0041  	
01 0042  	.DEFINE DLIST ;Define as LIST to enable FOOLIST
01 0043  	.DEFINE DXLIST ;Define as XLIST for FOOLIST stuff
01 0044  	
01 0045  	XLIST
01m0047                               	LIST
01m0047                               	
01m0047                               	.INSERT CFNEW

SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

01m0001                               	COMMENT \       FOONLY F2-F3 MICRO-CODE
01m0001                               	
01m0001                               	
01m0001                               	Recent history:
01m0001                               	
01m0001                               	21 Mar 80 TVR   Added DMOVE, DMOVEM and ADJSP instructions.  Changed opcode of
01m0001                               	                XMOVE to 107, as it conflicted with ADJSP.  Experimental boot
01m0001                               	                switches in preparation for auto-loading tapes.
01m0001                               	22 Mar 80 TVR   Fixed some typos with above.  
01m0001                               	26 Mar 80 TVR   Added WAITS switch to modify pager to make references to user
01m0001                               	                ACs go to user shadow memory (instead of special place pointed
01m0001                               	                to by AC Base Register in BBN Pager).  Since the addresses
01m0001                               	                supplied to the random instructions must be larger than 17
01m0001                               	                to prevent references to ACs in 2901, a page was stolen from
01m0001                               	                the EXEC address space, currently 770xxx, and that page table
01m0001                               	                entry in the hardware is copied from entry 0 of the user page
01m0001                               	                table in core.
01m0001                               	                Also, for Stanford only, defined ILGIOT to reference the PAN
01m0001                               	                interface, so that CONSZ will skip when no device is present
01m0001                               	                and new devices can be added to that bus without microcode
01m0001                               	                changes.
01m0001                               	                Fixed dispatch for UUO0 to look at opcode field only.  Made
01m0001                               	                indirect dispatch test for the stop switch, so that stop will
01m0001                               	                stop indirection loops
01m0001                               	                Fixed DATAO PI, to page fault properly.
01m0001                               	27 Mar 80 TVR   Pager mods and tape hack for CCRMA were both buggy.  Fixed.
01m0001                               	                Fixed bug in pager: PC was being over-decremented on page
01m0001                               	                fill cycle when indirection failed in XCTR'ed instruction.
01m0001                               	29 Mar 80 TVR   Flushed a spurious DEST-A-MEM which prevented WAITS from
01m0001                               	                working at XCTAC+1.
01m0001                               	02 Apr 80 TVR   Added code to trap IOT references if not Exec or IOT-User
01m0001                               	                mode.  New macro, UIOTRP, jumps if in IOT-USER mode.
01m0001                               	                ILGIOT still is a no-op for non-Stanford microcode for
01m0001                               	                the moment.
01m0001                               	                For Stanford only, the PAN interface has its micro-interrupts
01m0001                               	                re-enabled on PI-CHECK-RQS.
01m0001                               	                Bummed an instruction out of IOTDIS. Indirect bit is guaranteed
01m0001                               	                zero so one can double by shifting instead of doing an add.
01m0001                               	03 Apr 80 TVR   Fixed ADJSP.  XCT n,[PUSH x,y] failed if x was a user AC
01m0001                               	                reference.  Added code to emulate PUSH/POP.
01m0001                               	04 Apr 80 TVR   XCT 1,[POP x,AC] didn't have a chance of working.  It gets
01m0001                               	                emulated as well.  Added code for KAFIX.
01m0001                               	11 Apr 80 TVR   Changed PAN interrupt enables in PI-CHECK-RQS.  Added reset
01m0001                               	                code and IOT dispatch for temp. Grinnell code (under STANSW).
01m0001                               	                Looked at DIV code to try to fix divide-by-zero.  Gave up in
01m0001                               	                disgust.  I won't touch that code with a 10 ft battle axe!
01m0001                               	                Fixed another stupid typo in ADJSP.
01m0001                               	22 Apr 80 TVR   Fixed two bugs in DPB (and one in LDB).  DPB sets half flag
01m0001                               	                if it gets a page fault on the pointer reference.  The monitor
01m0001                               	                doesn't care much, but some user programs look at the fault
01m0001                               	                PC and flags to decide what kind of Pager and CPU they are
01m0001                               	                running under.  The other bug was that in LDB and DPB; they
01m0001                               	                do not handle bytes which 'wrap-around', i.e. 36-P<S.  If this
01m0001                               	                is the case, i think the right thing is S:=P.
01m0001                               	                Fixed bug in DMOVEM references to ACs.  One more time on ADJSP.
01m0001                               	                Added code (MAPRST) the clear entire map (not just valid bits)
01m0001                               	                on 'power-up' to prevent immediate mode references from going
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

01m0001                               	                to non-ex memory and/or causing spurious ECC traps.
01m0001                               	                Wrote some code for DMOVN, DMOVNM, and KIFIX.
01m0001                               	                Re-arranged a few things to make things fix (%$%@*#& orgs).
01m0001                               	26 Apr 80 TVR   Merged with DWP's version, which did not contain indications
01m0001                               	                of alterations.  Unfortunately, i did not have the most recent
01m0001                               	                CCRMA version available, so another merge will be necessary.
01m0001                               	                Many comments added.
01m0001                               	30 Apr 80 TVR   Attempted merge with CCRMA version.  That tape was not complete
01m0001                               	                so only some of the code will be merged.  Enough to proceed
01m0001                               	                with cleanup.
01m0001                               	                Replaced most :<expression> with macro calls in order to use
01m0001                               	                microcode memory in a more reasonable fashion.
01m0001                               	                More comments added.
01m0001                               	07 May 80 TVR   The assembler is a loser!  It redefines macros alright, some of
01m0001                               	                the time.  At any rate, the macros were rewritten and all
01m0001                               	                (shudder) of the macro calls changed.
01m0001                               	10 May 80 TVR   Merged in the rest of the CCRMA changes.
01m0001                               	11 May 80 TVR   Grumble, curse, moan!!!  No, the assembler isn't THAT bad.
01m0001                               	                The REAL loser not the assembler, but the person who wrote oet
01m0001                               	                the old version (which had a different name) onto
01m0001                               	                SCI:<POOLE>SLOEXP.SAV and which contains various and sundry
01m0001                               	                bugs, one of which appears to be macro re-definition and
01m0001                               	                another being an unusable storage map.  So, everything was
01m0001                               	                delayed a week while i tried to get around bugs which had
01m0001                               	                already been fixed.
01m0001                               	                Fortunately, this time it could be converted back to the
01m0001                               	                original form with the aid of a TECO macro.
01m0001                               	                Adjusted memory usage and it now assembles except for
01m0001                               	                re-usage of 5300 and 5301.
01m0001                               	12 May 80 TVR   Adjusted some of memory usage to make the silly thing assemble
01m0001                               	                WAITS version in preparation for making larger adjustments.
01m0001                               	                PAN interrupts are come out in the status word as low true. PAN
01m0001                               	                interrupt code has been corrected for that.
01m0001                               	                Fixed a rather obscure bug in SETHLF.  Because SETHLF stores
01m0001                               	                into CRYOV, the EXEC mode shift register (what COND[USER] is
01m0001                               	                based on) gets forced to be the current space.  Thus,
01m0001                               	                page faults from User pages in Exec mode on certain
01m0001                               	                instructions (like IDPB) were being processed as being Exec
01m0001                               	                mode page faults.
01m0001                               	13 May 80 TVR   Added .QUAD macro and put it in places jumped to by SLOOP
01m0001                               	                which were previously controlled by :<absolute number>.
01m0001                               	                Adjusted memory usage to make the one area using .QUAD fit.
01m0001                               	                Fixed misfeature in experimental boot.
01m0001                               	                LDB/DPB for bytes that wrap around just isn't right at all!
01m0001                               	                BYTE-OVERF is condition BEFORE incrementing, not after.  So,
01m0001                               	                i will have to rethink this one to come up with something
01m0001                               	                that handles that case properly without slowing byte
01m0001                               	                instructions down significantly.
01m0001                               	
01m0001                               	Changes at CCRMA follow:
01m0001                               	
01m0001                               	15 May 80 TVR   Fixed bug in DMOVNM.  Changed mechanism for PAN interrupts.
01m0001                               	                The PAN microinterrupt enable is turned off when the interrupt
01m0001                               	                for that channel is recieved and turned on by PI-CHECK-RQS
01m0001                               	                by setting all of the microinterrupt enables for the PAN to
01m0001                               	                the complement of PI IN PROGRESS and PI REQUEST.  This means
01m0001                               	                that the PAN can only request interrupts whenever something
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

01m0001                               	                else isn't using those channels.  This implies that any PAN
01m0001                               	                devices must be on the end of CONSZ chains, or else they will
01m0001                               	                steal interrupts from other, interrupt counting devices.
01m0001                               	24 May 80 TVR   Grinnell interrupt bug fixes.  Starting putting names on
01m0001                               	                opcodes and stuff to make it easier to use with E.
01m0001                               	26 May 80 TVR   Fixed problem in JRST1+1 falling thru to nothingness.  A few
01m0001                               	                more editorial changes.
01m0001                               	07 Jul 80 TVR   Changed CONO APR, code to turn on AR INT ENB and also made
01m0001                               	                symbols some references to APR A-MEM relating to APR.
01m0001                               	                Fixed bugs in F2 version of overflow interrupt.
01m0001                               	                *** Did not look at F3 code for same. ***
01m0001                               	                More comments added.
01m0001                               	08 Jul 80 TVR   Made attempt to fix [I]DIV by zero and no divide.
01m0001                               	                As part of that, commented the setup part of DODIV, and added
01m0001                               	                code to try to restore AC after finding no divide case.  I'm
01m0001                               	                not sure the DIV case will work properly, but we'll see...
01m0001                               	                Fixed bug in FDVR of negative number which set the flags wrong.
01m0001                               	                It had the wrong MASK when complementing a negative dividend
01m0001                               	                exponent.
01m0001                               	                Many comments added to divide and KA floating point as a result
01m0001                               	                of chasing these.  Some have (???) being i'm not sure that either
01m0001                               	                the code and/or the comments are right.
01m0001                               	15 Jul 80 TVR   Installed LPT device.  Microcode for LPT is still being tested.
01m0001                               	                Fixed bug in PAN enabling, so that PI channels that are not
01m0001                               	                turned on do not have their micro interrupts enabled.
01m0001                               	22 Jul 80 TVR   Fixed bug in [I]DIV which clobbered PC on divide by zero.
01m0001                               	                Sets overflow on KIFIX now.  Also, sets overflow on KAFIX, which
01m0001                               	                should not cause any problems.
01m0001                               	25 Jul 80 TVR   Added FIXR and FLTR.
01m0001                               	23 Aug 80 TVR   Fixed bugs in LDB/DPB having to do with bytes which overflow
01m0001                               	                word boundaries.
01m0001                               	                Ran out of micro-code space and re-adjusted .USEs to recover
01m0001                               	                some wasted space.
01m0001                               	                More work on LPT device.
01m0001                               	20 Sep 80 TVR   Added a new switch, MUM2.  At the moment, this only causes
01m0001                               	                ECC logging information to go to 1776x instead of 0776x.
01m0001                               	                Under WAITS switch, changed APR CONI, and clock interrupt
01m0001                               	                decision, to implement special feature of SAIL's KA, which
01m0001                               	                turns on bit 27 in APR CONI when it is NOT interrupting.
01m0001                               	25 Sep 80 TVR   Began merge of CCRMA version with DWP version.  MUM2 became
01m0001                               	                XUCODE.
01m0001                               	                Tape code got moved to separate files in order to make SRCCOM
01m0001                               	                feasible.
01m0001                               	                New symbol TYMORG defines where absolute part of TYMNET code
01m0001                               	                is assembled. It only need be changed in the future.
01m0001                               	
01m0001                               	Changes at Foonly follow:
01m0001                               	
01m0001                               	
01m0001                               	15 Aug 80 BO    Added Versatec to unused half of CTY IOT dispatch,
01m0001                               	                device code 124.
01m0001                               	                Removed the 16 NOP's at the very end of memory.  VC code
01m0001                               	                is broken up to fit available space.
01m0001                               	                Used absolute locations 5340-5437 (5340 defined as
01m0001                               	                VCORG1) and 7733-7777 (VCORG2) defined in VC.SLO
01m0001                               	                
01m0001                               	25 Sep 80 TVR   Following changes were not documented but evident from source
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

01m0001                               	                comparison:
01m0001                               	
01m0001                               	                MASK[18] was added to dispatch code at 2002. Presumably, this
01m0001                               	                        done to make the interrupt bug trap work properly.
01m0001                               	                CONSZ to DLS when no code is assembled now always skips, so
01m0001                               	                        that TENEX can tell if the DLS exists.
01m0001                               	                New device, VID, added.  This is Gossett's new display.
01m0001                               	                uDevice numbers for the DLS, VC are now variables.
01m0001                               	                Code for DMA tape controller was added.
01m0001                               	                Two new switches were added, OTP and NTP, which stand for
01m0001                               	                        Old Tape and New Tape controllers.  NTP is for
01m0001                               	                        the DMA tape controller and all others are OTP.
01m0001                               	                Changes to CTY code and TYMNet code to account for differences
01m0001                               	                        in MAPF fields for new tape controller.
01m0001                               	                Some adjustment of .ORG and .USE were done to make things fit.
01m0001                               	                FDVL was fixed.  This involved making changes to A-MEM usage
01m0001                               	                        in floating divide code.
01m0001                               	                SLOEXP was modified to truncate jump addresses to 12 bits without
01m0001                               	                        complaint.
01m0001                               	                New switch, XUCODE, was added.  If XUCODE=1, then some I/O devices
01m0001                               	                        are assembled into the upper 4K of microcode memory.
01m0001                               	                A new macro, .GETADR(X), constructs a 12 bit number in Q.
01m0001                               	                Tape code is optionally moved into upper 4K of microcode memory
01m0001                               	                        if XUCODE=1.  Dispatches for tape code were moved.
01m0001                               	                
01m0001                               	Versions merged.  This version is designated 1.02 by fiat of TVR.
01m0001                               	
01m0001                               	25 Sep 80 TVR   Completed merge.
01m0001                               	                *** VC needs a new device code.  It had used the slot assigned
01m0001                               	                historically to the LPT.
01m0001                               	                Some other minor formatting/comment changes were made to make
01m0001                               	                the source merge program work properly.
01m0001                               	                There were strong differences between the two in the floating
01m0001                               	                divide code.  Hopefully, all of the A-MEM changes made it
01m0001                               	                across.  I have checked them by hand.
01m0001                               	
01m0001                               	26 Sep 80 TVR   Assigned device 520 to VC (Versatec interface), and modified
01m0001                               	                VC.SLO to accomdate that.
01m0001                               	
01m0001                               	4 Nov 80 PG     Added new display service for FooVision (VID.SLO). This
01m0001                               	                stuff makes use of high memory, since it is quite large. Note
01m0001                               	                that the ,INSERT must be right after the tape code, since
01m0001                               	                (due to kludgery) .USE[OTHER] doesn't work properly for getting
01m0001                               	                you back to low memory (see TYMFOO). For your information:
01m0001                               	                .USE[HIGHMEM]   gets you to high memory
01m0001                               	                .USE[OTHER]     gets you back to low memory
01m0001                               	                GETADR[FOO] JUMP[GOHIGH] $      jumps to high memory 10000+FOO
01m0001                               	                                                (Note that this expands
01m0001                               	                                                to 2 microcode words.)
01m0001                               	                JUMP[GOMAIN] $                  jumps to MAIN in low memory
01m0001                               	
01m0001                               	21 Nov 80 - PG  Added new output instruction to TYMNET for F5 diagnostics.
01m0001                               	                Takes the data in the effective address, using the right
01m0001                               	                16. bits of the right half as data to go out;
01m0001                               	                AC=1 => STB DATA, and AC=2 => STB CTRL.
01m0001                               	
01m0001                               	Above is version 55 as received at Symbolics
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

01m0001                               	
01m0001                               	16 Mar 81 Moon  Moved TYMNET code into separate file, added new file DR11
01m0001                               	                under new switch DR11P providing packet oriented DR11C
01m0001                               	                support.  Involves new version of SWINIT also.
01m0001                               	
01m0001                               	(End history)
01m0001                               	\
01m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

02m0001                               	COMMENT \
02m0001                               	
02m0001                               	********************************************************
02m0001                               	
02m0001                               	        USEFUL MICROCODE WORD DEFINITIONS
02m0001                               	
02m0001                               	********************************************************
02m0001                               	\
02m0001                               	
02m0001       0	F3SW = 1 - F2SW
02m0001                               	
02m0001       0	OTP = 1 - NTP
02m0001                               	
02m0001                               	
02m0001       740007602375400000170000	FIXM1 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-RD] CYLEN[FIXM] $
02m0001       740007602375400000170000	FIXML = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-RD] CYLEN[LONG] $
02m0001       740007602375400000170000	FIXM2 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM] $
02m0001       740007602375400000170000	FIXM0 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[0] CYLEN[FIXM] $
02m0001                               	.DEFINE MEMST 02m0001                               	  ;  NOTE:  BECAUSE OF XCT MAPPED, MEMST IS SAME AS MEMSTMA
02m0001                               	 ; .DEFINE MEMST [] [COND[-MA-AC] LBJUMP[SMAIN] NORM ]
02m0001                               	.DEFINE MEMSTMA 02m0001                               	
02m0001       740767676376000000007777	DOSKIP = D[PC] ALU[D+1] DEST[MA PC] JUMP[MAIN1] NORM $
02m0001       000760000000000003607777	DONTSKIP = DEST[MA] SPEC[MA_PC] JUMP[MAIN1] $
02m0001       740767674000000000007777	DOJUMP = D[IR] DEST[MA PC] JUMP[MAIN1] NORM $
02m0001       740740000000000003607777	DOM1    = SPEC[MA_PC] JUMP[MAIN1] NORM $
02m0001                               	
02m0001       000000077775576770000000	CLRR    = ROT 22 D[MASK 22] ALU[D&AC] ACSEL[AC] DEST[AC] $
02m0001       000000077775400770000000	CLRL    =        D[MASK 22] ALU[D&AC] ACSEL[AC] DEST[AC] $
02m0001                               	
02m0001                               	;SLFFXM - Self FIXM (?)
02m0001                               	;Finish read fetch of read-modify-write type cycle.
02m0001                               	;Check to make sure effective address is writable.
02m0001                               	;Jump if AC field in IR is non-zero
02m0001                               	.DEFINE SLFFXM[02m0001                               	
02m0001                               	;;;;;;APR-A-MEM DEFINITIONS -- THERE SHOULD BE 7 MORE OF THESE !
02m0001                               	
02m0001       1	A-MEM-ECC-DATA = 1      ;Data on last ECC error -- readable by op. 750
02m0001                               	
02m0001                               	;;;;;;;
02m0001                               	
02m0001       000740000000000000007777	BADLOC = JUMP[MAIN] $;NOP FOR NOWJUMP BADPC $           ;FOR WORDS WE SHOULDN'T USE
02m0001                               	;;;;;ILGIOT = NORM JUMP[2000] $
02m0001                               	
02m0001                               	;The standard case for IOTs without devices
02m0001                               	.REPEAT 1 - STANSW [
02m0001                               	.DEFINE ILGIOT[02m0001                               	].REPEAT 1 - STANSW
02m0001                               	
02m0001                               	;At Stanford, any devices we don't know about go to the PAN interface.  It
02m0001                               	;may have something plugged into it that will respond to that address in a
02m0001                               	;PDP-10ish manner.
02m0001                               	.REPEAT STANSW [
02m0001                               	.REPEAT STANSW
02m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

02m0001                               	;Jump not IOT-USER mode
02m0001                               	.DEFINE UIOTRP[02m0001                               	DEFINE
02m0001                               	
02m0001                               	.DEFINE GETADR[02m0001                               	 ;Low-order 6 bits
02m0001                               	         ;NOTICE that a "$" is REQUIRED after a call of GETADR.
02m0001                               	
02m0001       740740074000001770007777	UUOLOC = D[CONST 40] JUMP[UUO1] NORM $
02m0001                               	
02m0001                               	   .DEFINE MUUO1 02m0001                               	   .DEFINE UAOP1 02m0001                               	
02m0001       740007674000177770000000	SET-TEMP-USER = D[CONST 17] ROT[11] DEST[MAP-EXEC-SR] NORM $
02m0001       740007674000177770000000	SET-TEMP-EXEC = D[CONST 0] ROT[11] DEST[MAP-EXEC-SR] NORM $
02m0001                               	
02m0001                               	;
02m0001                               	; THESE OUTLANDISHLY EXPLICIT DEFINITIONS OF NOP ASSURE THAT THE
02m0001                               	; DECODER WILL PRINT 'NOP' ONLY WHEN YOU REALLY MEAN IT.
02m0001                               	;
02m0001       037747602374000000000000	NOP =    COND[0] DEST[0] CONT ALU[D]
02m0001                               	        ACSEL[AC] NO-MA-STB NO-AR-STB ROT[0] MASK[-1] ALU-D[NONE] $
02m0001                               	
02m0001       037007602374000000000000	DONOP  = COND 0 DEST[ 0] ALU[D]
02m0001                               	         ROT[0] MASK[-1] ACSEL[AC] JUMP[MAIN] ALU-D[NONE] NORM $
02m0001                               	
02m0001       740777674000000003607777	DODISP  = D[MEM] DEST[IR-ALL MA AR] SPEC[PC+1-IF&] DISP[2374] CYLEN[DISP] $
02m0001                               	
02m0001                               	;------------------------------------------------------------------------------
02m0001                               	;
02m0001                               	;       CPU special registers                           uDevice 0
02m0001                               	;
02m0001                               	;------------------------------------------------------------------------------
02m0001                               	;
02m0001                               	; Dev  Subsel       Read                            Write
02m0001                               	;
02m0001                               	;  0     1                                      Address Break Register
02m0001                               	;        2      Data switches                   Data lights
02m0001                               	;        4      Address and console switches    Clear latched switches (no data)
02m0001                               	;       10      PC History (unimplemented)      Set AR,ECC enables, MAP ON, etc.
02m0001                               	;
02m0001                               	;  1     1      ECC status
02m0001                               	;        2      MAP status                      MAP (address in MA, LOCAL USER)
02m0001                               	;        4      (Same as 1)
02m0001                               	;       10      (Same as 1)
02m0001                               	;
02m0001                               	
02m0001                               	;------------------------------------------------------------------------------
02m0001                               	;
02m0001                               	;       A-Mem usage                                     uDevice 0 & 1
02m0001                               	;       (Note: Not all references are symbolic as yet.
02m0001                               	;
02m0001                               	;------------------------------------------------------------------------------
02m0001                               	;Device 0
02m0001       1	A-MEM-ECC-DATA = 1      ;Data on last ECC error -- readable by op. 750
02m0001       2	APRSTS = 2      ;Firmware status bits for APR
02m0001       7	APRENB = 7      ;Used to save ECC,AR interrupt enables, MAP ON, etc. during map
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

02m0001                               	                ;trap processing
02m0001                               	;Device 1
02m0001       3	ECCSVP = 3      ;Pointer to next place to remember ECC interrupt in microcode
02m0001                               	                ;memory
02m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

03m0001                               	
03m0001                               	COMMENT \
03m0001                               	
03m0001                               	*****************************************************
03m0001                               	
03m0001                               	                REAL CODE
03m0001                               	
03m0001                               	*****************************************************
03m0001                               	\
03m0001                               	
03m0001       2000	INST-DISP = 2000        ;Address of instruction dispatch.
03m0001       4001	NORMAL = 4001           ;Assembly starts here
03m0001                               	  .REPEAT XUCODE [
03m0001       10001	HIGHMEM = 10001         ;Upper 4K of 8K u-mem.
03m0001                               	    ]
03m0001                               	                        ;**** Next macro blows up with multiply defined symbol.          
03m0001                               	       ;**** Note that it usually does not complain!!!
03m0001                               	        .OPCODE[LIST 
03m0001                               	 LIST            ]      UUO 0 COMES HERE (ALONG WITH UUO 1 - 7 )
03m0001                               	
03m0001 02000 640140000571000440000000	        NORM JUMP[UUO0-7] $
03m0001                               	
03m0001                               	;; Location 2001 is used elsewhere !!!
03m0001                               	
03m0001                               	.REPEAT F3SW [
03m0001                               	
03m0001                               	.REPEAT F2SW [
03m0001                               	.REPEAT 0 [
03m0001                               	1 - DLS 9 JAN 80 BO
03m0001                               	
03m0001                               	:2002   ;I/O INTERRUPTS TRAP HERE
03m0001 02002 440540040571000440000000	        D[10] SDISP C600 $
03m0001                               	                ;Just dispatch to ucode intrpt. routine for device.
03m0001                               	: 2003 ;STOP SWITCH TRAPS HERE
03m0001 02003 640142400571000440000000	        DEST[CLR-DEV-FROM-INTR] JUMP[STOPS] NORM $
03m0001                               	: 2004  ;CAN'T GET HERE FROM THERE...
03m0001 02004 000140000571000440002004	        JUMP[.] $ ;HANG FOR NOW.
03m0001                               	: 2005  ;ECC ERRORS TRAP HERE
03m0001 02005 640142400571000440000000	        DEST[CLR-DEV-FROM-INTR] JUMP[SECCS] NORM $
03m0001                               	: 2006  ;PC OV TRAPS HERE
03m0001                               	;;;     DEST[CLR-DEV-FROM-INTR] JUMP[SOVRS] NORM $
03m0001 02006 640141614571000010000000	        D[CONST 1] DEST[DEV-ADR] JUMP[SOVRS] NORM $
03m0001                               	                ;Start setting up to read AR enabling
03m0001                               	: 2007 ;BOTH ECC AND OV (AT THE SAME TIME) TRAPS HERE
03m0001 02007 640142400571000440000000	        DEST[CLR-DEV-FROM-INTR] JUMP[SECCS] NORM $
03m0001                               	: 2010 ;NORMAL INDIRECT TRAPS HERE
03m0001 02010 640706000550400440010000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
03m0001 02011 540530404571000441602374	        D[MEM] DEST[IR-23 MA AR] DISP[2374] SPEC[PC+1-IF] CYLEN[DISP] $
03m0001                               	                ;WHEN EXTEND HAPPENS, DISP[2176]? NO-- HOW WOULD WE SEE
03m0001                               	                ;EXTENDED AREA OF IX REG?
03m0001                               	                ;Changed from 2174 to 2374 to allow stop switch to stop
03m0001                               	                ;indirection loops.  TVR-Mar80
03m0001                               	: 2012  ;NORMAL INDEXING TRAPS HERE
03m0001 02012 540530234420400221602024	        ALU[IX+D] D[IR] MASK[18.] DEST[AR IR-ADR MA] DISP[2024] SPEC[PC+1-IF]
03m0001                               	 CYLEN[DISP]$
03m0001                               	                ;WHEN EXTEND HAPPENS, DISP[2026]
03m0001                               	: 2014  ;EXTENDED INDIRECT TRAPS HERE
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

03m0001                               	; SOMETHING MAKES THIS DIFFERENT FROM 2010 -- MAYBE LOADING H.O. MA??
03m0001 02014 000140000571000440002014	 JUMP[.] $      ;FOR NOW ;;;ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
03m0001                               	
03m0001 02015 540530404571000441602176	        D[MEM] DEST[IR-23 MA AR] DISP[2176] SPEC[PC+1-IF] CYLEN[DISP] $
03m0001                               	: 2016  ;EXTENDED INDEXING TRAPS HERE
03m0001 02016 000140000571000440002016	 JUMP[.] $      ;FOR NOW ;;;D[AR] ROT[6] MASK[4] DEST[AC-SEL] NORM $
03m0001 02017 540530200420000441602026	        D[AR] ALU[D+AC] ACSEL[REG] DEST[IR-ADR MA AR] SPEC[PC+1-IF] DISP[2026]
03m0001                               	 CYLEN[DISP] $
03m0001                               	  ]
03m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

04m0001                               	;UUO1 UUO2 SMAIN SMAIN1 MAIN NMAIN1 MAIN1 MAIN2 MSMAIN MSMAIN1 MUUO MUUO2 MUUO3 MUUO4
04m0001                               	 PIMUUO MUUO44 UUOPJ MUUO5X MUUO5Y UAOP AREA216 UMOVE JSYS JSYS3 ADJSP XMOVEM1 DMOVE
04m0001                               	 DMOVN KIFIX DMOVEM DMOVNM FIXR FLTR UFA DFN FSC
04m0001                               	;------------------------------------------------------------------------------
04m0001                               	;       User UUO Trap
04m0001                               	;
04m0001                               	;       Traps thru location 40 of the current space
04m0001                               	;
04m0001                               	;       Instruction is stored in 40 (with effective address computed and
04m0001                               	;               index/indirection removed)
04m0001                               	;       Instruction in location 41 is executed, in the current space.  It
04m0001                               	;               customarily either jumps, saving the PC and flags, or halts.
04m0001                               	;------------------------------------------------------------------------------
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ];User UUOs 010:017
04m0001 02020 640060014571000400000000	UUO1:   D[CONST 40] DEST[MA] PUSHJ[UUOPJ] NORM  $
04m0001                               	                ;Setup MA for trap area and make mask for removing index/indir.
04m0001 02021 640704234635000440000000	UUO2:   D[IR] ALU[D&Q] DEST[MEMSTO] NORM $
04m0001                               	                ;Store instruction which caused trap.
04m0001 02022 640704620531000440170000	        D[PC] ALU[D-1] DEST[PC] MAPF[MASTO] CYLEN[MEMSTO] $
04m0001                               	                ;Ordinary page fault if not writable.  (*** Is PC correct???)
04m0001                               	                ;Backup the PC to point at the offensive instruction
04m0001 02023 640160014571000410000000	        D[CONST 41] DEST[MA] JUMP[NMAIN1] NORM $
04m0001                               	                ;Execute contents of (same space) location 41, usually a JSR or
04m0001                               	                ;a HALT instruction
04m0001                               	
04m0001                               	: 2024
04m0001 02024 640170005570400440640000	SMAIN: ACSEL[MA] D[MEM] DEST[AC AR MA] SPEC[MA_PC] JUMP[NMAIN1] CYLEN[MEMSTO] MAPF[STO] $
04m0001                               	
04m0001 02025 640170004571000440640000	SMAIN1: D[MEM] SPEC[MA_PC] DEST[AR MA] JUMP[NMAIN1] CYLEN[MEMSTO] MAPF[STO] $
04m0001                               	
04m0001 02026 640362400571000440600000	MAIN:   SPEC[MA_PC] DEST[MA CLR-DEV-FROM-INTR] NORM JPOP[MAIN1] $
04m0001                               	           ;START THE INSTR. FETCH (AND POP THE STACK A LITTLE...)
04m0001                               	           ;Also, clear forcing of interrupt device code, if still present
04m0001                               	
04m0001                               	NMAIN1:
04m0001                               	MAIN1:  ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] 
04m0001 02027 640346000550400440010000	         JPOP[MAIN2] CYLEN[FIXM] $ ; I.E. FIXM ### AND FLUSH STACK ####
04m0001                               	
04m0001 02030 540530604571000441602374	MAIN2:  D[MEM] DEST[IR-ALL MA AR] SPEC[PC+1-IF&] DISP[2374] CYLEN[DISP] $
04m0001                               	
04m0001                               	        .PAIR   . \ 2 + .
04m0001                               	];: 2032 ; .PAIR
04m0001 02032 640140005570400440172026	MSMAIN: ACSEL[MA] D[MEM] DEST[AC] JUMP[MAIN] CYLEN[MEMSTO] MAPF[MASTO] $
04m0001 02033 640140000571000440172026	MSMAIN1:        MAPF[MASTO] JUMP[MAIN] CYLEN[MEMSTO] $
04m0001                               	
04m0001       2034	AREA202 = .     ;(Not a lot left)
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ]      User UUOs 020-027
04m0001 02040 640140014571000400002020	        UUOLOC $
04m0001       2041	AREA204 = .
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ]      User UUOs 030-037
04m0001 02060 640140014571000400002020	UUOGO:  UUOLOC $
04m0001                               	
04m0001       2061	AREA206 = .
04m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

04m0001                               	;$*$*$*$ This should go somewhere else!!!
04m0001                               	  .OPCODE[LIST 
04m0001                               	 LIST            ] ;Set loc. to 2 before MUUO (opcode 37 doesn't come here).
04m0001                               	               ;We come here (from 2000) on opcodes 0-7.
04m0001 02076 510140034571022110000000	UUO0-7: D[IR] ROT[9.] MASK[9.] COND[OBUS=0] JUMP[MUUO] C550 $;J IF 0 UUO
04m0001 02077 640140014571000400002020	        UUOLOC $
04m0001                               	
04m0001                               	        .OPCODE[LIST 
04m0001                               	 LIST            ]      Monitor UUOs 040-047 (CALL,INIT,CALLI)
04m0001                               	MUUO:   MUUO1
04m0001 02100 640150020171000440000000	D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
04m0002                               	];The following need not be contiguous with MUUO, it is merely here for clarity.
04m0002                               	;It may be moved to another area if necessary.  TVR-Apr80
04m0002                               	
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;       Monitor UUO Trap
04m0002                               	;
04m0002                               	;       Traps thru location 40 of the current space, typically to handle user 
04m0002                               	;               request to the Monitor
04m0002                               	;
04m0002                               	;       Instruction is stored in 40 (with effective address computed and
04m0002                               	;               index/indirection removed)
04m0002                               	;       Instruction in Monitor 41 is executed, in the Monitor space.  It
04m0002                               	;               should save PC and flags, and handle the user's request.
04m0002                               	;------------------------------------------------------------------------------
04m0002 02101 640705410635076430000000	MUUO2:  D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $
04m0002                               	                ;Clear USER
04m0002 02102 640060014571000400000000	        D[CONST 40] DEST[MA] PUSHJ[UUOPJ] NORM $
04m0002                               	                ;Setup MA for trap area and make mask for removing index/indir.
04m0002                               	;       \ /
04m0002                               	;Common code for instruction traps
04m0002 02103 640704234635000440000000	MUUO3:  D[IR] ALU[D&Q] DEST[MEMSTO] NORM $
04m0002                               	                ;Store instruction which caused trap.
04m0002 02104 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] CYLEN[MEMSTO] $
04m0002                               	                ;Now, get dispatch instruction
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;***  CAUTION:  If write fails, micro-machine hangs at 6100.  This should be
04m0002                               	;***            fixed when a more general page-fault mechanism is added.  The
04m0002                               	;***            best thing would be to just halt the macro machine.
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	MUUO4:
04m0002 02105 640706014171004550000000	PIMUUO: D[CONST 55] ROT[2] DEST[Q FIXMAC-MAPF-RD] CYLEN[FIXM] $; JSR OPCODE
04m0002                               	                ;TVR-Apr80:  I don't have the foggiest notion what that FIXMAC
04m0002                               	                ;is supposed to do here.  The FIXM is needed for memory timing,
04m0002                               	                ;but aren't we guaranteed not to be fetching from ACs here????
04m0002 02106 410140004735022110000000	MUUO44: D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSR] CYLEN[C650] $
04m0002                               	                ;Jump if trap instruction is a JSR (opcode 264 = 55*4)
04m0002 02107 640700000017000440000000	        ALU[Q+1] DEST[Q] SHORT $
04m0002 02110 510140004735022110000000	        D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSP] C550 $
04m0002                               	                ;Jump if trap instruction is a JSP (opcode 265)
04m0002 02111 640700000017000440000000	        ALU[Q+1] DEST[Q] SHORT $
04m0002 02112 510140004735022110000000	        D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSA] C550 $
04m0002                               	                ;Jump if trap instruction is a JSA (opcode 266)
04m0002 02113 640700014171002420000000	        D[CONST 42] ROT[1] DEST[Q] SHORT $; JSYS OP
04m0002 02114 510140004735022110000000	        D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSYS] C550 $
04m0002                               	                ;Jump if trap instruction is a JSYS (opcode 104 = 42*2)
04m0002 02115 640704620531000440000000	        D[PC] ALU[D-1] DEST[PC] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

04m0002                               	                ;Any other opcode will be XCTed and the regular code will
04m0002                               	                ;resume.
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;***  CAUTION:  No special dispensation has been made for BLKI/BLKO.  They
04m0002                               	;***            MUST be handled specially, as if they DON'T skip, the
04m0002                               	;***            second trap location should be executed and should be a JSR
04m0002                               	;***            or some other instruction which saves flags.    TVR-Apr80
04m0002                               	;------------------------------------------------------------------------------
04m0002 02116 000145400571000440002030	        D[AR] DEST[CRYOV] JUMP[MAIN2] $
04m0002                               	                ;Else restore flags and dispatch
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;***  CAUTION:  This probably will not work proper if reference is being made
04m0002                               	;***            to EXEC memory and trap was from USER.  What really needs to
04m0002                               	;***            happen here is that the instruction should be XCTRed instead,
04m0002                               	;***            It may be sufficient to SET-TEMP-EXEC.  I haven't looked at
04m0002                               	;***            the problem seriously.                          TVR-Apr80
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	
04m0002                               	;Construct a mask which excludes indexing and indirection.  Used by UUO trap
04m0002                               	;routines (and currently no where else)
04m0002 02117 640300010171056370000000	UUOPJ:  D[MASK 37] ROT[27] DEST[Q] POPJ NORM $
04m0002                               	
04m0002                               	;(NO SPACE IS LEFT.  You will have plant jumps to another area to expand the
04m0002                               	; above code!)
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      Monitor UUOs 050-057 (OPEN,INIT,RENAME,IN,OUT)
04m0002                               	
04m0002 02120 640700034171016010000000	MUUO5X: D[IR] ROT[7] MASK[1] DEST[Q] NORM $
04m0002                               	                ;Special check for UUOs actually used by monitors we care about
04m0002 02121 510140034735020010002100	        D[IR] ROT[10] MASK[1] ALU[D#Q] COND[OBUS=0] JUMP[MUUO] C550 $
04m0002                               	                ;Jump if UUO 50,51,56, OR 57
04m0002 02122 610140000555000440000000	        ALU[Q] COND[OBUS=0] JUMP[MUUO5Y] CYLEN[C450] $
04m0002                               	                ;Jump if 52 OR 53 ("Reserved for DEC")
04m0002 02123 530140034571022010002100	        D[IR] ROT[11] MASK[1] COND[-OBUS=0] JUMP[MUUO] C550 $
04m0002                               	                ;Jump if 55
04m0002 02124 640710020171000440000000	MUUO5Y: D[PC] DEST[Q AR] SHORT $
04m0002                               	;       \ /
04m0002                               	;------------------------------------------------------------------------------
04m0002                               	;       Illegal Instruction Trap
04m0002                               	;
04m0002                               	;       Traps thru Monitor 60
04m0002                               	;
04m0002                               	;       Instruction is stored in 60 (with effective address computed and
04m0002                               	;               index/indirection removed)
04m0002                               	;       Instruction in Monitor 61 is executed, in the Monitor space.  It
04m0002                               	;               should save PC and flags, and stop the offensive process.
04m0002                               	;------------------------------------------------------------------------------
04m0002 02125 640705410635076430000000	UAOP:   D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $; CLR USER
04m0002 02126 640700010171056370000000	        D[MASK 37] ROT[27] DEST[Q] NORM $
04m0002 02127 640160014571000600002103	        D[CONST 60] DEST[MA] JUMP[MUUO3] NORM $
04m0002                               	
04m0002       2130	AREA212 = .     ;$*$** Stupid interrupt code makes this unusable!
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      Monitor UUOs 060-067
04m0002                               	                        ;(SETSTS,STATO,GETSTS,STATZ,INBUF,OUTBUF,INPUT,OUTPUT)
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

04m0002 02140 640150020171000440002101	        MUUO1 D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
04m0002                               	]$
04m0002                               	;;;AREA214 = .
04m0002       2142	area214 = 2142          ;Sigh... Another fixed location
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      Monitor UUOs 070-077
04m0002                               	                        ;(CLOSE,RELEAS,MTAPE,UGETF,USETI,USETO,LOOKUP,ENTER)
04m0002 02160 640150020171000440002101	        MUUO1 D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
04m0002                               	]$
04m0002                               	AREA216:
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      UMOVE
04m0002 02200 640724620531000440000000	UMOVE:  D[PC] ALU[D-1] DEST[MA PC] NORM $ ;RE-FETCH INSTR.
04m0002 02201 640146000550400440020000	        FIXM1 JUMP[UMOVX] $     ;WAIT FOR FETCH.
04m0002                               	
04m0002                               	; UMOVEI, UMOVEM, UMOVES
04m0002                               	        .REPEAT 3 [ 04m0002 02202 640140000571000440002200	JUMP[UMOVE] NORM $
04m0002 02203 000700000571000440000000	                        NOP $ 
04m0002 02204 640140000571000440002200	                ]JUMP[UMOVE] NORM $
04m0002 02205 000700000571000440000000	                        NOP $ 
04m0002 02206 640140000571000440002200	                ]JUMP[UMOVE] NORM $
04m0002 02207 000700000571000440000000	                        NOP $ 
04m0002                               	                ]
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      JSYS
04m0002                               	JSYS:
04m0002                               	.REPEAT 1 - WAITS [
04m0002 02210 530140034571066110000000	        D[IR] ROT[33] MASK[11] COND[-OBUS=0] JUMP[JSYS1] C550 $; J IF NOT EX JSYS
04m0002                               	].REPEAT 1 - WAITS
04m0002                               	.REPEAT WAITS [
04m0002                               	.REPEAT WAITS
04m0002 02211 000150020171000440000000	JSYS3:  D[PC] DEST[Q AR] JUMP[JSYS2] $; GET PC & FLAGS
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ]      ADJSP
04m0002                               	ADJSP:  D[IR] ROT[22] MASK[0] ALU[D+AC] SPEC[LEFT] DEST[Q]
04m0002 02212 511140034021044000200000	                        COND[OBUS<0] JUMP[ADJSP1] C550$
04m0002                               	                ;Jump if left result is negative
04m0002 02213 640150034421000220000000	        D[IR] MASK[22] ALU[D+AC] DEST[AR] JUMP[ADJSP2] NORM $   ;Add right half
04m0002                               	        ;(Continued just before TYMNET code)
04m0002                               	
04m0002                               	        .OPCODE[LIST 
04m0002                               	 LIST            ];XMOVEM
04m0002 02214 640722600551400440000000	        ALU[AC] ACSEL[AC+1] DEST[HI-ABS-MA MA] NORM $
04m0002 02215 640144200551000440000000	        ALU[AC] DEST[MEMSTO] NORM JUMP[XMOVEM1] $
04m0002                               	        .USE[04m0002                               	XLIST
04m0003 02041 640142600615000440002026	 LIST ]XMOVEM1: ALU[0] DEST[HI-ABS-MA] NORM JUMP[MAIN] $
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];XMOVE
04m0003 02216 640722600551400440000000	        ALU[AC] ACSEL[AC+1] DEST[HI-ABS-MA MA] NORM $
04m0003 02217 640142600615000440002401	        ALU[0] DEST[HI-ABS-MA] JUMP[2401] NORM $
04m0003                               	
04m0003                               	;Illegal instructions (?)
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

04m0003                               	        .REPEAT 117 - 110 + 1
04m0003 02220 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02221 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02222 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02223 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02224 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02225 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02226 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02227 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02230 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02231 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02232 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02233 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02234 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02235 000700000571000440000000	        NOP $
04m0003                               	        ]04m0003 02236 640150020171000440002125	UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02237 000700000571000440000000	        NOP $
04m0003                               	        ]
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DMOVE
04m0003 02240 640706000550400440020000	DMOVE:  FIXM1 $                 ; Fetch first word
04m0003 02241 640140005571000440000000	        ACSEL[AC] D[MEM] DEST[AC] JUMP[DMOVE2] CYLEN[FIXM+1] $
04m0003                               	                ;Put it in an AC [*** Is CYLEN right? ***]
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DMOVN
04m0003 02242 640706000550400440020000	DMOVN:  FIXM1 $ ;Fetch first word
04m0003                               	        ACSEL[AC] D[MEM] ALU[NOTD] DEST[AC] SPEC[CRYOV]
04m0003 02243 640140005771000441200000	                        JUMP[DMOVN2] CYLEN[FIXM+1] $
04m0003                               	                ;Ones complement high order word.  Set result flags
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];KIFIX
04m0003 02244 640706000550400440020000	KIFIX:  FIXM1 $ ;Fetch first word
04m0003 02245 640140014171000330000000	        D[CONST 33] DEST[Q] JUMP[KIFIX1] NORM $
04m0003                               	                ;Start making magic constant
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	;123
04m0003 02246 640150020171000440002125	        UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$
04m0003 02247 000700000571000440000000	        NOP $
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DMOVEM
04m0003                               	;*** Note: Like on the KI10, DMOVEM AC,AC+1 will lose.
04m0003 02250 640706200550400440030000	DMOVEM: FIXM2 $                 ; Make sure first word is in core
04m0003 02251 662104200551000440000000	        ACSEL[AC] ALU[AC] DEST[MEMSTO] COND[-MA-AC] LBJUMP[DMOVM2] NORM $
04m0003                               	                ;Store first word.  Decide where it really goes.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DMOVNM
04m0003                               	;*** Note: Like on the KI10, DMOVNM AC,AC+1 will lose.
04m0003 02252 640706200550400440030000	DMOVNM: FIXM2 $                 ; Make sure first word is in core
04m0003 02253 640150000751000441200000	        ACSEL[AC] ALU[NOTAC] DEST[AR] SPEC[CRYOV] JUMP[DMVNM2] NORM $
04m0003                               	                ;Ones complement high order word, leave result in IR
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];FIXR
04m0003 02254 640706000550400440020000	FIXR:   FIXM1 $ ;Fetch first word
04m0003 02255 640140014171060040000000	        D[CONST 04] ROT[24.] DEST[Q] JUMP[FIXR1] NORM $
04m0003                               	                ;Start making constant 0.5
04m0003                               	        ;(Continued just before TYMNET code)
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];FLTR
04m0003 02256 640706000550400440020000	FLTR:   FIXM1 $ ;Fetch first word
04m0003 02257 000150004571000440000000	        D[MEM] DEST[AR] JUMP[FLTR1] $
04m0003                               	                ;Setup for normalize
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];UFA
04m0003 02260 640706000550400440020000	UFA:    FIXM1 $
04m0003 02261 000141614571000110000000	        D[CONST 11] DEST[DEV-ADR] JUMP[UFA1] $
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];DFN
04m0003 02262 640706200550400440030000	DFN:    FIXM2 $
04m0003 02263 450110004473000330000000	        D[MEM] MASK[27.] ALU[0-D] DEST[AR] COND[OBUS=0] LBJUMP[DFN1] C600 $
04m0003                               	
04m0003                               	        .OPCODE[LIST 
04m0003                               	 LIST            ];FSC
04m0003 02264 510140010621000330000000	FSC:    D[MASK 27.] ALU[D&AC] ACSEL[AC] COND[OBUS=0] JUMP[FSCZAP] C550 $
04m0003 02265 640150000551000440000000	        ACSEL[AC] ALU[AC] DEST[AR] JUMP[FSC1] NORM $
04m0003                               	
04m0003                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

05m0003                               	;IBP ILDB LDB IDPB DPB FAD FSB FMP FDV
05m0003                               	;------------------------------------------------------------------------------
05m0003                               	;
05m0003                               	;       Byte Manipulation Instructions
05m0003                               	;
05m0003                               	;------------------------------------------------------------------------------
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ];IBP (and ADJBP)
05m0003 02266 656146200550400440032026	IBP:    FIXM2 COND[HALF] JUMP[MAIN] $
05m0003                               	                ;A no-op if we're already incremented.
05m0003 02267 643110004171000440000000	        D[MEM] DEST[Q AR] COND[AC=0] LBJUMP[IBP1] NORM $
05m0003                               	                ;Get byte pointer and decide if it's an ADJBP or a IBP
05m0003                               	
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ];ILDB
05m0003 02270 640706200550400440030000	ILDB:   FIXM2 $
05m0003 02271 676110004171000440000000	        D[MEM] DEST[Q AR] COND[-HALF] LBJUMP[ILDB1] NORM $
05m0003                               	
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ];LDB
05m0003 02272 640706000550400440020000	LDB:    FIXM1 $
05m0003 02273 564130004171000440000000	        D[MEM] DEST[Q AR MA] COND[-MEM-IDX-IND] LBJUMP[LDB1] CYLEN[C500] $
05m0003                               	
05m0003                               	IDPB:   .OPCODE[LIST 
05m0003                               	 LIST            ];IDPB
05m0003 02274 640706200550400440030000	        FIXM2 $
05m0003 02275 676110004171000440000000	        D[MEM] DEST[Q AR] COND[-HALF] LBJUMP[IDPB1] NORM $
05m0003                               	
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ];DPB
05m0003 02276 640706000550400440020000	DPB:    FIXM1 $
05m0003 02277 564130004171000440000000	        D[MEM] DEST[Q AR MA] LBJUMP[DPB1] COND[-MEM-IDX-IND] CYLEN[C500]  $
05m0003                               	
05m0003                               	;------------------------------------------------------------------------------
05m0003                               	;
05m0003                               	;       Single Procession Floating Point
05m0003                               	;
05m0003                               	;------------------------------------------------------------------------------
05m0003                               	
05m0003                               	;
05m0003                               	;FAD FADL FADM FADB FADR FADRI FADRM FADRB
05m0003                               	;
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ]      ;Opcodes 140-147
05m0003 02300 640146000550400440020000	FAD:    FIXM1 JUMP[FAOS1] $ NOP $
05m0003 02301 000700000571000440000000	
05m0003 02302 640146000550400440020000	        FIXM1 JUMP[FAOS2] $ NOP $
05m0003 02303 000700000571000440000000	
05m0003 02304 640146200550400440030000	        FIXM2 JUMP[FAOS3] $ NOP $
05m0003 02305 000700000571000440000000	
05m0003 02306 640146200550400440030000	        FIXM2 JUMP[FAOS4] $ NOP $
05m0003 02307 000700000571000440000000	
05m0003 02310 640146000550400440020000	        FIXM1 JUMP[FAOS1] $ NOP $
05m0003 02311 000700000571000440000000	
05m0003 02312 640144424571044000200000	        D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] JUMP[FAOS5] NORM $ NOP $
05m0003 02313 000700000571000440000000	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

05m0003 02314 640146200550400440030000	        FIXM2 JUMP[FAOS3] $ NOP $
05m0003 02315 000700000571000440000000	
05m0003 02316 640146200550400440030000	        FIXM2 JUMP[FAOS4] $ NOP $
05m0003 02317 000700000571000440000000	
05m0003                               	
05m0003                               	;
05m0003                               	;FSB FSBL FSBM FSBB FSBR FSBRI FSBRM FSBRB
05m0003                               	;
05m0003                               	.DEFINE FSBMAC[05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ]      ;Opcodes 150-157
05m0003 02320 640706000550400440020000	FSB:    FIXM1 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS1] NORM 
05m0003 02321 640144404473000440000000	]$
05m0003 02322 640706000550400440020000	        FIXM1 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS2] NORM 
05m0003 02323 640144404473000440000000	]$
05m0003 02324 640706200550400440030000	        FIXM2 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS3] NORM 
05m0003 02325 640144404473000440000000	]$
05m0003 02326 640706200550400440030000	        FIXM2 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS4] NORM 
05m0003 02327 640144404473000440000000	]$
05m0003 02330 640706000550400440020000	        FIXM1 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS1] NORM 
05m0003 02331 640144404473000440000000	]$
05m0003 02332 640144424473044000200000	        D[MA] ROT[18.] DEST[HOLD] ALU[0-D] SPEC[LEFT] JUMP[FAOS5] NORM $ NOP $
05m0003 02333 000700000571000440000000	
05m0003 02334 640706200550400440030000	        FIXM2 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS3] NORM 
05m0003 02335 640144404473000440000000	]$
05m0003 02336 640706200550400440030000	        FIXM2 $ FSBMAC[05m0003                               	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[FAOS4] NORM 
05m0003 02337 640144404473000440000000	]$
05m0003                               	
05m0003                               	;
05m0003                               	;FMP FMPL FMPM FMPB FMPR FMPRI FMPRM FMPRB
05m0003                               	;
05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ]      ;Opcodes 160-167
05m0003 02340 640146000550400440020000	FMP:    FIXM1 JUMP[FMP1] $ NOP $
05m0003 02341 000700000571000440000000	
05m0003 02342 640146000550400440020000	        FIXM1 JUMP[FMP2] $ NOP $
05m0003 02343 000700000571000440000000	
05m0003 02344 640146200550400440030000	        FIXM2 JUMP[FMP3] $ NOP $
05m0003 02345 000700000571000440000000	
05m0003 02346 640146200550400440030000	        FIXM2 JUMP[FMP4] $ NOP $
05m0003 02347 000700000571000440000000	
05m0003 02350 640146000550400440020000	        FIXM1 JUMP[FMP1] $ NOP $
05m0003 02351 000700000571000440000000	
05m0003 02352 640144424571044000200000	        D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] JUMP[FMP5] NORM $ NOP $
05m0003 02353 000700000571000440000000	
05m0003 02354 640146200550400440030000	        FIXM2 JUMP[FMP3] $ NOP $
05m0003 02355 000700000571000440000000	
05m0003 02356 640146200550400440030000	        FIXM2 JUMP[FMP4] $ NOP $
05m0003 02357 000700000571000440000000	
05m0003                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

05m0003                               	;FDV FDVL FDVM FDVB FDVR FDVRI FDVRM FDVRB
05m0003                               	.DEFINE DIVMAC[05m0003                               	        .OPCODE[LIST 
05m0003                               	 LIST            ]      ;Opcodes 170-177
05m0003 02360 640706000550400440020000	FDV:    FIXM1 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD1] NORM
05m0003 02361 640141614571000110000000	]$
05m0003 02362 640706000550400440020000	        FIXM1 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD2] NORM
05m0003 02363 640141614571000110000000	]$
05m0003 02364 640706200550400440030000	        FIXM2 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD3] NORM
05m0003 02365 640141614571000110000000	]$
05m0003 02366 640706200550400440030000	        FIXM2 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD4] NORM
05m0003 02367 640141614571000110000000	]$
05m0003 02370 640706000550400440020000	        FIXM1 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD1] NORM
05m0003 02371 640141614571000110000000	]$
05m0003 02372 640704424571044000200000	        D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] NORM $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD1] NORM
05m0003 02373 640141614571000110000000	]$
05m0003 02374 640706200550400440030000	        FIXM2 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD3] NORM
05m0003 02375 640141614571000110000000	]$
05m0003 02376 640706200550400440030000	        FIXM2 $ DIVMAC[05m0003                               	        D[CONST 11] DEST[DEV-ADR] JUMP[FD4] NORM
05m0003 02377 640141614571000110000000	]$
05m0003                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

06m0003                               	;MOVE MOVE1 MOVEI MOVEM MOVES MOVS MOVSI MOVSM MOVSS MOVN MOVNI MOVNM MOVNS MOVM MOVM1
06m0003                               	 MOVMI MOVMM MOVMS MOVMS1 MOVMS3 MOVMS4 MOVMS5 MOVMS6 MOVMS2
06m0003                               	;------------------------------------------------------------------------------
06m0003                               	;
06m0003                               	;       MOVE Group
06m0003                               	;
06m0003                               	;------------------------------------------------------------------------------
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVE
06m0003 02400 640706000550400440020000	MOVE:   FIXM1 $
06m0003                               	                ;Wait for memory, handle page faults, and fixup AC references
06m0003 02401 640160005571000440602027	MOVE1:  ACSEL[AC] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
06m0003                               	                ;Store result of read in AC
06m0003                               	                ;Start next instruction fetch (DEST[MA] refers to SPEC[MA_PC])
06m0003                               	                ;We are referring to the AC specified by the AC field in the IR
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVEI
06m0003 02402 640160035571000220602027	MOVEI:  ACSEL[AC] D[IR] MASK[18.] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
06m0003                               	                ;Store effective address into AC
06m0003                               	                ;Ignore any page faults or other memory related problems.  Read
06m0003                               	                ;will be ignored (except for ECC checking)
06m0003                               	                ;Start next instruction fetch (DEST[MA] refers to SPEC[MA_PC])
06m0003                               	                ;We are referring to the AC specified by the AC field in the IR
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVEM
06m0003 02404 662104200551000440002032	MOVEM:  ACSEL[AC] ALU[AC] DEST[MEMSTO]  MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	                ;Start writing AC (selected by AC field in IR) into memory.
06m0003                               	                ;MEMST macro will send us to MSMAIN (if we're writing to
06m0003                               	                ;another AC) or MSMAIN1 (if it's a real memory reference)
06m0003                               	                ;to complete to store.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVES
06m0003 02406 663146000550400440022401	MOVES:  FIXM1 COND[-AC=0] JUMP[MOVE1]  $
06m0003                               	                ;If AC field (in IR) is non-zero, we treat this as if it
06m0003                               	                ;were a MOVE instruction (a slight fudge).
06m0003                               	                ;*** Shouldn't this be a FIXM2?  Then it would do the right
06m0003                               	                ;*** thing for the clever person trying to fetch and dirty
06m0003                               	                ;*** a page.   TVR-Apr80
06m0003 02407 662104204571000440002032	        D[MEM] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	                ;If AC field is zero, this is a no-op which writes memory.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVS
06m0003 02410 640706000550400440020000	MOVS:   FIXM1 $
06m0003                               	        ACSEL[AC] D[MEM] ROT[18.] DEST[AC MA] SPEC[MA_PC]
06m0003 02411 640160005571044440602027	                        JUMP[MAIN1] CYLEN[FIXM+1] $
06m0003                               	                ;Rotating by 18 swaps halves.  Otherwise, it's just like a MOVE
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVSI
06m0003 02412 640160035571044000402027	MOVSI:  ACSEL[AC] D[IR] ROT[18.] DEST[AC MA] SPEC[LEFT&MA_PC] JUMP[MAIN1] NORM$
06m0003                               	                ;Just like a MOVEI except it puts the result in the left half
06m0003                               	                ;of the AC.  (SPEC[LEFT] makes a mask of -1,,0)
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVSM
06m0003 02414 640710000551000440000000	MOVSM:  ALU[AC] ACSEL[AC] DEST[AR] NORM $
06m0003 02415 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	                ;Swap halves and write it into memory like a MOVEM
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVSS
06m0003                               	MOVSS:  SLFFXM[06m0003 02416 663146200550400440030000	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM] COND[-AC=0] JUMP[
06m0003                               	 MOVSS1 ] $
06m0003                               	]$
06m0003                               	                ;Finish read fetch of read-modify-write type cycle.
06m0003                               	                ;Check to make sure effective address is writable.
06m0003                               	                ;Jump if AC field in IR is non-zero
06m0003 02417 662104204571044440002032	        D[MEM] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	                ;Swap halves and write backing into same place in memory.
06m0003                               	
06m0003                               	;*$*$*$ Move MOVSS1 here, a single instruction
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVN
06m0003 02420 640706000550400440020000	MOVN:   FIXM1 $
06m0003                               	        ACSEL[AC] D[MEM] ALU[0-D] DEST[AC MA] SPEC[CRYOV&MA_PC]
06m0003 02421 640160005473000441002027	                        JUMP[MAIN1] CYLEN[FIXM+1] $
06m0003                               	                ;Like MOVE except it negates the number it loads.
06m0003                               	                ;Set flags.  400000,,0 will overflow.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVNI
06m0003                               	MOVNI:  ACSEL[AC] D[IR] ALU[0-D] MASK[18.] DEST[AC MA] SPEC[CRYOV&MA_PC]
06m0003 02422 640160035473000221002027	                        JUMP[MAIN1] NORM $
06m0003                               	                ;Like MOVEI except that it load a negative number
06m0003                               	                ;Set flags.  Cannot overflow.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVNM
06m0003 02424 662104200513000441202032	MOVNM:  ACSEL[AC] ALU[0-AC] DEST[MEMSTO] SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN]
06m0003                               	 NORM ]$
06m0003                               	                ;Write negative of AC into memory.
06m0003                               	                ;Set flags.  400000,,0 will overflow.
06m0003                               	
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVNS
06m0003                               	MOVNS:  SLFFXM[06m0003 02426 663146200550400440030000	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM] COND[-AC=0] JUMP[
06m0003                               	 MOVNS1 ] $
06m0003                               	]$
06m0003                               	                ;Complete fetch of read-modify-write
06m0003                               	                ;Jump if AC field (of IR) is non-zero, i.e. it loads an AC
06m0003 02427 662104204473000441202032	        D[MEM] ALU[0-D] DEST[MEMSTO] SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0003                               	
06m0003                               	                ;Write negative of number read back into memory.
06m0003                               	
06m0003                               	;
06m0003                               	; MOVM - Move Magnitude (Absolute value)
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

06m0003                               	;
06m0003                               	        .OPCODE[LIST 
06m0003                               	 LIST            ];MOVM
06m0003 02430 640706000550400440020000	MOVM:   FIXM1 $ ;Complete data fetch
06m0003 02431 451100005571000440000000	        ACSEL[AC] D[MEM] DEST[AC] COND[OBUS<0] LBJUMP[MOVM1] C600 $
06m0003                               	                ;Load number.
06m0003                               	                ;If negative, negate it to make it positive.
06m0003                               	                ;In either case, start fetch of next instruction
06m0003                               	        .USE[XLIST
06m0003                               	 LIST ];$*$*$ Random hole
06m0003                               	        .PAIR
06m0003                               	. \ 2 + .
06m0004 02142 640160000571000440602027	]MOVM1: SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
06m0004                               	                ;Number is positive, leave it alone
06m0004                               	                ;Start next instruction fetch
06m0004 02143 640160001513000441002027	        ACSEL[AC] ALU[0-AC] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1] NORM$
06m0004                               	                ;Number is negative, make it positive.
06m0004                               	                ;Start next instruction fetch
06m0004                               	
06m0004                               	        .OPCODE[LIST 
06m0004                               	 LIST            ];MOVMI
06m0004 02432 640160035571000220602027	MOVMI:  ACSEL[AC] D[IR] MASK[18.] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
06m0004                               	                ;Immediate implies it's positive.  Equivalent to MOVEI
06m0004                               	
06m0004                               	        .OPCODE[LIST 
06m0004                               	 LIST            ];MOVMM
06m0004 02434 611140000551000440002424	MOVMM:  ACSEL[AC] ALU[AC] COND[OBUS<0] JUMP[MOVNM] CYLEN[C450] $
06m0004                               	                ;If AC is negative, store its negation and set flags
06m0004                               	                ;Note:  It will set overflow if AC contains 400000,,0
06m0004 02435 662104200551000441202032	        ACSEL[AC] ALU[AC] DEST[MEMSTO] SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM
06m0004                               	 ]$
06m0004                               	                ;Otherwise, store positive form.  (Both paths take same amount
06m0004                               	                ;of time.)
06m0004                               	                ;Also, set flags.
06m0004                               	
06m0004                               	        .OPCODE[LIST 
06m0004                               	 LIST            ];MOVMS
06m0004                               	MOVMS:  COND[MA-AC] JUMP[MOVMS2]
06m0004 02436 642146200571000440030000	                        DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM]$
06m0004                               	                ;Finish fetch of read-modify-write
06m0004                               	                ;Jump if we have to deal with two ACs
06m0004 02437 643100000571000440000000	        COND[AC=0] LBJUMP[MOVMS1] NORM $
06m0004                               	                ;Split off case where we load AC as side effect
06m0004                               	        .USE[06m0004                               	XLIST
06m0005                               	 LIST ] .PAIR
06m0005                               	. \ 2 + .
06m0006 02042 511100004571000440000000	]MOVMS1:        D[MEM] COND[OBUS<0] LBJUMP[MOVMS3] C550 $
06m0006                               	                ;AC field of IR is non-zero, AC is loaded as side effect
06m0006 02043 511100004571000440000000	        D[MEM] COND[OBUS<0] LBJUMP[MOVMS4] C550 $
06m0006                               	                ;Reference is only to memory
06m0006                               	        .PAIR
06m0006                               	. \ 2 + .
06m0007 02044 640160005571000440602027	]MOVMS3:        D[MEM] ACSEL[AC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $
06m0007                               	                ;Memory location is positive, just load AC
06m0007 02045 662104205473000441202032	        D[MEM] ALU[0-D] ACSEL[AC] DEST[MEMSTO AC] SPEC[CRYOV] MEMST OND[-MA-AC]
06m0007                               	 LBJUMP[MSMAIN] NORM ]$
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

06m0007                               	                ;Load AC with negative of memory and write negative back
06m0007                               	                ;into memory.
06m0007                               	                ;Set flags.  Will overflow if memory contains 400000,,0
06m0007                               	        .PAIR
06m0007                               	. \ 2 + .
06m0008 02046 640160000571000440602027	]MOVMS4:        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
06m0008                               	                ;Memory is positive.  Don't have to do anything here.
06m0008 02047 640144204473000441202033	        D[MEM] ALU[0-D] DEST[MEMSTO] SPEC[CRYOV] JUMP[MSMAIN1] NORM $
06m0008                               	                ;Memory is negative.  Store negation.
06m0008                               	                ;Set flags.  Will overflow if memory contains 400000,,0
06m0008                               	;Special cases for references to two ACs
06m0008                               	        .PAIR
06m0008                               	. \ 2 + .
06m0009                               	]MOVMS5:        ACSEL[MA] ALU[0-AC] DEST[AC AR] SPEC[CRYOV]
06m0009 02050 643110001512400441200000	                        COND[AC=0] LBJUMP[MOVMS6] NORM $
06m0009                               	                ;'memory' AC is negative, negate it and put it somewhere
06m0009                               	                ;the other AC loaded from.
06m0009                               	                ;Then, decide whether to load it into another AC
06m0009 02051 643110000550400440000000	        ACSEL[MA] ALU[AC] DEST[AR] COND[AC=0] LBJUMP[MOVMS6] NORM $
06m0009                               	                ;'memory' AC is positive.  Put it somewhere the other AC
06m0009                               	                ;can reference.
06m0009                               	                ;Decide whether to load it into another AC
06m0009                               	        .PAIR
06m0009                               	. \ 2 + .
06m0010 02052 640160001571000440602027	]MOVMS6:        ACSEL[AC] D[AR] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
06m0010                               	                ;AC field (of IR) is non-zero, load corresponding AC from
06m0010                               	                ;saved value of 'memory' AC.
06m0010                               	                ;Start next instruction fetch
06m0010 02053 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
06m0010                               	                ;AC field (of IR) is zero, just start next instruction fetch
06m0010                               	;       ---
06m0010                               	;MA refers to an AC.  Decide which special case we're dealing with.
06m0010 02054 571100000550400440002050	MOVMS2: ACSEL[MA] ALU[AC] COND[-OBUS<0] LBJUMP[MOVMS5] CYLEN[C500] $
06m0010                               	                ;Decide sign of 'memory' AC
06m0010                               	
06m0010                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

07m0010                               	;------------------------------------------------------------------------------
07m0010                               	;
07m0010                               	;       Integer Multiply
07m0010                               	;
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IMUL
07m0010 02440 640706000550400440020000	        FIXM1 $
07m0010 02441 640140004171000440000000	        D[MEM] DEST[Q] JUMP[IMUL1] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IMULI
07m0010 02442 640140034171000220000000	        D[IR] MASK[18.] DEST[Q] JUMP[IMUL1] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IMULM
07m0010 02444 640706200550400440030000	        FIXM2 $
07m0010 02445 640140004171000440000000	        D[MEM] DEST[Q] JUMP[IMUL2] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IMULB
07m0010 02446 640706200550400440030000	        FIXM2 $
07m0010 02447 640140004171000440000000	        D[MEM] DEST[Q] JUMP[IMUL3] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];MUL
07m0010 02450 640706000550400440020000	        FIXM1 $
07m0010 02451 640140004171000440000000	        D[MEM] DEST[Q] JUMP[MUL1] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];MULI
07m0010 02452 640140034171000220000000	        D[IR] MASK[18.] DEST[Q] JUMP[MUL1] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];MULM
07m0010 02454 640706200550400440030000	        FIXM2 $
07m0010 02455 640140004171000440000000	        D[MEM] DEST[Q] JUMP[MUL2] NORM $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];MULB
07m0010 02456 640706200550400440030000	        FIXM2 $
07m0010 02457 640140004171000440000000	        D[MEM] DEST[Q] JUMP[MUL3] NORM $
07m0010                               	
07m0010                               	;*$*$* Move rest of multiply code here
07m0010                               	
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	;
07m0010                               	;       Integer Divide
07m0010                               	;
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IDIV
07m0010 02460 640706000550400440020000	        FIXM1 $
07m0010 02461 571110000151000440000000	IDIV9:  ACSEL[AC] ALU[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV1] CYLEN[C500] $
07m0010                               	                ;LO PART TO Q, CHECK SIGN
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IDIVI
07m0010 02462 640144434571000220002461	        D[IR] MASK[18.] DEST[HOLD] JUMP[IDIV9]  NORM $ ;IMMD
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IDIVM
07m0010 02464 640706200550400440030000	        FIXM2 $
07m0010 02465 571110000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV2]  CYLEN[C500] $
07m0010                               	                ;LO PART TO Q, SAVE AC, CHECK SIGN
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];IDIVB
07m0010 02466 640706200550400440030000	        FIXM2 $
07m0010 02467 571110000151000440000000	        ACSEL[AC] ALU[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV3] CYLEN[C500] $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];DIV
07m0010 02470 640706000550400440020000	        FIXM1 $
07m0010 02471 000140000151400440000000	DIV9:   ACSEL[AC+1] ALU[AC] DEST[Q] JUMP[DIV1] $ ;LO PART
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];DIVI
07m0010 02472 000144434571000220002471	        D[IR] MASK[18.] DEST[HOLD] JUMP[DIV9] $ ;IMMD
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];DIVM
07m0010 02474 640706200550400440030000	        FIXM2 $
07m0010 02475 000140000151400440000000	        ALU[AC] ACSEL[AC+1] DEST[Q] JUMP[DIV2] $
07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];DIVB
07m0010 02476 640706200550400440030000	        FIXM2 $
07m0010 02477 000140000151400440000000	        ALU[AC] ACSEL[AC+1] DEST[Q] JUMP[DIV3] $
07m0010                               	
07m0010                               	;$*$*$  Move rest of divide code here
07m0010                               	
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	;
07m0010                               	;       Shifts and Rotates
07m0010                               	;
07m0010                               	;       Two branches are taken for each shift/rotate, depending on direction.
07m0010                               	;       The macro SH1ST handles that.  The positive case gets ROTR loaded by
07m0010                               	;       that macro and other negative case will have to load it itself.
07m0010                               	;
07m0010                               	;       Note that by the time we get here, indexing and indirection have
07m0010                               	;       already been done, so the left half of the IR contains an honest
07m0010                               	;       shift count, albeit not necessarily in the range -35..35
07m0010                               	;
07m0010                               	;------------------------------------------------------------------------------
07m0010                               	   .DEFINE SH1ST 07m0010                               	
07m0010                               	        .OPCODE[LIST 
07m0010                               	 LIST            ];ASH
07m0010                               	        SH1ST 07m0010 02500 513140034171000440000000	D[IR] COND[OBUS18] DEST[Q] JUMP[ASHNEG] C550 $
07m0010 02501 640141234171000100000000	        D[IR] MASK[10] DEST[Q ROTR] JUMP[ASHPLS] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

07m0011                               	]
07m0011                               	        .OPCODE[LIST 
07m0011                               	 LIST            ];ROT
07m0011                               	        SH1ST 07m0011 02502 513140034171000440000000	D[IR] COND[OBUS18] DEST[Q] JUMP[ROTNEG] C550 $
07m0011 02503 640141234171000100000000	        D[IR] MASK[10] DEST[Q ROTR] JUMP[ROTPLS] NORM $
07m0012                               	]
07m0012                               	        .OPCODE[LIST 
07m0012                               	 LIST            ];LSH
07m0012                               	        SH1ST 07m0012 02504 513140034171000440000000	D[IR] COND[OBUS18] DEST[Q] JUMP[LSHNEG] C550 $
07m0012 02505 640141234171000100000000	        D[IR] MASK[10] DEST[Q ROTR] JUMP[LSHPLS] NORM $
07m0013                               	]
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];JFFO (a funny kind of shift instruction)
07m0013 02506 610150000551000440000000	        ACSEL[AC] ALU[AC] COND[OBUS=0] JUMP[JFFO1] DEST[AR] CYLEN[C450] $
07m0013 02507 640140001615400440000000	        ACSEL[AC+1] ALU[0] DEST[AC] JUMP[JFFO2] NORM $
07m0013                               	
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];ASHC
07m0013 02510 640710010621400430000000	        ACSEL[AC+1] D[MASK 43] ALU[D&AC]   DEST[AR] NORM $
07m0013 02511 640140000171002440000000	        D[AR] ROT[1] DEST[Q] JUMP[ASHC1] NORM $
07m0013                               	
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];ROTC
07m0013 02512 640700000151400440000000	        ACSEL[AC+1] ALU[AC] DEST[Q]   NORM $
07m0013 02513 533100034571000440000000	        D[IR] COND[-OBUS18] LBJUMP[ROTC1] C550 $
07m0013                               	
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];LSHC
07m0013 02514 640700000151400440000000	        ACSEL[AC+1] ALU[AC] DEST[Q]   NORM $
07m0013 02515 533100034571000440000000	        D[IR] COND[-OBUS18] LBJUMP[LSHC1] C550 $
07m0013                               	
07m0013                               	        .OPCODE[LIST 
07m0013                               	 LIST            ];(KAFIX at SAIL: "A. Kotok should have done this")
07m0013 02516 531154400551000440000000	        ACSEL[AC] ALU[AC] DEST[HOLD AR] COND[-OBUS<0] JUMP[KAFIXP] C550 $
07m0013                               	                ;Load up things for FIXER, check for positive mantissa
07m0013 02517 640150000513000440000000	        ACSEL[AC] ALU[0-AC] DEST[AR] JUMP[KAFIXN] NORM $
07m0013                               	                ;Negate AR so that its exponent can be used.
07m0013                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;       Exchange AC and memory
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];EXCH
08m0013 02520 640706200550400440030000	        FIXM2 $
08m0013                               	                ;Finish fetch of read-modify-write, checking for faults
08m0013 02521 662104205171000440002032	        ACSEL[AC] D[MEM] DEST[MEMSTO O_AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
08m0013                               	                ;Store result of fetch into AC, writing the old contents of
08m0013                               	                ;that AC into memory (O_AC means store new AC and output old
08m0013                               	                ;contents).
08m0013                               	
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;       Block Transfer Instruction
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];BLT
08m0013 02522 510140010621010160000000	        D[MASK 16] ROT[4] ACSEL[AC] ALU[D&AC] COND[OBUS=0] JUMP[BLTA1] C550 $ ;J IF DEST
08m0013                               	 IS AC
08m0013 02523 470100010621054160000000	        D[MASK 16] ROT[26] ACSEL[AC] ALU[D&AC] COND[-OBUS=0] LBJUMP[BLTA2] C600 $ ; J ON
08m0013                               	 SRC NOT AC
08m0013                               	
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;       Conditional jumps which add one to both halves
08m0013                               	;
08m0013                               	;  Caution:     With these instructions, overflow from the right half will be
08m0013                               	;               added to the left half, as on a KA.
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];AOBJP
08m0013                               	        D[CONST 1,,1] ACSEL[AC] ALU[D+AC] DEST[AC]
08m0013 02524 451140015421001000002026	                        COND[OBUS<0] JUMP[MAIN] C600 $
08m0013                               	                ;Add to both halves.  If result is negative, do not jump
08m0013 02525 640164634571000440002027	        DOJUMP $
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];AOBJN
08m0013                               	        D[CONST 1,,1] ACSEL[AC] ALU[D+AC]   DEST[AC]
08m0013 02526 471140015421001000002026	          COND[-OBUS<0] JUMP[MAIN] C600 $
08m0013 02527 640164634571000440002027	        DOJUMP $
08m0013                               	
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;       Jump Instructions (and halts)
08m0013                               	;
08m0013                               	;  Caution:     Halts set PC to effective address instead of the instruction
08m0013                               	;               that caused the halt.  This is especially bad because most
08m0013                               	;               programs which do not use UUOs place a halt in location 40,
08m0013                               	;               and the location of the UUO is then lost on an F2.  This
08m0013                               	;               might be cured by replicating the instruction fetch seqeunce
08m0013                               	;               herein with the copying of the IR into the PC happening later
08m0013                               	;               during that sequence.
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JRST
08m0013 02530 643164634571000440002027	        D[IR] DEST[MA PC] COND[AC=0] JUMP[MAIN1] NORM $
08m0013                               	                ;Make ordinary jumps as fast as possible.  Always load the PC
08m0013                               	                ;from the effective address, even on halts!?!
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

08m0013 02531 510100034571024010000000	        D[IR] ROT[12] MASK[1] COND[OBUS=0] LBJUMP[JRST1] C550 $
08m0013                               	                ;Seperate according to the 10 bit of the AC field.
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JFCL
08m0013 02532 643150034571032040002026	        D[IR] ROT[15] MASK[4] DEST[AR] COND[AC=0] JUMP[MAIN] NORM $
08m0013                               	                ;Check AC field and jump to instruction fetch if zero.
08m0013                               	                ;JFCL 0,  is the fastest no-op on a KA
08m0013 02533 640140020171000440000000	        D[PC] DEST[Q] JUMP[JFCL1] NORM $
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];XCT
08m0013 02534 663146000550400440020000	        FIXM1 COND[-AC=0] JUMP[XCT1] $
08m0013 02535 640144620531000440000000	        D[PC] ALU[D-1] DEST[PC] JUMP[XCT2] NORM $
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];A No-Op on KA's not having special features
08m0013 02536 640140000571000440002026	        JUMP[MAIN] NORM $
08m0013                               	
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	;
08m0013                               	;       Stack Instructions
08m0013                               	;
08m0013                               	;  Caution:     If a stack crosses zero (i.e. a carry from the right half
08m0013                               	;               occurs, the left half will be off by one, as on a KA
08m0013                               	;               (People who wrap their stacks around and thru ACs deserve to
08m0013                               	;               lose!)
08m0013                               	;------------------------------------------------------------------------------
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];PUSHJ
08m0013                               	        ACSEL[AC] D[CONST 1,,1] ALU[D+AC]   DEST[AC MA]
08m0013 02540 455160015421001000000000	          COND[CRY0] JUMP[PDLO1] C600 $
08m0013                               	                ;Increment stack pointer.
08m0013                               	                ;Jump on overflow (overflow code will complete instruction)
08m0013 02541 640144220571000440000000	        D[PC] DEST[MEMSTO] JUMP[PUSHJ1] NORM $
08m0013                               	                ;Store the PC and flags on the stack
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];PUSH
08m0013 02542 640706000550400440020000	        FIXM1 $
08m0013                               	                ;Complete fetch of thing to push
08m0013 02543 640150004571000440000000	        D[MEM] DEST[AR] JUMP[PUSH1] NORM $
08m0013                               	                ;Move it somewhere else so we set MA to point to stack.
08m0013                               	                ;(Setting the MA implies a read, which would destroy the thing
08m0013                               	                ;to push).
08m0013                               	                ;*$*$* Go elsewhere to finish instruction
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];POP
08m0013                               	        ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC]
08m0013 02544 475160015063001000000000	                        COND[-CRY0] JUMP[PDLO3] C600 $
08m0013                               	                ;Decrement stack pointer, but setting the MA to the old top of
08m0013                               	                ;stack.
08m0013                               	                ;If stack underflow, jump.  (Underflow code will finish the
08m0013                               	                ;instruction).
08m0013                               	         MAPF[PPOP] ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD]
08m0013 02545 640146000550400440160000	                        JUMP[POP1] CYLEN[FIXM] $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

08m0013                               	                ;If page fault, trap to special code to handle POP
08m0013                               	                ;*$*$* Go elsewhere to finish instruction
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];POPJ
08m0013                               	        ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC]
08m0013 02546 475160015063001000000000	                        COND[-CRY0] JUMP[PDLO4] C600 $
08m0013                               	                ;Decrement stack pointer, but setting the MA to the old top of
08m0013                               	                ;stack.
08m0013                               	                ;If stack underflow, jump.  (Underflow code will finish the
08m0013                               	                ;instruction).
08m0013                               	        MAPF[PPOP] ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD]
08m0013 02547 640146000550400440160000	                        JUMP[POPJ1] CYLEN[FIXM] $
08m0013                               	                ;If page fault, trap to special code to handle POP
08m0013                               	                ;*$*$* Go elsewhere to finish instruction
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JSR
08m0013 02550 642154220571000440000000	        D[PC] DEST[AR MEMSTO] COND[MA-AC] JUMP[JSR2] NORM $
08m0013                               	                ;Write PC (and flags) into effective address.
08m0013                               	                ;Watch for special case of store into AC
08m0013                               	        MAPF[STO] D[MA] ALU[D+1] DEST[PC] SPEC[CLR-HALF]
08m0013 02551 640144624433000442242026	                        JUMP[MAIN] CYLEN[MEMSTO] $
08m0013                               	                ;Set PC into one after effective address (where we stored old
08m0013                               	                ;PC) and take next instruction from there.
08m0013                               	                ;Make sure some nurd hasn't left the BIS flag on. (*** i assume
08m0013                               	                ;  that's what going on here.  TVR-Apr80)
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JSP
08m0013 02552 640700021571000440000000	        D[PC] ACSEL[AC] DEST[AC] NORM $
08m0013                               	                ;Store PC (and flags) in AC
08m0013 02553 640144624571000442202027	JSP1:   D[MA] DEST[PC] JUMP[MAIN1] SPEC[CLR-HALF] NORM $
08m0013                               	                ;Jump to effective address
08m0013                               	                ;Make sure some nurd hasn't left the BIS flag on. (*** i assume
08m0013                               	                ;  that's what going on here.  TVR-Apr80)
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JSA
08m0013 02554 640710021171000220000000	        D[PC] MASK[18.] DEST[O_AC AR] ACSEL[AC] NORM $
08m0013                               	                ;Copy PC into left half of AC and save old contents of AC in AR
08m0013                               	                ; DID SAVE A CYCLE WITH O_AC ****
08m0013                               	        D[MA] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC]
08m0013 02555 640140025561044000200000	                        JUMP[JSA1] NORM $
08m0013                               	                ;Put effective address into right half, i.e. were the old
08m0013                               	                ;contents of the AC is stored.
08m0013                               	                ;(This is the FORTRAN subroutine call, in case you were
08m0013                               	                ; wondering why it was so wierd...)
08m0013                               	                ;*$*$* (Finish instruction elsewhere)
08m0013                               	
08m0013                               	        .OPCODE[LIST 
08m0013                               	 LIST            ];JRA
08m0013 02556 640710000551000440000000	        ACSEL[AC] ALU[AC] DEST[AR] NORM  $
08m0013                               	                ;Save the return address in AR
08m0013 02557 640160000571044220000000	        D[AR] ROT[18.] MASK[18.] DEST[MA] JUMP[JRA1] NORM $
08m0013                               	                ;Begin read of location containing what's to be restored into
08m0013                               	                ;the AC (to invert a JSA)
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

08m0013                               	                ;*$*$* (Finish instruction elsewhere)
08m0013                               	
08m0013                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

09m0013                               	;------------------------------------------------------------------------------
09m0013                               	;
09m0013                               	;       Integer Add and Subtract
09m0013                               	;
09m0013                               	;------------------------------------------------------------------------------
09m0013                               	
09m0013                               	;These two macros make xxx,xxxI,xxxM,xxxB for instructions which map into a
09m0013                               	;single 2901 instruction involving AC and MEM.  OP is thing to put in the 
09m0013                               	;ALU field to do this 2901 instruction.
09m0013                               	;
09m0013                               	;ADOP and LOGOP differ only in that ADOP sets flags, and can get integer
09m0013                               	;overflow
09m0013                               	;
09m0013                               	.DEFINE ADOP 09m0013                               	
09m0013                               	.DEFINE LOGOP 09m0013                               	
09m0013                               	        .OPCODE[LIST 
09m0013                               	 LIST            ];Opcodes 270-273: ADD,ADDI,ADDM,ADDB
09m0013                               	        ADOP[09m0013 02560 640706000550400440020000	        FIXM1 $
09m0013 02561 640160005421000441002027	        ACSEL[AC] D[MEM] ALU[ D+AC ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1]
09m0013                               	 CYLEN[FIXM+1] $
09m0013                               	
09m0013 02562 640160035421000221002027	        ACSEL[AC] D[IR] MASK[18.] ALU[ D+AC ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1]
09m0013                               	 NORM $
09m0013 02563 000700000571000440000000	        NOP $
09m0013                               	
09m0013 02564 640706200550400440030000	        FIXM2 $
09m0013                               	        ACSEL[AC] D[MEM] ALU[ D+AC ] DEST[MEMSTO]
09m0013 02565 662104204421000441202032	          SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0013                               	
09m0013 02566 640706200550400440030000	        FIXM2 $
09m0013                               	        ACSEL[AC] D[MEM] ALU[ D+AC ] DEST[MEMSTO AC]
09m0013 02567 662104205421000441202032	          SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0014                               	END ADOP                ;Macro defines four instructions.  See above
09m0014                               	
09m0014                               	        .OPCODE[LIST 
09m0014                               	 LIST            ];Opcodes 274-277: SUB,SUBI,SUBM,SUBB
09m0014                               	        ADOP[09m0014 02570 640706000550400440020000	        FIXM1 $
09m0014 02571 640160005463000441002027	        ACSEL[AC] D[MEM] ALU[ AC-D ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1]
09m0014                               	 CYLEN[FIXM+1] $
09m0014                               	
09m0014 02572 640160035463000221002027	        ACSEL[AC] D[IR] MASK[18.] ALU[ AC-D ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1]
09m0014                               	 NORM $
09m0014 02573 000700000571000440000000	        NOP $
09m0014                               	
09m0014 02574 640706200550400440030000	        FIXM2 $
09m0014                               	        ACSEL[AC] D[MEM] ALU[ AC-D ] DEST[MEMSTO]
09m0014 02575 662104204463000441202032	          SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0014                               	
09m0014 02576 640706200550400440030000	        FIXM2 $
09m0014                               	        ACSEL[AC] D[MEM] ALU[ AC-D ] DEST[MEMSTO AC]
09m0014 02577 662104205463000441202032	          SPEC[CRYOV] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0015                               	END ADOP                ;Macro defines four instructions.  See above
09m0015                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

09m0015                               	;------------------------------------------------------------------------------
09m0015                               	;
09m0015                               	;       Conditional Instructions
09m0015                               	;
09m0015                               	;       Instruction dispatch sends each group of eight instructions to one 
09m0015                               	;       place.  The condition JCOND looks at the IR to decide whether the
09m0015                               	;       condition specified by the low order three bits of the opcode has
09m0015                               	;       been satisfied.
09m0015                               	;
09m0015                               	;------------------------------------------------------------------------------
09m0015                               	
09m0015                               	;Compare AC to effective address
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];CAI
09m0015 02600 472140034463000220002026	        D[IR] MASK[18.] ACSEL[AC] ALU[AC-D] COND[-JCOND] JUMP[MAIN] C600 $
09m0015 02601 640164620433000440002027	        DOSKIP $
09m0015                               	
09m0015                               	AREA260:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Compare AC to memory
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];CAM
09m0015 02620 640706000550400440020000	        FIXM1 $
09m0015 02621 472140004463000440002026	        D[MEM] ACSEL[AC] ALU[AC-D] COND[-JCOND] JUMP[MAIN] C600 $
09m0015 02622 640164620433000440002027	DOSKP1: DOSKIP $
09m0015                               	
09m0015                               	AREA262:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Jump on AC [compared with zero]
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];JUMP
09m0015 02640 472140014421000000002026	        D[CONST 0] ACSEL[AC] ALU[AC+D] COND[-JCOND] JUMP[MAIN] C600 $
09m0015 02641 640164634571000440002027	        DOJUMP $
09m0015                               	
09m0015                               	AREA264:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Skip on memory [compared with zero]
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];SKIP
09m0015 02660 643146000550400440020000	        FIXM1 COND[AC=0] JUMP[SKIPX1] $
09m0015                               	                ;Jump if AC not loaded as side effect
09m0015 02661 472140005533000440002026	        D[MEM] ALU[D-0] ACSEL[AC] DEST[AC] COND[-JCOND] JUMP[MAIN] C600 $
09m0015                               	                ;AC field (in IR) is zero.  Just skip on appropriate condition
09m0015 02662 640164620433000440002027	        DOSKIP $
09m0015 02663 472140004533000440002026	SKIPX1: D[MEM] ALU[D-0] COND[-JCOND] JUMP[MAIN] C600 $
09m0015                               	                ;Load memory into AC as well as skipping on appropriate
09m0015                               	                ;condition
09m0015 02664 640164620433000440002027	        DOSKIP $
09m0015                               	
09m0015                               	AREA266:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Add One to AC and jump [on AC compared with zero]
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];AOJ
09m0015 02700 472140001413000441202026	        ACSEL[AC] ALU[AC+1] DEST[AC] SPEC[CRYOV] COND[-JCOND] JUMP[MAIN] C600 $
09m0015 02701 640164634571000440002027	        DOJUMP $
09m0015                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

09m0015                               	AREA270:        ;Recover space from hole in instruction dispatch
09m0015                               	
09m0015                               	;Add One to Memory and skip [on memory compared to zero]
09m0015                               	        .OPCODE[LIST 
09m0015                               	 LIST            ];AOS
09m0015 02720 643146200550400440030000	        FIXM2 COND[AC=0] JUMP[ASOS1]  $
09m0015                               	                ;Finish fetch part of read-modify-write
09m0015                               	                ;Jump if AC is not loaded as a side effect.
09m0015                               	        D[MEM] ALU[D+1] ACSEL[AC] DEST[AC MEMSTO] SPEC[CRYOV]
09m0015 02721 452104205433000441200000	                        COND[JCOND] LBJUMP[ASOS2] C600 $
09m0015                               	                ;(AC field (in IR) is non-zero.  Load AC as side effect.)
09m0015                               	                ;Increment memory and store result in AC.
09m0015                               	                ;Set flags (set overflow if memory was 377777,,777777)
09m0015                               	                ;Decide where or not to skip before checking for store to AC
09m0015                               	        .PAIR
09m0015                               	. \ 2 + .
09m0016 02722 662100000571000440002032	]ASOS2: MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0016                               	                ;Do not skip.  Finish store (checking for store to AC)
09m0016 02723 662104620433000440002032	        D[PC] ALU[D+1] DEST[PC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
09m0016                               	                ;Do skip.  Finish store.
09m0016                               	;       ---
09m0016                               	ASOS1:  D[MEM] ALU[D+1] DEST[MEMSTO] SPEC[CRYOV]
09m0016 02724 452104204433000441202722	                        COND[JCOND] LBJUMP[ASOS2] C600 $
09m0016                               	                ;Simply increment memory location.  Otherwise, same as above.
09m0016                               	
09m0016       2725	AREA272 = .     ;Recover space from hole in instruction dispatch
09m0016                               	
09m0016                               	;Subtract One from AC and jump [on AC compared with zero]
09m0016                               	        .OPCODE[LIST 
09m0016                               	 LIST            ];SOJ
09m0016 02740 472140001451000441202026	        ACSEL[AC] ALU[AC-1] DEST[AC] SPEC[CRYOV] COND[-JCOND] JUMP[MAIN] C600 $
09m0016 02741 640164634571000440002027	        DOJUMP $
09m0016                               	
09m0016                               	AREA274:        ;Recover space from hole in instruction dispatch
09m0016                               	
09m0016                               	;Subtract One from Memory and skip [on memory compared to zero]
09m0016                               	        .OPCODE[LIST 
09m0016                               	 LIST            ];SOS
09m0016 02760 643146200550400440030000	        FIXM2 COND[AC=0] JUMP[ASOS3] $
09m0016                               	                ;Finish fetch part of read-modify-write
09m0016                               	                ;Jump if AC is not loaded as a side effect.
09m0016                               	        D[MEM] ALU[D-1] ACSEL[AC] DEST[AC MEMSTO] SPEC[CRYOV]
09m0016 02761 452104205531000441202722	                        COND[JCOND] LBJUMP[ASOS2] C600 $
09m0016                               	                ;(AC field (in IR) is non-zero.  Load AC as side effect.)
09m0016                               	                ;Decrement memory and store result in AC.
09m0016                               	                ;Set flags (set overflow if memory was 400000,,0)
09m0016                               	                ;Decide where or not to skip before checking for store to AC
09m0016                               	ASOS3:  D[MEM] ALU[D-1] DEST[MEMSTO] SPEC[CRYOV]
09m0016 02762 452104204531000441202722	                        COND[JCOND] LBJUMP[ASOS2] C600 $
09m0016                               	                ;Simply decrement memory location.  Otherwise, same as above.
09m0016                               	
09m0016       2763	AREA276 = .     ;Recover space from hole in instruction dispatch
09m0016                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

10m0016                               	;------------------------------------------------------------------------------
10m0016                               	;
10m0016                               	;       Boolean Instructions
10m0016                               	;
10m0016                               	;------------------------------------------------------------------------------
10m0016                               	
10m0016                               	.DEFINE CLRAC 10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];SETZ
10m0016 03000 640140001615000440002026	        CLRAC ALU[0] ACSEL[AC] DEST[AC] NORM ]  JUMP[MAIN] $
10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];SETZI
10m0016 03002 640140001615000440002026	        CLRAC ALU[0] ACSEL[AC] DEST[AC] NORM ]  JUMP[MAIN] $
10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];SETZM
10m0016 03004 662104200615000440002032	          ALU[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];SETZB
10m0016 03006 662104201615000440002032	          ALU[0] DEST[MEMSTO AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0016                               	
10m0016                               	        .OPCODE[LIST 
10m0016                               	 LIST            ];AND,ANDI,ANDM,ANDB
10m0016                               	                ;Generates code for four instructions.  See ADD (ADOP)  
10m0016                               	        LOGOP[10m0016 03010 640706000550400440020000	        FIXM1 $
10m0016 03011 640160005621000440602027	        ACSEL[AC] D[MEM] ALU[ D&AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0016                               	
10m0016                               	
10m0016 03012 640160035621000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ D&AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0016                               	
10m0016 03013 000700000571000440000000	        NOP $
10m0016                               	
10m0016 03014 640706200550400440030000	        FIXM2 $
10m0016                               	        ACSEL[AC] D[MEM] ALU[ D&AC ] DEST[MEMSTO]
10m0016 03015 662104204621000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0016                               	
10m0016 03016 640706200550400440030000	        FIXM2 $
10m0016                               	        ACSEL[AC] D[MEM] ALU[ D&AC ] DEST[MEMSTO AC]
10m0016 03017 662104205621000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0017                               	END LOGOP
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];ANDCA
10m0017 03020 640706000550400440020000	        FIXM1 $
10m0017 03021 640140000351000440000000	        ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA1] CYLEN[FIXM+1] $
10m0017                               	
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];ANDCAI
10m0017 03022 640700000351000440000000	        ALU[NOTAC] DEST[Q] ACSEL[AC] NORM $
10m0017                               	        D[IR] MASK[18.] ACSEL[AC] ALU[D&Q] DEST[AC MA] SPEC[MA_PC]
10m0017 03023 640160035635000220602027	                        JUMP[MAIN1] NORM $
10m0017                               	
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];ANDCAM
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

10m0017 03024 640706200550400440030000	        FIXM2 $
10m0017 03025 640140000351000440000000	        ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA2] CYLEN[FIXM+1] $
10m0017                               	
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];ANDCAB
10m0017 03026 640706200550400440030000	        FIXM2 $
10m0017 03027 640140000351000440000000	        ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA3] CYLEN[FIXM+1] $
10m0017                               	
10m0017                               	        .OPCODE[LIST 
10m0017                               	 LIST            ];SETM,SETMI,SETMM,SETMB
10m0017                               	SETM:   LOGOP[10m0017 03030 640706000550400440020000	        FIXM1 $
10m0017 03031 640160005571000440602027	        ACSEL[AC] D[MEM] ALU[ D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0017                               	
10m0017 03032 640160035571000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0017 03033 000700000571000440000000	        NOP $
10m0017                               	
10m0017 03034 640706200550400440030000	        FIXM2 $
10m0017                               	        ACSEL[AC] D[MEM] ALU[ D ] DEST[MEMSTO]
10m0017 03035 662104204571000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0017                               	
10m0017 03036 640706200550400440030000	        FIXM2 $
10m0017                               	        ACSEL[AC] D[MEM] ALU[ D ] DEST[MEMSTO AC]
10m0017 03037 662104205571000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0018                               	END LOGOP
10m0018                               	        .OPCODE[LIST 
10m0018                               	 LIST            ];ANDCM,ANDCMI,ANDCMM,ANDCMB
10m0018                               	        LOGOP[10m0018 03040 640706000550400440020000	        FIXM1 $
10m0018 03041 640160005661000440602027	        ACSEL[AC] D[MEM] ALU[ -D&AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0018                               	
10m0018                               	
10m0018 03042 640160035661000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ -D&AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0018                               	
10m0018 03043 000700000571000440000000	        NOP $
10m0018                               	
10m0018 03044 640706200550400440030000	        FIXM2 $
10m0018                               	        ACSEL[AC] D[MEM] ALU[ -D&AC ] DEST[MEMSTO]
10m0018 03045 662104204661000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0018                               	
10m0018 03046 640706200550400440030000	        FIXM2 $
10m0018                               	        ACSEL[AC] D[MEM] ALU[ -D&AC ] DEST[MEMSTO AC]
10m0018 03047 662104205661000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0019                               	END LOGOP
10m0019                               	        .OPCODE[LIST 
10m0019                               	 LIST            ];SETA,SETAI,SETAM,SETAB
10m0019                               	        LOGOP[10m0019 03050 640706000550400440020000	        FIXM1 $
10m0019 03051 640160005551000440602027	        ACSEL[AC] D[MEM] ALU[ AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0019                               	
10m0019 03052 640160035551000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ AC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0019 03053 000700000571000440000000	        NOP $
10m0019                               	
10m0019 03054 640706200550400440030000	        FIXM2 $
10m0019                               	        ACSEL[AC] D[MEM] ALU[ AC ] DEST[MEMSTO]
10m0019 03055 662104204551000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0019                               	
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

10m0019 03056 640706200550400440030000	        FIXM2 $
10m0019                               	        ACSEL[AC] D[MEM] ALU[ AC ] DEST[MEMSTO AC]
10m0019 03057 662104205551000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0019                               	END LOGOP$
10m0019                               	
10m0019                               	        .OPCODE[LIST 
10m0019                               	 LIST            ];XOR,XORI,XORM,XORB
10m0019                               	        LOGOP[10m0019 03060 640706000550400440020000	        FIXM1 $
10m0019 03061 640160005721000440602027	        ACSEL[AC] D[MEM] ALU[ AC#D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0019                               	
10m0019                               	
10m0019 03062 640160035721000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ AC#D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0019                               	
10m0019 03063 000700000571000440000000	        NOP $
10m0019                               	
10m0019 03064 640706200550400440030000	        FIXM2 $
10m0019                               	        ACSEL[AC] D[MEM] ALU[ AC#D ] DEST[MEMSTO]
10m0019 03065 662104204721000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0019                               	
10m0019 03066 640706200550400440030000	        FIXM2 $
10m0019                               	        ACSEL[AC] D[MEM] ALU[ AC#D ] DEST[MEMSTO AC]
10m0019 03067 662104205721000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0020                               	END LOGOP
10m0020                               	        .OPCODE[LIST 
10m0020                               	 LIST            ];IOR,IORI,IORM,IORB
10m0020                               	        LOGOP[10m0020 03070 640706000550400440020000	        FIXM1 $
10m0020 03071 640160005561000440602027	        ACSEL[AC] D[MEM] ALU[ DORAC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0020                               	
10m0020                               	
10m0020 03072 640160035561000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ DORAC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0020                               	
10m0020 03073 000700000571000440000000	        NOP $
10m0020                               	
10m0020 03074 640706200550400440030000	        FIXM2 $
10m0020                               	        ACSEL[AC] D[MEM] ALU[ DORAC ] DEST[MEMSTO]
10m0020 03075 662104204561000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0020                               	
10m0020 03076 640706200550400440030000	        FIXM2 $
10m0020                               	        ACSEL[AC] D[MEM] ALU[ DORAC ] DEST[MEMSTO AC]
10m0020 03077 662104205561000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0021                               	END LOGOP
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];ANDCB
10m0021 03100 640706000550400440020000	        FIXM1 $
10m0021 03101 640140004161000440000000	        ACSEL[AC] ALU[DORAC] DEST[Q] D[MEM] JUMP[ACBI1] CYLEN[FIXM+1] $
10m0021                               	
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];ANDCBI
10m0021 03102 640700034161000220000000	          ACSEL[AC] D[IR] MASK[18.] ALU[DORAC] DEST[Q] NORM $
10m0021 03103 640160001755000440602027	ACBI1:  ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0021                               	
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];ANDCBM
10m0021 03104 640706200550400440030000	        FIXM2 $
10m0021 03105 640140004161000440000000	        ACSEL[AC] ALU[DORAC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

10m0021                               	
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];ANDCBB
10m0021 03106 640706200550400440030000	        FIXM2 $
10m0021 03107 640140004161000440000000	        ACSEL[AC] ALU[DORAC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $
10m0021                               	
10m0021                               	        .OPCODE[LIST 
10m0021                               	 LIST            ];EQV,EQVI,EQVM,EQVB
10m0021                               	        LOGOP[10m0021 03110 640706000550400440020000	        FIXM1 $
10m0021 03111 640160005761000440602027	        ACSEL[AC] D[MEM] ALU[ AC/#D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0021                               	
10m0021                               	
10m0021 03112 640160035761000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ AC/#D ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0021                               	
10m0021 03113 000700000571000440000000	        NOP $
10m0021                               	
10m0021 03114 640706200550400440030000	        FIXM2 $
10m0021                               	        ACSEL[AC] D[MEM] ALU[ AC/#D ] DEST[MEMSTO]
10m0021 03115 662104204761000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0021                               	
10m0021 03116 640706200550400440030000	        FIXM2 $
10m0021                               	        ACSEL[AC] D[MEM] ALU[ AC/#D ] DEST[MEMSTO AC]
10m0021 03117 662104205761000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0022                               	END LOGOP
10m0022                               	        .OPCODE[LIST 
10m0022                               	 LIST            ];SETCA,SETCAI,SETCAM,SETCAB
10m0022                               	        LOGOP[10m0022 03120 640706000550400440020000	        FIXM1 $
10m0022 03121 640160005751000440602027	        ACSEL[AC] D[MEM] ALU[ NOTAC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0022                               	
10m0022                               	
10m0022 03122 640160035751000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ NOTAC ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0022                               	
10m0022 03123 000700000571000440000000	        NOP $
10m0022                               	
10m0022 03124 640706200550400440030000	        FIXM2 $
10m0022                               	        ACSEL[AC] D[MEM] ALU[ NOTAC ] DEST[MEMSTO]
10m0022 03125 662104204751000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0022                               	
10m0022 03126 640706200550400440030000	        FIXM2 $
10m0022                               	        ACSEL[AC] D[MEM] ALU[ NOTAC ] DEST[MEMSTO AC]
10m0022 03127 662104205751000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0023                               	END LOGOP
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];ORCA
10m0023 03130 640706000550400440020000	        FIXM1 $
10m0023 03131 640140004261000440000000	        ACSEL[AC] D[MEM] ALU[-D&AC] DEST[Q] JUMP[OCAI1] CYLEN[FIXM+1] $
10m0023                               	
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];ORCAI
10m0023 03132 640700034261000220000000	          ACSEL[AC] D[IR] MASK[18.] ALU[-D&AC] DEST[Q] NORM $
10m0023 03133 640160001755000440602027	OCAI1:  ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0023                               	
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];ORCAM
10m0023 03134 640706200550400440030000	        FIXM2 $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

10m0023 03135 640140004261000440000000	        ACSEL[AC] ALU[-D&AC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $
10m0023                               	
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];ORCAB
10m0023 03136 640706200550400440030000	        FIXM2 $
10m0023 03137 640140004261000440000000	        ACSEL[AC] ALU[-D&AC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $
10m0023                               	
10m0023                               	        .OPCODE[LIST 
10m0023                               	 LIST            ];SETCM,SETCMI,SETCMM,SETCMB
10m0023                               	        LOGOP[10m0023 03140 640706000550400440020000	        FIXM1 $
10m0023 03141 640160005771000440602027	        ACSEL[AC] D[MEM] ALU[ NOTD ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
10m0023                               	
10m0023                               	
10m0023 03142 640160035771000220602027	        ACSEL[AC] D[IR] MASK[18.] ALU[ NOTD ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0023                               	
10m0023 03143 000700000571000440000000	        NOP $
10m0023                               	
10m0023 03144 640706200550400440030000	        FIXM2 $
10m0023                               	        ACSEL[AC] D[MEM] ALU[ NOTD ] DEST[MEMSTO]
10m0023 03145 662104204771000440002032	         MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0023                               	
10m0023 03146 640706200550400440030000	        FIXM2 $
10m0023                               	        ACSEL[AC] D[MEM] ALU[ NOTD ] DEST[MEMSTO AC]
10m0023 03147 662104205771000440002032	          MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0024                               	END LOGOP
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCM,ORCMI,ORCMM,ORCMB
10m0024 03150 640706000550400440020000	        FIXM1 $
10m0024 03151 640140004371000440000000	        D[MEM] ALU[NOTD] DEST[Q] JUMP[OCMI1] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCMI
10m0024 03152 640700034371000220000000	          D[IR] MASK[18.] ALU[NOTD] DEST[Q] NORM $
10m0024 03153 640160001545000440602027	OCMI1:  ACSEL[AC] ALU[QORAC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCMM
10m0024 03154 640706200550400440030000	        FIXM2 $
10m0024 03155 640140004371000440000000	        D[MEM] ALU[NOTD] DEST[Q] JUMP[ORCM2] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCMB
10m0024 03156 640706200550400440030000	        FIXM2 $
10m0024 03157 640140004371000440000000	        D[MEM] ALU[NOTD] DEST[Q] JUMP[ORCM3] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCB
10m0024 03160 640706000550400440020000	        FIXM1 $
10m0024 03161 640140004221000440000000	        ACSEL[AC] D[MEM] ALU[D&AC] DEST[Q] JUMP[OCBI1] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCBI
10m0024 03162 640700034221000220000000	          ACSEL[AC] D[IR] MASK[18.] ALU[D&AC] DEST[Q] NORM $
10m0024 03163 640160001755000440602027	OCBI1:  ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

10m0024                               	 LIST            ];ORCBM
10m0024 03164 640706200550400440030000	        FIXM2 $
10m0024 03165 640140004221000440000000	        ACSEL[AC] ALU[D&AC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];ORCBB
10m0024 03166 640706200550400440030000	        FIXM2 $
10m0024 03167 640140004221000440000000	        ACSEL[AC] ALU[D&AC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];SETO
10m0024 03170 640160001741000440602027	        ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];SETOI
10m0024 03172 640160001741000440602027	        ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];SETOM
10m0024 03174 662104200741000440002032	        ALU[-1] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]    $
10m0024                               	
10m0024                               	        .OPCODE[LIST 
10m0024                               	 LIST            ];SETOB
10m0024 03176 662104201741000440002032	        ALU[-1] ACSEL[AC] DEST[MEMSTO AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
10m0024 03177 000700000571000440000000	        NOP $
10m0024                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

11m0024                               	;------------------------------------------------------------------------------
11m0024                               	;
11m0024                               	;       Half Word Instructions
11m0024                               	;
11m0024                               	;------------------------------------------------------------------------------
11m0024                               	
11m0024                               	.DEFINE MH1 11m0024                               	
11m0024                               	.DEFINE MH2 11m0024                               	
11m0024                               	.DEFINE MH3 11m0024                               	
11m0024                               	        .OPCODE[LIST 
11m0024                               	 LIST            ];HLL,HLLI,HLLM,HLLS
11m0024                               	        MH3[11m0024 03200 640706000550400440020000	FIXM1 $
11m0024 03201 640150005171000000200000	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[O_AC AR] JUMP[ HRAR ]
11m0024                               	 CYLEN[FIXM+1] $
11m0024 03202 640150025171000000200000	        D[MA] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[O_AC AR] JUMP[ HRAR ] NORM $
11m0024                               	
11m0024 03203 000700000571000440000000	        NOP $
11m0024 03204 640706200550400440030000	        FIXM2 $
11m0024 03205 640150010221044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ HLLM1 ] CYLEN[FIXM+1] $
11m0024                               	
11m0024 03206 663100000550400440030000	        ACSEL[MA] ALU[AC] DEST[ 0 ] MAPF[3] COND[-AC=0] LBJUMP[HMV] CYLEN[FIXM] $
11m0024 03207 663110004171000000200000	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS]
11m0024                               	 CYLEN[FIXM+1] $
11m0025                               	];HRL
11m0025                               	        MH3[11m0025 03210 640706000550400440020000	FIXM1 $
11m0025 03211 640150005171044000200000	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[O_AC AR] JUMP[ HRAR ]
11m0025                               	 CYLEN[FIXM+1] $
11m0025 03212 640150025171044000200000	        D[MA] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[O_AC AR] JUMP[ HRAR ] NORM
11m0025                               	 $
11m0025 03213 000700000571000440000000	        NOP $
11m0025 03214 640706200550400440030000	        FIXM2 $
11m0025 03215 640150010221000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ HRLM1 ] CYLEN[FIXM+1] $
11m0025                               	
11m0025 03216 663706200550400440030000	        ACSEL[MA] ALU[AC] DEST[ FIXMAC-MAPF-WRT ] MAPF[3] COND[-AC=0] CONTA[0]
11m0025                               	 CYLEN[FIXM] $
11m0025 03217 663110004171044000200000	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS]
11m0025                               	 CYLEN[FIXM+1] $
11m0026                               	];HLLZ
11m0026                               	        MH1[11m0026 03220 640706000550400440020000	FIXM1 $
11m0026 03221 640160005571000000402027	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT&MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1]
11m0026                               	 CYLEN[FIXM+1] $
11m0026 03222 640160025571000000402027	        D[MA] ROT[0] MASK[ 0 ] SPEC[ LEFT&MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM
11m0026                               	 $
11m0026 03223 000700000571000440000000	        NOP $
11m0026 03224 662104210621044220002032	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[D&AC] DEST[ MEMSTO ] COND[-MA-AC] LBJUMP [
11m0026                               	 MSMAIN ]  CYLEN[ NORM ] $
11m0026 03225 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0026 03226 642146200550400440030000	        ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ HLLZS1 ] DEST[FIXMAC-MAPF-WRT] MAPF[3]
11m0026                               	 CYLEN[FIXM] $
11m0026 03227 663104204571000000200000	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1]
11m0026                               	 CYLEN[FIXM+1] $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

11m0027                               	];HRLZ
11m0027                               	        MH1[11m0027 03230 640706000550400440020000	FIXM1 $
11m0027 03231 640160005571044000402027	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT&MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1]
11m0027                               	 CYLEN[FIXM+1] $
11m0027 03232 640160025571044000402027	        D[MA] ROT[22] MASK[ 0 ] SPEC[ LEFT&MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM
11m0027                               	 $
11m0027 03233 000700000571000440000000	        NOP $
11m0027 03234 662710010621000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[D&AC] DEST[ AR ] COND[-MA-AC] CONTA [ 0 ] 
11m0027                               	 CYLEN[ NORM ] $
11m0027 03235 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0027 03236 642146200550400440030000	        ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ HRLZS1 ] DEST[FIXMAC-MAPF-WRT] MAPF[3]
11m0027                               	 CYLEN[FIXM] $
11m0027 03237 663104204571044000200000	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1]
11m0027                               	 CYLEN[FIXM+1] $
11m0028                               	];HLLO
11m0028                               	        MH2[11m0028 03240 640706000550400440020000	FIXM1 $
11m0028 03241 640150005571000440000000	        D[MEM] ROT[ 0 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOR ]
11m0028                               	 CYLEN[FIXM+1] $
11m0028 03242 640150025571000440000000	        D[MA] ROT[ 0 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOR ]
11m0028                               	 NORM $
11m0028 03243 000700000571000440000000	        NOP $
11m0028 03244 662104210161000220002032	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[DORAC] DEST[Q MEMSTO ] COND[ -MA-AC ]
11m0028                               	 LBJUMP[MSMAIN] CYLEN[ NORM ] $
11m0028 03245 662104200571000440002032	        D[AR] ROT[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0028 03246 640706200550400440030000	        FIXM2 $
11m0028 03247 663110004171000440000000	        D[MEM] ROT[ 0 ] DEST[Q AR] COND[ -AC=0 ] LBJUMP[ HLLOS1] CYLEN[FIXM+1] $
11m0029                               	];HRLO
11m0029                               	        MH2[11m0029 03250 640706000550400440020000	FIXM1 $
11m0029 03251 640150005571044440000000	        D[MEM] ROT[ 22 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOR
11m0029                               	 ] CYLEN[FIXM+1] $
11m0029 03252 640150025571044440000000	        D[MA] ROT[ 22 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOR ]
11m0029                               	 NORM $
11m0029 03253 000700000571000440000000	        NOP $
11m0029 03254 640710010161044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ 0 ] CONTA[0] CYLEN[
11m0029                               	 NORM ] $
11m0029 03255 662104200571044440002032	        D[AR] ROT[22] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0029 03256 640706200550400440030000	        FIXM2 $
11m0029 03257 663110004171044440000000	        D[MEM] ROT[ 22 ] DEST[Q AR] COND[ -AC=0 ] LBJUMP[ HLLOS1] CYLEN[FIXM+1] $
11m0030                               	];HLLE
11m0030                               	        MH2[11m0030 03260 640706000550400440020000	FIXM1 $
11m0030 03261 651110005571000000200000	        D[MEM] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[AC AR] COND[ OBUS<0 ]
11m0030                               	 LBJUMP [ HLSZ ] CYLEN[FIXM+1] $
11m0030 03262 651110025571000000200000	        D[MA] ROT[ 0 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[AC AR] COND[ OBUS<0 ] LBJUMP
11m0030                               	 [ HLSZ ] NORM $
11m0030 03263 000700000571000440000000	        NOP $
11m0030 03264 531150010161000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ -OBUS<0 ] JUMP[HLLEM1]
11m0030                               	 CYLEN[ C550 ] $
11m0030 03265 662104200571000440002032	        D[AR] ROT[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0030 03266 640706200550400440030000	        FIXM2 $
11m0030 03267 651110004171000440000000	        D[MEM] ROT[ 0 ] DEST[Q AR] COND[ OBUS<0 ] LBJUMP[ HLLES1] CYLEN[FIXM+1] $
11m0031                               	];HRLE
11m0031                               	        MH2[11m0031 03270 640706000550400440020000	FIXM1 $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

11m0031 03271 651110005571044000200000	        D[MEM] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[AC AR] COND[ OBUS<0 ]
11m0031                               	 LBJUMP [ HLSZ ] CYLEN[FIXM+1] $
11m0031 03272 651110025571044000200000	        D[MA] ROT[ 22 ] MASK[ 0 ] SPEC[ LEFT ] ACSEL[AC] DEST[AC AR] COND[ OBUS<0 ]
11m0031                               	 LBJUMP [ HLSZ ] NORM $
11m0031 03273 000700000571000440000000	        NOP $
11m0031 03274 533150010161044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ -OBUS18 ]
11m0031                               	 JUMP[HRLEM1] CYLEN[ C550 ] $
11m0031 03275 662104200571044440002032	        D[AR] ROT[22] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0031 03276 640706200550400440030000	        FIXM2 $
11m0031 03277 651110004171044440000000	        D[MEM] ROT[ 22 ] DEST[Q AR] COND[ OBUS<0 ] LBJUMP[ HLLES1] CYLEN[FIXM+1] $
11m0032                               	];HRR
11m0032                               	        MH3[11m0032 03300 640706000550400440020000	FIXM1 $
11m0032 03301 640150005171000220000000	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[O_AC AR] JUMP[ HLAR ]
11m0032                               	 CYLEN[FIXM+1] $
11m0032 03302 640150025171000220000000	        D[MA] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[O_AC AR] JUMP[ HLAR ] NORM $
11m0032 03303 000700000571000440000000	        NOP $
11m0032 03304 640706200550400440030000	        FIXM2 $
11m0032 03305 640150010221000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ HRRM1 ] CYLEN[FIXM+1] $
11m0032                               	
11m0032 03306 663100000550400440030000	        ACSEL[MA] ALU[AC] DEST[ 0 ] MAPF[3] COND[-AC=0] LBJUMP[HMV] CYLEN[FIXM] $
11m0032 03307 663110004171000220000000	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS]
11m0032                               	 CYLEN[FIXM+1] $
11m0033                               	];HLR
11m0033                               	        MH3[11m0033 03310 640706000550400440020000	FIXM1 $
11m0033 03311 640150005171044220000000	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[O_AC AR] JUMP[ HLAR ]
11m0033                               	 CYLEN[FIXM+1] $
11m0033 03312 640150025171044220000000	        D[MA] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[O_AC AR] JUMP[ HLAR ] NORM $
11m0033                               	
11m0033 03313 000700000571000440000000	        NOP $
11m0033 03314 640706200550400440030000	        FIXM2 $
11m0033 03315 640150010221044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ HLRM1 ] CYLEN[FIXM+1] $
11m0033                               	
11m0033 03316 663706200550400440030000	        ACSEL[MA] ALU[AC] DEST[ FIXMAC-MAPF-WRT ] MAPF[3] COND[-AC=0] CONTA[0]
11m0033                               	 CYLEN[FIXM] $
11m0033 03317 663110004171044220000000	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS]
11m0033                               	 CYLEN[FIXM+1] $
11m0034                               	];HRRZ
11m0034                               	        MH1[11m0034 03320 640706000550400440020000	FIXM1 $
11m0034 03321 640160005571000220602027	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1]
11m0034                               	 CYLEN[FIXM+1] $
11m0034 03322 640160025571000220602027	        D[MA] ROT[0] MASK[ 22 ] SPEC[ MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM $
11m0034 03323 000700000571000440000000	        NOP $
11m0034 03324 662104210621000220002032	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[D&AC] DEST[ MEMSTO ] COND[-MA-AC] LBJUMP [
11m0034                               	 MSMAIN ]  CYLEN[ NORM ] $
11m0034 03325 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0034 03326 642146200550400440030000	        ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ HRRZS1 ] DEST[FIXMAC-MAPF-WRT] MAPF[3]
11m0034                               	 CYLEN[FIXM] $
11m0034 03327 663104204571000220000000	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1]
11m0034                               	 CYLEN[FIXM+1] $
11m0035                               	];HLRZ
11m0035                               	        MH1[11m0035 03330 640706000550400440020000	FIXM1 $
11m0035 03331 640160005571044220602027	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1]
11m0035                               	 CYLEN[FIXM+1] $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

11m0035 03332 640160025571044220602027	        D[MA] ROT[22] MASK[ 22 ] SPEC[ MA_PC ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM $
11m0035 03333 000700000571000440000000	        NOP $
11m0035 03334 662710010621044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[D&AC] DEST[ AR ] COND[-MA-AC] CONTA [ 0 ] 
11m0035                               	 CYLEN[ NORM ] $
11m0035 03335 662104200571044440002032	        D[AR] ROT[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0035 03336 642146200550400440030000	        ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ HLRZS1 ] DEST[FIXMAC-MAPF-WRT] MAPF[3]
11m0035                               	 CYLEN[FIXM] $
11m0035 03337 663104204571044220000000	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1]
11m0035                               	 CYLEN[FIXM+1] $
11m0036                               	];HRRO
11m0036                               	        MH2[11m0036 03340 640706000550400440020000	FIXM1 $
11m0036 03341 640150005571000440000000	        D[MEM] ROT[ 0 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOL ]
11m0036                               	 CYLEN[FIXM+1] $
11m0036 03342 640150025571000440000000	        D[MA] ROT[ 0 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOL ]
11m0036                               	 NORM $
11m0036 03343 000700000571000440000000	        NOP $
11m0036 03344 662104210161044220002032	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[DORAC] DEST[Q MEMSTO ] COND[ -MA-AC ]
11m0036                               	 LBJUMP[MSMAIN] CYLEN[ NORM ] $
11m0036 03345 662104200571000440002032	        D[AR] ROT[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0036 03346 640706200550400440030000	        FIXM2 $
11m0036 03347 663110004171000440000000	        D[MEM] ROT[ 0 ] DEST[Q AR] COND[ -AC=0 ] LBJUMP[ HRROS1] CYLEN[FIXM+1] $
11m0037                               	];HLRO
11m0037                               	        MH2[11m0037 03350 640706000550400440020000	FIXM1 $
11m0037 03351 640150005571044440000000	        D[MEM] ROT[ 22 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOL
11m0037                               	 ] CYLEN[FIXM+1] $
11m0037 03352 640150025571044440000000	        D[MA] ROT[ 22 ] MASK[ 44 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ 0 ] JUMP [ HOL ]
11m0037                               	 NORM $
11m0037 03353 000700000571000440000000	        NOP $
11m0037 03354 640710010161000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ 0 ] CONTA[0] CYLEN[
11m0037                               	 NORM ] $
11m0037 03355 662104200571044440002032	        D[AR] ROT[22] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0037 03356 640706200550400440030000	        FIXM2 $
11m0037 03357 663110004171044440000000	        D[MEM] ROT[ 22 ] DEST[Q AR] COND[ -AC=0 ] LBJUMP[ HRROS1] CYLEN[FIXM+1] $
11m0038                               	];HRRE
11m0038                               	        MH2[11m0038 03360 640706000550400440020000	FIXM1 $
11m0038 03361 653110005571000220000000	        D[MEM] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ OBUS18 ] LBJUMP
11m0038                               	 [ HRSZ ] CYLEN[FIXM+1] $
11m0038 03362 653110025571000220000000	        D[MA] ROT[ 0 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ OBUS18 ] LBJUMP [
11m0038                               	 HRSZ ] NORM $
11m0038 03363 000700000571000440000000	        NOP $
11m0038 03364 533150010161044220000000	        D[MASK 22] ROT[ 22 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ -OBUS18 ]
11m0038                               	 JUMP[HRREM1] CYLEN[ C550 ] $
11m0038 03365 662104200571000440002032	        D[AR] ROT[0] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0038 03366 640706200550400440030000	        FIXM2 $
11m0038 03367 653110004171000440000000	        D[MEM] ROT[ 0 ] DEST[Q AR] COND[ OBUS18 ] LBJUMP[ HRRES1] CYLEN[FIXM+1] $
11m0039                               	];HLRE
11m0039                               	        MH2[11m0039 03370 640706000550400440020000	FIXM1 $
11m0039 03371 653110005571044220000000	        D[MEM] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ OBUS18 ] LBJUMP
11m0039                               	 [ HRSZ ] CYLEN[FIXM+1] $
11m0039 03372 653110025571044220000000	        D[MA] ROT[ 22 ] MASK[ 22 ] SPEC[ 0 ] ACSEL[AC] DEST[AC AR] COND[ OBUS18 ] LBJUMP
11m0039                               	 [ HRSZ ] NORM $
11m0039 03373 000700000571000440000000	        NOP $
11m0039 03374 531150010161000220000000	        D[MASK 22] ROT[ 0 ] ACSEL[AC] ALU[DORAC] DEST[Q AR ] COND[ -OBUS<0 ] JUMP[HLREM1]
11m0039                               	 CYLEN[ C550 ] $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

11m0039 03375 662104200571044440002032	        D[AR] ROT[22] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
11m0039 03376 640706200550400440030000	        FIXM2 $
11m0039 03377 653110004171044440000000	        D[MEM] ROT[ 22 ] DEST[Q AR] COND[ OBUS18 ] LBJUMP[ HRRES1] CYLEN[FIXM+1] $
11m0040                               	]
11m0040                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

12m0040                               	;------------------------------------------------------------------------------
12m0040                               	;
12m0040                               	;       Bit Test Instructions
12m0040                               	;
12m0040                               	;  Caution:     Instruction dispatch for these instructions is peculiar.
12m0040                               	;
12m0040                               	;------------------------------------------------------------------------------
12m0040                               	
12m0040                               	        .OPCODE[LIST 
12m0040                               	 LIST            ];TRN GROUP
12m0040                               	          D[IR] MASK[18.] ACSEL[AC] ALU[D&AC]
12m0040 03400 532160034621000220602027	            SPEC[MA_PC] DEST[MA] COND[-JCOND] JUMP[MAIN1] C550 $
12m0040 03401 640164620433000440002027	        DOSKIP $
12m0040                               	
12m0040                               	        .OPCODE[LIST 
12m0040                               	 LIST            ];TLN GROUP
12m0040                               	          D[IR] ROT[18.] ACSEL[AC] ALU[D&AC]
12m0040 03402 532160034621044000402027	            SPEC[LEFT&MA_PC] DEST[MA] COND[-JCOND] JUMP[MAIN1] C550 $
12m0040 03403 640164620433000440002027	        DOSKIP $
12m0040                               	
12m0040                               	   .DEFINE T2GRP 12m0040                               	
12m0040                               	;Following code is NOT dispatched to, it is JUMPed to.
12m0040                               	TRZ1:   T2GRP 12m0040 03404 640700035661000220000000	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[-D&AC] DEST[AC] NORM $
12m0040 03405 640164620433000440002027	        DOSKIP $
12m0041                               	]TLZ1:  T2GRP 12m0041 03406 640700035661044000200000	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[-D&AC] DEST[AC] NORM $
12m0041 03407 640164620433000440002027	        DOSKIP $
12m0042                               	]TRO1:  T2GRP 12m0042 03410 640700035561000220000000	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[DORAC] DEST[AC] NORM $
12m0042 03411 640164620433000440002027	        DOSKIP $
12m0043                               	]TLO1:  T2GRP 12m0043 03412 640700035561044000200000	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[DORAC] DEST[AC] NORM $
12m0043 03413 640164620433000440002027	        DOSKIP $
12m0044                               	]TRC1:  T2GRP 12m0044 03414 640700035721000220000000	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[D#AC] DEST[AC] NORM $
12m0044 03415 640164620433000440002027	        DOSKIP $
12m0045                               	]TLC1:  T2GRP 12m0045 03416 640700035721044000200000	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[D#AC] DEST[AC] NORM $
12m0045 03417 640164620433000440002027	        DOSKIP $
12m0046                               	]
12m0046                               	;(No space left before dispatch entry)
12m0046                               	
12m0046                               	        .OPCODE[LIST 
12m0046                               	 LIST            ];TDN GROUP
12m0046 03420 640706000550400440020000	        FIXM1 $
12m0046 03421 452100004621000440000000	        D[MEM] ACSEL[AC] ALU[D&AC] COND[JCOND] LBJUMP[SKMAIN] C600 $
12m0046                               	        .OPCODE[LIST 
12m0046                               	 LIST            ];TSN GROUP
12m0046 03422 640706000550400440020000	        FIXM1 $
12m0046 03423 452100004621044440000000	        D[MEM] ACSEL[AC] ROT[18.] ALU[D&AC] COND[JCOND] LBJUMP[SKMAIN] C600 $
12m0046                               	
12m0046                               	;(Following is not dispatched to.  It probably belongs with MSMAIN, etc.)
12m0046                               	        .PAIR
12m0046                               	. \ 2 + .
12m0047 03424 640160000571000440602027	]SKMAIN:        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

12m0047 03425 640164620433000440002027	        DOSKIP $
12m0047                               	
12m0047                               	AREA342:        ;Recover space from hole in instruction dispatch
12m0047                               	
12m0047                               	  .DEFINE T1GRP 12m0047                               	        .OPCODE[LIST 
12m0047                               	 LIST            ];TRZ GROUP
12m0047                               	        T1GRP 12m0047 03440 512140034621000220003404	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[D&AC] COND[JCOND] JUMP[TRZ1] C550 $
12m0047 03441 640160035661000220602027	        ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[MA_PC] ALU[-D&AC] DEST[AC MA] JUMP[MAIN1]
12m0047                               	 NORM $
12m0048                               	]
12m0048                               	        .OPCODE[LIST 
12m0048                               	 LIST            ];TLZ GROUP
12m0048                               	        T1GRP 12m0048 03442 512140034621044000203406	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[D&AC] COND[JCOND] JUMP[TLZ1] C550 $
12m0048 03443 640160035661044000402027	        ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT&MA_PC] ALU[-D&AC] DEST[AC MA]
12m0048                               	 JUMP[MAIN1] NORM $
12m0049                               	]
12m0049                               	AREA344:        ;Recover space from hole in instruction dispatch
12m0049                               	
12m0049                               	        .OPCODE[LIST 
12m0049                               	 LIST            ];TDZ
12m0049 03460 640706000550400440020000	        FIXM1 $
12m0049 03461 640140000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDZ1] NORM $
12m0049                               	
12m0049                               	        .OPCODE[LIST 
12m0049                               	 LIST            ];TSZ
12m0049 03462 640706000550400440020000	        FIXM1 $
12m0049 03463 640700000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] NORM $
12m0049                               	;       \ /
12m0049                               	;Following is not in instruction dispatch
12m0049 03464 640700005661044440000000	        ACSEL[AC] D[MEM] ROT[18.] ALU[-D&AC] DEST[AC] SHORT $
12m0049 03465 452100004635044440003424	TSZ2:   D[MEM] ROT[18.] ALU[D&Q] COND[JCOND] LBJUMP[SKMAIN] C600 $
12m0049 03466 640700005661000440000000	TDZ1:   ACSEL[AC] D[MEM] ALU[-D&AC] DEST[AC] SHORT $
12m0049 03467 452100004635000440003424	TDZ2:   D[MEM] ALU[D&Q] COND[JCOND] LBJUMP[SKMAIN] C600 $
12m0049                               	
12m0049                               	AREA346:        ;Recover space from hole in instruction dispatch
12m0049                               	
12m0049                               	        .OPCODE[LIST 
12m0049                               	 LIST            ];TRC GROUP
12m0049                               	        T1GRP 12m0049 03500 512140034621000220003414	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[D&AC] COND[JCOND] JUMP[TRC1] C550 $
12m0049 03501 640160035721000220602027	        ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[MA_PC] ALU[D#AC] DEST[AC MA] JUMP[MAIN1]
12m0049                               	 NORM $
12m0050                               	]
12m0050                               	        .OPCODE[LIST 
12m0050                               	 LIST            ];TLC GROUP
12m0050                               	        T1GRP 12m0050 03502 512140034621044000203416	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[D&AC] COND[JCOND] JUMP[TLC1] C550 $
12m0050 03503 640160035721044000402027	        ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT&MA_PC] ALU[D#AC] DEST[AC MA]
12m0050                               	 JUMP[MAIN1] NORM $
12m0051                               	]
12m0051                               	AREA350:        ;Recover space from hole in instruction dispatch
12m0051                               	
12m0051                               	        .OPCODE[LIST 
12m0051                               	 LIST            ];TDC
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

12m0051 03520 640706000550400440020000	        FIXM1 $
12m0051 03521 640140000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDC1] NORM $
12m0051                               	
12m0051                               	        .OPCODE[LIST 
12m0051                               	 LIST            ];TSC
12m0051 03522 640706000550400440020000	        FIXM1 $
12m0051 03523 640700000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] NORM $
12m0051 03524 640140005721044440003465	        ACSEL[AC] D[MEM] ROT[18.] ALU[AC#D] DEST[AC] JUMP[TSZ2] NORM $
12m0051 03525 640140005721000440003467	TDC1:   ACSEL[AC] D[MEM] ALU[AC#D] DEST[AC] JUMP[TDZ2] NORM $
12m0051                               	
12m0051                               	AREA352:        ;Recover space from hole in instruction dispatch
12m0051                               	
12m0051                               	        .OPCODE[LIST 
12m0051                               	 LIST            ];TRO GROUP
12m0051                               	        T1GRP 12m0051 03540 512140034621000220003410	ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[0] ALU[D&AC] COND[JCOND] JUMP[TRO1] C550 $
12m0051 03541 640160035561000220602027	        ACSEL[AC] D[IR] ROT[0] MASK[22] SPEC[MA_PC] ALU[DORAC] DEST[AC MA] JUMP[MAIN1]
12m0051                               	 NORM $
12m0052                               	]
12m0052                               	        .OPCODE[LIST 
12m0052                               	 LIST            ];TLO GROUP
12m0052                               	        T1GRP 12m0052 03542 512140034621044000203412	ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT] ALU[D&AC] COND[JCOND] JUMP[TLO1] C550 $
12m0052 03543 640160035561044000402027	        ACSEL[AC] D[IR] ROT[22] MASK[0] SPEC[LEFT&MA_PC] ALU[DORAC] DEST[AC MA]
12m0052                               	 JUMP[MAIN1] NORM $
12m0053                               	]
12m0053                               	AREA354:        ;Recover space from hole in instruction dispatch
12m0053                               	
12m0053                               	        .OPCODE[LIST 
12m0053                               	 LIST            ];TDO GROUP
12m0053 03560 640706000550400440020000	        FIXM1 $
12m0053 03561 640140000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDO1] NORM $
12m0053                               	
12m0053                               	        .OPCODE[LIST 
12m0053                               	 LIST            ];TSO GROUP
12m0053 03562 640706000550400440020000	        FIXM1 $
12m0053 03563 640700000151000440000000	        ALU[AC] ACSEL[AC] DEST[Q] NORM $
12m0053 03564 640140005561044440003465	        ACSEL[AC] D[MEM] ROT[18.] ALU[DORAC] DEST[AC] JUMP[TSZ2] NORM $
12m0053 03565 640140005561000440003467	TDO1:   ACSEL[AC] D[MEM] ALU[DORAC] DEST[AC] JUMP[TDZ2] NORM $
12m0053                               	
12m0053                               	AREA356:        ;Recover space from hole in instruction dispatch
12m0053                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

13m0053                               	; IOT GROUP -- FOR NOW
13m0053                               	
13m0053                               	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
13m0053                               	;;;;                                                                    ;;;;
13m0053                               	;;;;    CAUTION: Hardware currently does not check for User when doing  ;;;;
13m0053                               	;;;;    IOTs.  Most, but not all, now check it in micro code.  The      ;;;;
13m0053                               	;;;;    instruction dispatch hardware is probably the right place to    ;;;;
13m0053                               	;;;;    check for this, but try to convince Poole of that...            ;;;;
13m0053                               	;;;;                                                                    ;;;;
13m0053                               	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
13m0053                               	
13m0053                               	
13m0053                               	.repeat 0[
13m0053                               	repeat 0
13m0053                               	
13m0053                               	.DEFINE IOTDIS 13m0053                               	.DEFINE IOTDIS
13m0053                               	        ;Bit 14 is guaranteed zero by instruction decode process and therefore
13m0053                               	        ;doubling can be obtained by extraction.   TVR-Apr80
13m0053                               	
13m0053                               	        .OPCODE[LIST 
13m0053                               	 LIST            ];APR & PI
13m0053 03600 665101614571000060020000	        MAPF[2] D[CONST 6] DEST[DEV-ADR] COND[-USER] LBJUMP[APIOT] NORM $
13m0053 03601 000700000571000440000000	        NOP $
13m0053                               	
13m0053                               	        .OPCODE[13m0053                               	LIST 
13m0054                               	 LIST            ]      ILGIOT 13m0054 03602 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03603 000700000571000440000000	        NOP $
13m0054                               	
13m0054                               	        .OPCODE[LIST 
13m0054                               	 LIST            ];UNUSED & MAP
13m0054 03604 640701614571000010020000	        MAPF[2] D[CONST 1] DEST[DEV-ADR] NORM $
13m0054 03605 665100034171032040000000	        D[IR] ROT[15] MASK[4] DEST[Q] COND[-USER] LBJUMP[MAPIOT] NORM $
13m0054                               	
13m0054                               	.REPEAT 7 [I13m0054                               	LGIOT 13m0054 03606 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03607 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03610 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03611 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03612 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03613 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03614 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03615 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03616 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03617 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03620 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03621 000700000571000440000000	        NOP $
13m0054                               	         ]LGIOT 13m0054 03622 000140000571000440002026	 JUMP [MAIN] ]$
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

13m0054 03623 000700000571000440000000	        NOP $
13m0054                               	         ]
13m0054                               	        .OPCODE[LIST 
13m0054                               	 LIST            ];CTY & LPT
13m0054 03624 665101614571000040020000	        MAPF[2] D[CONST 4] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[CTYIOT] $
13m0054 03625 000700000571000440000000	        NOP $
13m0054                               	
13m0054                               	        ILGIOT 13m0054 03626 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03627 000700000571000440000000	         NOP $
13m0054                               	        ILGIOT 13m0054 03630 000140000571000440002026	 JUMP [MAIN] ]$
13m0054 03631 000700000571000440000000	         NOP $
13m0054                               	
13m0054                               	;DISK CTRL IOTS-- 140 - 174
13m0054                               	
13m0054                               	        .OPCODE[LIST 
13m0054                               	 LIST            ];DISK CTRL IOTS-- OPCODES 715 TO 724
13m0054 03632 005141614571000103400000	        D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
13m0054                               	         MAPF[0] D[IOD] DEST[MEMSTO] 
13m0054 03633 022104230571000440002024	                COND[-MA-AC] LBJUMP[SMAIN] $
13m0054 03634 005141614571000103400000	        D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
13m0054                               	         MAPF[1] D[IOD] DEST[MEMSTO] 
13m0054 03635 022104230571000440012024	                COND[-MA-AC] LBJUMP[SMAIN] $
13m0054 03636 005141614571000103400000	        D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
13m0054                               	         MAPF[2] D[IOD] DEST[MEMSTO] 
13m0054 03637 022104230571000440022024	                COND[-MA-AC] LBJUMP[SMAIN] $
13m0054 03640 005141614571000103400000	        D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
13m0054                               	         MAPF[3] D[IOD] DEST[MEMSTO] 
13m0054 03641 022104230571000440032024	                COND[-MA-AC] LBJUMP[SMAIN] $
13m0054 03642 000046000550400440020000	        FIXML PUSHJ[SET-DSK-OUT] $ ;ld cmd -- opcode 721
13m0054 03643 000140400571000443042026	         MAPF[4] d[ar] DEST[2]  DEST-A-MEM JUMP[MAIN] $
13m0054 03644 000046000550400440020000	        FIXML PUSHJ[SET-DSK-OUT] $
13m0054 03645 000160000571000440652027	         MAPF[5] DEST[MA]  SPEC[MA_PC]  JUMP[MAIN1] $
13m0054 03646 000046000550400440020000	        FIXML PUSHJ[SET-DSK-OUT] $
13m0054 03647 000160000571000440662027	         MAPF[6] DEST[MA]  SPEC[MA_PC]  JUMP[MAIN1] $
13m0054 03650 000046000550400440020000	        FIXML PUSHJ[SET-DSK-OUT] $
13m0054 03651 000160000571000440672027	         MAPF[7] DEST[MA]  SPEC[MA_PC]  JUMP[MAIN1] $
13m0054                               	        
13m0054                               	;TAPE IOTS - OPCODES 725 - 732 --Dispatch entries on page headed ";TAPE DISP"
13m0054                               	
13m0054                               	
13m0054                               	.OPCODE[13m0054                               	LIST 
13m0055                               	 LIST            ]
13m0055                               	  .REPEAT  4 [I13m0055                               	LGIOT 13m0055 03666 000140000571000440002026	 JUMP [MAIN] ]$ ;SKIP OPCODES 733 - 736
13m0055 03667 000700000571000440000000	        NOP $
13m0055                               	  ]LGIOT 13m0055 03670 000140000571000440002026	 JUMP [MAIN] ]$ ;SKIP OPCODES 733 - 736
13m0055 03671 000700000571000440000000	        NOP $
13m0055                               	  ]LGIOT 13m0055 03672 000140000571000440002026	 JUMP [MAIN] ]$ ;SKIP OPCODES 733 - 736
13m0055 03673 000700000571000440000000	        NOP $
13m0055                               	  ]LGIOT 13m0055 03674 000140000571000440002026	 JUMP [MAIN] ]$ ;SKIP OPCODES 733 - 736
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

13m0055 03675 000700000571000440000000	        NOP $
13m0055                               	  ]     .OPCODE[LIST 
13m0055                               	 LIST            ];DLS iot's (DLS is device 370)
13m0055                               	 .REPEAT 1 - DLS [ 13m0055                               	;1 - DLS
13m0055                               	
13m0055                               	   ;skip space for disk cono,coni, etc. OPS 740 - 743
13m0055                               	   ;locs 3700 to 3707
13m0055                               	          ; these dispatch entries are on dsk page.
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Tymnet opcodes (or undefined)
13m0055                               	 .repeat 1 - TYMNET - DR11P [
13m0055                               	
13m0055                               	.repeat tymnet [
13m0055                               	   ;skip space for TYMNET IOTS.  OPS 744 - 747
13m0055                               	          ; these dispatch entries are on TYMNET page.
13m0055                               	    ]
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ] ;READ ECC INFO
13m0055 03720 662104244571000442402032	        D[11] A-MEM-APR DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
13m0055                               	         ;Get info on last ECC error from A-MEM(1), store in eff. adr.
13m0055 03721 000700000571000440000000	        NOP $
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Undefined
13m0055                               	        ILGIOT 13m0055 03722 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03723 000700000571000440000000	        NOP $
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];
13m0055                               	.REPEAT 1 - VC [
13m0055                               	        ILGIOT 13m0055 03724 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03725 000700000571000440000000	        NOP $
13m0055                               	].REPEAT 1 - VC
13m0055                               	.REPEAT VC [    13m0055                               	.REPEAT VC
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Undefined
13m0055                               	        ILGIOT 13m0055 03726 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03727 000700000571000440000000	        NOP $
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Undefined
13m0055                               	        ILGIOT 13m0055 03730 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03731 000700000571000440000000	        NOP $
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];IMP (BBN), device code 550
13m0055                               	.REPEAT 1 - IMP [I13m0055                               	LGIOT 13m0055 03732 000140000571000440002026	 JUMP [MAIN] ]$
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

13m0055 03733 000700000571000440000000	        NOP $
13m0055                               	]1 - IMP
13m0055                               	
13m0055                               	.REPEAT IMP [   13m0055                               	IMP
13m0055                               	
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];Undefined
13m0055                               	.REPEAT (757 - 756 + 1) [I13m0055                               	LGIOT 13m0055 03734 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03735 000700000571000440000000	        NOP $
13m0055                               	 ]LGIOT 13m0055 03736 000140000571000440002026	 JUMP [MAIN] ]$
13m0055 03737 000700000571000440000000	        NOP $
13m0055                               	 ]
13m0055                               	TIMER-IOTS:
13m0055                               	  
13m0055                               	        .OPCODE[LIST 
13m0055                               	 LIST            ];760:765
13m0055                               	.REPEAT 0 * (1 - TIMER) * (765 - 760 + 1) [I13m0055                               	;;; : TIMER-IOTS + 12.  ;LEAVE SPACE FOR OPCODES 760-765
13m0055                               	;*** This is an unreasonably large waste of opcode space.  It should dispatch
13m0055                               	;*** on the AC field at least if normal PDP-10 I/O opcodes aren't suitable.
13m0055                               	;*** Furthermore, this kind of opcode has no chance of being properly
13m0055                               	;*** disassembled by DDT.                                       TVR-Apr80
13m0055                               	
13m0055                               	        .OPCODE[13m0055                               	LIST 
13m0056                               	 LIST            ].REPEAT STANSW [      13m0056                               	.REPEAT 1 - STANSW [C13m0056 03770 000140100571000440002026	URRENTLY-UNUSED[1]  JUMP[MAIN] $
13m0056                               	
13m0056 03771 000700000571000440000000	        NOP $
13m0056                               	]
13m0056                               	        .OPCODE[13m0056                               	LIST 
13m0057                               	 LIST            ]
13m0057                               	 .REPEAT 1 [
13m0057                               	        
13m0057                               	;CAM -- A COPY OF CAM WHICH HALTS IF IT DOESN'T SKIP.  WOW !
13m0057 03772 640706000550400440020000	        FIXM1 $
13m0057 03773 452140004463000440002622	        D[MEM] ACSEL[AC] ALU[AC-D] COND[JCOND] JUMP[DOSKP1] C600 $
13m0057 03774 000140104571000440003774	        D[MEM] CURRENTLY-UNUSED[1] JUMP[.] $
13m0057                               	
13m0057                               	;;DSKWT  -- DELAY UNTIL DISK NOT BUSY
13m0057                               	;       JUMP[DSKWT1] $          ;OPCODE 775
13m0057                               	;       NOP $
13m0057                               	;       NOP $
13m0057                               	;       NOP $
13m0057                               	
13m0057                               	]
13m0057                               	.REPEAT 0 [ 13m0057                               	
13m0057                               	        .OPCODE[LIST 
13m0057                               	 LIST            ];OPCODE 777 --- MAKE IT A UUO
13m0057                               	;;;     JUMP[MUUO] $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

13m0057 03776 640150020171000440002125	        UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$             ;Illegal instruction
13m0057                               	 rather than an IOT.  It's an
13m0057                               	                        ;easy thing to stumble upon in buggy programs (or
13m0057                               	                        ;hardware), being it is most common negative integers
13m0057                               	
13m0057                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

14m0057                               	;MSTART MSTRT1 BADPC ILDB1 ILDB2 IDPB1 IDPB2 ILDB3 LDB1 LDB5 LDB2 LDB4 DPB1 DPB5 DPB7
14m0057                               	 IDPB3 DPB2 DPB4 BIIH1 BIIH BII IBP1 IBT1
14m0057                               	;NON DISPATCH STUFF HERE
14m0057                               	
14m0057                               	        .ORG[14m0057                               	XLIST
14m0058                               	 LIST ]; INIT THINGS -- INITIALIZE MACHINE, POWER-UP COMES HERE.
14m0058                               	
14m0058                               	MSTART:
14m0058 04000 000140000571000440000000	JUMP[MSTRT1] $  ;to help operator start from switches (KEEP THIS SIMPLE -- MLB)
14m0058                               	
14m0058                               	        .USE[14m0058                               	XLIST
14m0059                               	 LIST ]MSTRT1:
14m0059                               	
14m0059                               	;******* This code to be made a subroutine to allow machine resetting *******
14m0059                               	;******* to be done by auto-loading and via CONO APR,20000  TVR-Mar80 *******
14m0059                               	
14m0059                               	.REPEAT 1 - CROCK [     14m0059                               	1 - CROCK
14m0059                               	
14m0059                               	
14m0059                               	;The following code sets up the AMEM zero vectors for various random devices.
14m0059                               	;this is a complete CROCK!  The device reset subroutines should do this!!
14m0059                               	;I plan to fix this soon (when I have time, ha ha)      -- MLB 23JAN80
14m0059                               	;$*$*$ Fix this soon.   TVR-Apr80
14m0059                               	
14m0059 04001 640702414171014200000000	        D[CONST 20] ROT[6] DEST[Q CLR-DEV-FROM-INTR] NORM $
14m0059                               	
14m0059                               	        .DEFINE AMLD2 14m0059                               	        AMLD2 14m0059 04002 640701614571000010000000	D[CONST 1] DEST[DEV-ADR] NORM $
14m0059 04003 640700014575000623000000	        D[CONST 62] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTERRUPTS FROM DEV 1 (SWITCHES) GO TO 2062
14m0059 04004 640700014171014210000000	        D[CONST 21] ROT[6] DEST[Q] NORM $
14m0059                               	;;;     AMLD2 [ 4 0 30 ] ; INTERRUPTS FROM DEV 4 GO TO 2130 [Now set at CTYRST]
14m0059                               	        AMLD2 14m0059 04005 640701614571000050000000	D[CONST 5] DEST[DEV-ADR] NORM $
14m0059 04006 640700014575000343000000	        D[CONST 34] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTRS FROM DEV 5 GO TO 2134
14m0059                               	        AMLD2 14m0059 04007 640701614571000060000000	D[CONST 6] DEST[DEV-ADR] NORM $
14m0059 04010 640700014575000413000000	        D[CONST 41] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTS FROM DEV 6 GO TO 2141
14m0059                               	        AMLD2 14m0059 04011 640701614571000070000000	D[CONST 7] DEST[DEV-ADR] NORM $
14m0059 04012 640700014575000503000000	        D[CONST 50] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTS FROM DEV 7 GO TO 2150
14m0059                               	        AMLD2 14m0059 04013 640701614571000100000000	D[CONST 10] DEST[DEV-ADR] NORM $
14m0059 04014 640700014575000563000000	        D[CONST 56] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; INTS FROM DEV 10 GO TO 2156
14m0059                               	.REPEAT DLS [
14m0059                               	        AMLD2 14m0059 04015 640701614571000200000000	D[CONST DLSDEV] DEST[DEV-ADR] NORM $
14m0059 04016 640700014575000373000000	        D[CONST 37] ALU[DORQ] DEST-A-MEM DEST[0] NORM $
14m0059                               	]; DLS GOES TO 2137
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

14m0059                               	]DLS
14m0059                               	;;      the IMP reset code takes care of this for itself!!
14m0059                               	
14m0059                               	;;; Moved code to set MAP-DISP to MAPRST (due to lack of space between
14m0059                               	;;; 4000:4777).                                           TVR-Apr80
14m0059 04017 640705400615000440000000	        ALU[0] DEST[CRYOV] NORM $
14m0059 04020 640703600615000440000000	        ALU[0] DEST[CLR-MI-ERR] NORM $
14m0059 04021 640700614571000002600000	        D[CONST 0] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
14m0059 04022 640140000571000440000000	        JUMP[RESLOP] NORM $
14m0059                               	
14m0059 04023 000140000571000440002026	BADPC:  BADLOC $
14m0059                               	
14m0059                               	;------------------------------------------------------------------------------
14m0059                               	;$*$*$* THIS JUNK HAS GOT TO MOVE! TVR-Apr80
14m0059                               	;
14m0059                               	;Some of it also needs commenting but this must be postponed until after CCRMA
14m0059                               	;merge.
14m0059                               	;------------------------------------------------------------------------------
14m0059                               	
14m0059                               	        .USE[14m0059                               	XLIST
14m0060                               	 LIST ] .PAIR   . \ 2 + .
14m0060                               	];Goes to second if HALF is not set
14m0060 02602 640141400571030060000000	ILDB1:  D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[ILDB2] NORM $
14m0060                               	                ;Extract S field.  Being HALF was set, don't increment
14m0060 02603 657051400571030060000000	        D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $
14m0060                               	                ;Extract S field.  Increment word if byte overflow will happen
14m0060 02604 662154200077074440002606	        D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] -MA-AC JUMP[. + 2] NORM $
14m0060                               	                ;SUB S FROM P
14m0060                               	                ;Increment byte pointer, no overflow possible now
14m0060                               	                ;Store into memory, check for store into AC
14m0060 02605 640700005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] $
14m0060                               	                ;Store is into an AC, write it there.
14m0060 02606 664120000555000440000000	ILDB2:  ALU[Q] DEST[MA] COND[-MEM-IDX-IND] LBJUMP[ILDB3] NORM $
14m0060                               	                ;Fetch data, perhaps.  Maybe also do indexing or indirection
14m0060                               	        .PAIR
14m0060                               	. \ 2 + .
14m0061 02610 640141400571030060000000	]IDPB1: D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[IDPB2] NORM $
14m0061 02611 657051400571030060000000	        D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $;GET S FLD,
14m0061                               	 OVFL?
14m0061 02612 662154200077074440002614	        D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $;SUB S
14m0061                               	 FROM P
14m0061 02613 640700005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] $
14m0061 02614 664120000555000440000000	IDPB2:  ALU[Q] DEST[MA] COND[-MEM-IDX-IND] LBJUMP[IDPB3] NORM $
14m0061                               	
14m0061                               	        .PAIR   . \ 2 + .
14m0061                               	];Goes to second if not indexing or indirecting
14m0061 02616 640040000571000440020000	ILDB3:  MAPF[NORM-RD] PUSHJ[BIIH] NORM $;HANDLE IDX-IND
14m0061                               	        MAPF[BYTE-ILD] ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD]
14m0061 02617 640146000550400440110000	                        JUMP[LDB2] CYLEN[FIXM] $
14m0061                               	                ;Finish read of data word, then go extract byte
14m0061                               	
14m0061                               	        .USE[14m0061                               	XLIST
14m0062                               	 LIST ] .PAIR   . \ 2 + .
14m0062                               	];Goes to second if not indexing or indirecting
14m0062 02624 640040000571000440020000	LDB1:   MAPF[2] PUSHJ[BII] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

14m0062 02625 640706000550400440020000	LDB5:   FIXM1 $ ;Also gets here from XBY13
14m0062 02626 640701400571030060000000	        D[AR] ROT[14] MASK[6] DEST[MASKR] SHORT $
14m0062                               	                ;GET S FLD
14m0062 02627 640700014171000442200000	        SPEC[CLR-HALF] D[CONST 44] DEST[Q] SHORT $
14m0062 02630 640701200077014060000000	        D[AR] ROT[6] MASK[6] ALU[Q-D] DEST[Q ROTR] SHORT $
14m0062                               	                ;SUB P FLD FROM 44
14m0062 02631 531140000477030060000000	        D[AR] ROT[12.] MASK[6] ALU[Q-D] COND[-OBUS<0] JUMP[LDB4] C550 $
14m0062                               	                ;Also, subtract S field.  If result is positive, then byte
14m0062                               	                ;of size S fits with at least P bits remaining in the right
14m0062                               	                ;side of the word
14m0062 02632 640141400555000440000000	        ALU[Q] DEST[MASKR] JUMP[LDB4] NORM $
14m0062                               	                ;Byte does not fit!!!  We want only the stuff to the left
14m0062                               	                ;of postion P, which is 36.-P bits, coincidentally, the same
14m0062                               	                ;size as the rotation
14m0062                               	;S field is already set up.  Set up P field and extract data from word.
14m0062 02633 640700014171000442200000	LDB2:   SPEC[CLR-HALF] D[CONST 44] DEST[Q] SHORT $
14m0062 02634 640701200477014060000000	        D[AR] ROT[6] MASK[6] ALU[Q-D] DEST[ROTR] SHORT $
14m0062                               	                ;SUB P FLD FROM 44
14m0062 02635 640160005571201000602027	LDB4:   D[MEM] ACSEL[AC] ROT[R] MASK[R] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $; DO
14m0062                               	 THE LDB
14m0062                               	
14m0062                               	
14m0062                               	        .PAIR
14m0062                               	. \ 2 + .
14m0063 02636 640040000571000440020000	]DPB1:  MAPF[2] PUSHJ[BII] NORM $
14m0063                               	DPB5:           ;Also gets here from XBY13
14m0063                               	;;;     FIXM2 $ ;Wrong thing for WAITS.
14m0063                               	          MAPF[BYTE-IDP] CYLEN[FIXM]
14m0063 02637 640146200550400440120000	                        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] JUMP[DPB7] $
14m0063                               	                ;KA/KL set half flag even on DPB.  They would also set read
14m0063                               	                ;failure, not write, in the case of not in map; but we don't
14m0063                               	                ;have time to be particular.                    TVR-Apr80
14m0063                               	
14m0063                               	        .USE[14m0063                               	XLIST
14m0064 04024 640701400571030060000000	 LIST ]DPB7:    D[AR] ROT[12.] MASK[6] DEST[MASKR] SHORT $
14m0064                               	                ;Fetch S field.
14m0064 04025 640701200171014062200000	        SPEC[CLR-HALF] D[AR] ROT[6] MASK[6] DEST[Q ROTR] SHORT $
14m0064                               	                ;Fetch P field.
14m0064 04026 640700014137000440000000	        D[CONST 44] ALU[D-Q] DEST[Q] SHORT $
14m0064                               	                ;Calculate 36-P, which is maximum number of bits in this byte
14m0064 04027 531140000477030060000000	        D[AR] ROT[12.] MASK[6] ALU[Q-D] COND[-OBUS<0] JUMP[DPB4] C550 $
14m0064                               	                ;Does this byte fit?  I.e. 36-P-S is non-negative.  If so,
14m0064                               	                ;use this mask field
14m0064 04030 640141400555000440000000	        ALU[Q] DEST[MASKR] JUMP[DPB4] NORM $
14m0064                               	                ;Setup mask which is everything to the left of the position
14m0064                               	                ;designated by P.
14m0064                               	
14m0064                               	        .USE[14m0064                               	XLIST
14m0065                               	 LIST ] .PAIR
14m0065                               	. \ 2 + .
14m0066 02666 640040000571000440020000	]IDPB3: MAPF[2] PUSHJ[BIIH] NORM $;HANDLE IDX-IND
14m0066                               	        MAPF[BYTE-IDP] CYLEN[FIXM]
14m0066 02667 640706200550400440120000	                ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] $
14m0066 02670 640701400571030060000000	        D[AR] ROT[14] MASK[6] DEST[MASKR] SHORT $
14m0066 02671 640701200171014062200000	DPB2:   SPEC[CLR-HALF] D[AR] ROT[6] MASK[6] DEST[Q ROTR] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

14m0066 02672 640710010621001000000000	DPB4:   D[2] MASK[R] ACSEL[AC] ALU[D&AC] DEST[AR] SHORT $;GET BYTE
14m0066 02673 640700004171000440000000	        D[MEM] DEST[Q] SHORT $; GET DEST WORD
14m0066 02674 640700010275201000000000	        D[2] MASK[R] ROT[R] ALU[-D&Q] DEST[Q] SHORT $;CLR DEST BYTE
14m0066 02675 662104200575200440002032	        D[AR] ROT[R] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$;DO
14m0066                               	 IT
14m0066                               	
14m0066                               	.DEFINE BIIMAC[14m0066                               	        .USE[14m0066                               	XLIST
14m0067                               	 LIST ]BIIH:    BIIMAC 14m0067 02642 510141000571044040000000	D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[BII1] C550 $
14m0067                               	                ;IDX FLD
14m0067 02643 640720024420000220000000	        D[MA] ACSEL[REG] MASK[18.] ALU[D+AC] DEST[MA] SHORT $
14m0067                               	                ;DO INDEXING
14m0067 02644 550300000571034010020000	        D[AR] ROT[16] MASK[1] MAPF[2] COND[OBUS=0] POPJ CYLEN[C500] $
14m0067                               	                ;LEAVEIF NO IND
14m0067 02645 640706000550400440130000	BII1:   ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BYTE-IND] CYLEN[FIXM] $
14m0067 02646 564320004171000270000000	        D[MEM] MASK[27] DEST[Q MA] COND[-MEM-IDX-IND] POPJ CYLEN[C500] $
14m0067                               	                ;GET INDIRECT WORD, LEAVE IF NO MORE IND OR IDX
14m0067 02647 640710000571030140020000	        D[AR] ROT[14] MASK[14] DEST[AR] MAPF[2] NORM $
14m0067 02650 640150000175060440002642	        D[AR] ROT[30] ALU[DORQ] DEST[Q AR] JUMP[BIIH] NORM $
14m0068                               	]BII:   BIIMAC 14m0068 02651 510141000571044040000000	D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[BII2] C550 $
14m0068                               	                ;IDX FLD
14m0068 02652 640720024420000220000000	        D[MA] ACSEL[REG] MASK[18.] ALU[D+AC] DEST[MA] SHORT $
14m0068                               	                ;DO INDEXING
14m0068 02653 550300000571034010020000	        D[AR] ROT[16] MASK[1] MAPF[2] COND[OBUS=0] POPJ CYLEN[C500] $
14m0068                               	                ;LEAVEIF NO IND
14m0068 02654 640706000550400440020000	BII2:   ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-RD] CYLEN[FIXM] $
14m0068 02655 564320004171000270000000	        D[MEM] MASK[27] DEST[Q MA] COND[-MEM-IDX-IND] POPJ CYLEN[C500] $
14m0068                               	                ;GET INDIRECT WORD, LEAVE IF NO MORE IND OR IDX
14m0068 02656 640710000571030140020000	        D[AR] ROT[14] MASK[14] DEST[AR] MAPF[2] NORM $
14m0068 02657 640150000175060440002651	        D[AR] ROT[30] ALU[DORQ] DEST[Q AR] JUMP[BII] NORM $
14m0069                               	]
14m0069                               	        .USE[14m0069                               	XLIST
14m0070                               	 LIST ] .PAIR   . \ 2 + .
14m0070                               	];Skip if AC=0
14m0070 04032 640150020171000440002125	IBP1:   UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$     ;Non-zero AC implies ADJBP.  We
14m0070                               	 don't, yet.
14m0070 04033 657050000571030060000000	        D[AR] ROT[14] MASK[6] DEST[AR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $;GET S FLD, OVFL?
14m0070                               	
14m0070                               	                ;Zero AC.  Do ordinary increment byte pointer.
14m0070                               	                ;PUSHJ if we are about to overflow a word.
14m0070 04034 662104200077074440002032	        D[AR] ROT[36] ALU[Q-D] DEST[Q MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
14m0070                               	                ;Finish updating byte position part of pointer
14m0070                               	
14m0070                               	;Increment byte pointer which crosses a word boundary
14m0070 04035 640700010235000360000000	IBT1:   D[MASK 36] ALU[D&Q] DEST[Q] SHORT $
14m0070 04036 640300014037074440000000	        D[CONST 44] ROT[36] ALU[D+Q+1] DEST[Q] POPJ NORM $
14m0070                               	                ;NEW P FLD OF 44, ADD 1 TO ADR
14m0070                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

15m0070                               	;IMUL1 IMUL2 IMUL3 MUL1 MUL2 MUL3 DOIMUL MSETOV DOMMUL DOMUL DOMUL1 DOMUL4 IDIV1 IDIV2
15m0070                               	 IDIV3 DIV1 DIV2 DIV3 DODDIV DODIV DODIV1 DODIV3 DODIV2 STOVFQ DODIV4 DODIV6 DODIV5
15m0070                               	
15m0070 04037 640050001215000440000000	IMUL1:  ALU[0] DEST[AR O_AC] PUSHJ[DOIMUL] NORM $       ;0 TO AC,AC TO AR
15m0070 04040 640140001555000440002026	        ALU[Q] DEST[AC] JUMP[MAIN] NORM $
15m0070 04041 640050001215000440000000	IMUL2:  ALU[0] DEST[AR O_AC] PUSHJ[DOIMUL] NORM $       ;0 TO AC
15m0070 04042 640700001571000440000000	        D[AR] DEST[AC] NORM $
15m0070 04043 662104200555000440002032	        ALU[Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0070                               	
15m0070 04044 640050001215000440000000	IMUL3:  ALU[0] DEST[AR O_AC] PUSHJ[DOIMUL] NORM $
15m0070 04045 662104201555000440002032	        ALU[Q] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0070                               	
15m0070 04046 640050001215000440000000	MUL1:   ALU[0] DEST[AR O_AC] PUSHJ[DOMMUL] NORM $
15m0070 04047 640140001555400440002026	        ACSEL[AC+1] ALU[Q] DEST[AC] JUMP[MAIN] NORM $
15m0070                               	
15m0070 04050 640050001215000440000000	MUL2:   ALU[0] DEST[AR O_AC] PUSHJ[DOMMUL] NORM $
15m0070 04051 662104201171000440002032	        D[AR] DEST[O_AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0070 04052 640050001215000440000000	MUL3:   ALU[0] DEST[AR O_AC] PUSHJ[DOMMUL] NORM $
15m0070 04053 640700001555400440000000	        ACSEL[AC+1] ALU[Q] DEST[AC] NORM $
15m0070 04054 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0070                               	
15m0070 04055 640040000571000440000000	DOIMUL: PUSHJ[DOMUL] NORM $
15m0070 04056 550300000551000440000000	        ALU[AC] COND[OBUS=0] POPJ CYLEN[C500] $; NO OV IF 0
15m0070 04057 550300000751000440000000	        ALU[NOTAC] COND[OBUS=0] POPJ CYLEN[C500] $; NO OV IF -1
15m0070 04060 640700021571000440000000	MSETOV: D[PC] DEST[AC] SHORT $; GET FLAGS
15m0070 04061 640305414561106010000000	MSTOV1: D[CONST 1] ROT[43] ALU[DORAC] DEST[CRYOV] NORM POPJ $; SET OV
15m0070 04062 570140000735000440000000	DOMMUL: D[AR] ALU[D#Q] COND[-OBUS=0] JUMP[DOMUL] CYLEN[C500] $; NO OV IF DIFF OPERS
15m0070 04063 570140014735106010000000	        D[CONST 1] ROT[43] ALU[D#Q] COND[-OBUS=0] JUMP[DOMUL] CYLEN[C500] $; J IF NOT
15m0070                               	 -2**35
15m0070 04064 640040000571000440004060	        PUSHJ[MSETOV] NORM $;SET OV
15m0070 04065 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
15m0070 04066 640740014571000420000000	DOMUL:  D[CONST 42] LLOAD NORM $        ;LOOP 35 TIMES
15m0070                               	
15m0070                               	DOMUL1: D[AR] ALU[MULAC+D] DEST[D4] MASK[3]
15m0070 04067 640240002021000030004067	                        LOOP[DOMUL1] NORM $ ;SHIFT, END-COND MUL; SOJGE, SH RT
15m0070                               	                ;This shifts right, with the low order bit of the partial
15m0070                               	                ;product being saved in Q.  At the same time, shift out of Q
15m0070                               	                ;a bit of the multiplier (and somehow??? the hardware uses this
15m0070                               	                ;to decide whether to add or not???)
15m0070                               	                ;MASK field specifies what gets shifted into AC, in this case,
15m0070                               	                ;(ALU OV) XOR (-OUT<0)
15m0070                               	        D[AR] ALU[MULAC+D] DEST[D4] MASK[3]
15m0070 04070 634140002021000030004072	                        COND[-Q0-35] JUMP[. + 2] CYLEN[C450] $ ;J IF QUOT WAS +
15m0070                               	                ;Do last step of multiply. Jump on sign of multiplier(?)
15m0070                               	        D[AR] ALU[MULAC-D] DEST[D7]
15m0070 04071 640140003443000440004073	                        JUMP[. + 2] NORM $ ; DEST AC SH LFT, ALU=1, ALU S=0
15m0070                               	                ;Multiplier was positive... ???: Shift left to make properly
15m0070                               	                ;signed result, with low order bit coming from Q0 (i think???)
15m0070 04072 640700003545000440000000	        ALU[SH-AC] DEST[D7] NORM $ ;DEST AC SH LFT
15m0070                               	                ;SINCE DEST IS >3, ALU[QORAC] IS ALU[AC]
15m0070                               	                ;Multiplier was negative... ???
15m0070 04073 551100000551000440000000	        ALU[AC] COND[OBUS<0] LBJUMP[DOMUL4] CYLEN[C500] $
15m0070                               	                ;Decide what sign should be in the low order result.
15m0070                               	
15m0070                               	        .PAIR
15m0070                               	. \ 2 + .
15m0071 04074 640300010235000430000000	]DOMUL4:        D[MASK 35.] ALU[D&Q] DEST[Q] POPJ NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

15m0071                               	                ;Positive.  Turn off Q0, which was copied into AC35.
15m0071 04075 640300014175106010000000	        D[CONST 1] ROT[35.] ALU[DORQ] DEST[Q] POPJ NORM $
15m0071                               	                ;Negative.  Set Q0 so the number is negative (Q0 was copied into
15m0071                               	                ;AC35).
15m0071                               	
15m0071       740000000000000000000000	  CCC1  = SHORT $       ;Apparently used as a NO-OP for macros below. TVR-Apr80
15m0071       777740000000000000007777	  MEMST1 = MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$     ;Store to memory. (Cause macro
15m0071                               	 expansion now, rather
15m0071                               	                        ;than in macro call.)
15m0071                               	
15m0071                               	.DEFINE DMACFN 15m0071                               	.DEFINE DMAC2 15m0071                               	.DEFINE DMAC1 15m0071                               	
15m0071                               	IDIV1:  DMAC1
15m0071                               	.PAIR
15m0071                               	. \ 2 + .
15m0072 04076 640140001741000440004100	]       ALU[-1] DEST[AC] JUMP[. + 2] NORM $
15m0072 04077 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
15m0072 04100 640710004721000440000000	        D[MEM] ALU[D#AC] DEST[AR] SHORT $
15m0072 04101 640700200571002010000000	        D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
15m0072 04102 640050000555000440000000	        ALU[Q] DEST[AR] PUSHJ[DODIV] NORM $
15m0072                               	]       DMACFN[15m0072 04103 640710001155000440000000	ALU[Q] D[AR] DEST[O_AC AR] SHORT $
15m0072 04104 640160001571400440602027	        ACSEL[AC+1] D[AR] ALU[D] DEST[AC MA] DOM1 $
15m0072 04105 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0073                               	]IDIV2: DMAC1
15m0073                               	.PAIR
15m0073                               	. \ 2 + .
15m0074 04106 640140001741000440004110	]       ALU[-1] DEST[AC] JUMP[. + 2] NORM $
15m0074 04107 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
15m0074 04110 640710004721000440000000	        D[MEM] ALU[D#AC] DEST[AR] SHORT $
15m0074 04111 640700200571002010000000	        D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
15m0074 04112 640050000555000440000000	        ALU[Q] DEST[AR] PUSHJ[DODIV] NORM $
15m0074                               	]       DMACFN[15m0074 04113 640710001171000440000000	ALU[D] D[AR] DEST[O_AC AR] SHORT $
15m0074 04114 662114200555400440002032	        ACSEL[AC+1] D[AR] ALU[Q] DEST[MEMSTO AR] MEMST1 $
15m0074 04115 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0075                               	]IDIV3: DMAC1
15m0075                               	.PAIR
15m0075                               	. \ 2 + .
15m0076 04116 640140001741000440004120	]       ALU[-1] DEST[AC] JUMP[. + 2] NORM $
15m0076 04117 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
15m0076 04120 640710004721000440000000	        D[MEM] ALU[D#AC] DEST[AR] SHORT $
15m0076 04121 640700200571002010000000	        D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
15m0076 04122 640050000555000440000000	        ALU[Q] DEST[AR] PUSHJ[DODIV] NORM $
15m0076                               	]       DMACFN[15m0076 04123 640710001155000440000000	ALU[Q] D[AR] DEST[O_AC AR] SHORT $
15m0076 04124 640700001571400440000000	        ACSEL[AC+1] D[AR] ALU[D] DEST[AC 0] CCC1 $
15m0076 04125 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0077                               	]DIV1:  DMAC2
15m0077 04126 640050004721000440000000	D[MEM] ALU[D#AC] DEST[AR] PUSHJ[DODDIV] NORM $
15m0078                               	]       DMACFN[15m0078 04127 640710001155000440000000	ALU[Q] D[AR] DEST[O_AC AR] SHORT $
15m0078 04130 640160001571400440602027	        ACSEL[AC+1] D[AR] ALU[D] DEST[AC MA] DOM1 $
15m0078 04131 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0079                               	]DIV2:  DMAC2
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

15m0079 04132 640050004721000440000000	D[MEM] ALU[D#AC] DEST[AR] PUSHJ[DODDIV] NORM $
15m0080                               	]       DMACFN[15m0080 04133 640710001171000440000000	ALU[D] D[AR] DEST[O_AC AR] SHORT $
15m0080 04134 662114200555400440002032	        ACSEL[AC+1] D[AR] ALU[Q] DEST[MEMSTO AR] MEMST1 $
15m0080 04135 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0081                               	]DIV3:  DMAC2
15m0081 04136 640050004721000440000000	D[MEM] ALU[D#AC] DEST[AR] PUSHJ[DODDIV] NORM $
15m0082                               	]       DMACFN[15m0082 04137 640710001155000440000000	ALU[Q] D[AR] DEST[O_AC AR] SHORT $
15m0082 04140 640700001571400440000000	        ACSEL[AC+1] D[AR] ALU[D] DEST[AC 0] CCC1 $
15m0082 04141 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
15m0083                               	]
15m0083 04142 640700200571002010000000	DODDIV: D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
15m0083 04143 640710002545000010000000	        ALU[SH-AC] DEST[AR D5] MASK[1] NORM $
15m0083 04144 510140000571000010004146	        D[AR] MASK[1] COND[OBUS=0] JUMP[. + 2] C550 $
15m0083 04145 640140014175106010004147	        D[CONST 1] ROT[43] ALU[DORQ] DEST[Q] JUMP[. + 2] NORM $
15m0083 04146 640700010235000430000000	        D[MASK 43] ALU[D&Q] DEST[Q] NORM $
15m0083                               	;------------------------------------------------------------------------------
15m0083                               	;
15m0083                               	;       Single Precision Divide (and continuation of double precision)
15m0083                               	;
15m0083                               	;       (Reminder: Quotient, Remainder = Dividend / Divisor)
15m0083                               	;
15m0083                               	;Where we get here:
15m0083                               	;    MEM        36 bit signed divisor
15m0083                               	;    AC         High order dividend (0 or -1 for single precision)
15m0083                               	;    Q          Low order dividend
15m0083                               	;    IR<35>     Sign of dividend XOR sign of divisor
15m0083                               	;    AR         Sign of dividend and original contents of AC
15m0083                               	;  
15m0083                               	;------------------------------------------------------------------------------
15m0083 04147 531140004571000440000000	DODIV:  D[MEM] COND[-OBUS<0] JUMP[DODIV1] C550 $
15m0083                               	                ;Jump if divide by positive number
15m0083 04150 640704404473000440000000	        D[MEM] ALU[0-D] DEST[HOLD] SHORT $
15m0083                               	                ;Take absolute value
15m0083 04151 631140000551000440000000	DODIV1: ALU[AC] COND[-OBUS<0] JUMP[DODIV2] CYLEN[C450] $
15m0083                               	                ;Check sign of high order word.  If positive, we're ready to go
15m0083 04152 550140000117000440000000	        ALU[0-Q] DEST[Q] COND[OBUS=0] JUMP[DODIV3] CYLEN[C500] $
15m0083                               	                ;Double precision negate, low order word
15m0083 04153 640140001751000440000000	        ALU[NOTAC] DEST[AC] JUMP[DODIV2] NORM $
15m0083                               	                ;High order word, no carry
15m0083 04154 640700001513000440000000	DODIV3: ALU[0-AC] DEST[AC] NORM $
15m0083                               	                ;High order word, with carry
15m0083 04155 640740014571000440000000	DODIV2: D[CONST 44] LLOAD NORM $
15m0083                               	                ;LOOP 37 TIMES
15m0083                               	;Now have:
15m0083                               	;   MEM         Absolute value of divisor
15m0083                               	;   AC          Absolute value of high order dividend
15m0083                               	;   Q           Absolute value of low order dividend
15m0083                               	;   R           Repeat count for division
15m0083 04156 511140004463000440000000	        D[MEM] ALU[AC-D] COND[OBUS<0] JUMP[DODIV7] C550 $
15m0083                               	                ;Jump if not no divide case
15m0083 04157 640700021571000440000000	        D[PC] DEST[AC] SHORT $
15m0083                               	                ;Get ready to set flags
15m0083 04160 640040015561056010004061	        D[CONST 1] ROT[23.] ALU[DORAC] DEST[AC] PUSHJ[MSTOV1] NORM $
15m0083                               	                ;Set no divide
15m0083 04161 640300001571000440000000	        D[AR] DEST[AC] POPJ NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

15m0083                               	                ;Fix clobbered AC
15m0083                               	
15m0083                               	        ;$*$*$* NORMAL area runs of space for now.  TVR-Apr80
15m0083                               	        .USE[15m0083                               	XLIST
15m0084 02161 640040000571000440000000	 LIST ]DODIV7:  NORM PUSHJ[DODIV4] $
15m0084 02162 531140000571000440002164	        D[AR] COND[-OBUS<0] JUMP[. + 2] C550 $; J IF DIVIDEND WAS +
15m0084 02163 640700001513000440000000	        ALU[0-AC] DEST[AC] SHORT $
15m0084 02164 510300034571000010000000	        D[IR] MASK[1] COND[OBUS=0] POPJ C550 $ ;LEAVE IF RESULT SHOULD BE +
15m0084 02165 640300000117000440000000	        ALU[0-Q] DEST[Q] POPJ NORM $
15m0084                               	;On completion:
15m0084                               	;   MEM         Absolute value of divisor
15m0084                               	;   AC          Remainder
15m0084                               	;   Q           Quotient
15m0084                               	;   AR<0>       Sign of dividend
15m0084                               	;   IR<35>      Sign of dividend
15m0084                               	
15m0084                               	        .QUAD
15m0084                               	. + 3 - (. + 3) \ 4 
15m0085 02170 451640007043000030002170	]DODIV4:        D[MEM] ALU[DIVAC-D] DEST[D6] MASK[3] COND[OBUS<0] SLOOP[DODIV4] C600 $
15m0085 02171 640140002545000000000000	        ALU[SH-AC] DEST[D5] MASK[0] JUMP[DODIV6] NORM $ ; RE-SHIFT REMAINDER
15m0085 02172 451640007001000030002170	        D[MEM] ALU[DIVAC+D] DEST[D6] MASK[3] COND[OBUS<0] SLOOP[DODIV4] C600 $
15m0085 02173 640700002545000000000000	        ALU[SH-AC] DEST[D5] MASK[0] NORM $
15m0085                               	    ;end of .QUAD
15m0085 02174 531300015721106010000000	DODIV6: D[CONST 1] ROT[43] ALU[D#AC] DEST[AC] COND[-OBUS<0] C550 POPJ $ 
15m0085                               	                ;ADJUST REM SIGN, CHECK IT
15m0085 02175 640300005421000440000000	        D[MEM] ALU[D+AC] DEST[AC] NORM POPJ $ 
15m0085                               	                ;ADJUST REM.
15m0085                               	
15m0085                               	        .USE[15m0085                               	XLIST
15m0086                               	 LIST ]
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

16m0086                               	;JFFO1 JFFO2 JFFO3 JFFO5 JFFO4 ROTDO BIGLSH LSHPDO LSHDO LSHDO1 ASHDO1 BIGASH SETOV1
16m0086                               	 ASHDO ASHDOP BIGAS2 ASHC1 ASHC8 ASHC6 ASHC9 ASHC4 ASHC2 ASHC7 ROTC1 ROTC2 LSHC1 LSHC2
16m0086                               	 SJMAIN PUSH1 POP1 POPJ1 PUSHJ1
16m0086                               	
16m0086 04162 640140001615400440002026	JFFO1:  ACSEL[AC+1] ALU[0] DEST[AC] JUMP[MAIN] NORM $
16m0086 04163 530140000571014060000000	JFFO2:  D[AR] ROT[6] MASK[6] COND[-OBUS=0] JUMP[JFFO3] C550 $
16m0086 04164 640710000571014440000000	        D[AR] ROT[6] DEST[AR] NORM $
16m0086 04165 640140015421400060004163	        D[CONST 6] ACSEL[AC+1] ALU[AC+D] DEST[AC] JUMP[JFFO2] NORM $
16m0086 04166 511140000571000440000000	JFFO3:  D[AR] COND[OBUS<0] JUMP[JFFO4] C550 $
16m0086 04167 640700001413400440000000	JFFO5:  ACSEL[AC+1] ALU[AC+1] DEST[AC] NORM $
16m0086 04170 531150000571002440004167	        D[AR] ROT[1] DEST[AR] COND[-OBUS<0] JUMP[JFFO5] C550 $
16m0086 04171 640164634571000440002027	JFFO4:  D[IR] DEST[PC MA] JUMP[MAIN1] NORM $; JUMP
16m0086                               	.DEFINE SH2ND 16m0086                               	
16m0086                               	        .USE[16m0086                               	XLIST
16m0087                               	 LIST ] SH2ND 16m0087 02702 453140014477000440000000	OTPLS:  D[CONST 44] ALU[Q-D] COND[OBUS18] JUMP[ROTDO] C600 $
16m0087 02703 640141214077000440002702	        D[CONST 44] ALU[Q-D] DEST[Q ROTR] JUMP[ROTPLS] NORM $
16m0087 02704 640701210175020220000000	ROTNEG: D[MASK 22] ROT[10] ALU[DORQ] DEST[Q ROTR] NORM $
16m0087 02705 473141214035000440000000	ROTNN1: D[CONST 44] ALU[D+Q] DEST[Q ROTR] COND[-OBUS18] JUMP[ROTDO] C600 $
16m0087 02706 640140000571000440002705	        JUMP[ROTNN1] NORM $
16m0088 02707 640710000551000440000000	]ROTDO: ACSEL[AC] ALU[AC] DEST[AR] SHORT $
16m0088 02710 640160001571200440602027	        D[AR] ROT[R] ACSEL[AC] SPEC[MA_PC] DEST[AC MA] JUMP[MAIN1] NORM $
16m0088                               	        SH2ND 16m0088 02711 453140014477000440000000	SHPLS:  D[CONST 44] ALU[Q-D] COND[OBUS18] JUMP[LSHPDO] C600 $
16m0088 02712 640141214077000440000000	        D[CONST 44] ALU[Q-D] DEST[Q ROTR] JUMP[BIGLSH] NORM $
16m0088 02713 640701210175020220000000	LSHNEG: D[MASK 22] ROT[10] ALU[DORQ] DEST[Q ROTR] NORM $
16m0088 02714 473141214035000440000000	LSHNN1: D[CONST 44] ALU[D+Q] DEST[Q ROTR] COND[-OBUS18] JUMP[LSHDO] C600 $
16m0088 02715 640140000571000440000000	        JUMP[BIGLSH] NORM $
16m0089                               	]
16m0089                               	        .USE[16m0089                               	XLIST
16m0090 02725 640160001615000440602027	 LIST ]BIGLSH:  ACSEL[AC] ALU[0] SPEC[MA_PC] DEST[AC MA] JUMP[MAIN1] NORM $
16m0090                               	
16m0090 02726 640701414537000440000000	LSHPDO: D[CONST 44] ALU[D-Q] DEST[MASKR] SHORT $
16m0090 02727 640710010621001000000000	        D[2] MASK[R] ALU[D&AC] ACSEL[AC] DEST[AR] SHORT $
16m0090 02730 640160001571200440602027	        D[AR] ROT[R] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
16m0090                               	
16m0090 02731 640701400555000440000000	LSHDO:  ALU[Q] DEST[MASKR] SHORT $
16m0090 02732 640710000551000440000000	        ALU[AC] ACSEL[AC] DEST[AR] SHORT $
16m0090 02733 640160001571201000602027	LSHDO1: D[AR] MASK[R] ROT[R] SPEC[MA_PC] DEST[AC MA] ACSEL[AC] JUMP[MAIN1] NORM $
16m0090 02734 640141400555000440002733	ASHDO1: ALU[Q] DEST[MASKR] JUMP[LSHDO1] NORM $
16m0090                               	
16m0090                               	        .USE[16m0090                               	XLIST
16m0091                               	 LIST ] SH2ND 16m0091 04172 453140014477000440000000	SHPLS:  D[CONST 44] ALU[Q-D] COND[OBUS18] JUMP[ASHDOP] C600 $
16m0091 04173 640141214077000440000000	        D[CONST 44] ALU[Q-D] DEST[Q ROTR] JUMP[BIGASH] NORM $
16m0091 04174 640701210175020220000000	ASHNEG: D[MASK 22] ROT[10] ALU[DORQ] DEST[Q ROTR] NORM $
16m0091 04175 473141214035000440000000	ASHNN1: D[CONST 44] ALU[D+Q] DEST[Q ROTR] COND[-OBUS18] JUMP[ASHDO] C600 $
16m0091 04176 640140000571000440000000	        JUMP[BIGAS2] NORM $
16m0092 04177 610140000551000440002026	]BIGASH:        ALU[AC] ACSEL[AC] COND[OBUS=0] JUMP[MAIN] CYLEN[C450] $
16m0092 04200 640700015621106010000000	        D[CONST 1] ROT[43] ACSEL[AC] ALU[D&AC] DEST[AC] SHORT $
16m0092 04201 640700020171000440000000	        D[PC] DEST[Q] SHORT $
16m0092 04202 640165414575106010602027	SETOV1: D[CONST 1] ROT[43] ALU[DORQ] DEST[MA CRYOV] SPEC[MA_PC] NORM JUMP[MAIN1] $
16m0092 04203 571150000551000440002734	ASHDO:  ACSEL[AC] ALU[AC] DEST[AR] COND[-OBUS<0] JUMP[ASHDO1] CYLEN[C500] $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

16m0092 04204 640701414537000440000000	        D[CONST 44] ALU[D-Q] DEST[MASKR] SHORT $
16m0092 04205 640700010171201000000000	        D[2] MASK[R] ROT[R] DEST[Q] SHORT $
16m0092 04206 640160001575200440602027	        D[AR] ROT[R] ALU[DORQ] SPEC[MA_PC] DEST[AC MA] ACSEL[AC] JUMP[MAIN1] NORM $
16m0092 04207 640701414537000430000000	ASHDOP: D[CONST 43] ALU[D-Q] DEST[MASKR] SHORT $
16m0092 04210 640700200555000440000000	        ALU[Q] DEST[IR-ADR] SHORT $; SAVE SH AMT
16m0092 04211 640700014221106010000000	        D[CONST 1] ROT[43] ACSEL[AC] ALU[D&AC] DEST[Q] SHORT $ ;GET SIGN BIT
16m0092 04212 640710010621001000000000	        D[2] MASK[R] ACSEL[AC] ALU[D&AC] DEST[AR] SHORT $
16m0092 04213 640710001175200440000000	        D[AR] ROT[R] ACSEL[AC] ALU[DORQ] DEST[O_AC AR] SHORT $
16m0092 04214 640701434433000440000000	        D[IR] ALU[D+1] DEST[MASKR] SHORT $
16m0092 04215 640700000171200440000000	        D[AR] ROT[R] DEST[Q] SHORT $
16m0092 04216 510140010235107000002026	        D[2] MASK[R] ROT[43] ALU[D&Q] DEST[Q] COND[OBUS=0] JUMP[MAIN] C550 $
16m0092 04217 510140010735107000002026	        D[2] MASK[R] ROT[43] ALU[D#Q] COND[OBUS=0] JUMP[MAIN] C550 $
16m0092 04220 640140020171000440004202	        D[PC] DEST[Q] JUMP[SETOV1] NORM $
16m0092 04221 631140000551000440002725	BIGAS2: ACSEL[AC] ALU[AC] COND[-OBUS<0] JUMP[BIGLSH] CYLEN[C450] $
16m0092 04222 640160001741000440602027	        ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
16m0092                               	
16m0092 04223 640704414621106010000000	ASHC1:  D[CONST 1] ROT[43] ALU[D&AC] ACSEL[AC] DEST[HOLD] NORM $ ; SAVE SIGN BIT
16m0092 04224 513140034571000220000000	        D[IR] MASK[18.] COND[OBUS18] JUMP[ASHC2] C550 $
16m0092 04225 510140034571000100002026	        D[IR] MASK[10] COND[OBUS=0] JUMP[MAIN] C550 $
16m0092 04226 640700001615400440000000	        ALU[0] ACSEL[AC+1] DEST[AC] SHORT $
16m0092 04227 640740034531000100000000	        D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0092 04230 640700003145000010000000	ASHC8:  ALU[SH-AC] DEST[D6] MASK[1] ACSEL[AC] NORM $
16m0092 04231 511140004721000440000000	        ACSEL[AC] D[MEM] ALU[D#AC] COND[OBUS<0] JUMP[ASHC9] C550 $
16m0092 04232 640240000571000440004230	ASHC6:  LOOP[ASHC8] NORM $
16m0092 04233 640145420561400440000000	        D[PC] ACSEL[AC+1] ALU[DORAC] DEST[CRYOV] JUMP[ASHC7] NORM $
16m0092 04234 640140015571506010004232	ASHC9:  D[CONST 1] ROT[43] ACSEL[AC+1] DEST[AC] JUMP[ASHC6] NORM $
16m0092                               	
16m0092                               	.DEFINE SHLOOP 16m0092                               	
16m0092 04235 640700004171000440000000	ASHC4:  D[MEM] DEST[Q] SHORT $
16m0092 04236 640700001575506430000000	        D[AR] ROT[43] MASK[43] ALU[DORQ] ACSEL[AC+1] DEST[AC] NORM $
16m0092 04237 640700011621000430000000	        D[MASK 43] ACSEL[AC] ALU[D&AC] DEST[AC] SHORT $
16m0092 04240 640140001545000440002026	        ACSEL[AC] ALU[QORAC] DEST[AC] JUMP[MAIN] NORM $
16m0092 04241 640700234473000440000000	ASHC2:  D[IR] ALU[0-D] DEST[IR-ADR] NORM $
16m0092                               	        SHLOOP 16m0092 04242 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0092 04243 640240002145000010004243	        ALU[SH-AC] DEST[D4] MASK[1] ACSEL[AC] LOOP[.] NORM $
16m0093 04244 640150000555000440004235	]ASHC7: ALU[Q] DEST[AR] JUMP[ASHC4] NORM $
16m0093                               	
16m0093                               	        .USE[16m0093                               	XLIST
16m0094 02742 640140234473000440000000	 LIST ]ROTC1:   D[IR] ALU[0-D] DEST[IR-ADR] JUMP[ROTC2] NORM $
16m0094 02743 510140034571000100002026	        D[IR] COND[OBUS=0] MASK[10] JUMP[MAIN] C550 $
16m0094                               	        SHLOOP[16m0094 02744 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0094 02745 640240003145000000002745	        ALU[SH-AC] DEST[D6] MASK[0] ACSEL[AC] LOOP[.] NORM $
16m0095 02746 640140001555400440002026	]       ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
16m0095                               	ROTC2:  SHLOOP[16m0095 02747 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0095 02750 640240002145000000002750	        ALU[SH-AC] DEST[D4] MASK[0] ACSEL[AC] LOOP[.] NORM $
16m0096 02751 640140001555400440002026	]       ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
16m0096                               	
16m0096                               	        .PAIR
16m0096                               	. \ 2 + .
16m0097 02752 640140234473000220000000	]LSHC1: D[IR] MASK[18.] ALU[0-D] DEST[IR-ADR] JUMP[LSHC2] NORM $
16m0097 02753 510140034571000100002026	        D[IR] MASK[10] COND[OBUS=0] JUMP[MAIN] C550 $
16m0097                               	        SHLOOP SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

16m0097 02754 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0097 02755 640240003145000020002755	        ALU[SH-AC] DEST[D6] MASK[2] ACSEL[AC] LOOP[.] NORM $
16m0098 02756 640140001555400440002026	]       ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
16m0098                               	        .USE[16m0098                               	XLIST
16m0099       2735	 LIST ] debuguse = .            ;See if it is still losing
16m0099                               	: 2735  ;%$@#&@# SLOEXP didn't redefine AREA272 properly!!! $*$*$*
16m0099                               	LSHC2:  SHLOOP[16m0099 02735 640740034531000100000000	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
16m0099 02736 640240002145000020002736	        ALU[SH-AC] DEST[D4] MASK[2] ACSEL[AC] LOOP[.] NORM $
16m0100 02737 640140001555400440002026	]       ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
16m0100                               	
16m0100                               	        .USE[16m0100                               	XLIST
16m0101 02034 000700005570400440000000	 LIST ]SJMAIN:  ACSEL[MA] D[MEM] DEST[AC] $
16m0101 02035 000164634571000440002027	        D[IR] DEST[MA PC] JUMP[MAIN1] $
16m0101                               	
16m0101                               	        .USE[16m0101                               	XLIST
16m0102 04245 455160015421001000000000	 LIST ]PUSH1:   ACSEL[AC] D[CONST 1,,1] ALU[D+AC] DEST[AC MA] COND[CRY0] JUMP[PDLO2] C600
16m0102                               	 $
16m0102 04246 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
16m0102                               	
16m0102 04247 640710004571000440000000	POP1:   D[MEM] DEST[AR] SHORT $
16m0102 04250 640720034571000220000000	        D[IR] MASK[18.] DEST[MA] SHORT $
16m0102 04251 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
16m0102                               	
16m0102 04252 640164604571000220002027	POPJ1:  D[MEM] MASK[18.] DEST[PC MA] JUMP[MAIN1] NORM $
16m0102                               	
16m0102 04253 662104634571000222372032	PUSHJ1: MAPF[MASTO] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] MEMST OND[-MA-AC]
16m0102                               	 LBJUMP[MSMAIN] NORM ]$
16m0102                               	
16m0102                               	
16m0102                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

17m0102                               	;BLTA2 BLT1 BLT7 BLT5 BLT3 BLT2 BLT9 BLT4 BLT6 BLT8 BLTA3 BLTL1 BLTA4 BLTA1 BLTAL2 BLTA10
17m0102                               	 BLTL2 BLTA12 ANDCA1 ANDCA2 ANDCA3 LOG2 LOG3 ORCM2 ORCM3
17m0102                               	        .PAIR
17m0102                               	. \ 2 + .
17m0103 04254 640170000551000440000000	]BLTA2: ACSEL[AC] ALU[AC] DEST[AR MA] JUMP[BLTA3] NORM $ ;SRC IS AC GET DEST ADR
17m0103 04255 640710021171000440000000	BLT1:   D[PC] DEST[O_AC AR] ACSEL[AC] SHORT $
17m0103 04256 640704600171000220000000	        D[AR] MASK[18.] DEST[Q PC] SHORT $
17m0103 04257 640740034137000220000000	        D[IR] MASK[18.] ALU[D-Q] DEST[Q] LLOAD NORM $;GET COUNT
17m0103 04260 611140000555000440000000	        ALU[Q] COND[OBUS<0] JUMP[BLT4] CYLEN[C450] $ ; J IF END PRECEDES STRT
17m0103 04261 640730000171044220000000	BLT7:   D[AR] MASK[18.] ROT[18.] DEST[Q MA AR] SHORT $; FETCH FIRST WORD
17m0103 04262 640146000571000440050000	BLT5:   DEST[FIXMAC-MAPF-RD] MAPF[BLT-RD] JUMP[BLT2] CYLEN[FIXM] $
17m0103 04263 640706000571000442050000	BLT3:   DEST[FIXMAC-MAPF-RD] MAPF[BLT-RD] SPEC[PC+1] CYLEN[FIXM] $
17m0103 04264 641164204571000440600000	BLT2:   D[MEM] SPEC[MA_PC] DEST[MEMSTO MA] COND[INTRPT] JUMP[BLT6] NORM $
17m0103 04265 640270000017000440064263	        ALU[Q+1] DEST[Q AR MA] LOOP[BLT3] MAPF[BLT-WRT] CYLEN[MEMSTO] $
17m0103 04266 640704621171000220000000	BLT9:   D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC] NORM $
17m0103 04267 531140034463000220002026	        ACSEL[AC] D[IR] MASK[18.] ALU[AC-D] COND[-OBUS<0] JUMP[MAIN] C550 $ ;J IF DONE
17m0103 04270 640700001413000440000000	        ACSEL[AC] ALU[AC+1] DEST[AC] SHORT $
17m0103 04271 640740034523000440000000	        D[IR] ACSEL[AC] ALU[D-AC] LLOAD NORM $ ;GET COUNT
17m0103 04272 640704621171000440000000	        D[PC] ACSEL[AC] DEST[O_AC PC] SHORT $
17m0103 04273 640160000555000440004262	        ALU[Q] DEST[MA] JUMP[BLT5] NORM $
17m0103 04274 640740000615000440000000	BLT4:   ALU[0] LLOAD NORM $
17m0103 04275 640140000571000440004261	        JUMP[BLT7] NORM $
17m0103 04276 640250000017000440060000	BLT6:   ALU[Q+1] DEST[Q AR] LOOP[BLT8] MAPF[BLT-WRT] CYLEN[MEMSTO] $
17m0103 04277 000140000571000440004266	        JUMP[BLT9] $
17m0103 04300 640700001451000442000000	BLT8:   ACSEL[AC] ALU[AC-1] DEST[AC] SPEC[PC+1] NORM $
17m0103 04301 640704621171000220000000	        ACSEL[AC] D[PC] MASK[18.] DEST[O_AC PC] SHORT $
17m0103 04302 640700001561044000200000	        D[AR] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC] SHORT $
17m0103 04303 540500000571000441602320	        DISP[2320] SPEC[PC+1-IF&] CYLEN[DISP] $
17m0103 04304 640701000571044440000000	BLTA3:  D[AR] ROT[18.] DEST[AC-SEL] SHORT $ ;GET SRC ADR
17m0103 04305 640700034171000220000000	        D[IR] MASK[18.] DEST[Q] SHORT $
17m0103 04306 640740024077000220000000	        D[MA] MASK[18.] ALU[Q-D] DEST[Q] LLOAD NORM $
17m0103 04307 611040000555000440000000	        ALU[Q] COND[OBUS<0] PUSHJ[BLTA4] CYLEN[C450] $
17m0103 04310 640700000035044220000000	        D[AR] ROT[18.] MASK[18.] ALU[D+Q] DEST[Q] SHORT $
17m0103 04311 530140010635010300000000	        D[MASK 30] ROT[4] ALU[D&Q] COND[-OBUS=0] JUMP[BLTA10] C550  $;J IF SRC LEAVES
17m0103                               	 AC'S
17m0103 04312 640704200550000440000000	BLTL1:  ACSEL[REG] ALU[AC] DEST[MEMSTO] NORM $
17m0103 04313 640267024433000440104312	        D[MA] ALU[D+1] DEST[MA A-MEM-CNTR&INC] MAPF[BLT-WRTA] LOOP[BLTL1] CYLEN[MEMSTO] $
17m0103                               	
17m0103 04314 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
17m0103 04315 640740000215000440000000	BLTA4:  ALU[0] DEST[Q] LLOAD NORM $
17m0103 04316 640300000571000440000000	        POPJ NORM $
17m0103 04317 510140010621054160000000	BLTA1:  D[MASK 16] ROT[26] ACSEL[AC] ALU[D&AC] COND[OBUS=0] JUMP[BLTA10] C550 $; DEST IS
17m0103                               	 AC, J IF SRC AC?
17m0103 04320 530140034571100160000000	        D[IR] ROT[40] MASK[16] COND[-OBUS=0] JUMP[BLTA10] C550 $;J IF FINAL DEST NOT AC
17m0103 04321 640711000551000440000000	        ACSEL[AC] ALU[AC] DEST[AR AC-SEL] SHORT $;GET DEST ADR
17m0103 04322 640700034171000220000000	        D[IR] MASK[18.] DEST[Q] SHORT $
17m0103 04323 640740000077000220000000	        D[AR] MASK[18.] ALU[Q-D] DEST[Q] LLOAD NORM $;GET COUNT
17m0103 04324 611040000555000440004315	        ALU[Q] COND[OBUS<0] PUSHJ[BLTA4] CYLEN[C450] $;ADJUST IF CNT NEG.
17m0103 04325 640720000571044220000000	        D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $;GET SRC ADR
17m0103 04326 640706025432000440070000	BLTAL2: DEST[FIXMAC-MAPF-RD AC] MAPF[BLT-RDA] D[MA] ALU[D+1] ACSEL[REG] CYLEN[FIXM] $
17m0103 04327 640267005170000440004326	        ACSEL[REG] D[MEM] DEST[O_AC MA A-MEM-CNTR&INC] LOOP[BLTAL2] NORM $
17m0103 04330 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
17m0103 04331 640710000551000440000000	BLTA10: ACSEL[AC] ALU[AC] DEST[AR] SHORT $
17m0103 04332 640720000571044220000000	BLTL2:  D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $;GET WORD
17m0103 04333 640706000550400440070000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BLT-RDA] CYLEN[FIXM] $
17m0103 04334 640704404171000440000000	        D[MEM] DEST[HOLD Q] SHORT $
17m0103 04335 640724000571000220000000	        D[AR] MASK[18.] DEST[MA STRT-WRT] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

17m0103 04336 562140000571000440104340	        MAPF[BLT-WRTA] COND[-MA-AC] JUMP[. + 2] C500 $
17m0103 04337 640700001554400440000000	        ALU[Q] ACSEL[MA] DEST[AC] SHORT $
17m0103 04340 640700000171000220000000	        D[AR] MASK[18.] DEST[Q] NORM $
17m0103 04341 471140034477000220102026	        D[IR] MASK[18.] ALU[Q-D] MAPF[BLT-WRTA] COND[-OBUS<0] JUMP[MAIN] C600 $
17m0103 04342 640700014171001000000000	        D[CONST 1,,1] DEST[Q]  NORM $
17m0103 04343 640150000435000440004332	        D[AR] ALU[D+Q] DEST[AR] JUMP[BLTL2] NORM $;*** TEST FOR INTERRUPT HERE?
17m0103 04344 662100000571000440002032	BLTA12: MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0103                               	
17m0103                               	        .USE[17m0103                               	XLIST
17m0104                               	 LIST ]
17m0104 02763 640160005635000440602027	ANDCA1: D[MEM] ACSEL[AC] ALU[D&Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
17m0104                               	
17m0104 02764 662104204635000440002032	ANDCA2: D[MEM] ALU[D&Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104 02765 662104205635000440002032	ANDCA3: D[MEM] ACSEL[AC] ALU[D&Q] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM
17m0104                               	 ]$
17m0104                               	
17m0104 02766 662104200755000440002032	LOG2:   ALU[NOTQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104 02767 662104201755000440002032	LOG3:   ACSEL[AC] ALU[NOTQ] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104 02770 662104200545000440002032	ORCM2:  ACSEL[AC] ALU[QORAC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104 02771 662104201545000440002032	ORCM3:  ACSEL[AC] ALU[QORAC] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
17m0104                               	
17m0104                               	        .USE[17m0104                               	XLIST
17m0105                               	 LIST ]
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

18m0105                               	;SWINT NORSW NOSW RESW1 RESET RESET RESLOP DOHALT STPLOP STPLP1 NORSW2 RESW2 STRTSW CONSW
18m0105                               	 DEPTSW DEPNSW DEPSW1 EXMTSW EXMNSW SETLTS EXMSW1 BRPNT MOVSS1 MOVNS1 HLLZS1 HRLZS1
18m0105                               	 HRRZS1 HLRZS1 HRAR HLAR HLLEM1 HRLEM1 HLREM1 HRREM1 HSMAIN HSMN1 HLLOS1 HRROS1 HLLES1
18m0105                               	 HRRES1 HLLES2 HMV HHS HLSZ HOR HRSZ HOL HRLM1 HLLM1 HLRM1 HRRM1 JRST1 JRST4 JRST5 JRST9
18m0105                               	 JRST8 JRST2 JRST3 JFCL1 JSR2 JSA1 JRA1 MUJSR MUJSP
18m0105                               	;  MUJSA MUJSYS MUJSM1
18m0105                               	;;;RESW1:
18m0105                               	        .ORG[XLIST
18m0105                               	 LIST ];*$*$* No REAL reason for this
18m0105                               	: 2062  ;SWITCH, AR & ECC INTERRUPTS COME HERE
18m0105 02062 640702400571000440000000	SWINT:  DEST[CLR-DEV-FROM-INTR] SHORT $
18m0105 02063 640701600615000443400000	        ALU[0] DEST[DEV-ADR] SPEC[IOB-IN] SHORT $
18m0105 02064 140710030571000440040000	        D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $                 ;GET SW BITS
18m0105 02065 530140000571016010000000	        D[AR] ROT[7] MASK[1] COND[-OBUS=0] JUMP[APDINT] C550 $  ;JUMP IF OVFL OR ECC INT
18m0105                               	
18m0105 02066 640700014171002153600000	        D[CONST 15] ROT[1] DEST[Q] SPEC[IOB-OUT] SHORT $
18m0105 02067 510140000635030440040000	        D[AR] ROT[14] ALU[D&Q] MAPF[4] COND[OBUS=0] JUMP[NOSW] C550 $   ;CHECK FOR
18m0105                               	 RELEVANT SW, & CLR FF.
18m0105 02070 530140000571020010000000	        D[AR] ROT[10] MASK[1] COND[-OBUS=0] JUMP[RESW1] C550 $  ;J IF RESET SW
18m0105 02071 530040000571026010000000	NORSW:  D[AR] ROT[13] MASK[1] COND[-OBUS=0] PUSHJ[EXMTSW] C550 $        ;PUSHJ IF EXAM
18m0105                               	 THIS
18m0105 02072 530040000571022010000000	        D[AR] ROT[11] MASK[1] COND[-OBUS=0] PUSHJ[DEPTSW] C550 $        ;PUSHJ IF DEPO
18m0105                               	 THIS
18m0105 02073 640160000571000440602027	NOSW:   SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
18m0105                               	
18m0105       2074	area206 = .     ;Sigh...
18m0105                               	
18m0105                               	        .RELOC
18m0105                               	USE[18m0105                               	XLIST
18m0106                               	 LIST ]]
18m0106 04345 640700000571000443400000	RESW1:  SPEC[IOB-IN] SHORT $
18m0106 04346 140710030571000440000000	        D[IOD] DEST[AR]  CYLEN[IOB-IN] $        ;DOUBLE CHECK RESET SW
18m0106 04347 410140000571020010002071	        D[AR] ROT[10] MASK[1] COND[OBUS=0] JUMP[NORSW] CYLEN[C650] $    ;DOUBLE CHECK
18m0106                               	 RESET SW
18m0106                               	
18m0106                               	;******* This code to be made a subroutine to allow machine resetting *******
18m0106                               	;******* to be done by auto-loading and via CONO APR,20000  TVR-Mar80 *******
18m0106                               	
18m0106                               	.REPEAT F2SW [
18m0106 04350 640702214571000003600000	RESET:  D[CONST 0] DEST[IOD] SPEC[IOB-OUT] NORM $
18m0106                               	  ] ;END F2SW
18m0106                               	
18m0106                               	.REPEAT 1 - F2SW [
18m0106                               	 ;END 1 - F2SW
18m0106                               	;*** Disable ECC interrupts on F3's?????
18m0106                               	
18m0106 04351 440705400615000440100000	        MAPF[10] ALU[0] DEST[CRYOV] CYLEN[IOB-OUT] $    ;CLR MAP-IN-USE & PC FLAGS & AR
18m0106                               	 INT ENBL, ETC.
18m0106 04352 640143600571000440000000	        DEST[CLR-MI-ERR] JUMP[RESLOP] NORM $
18m0106 04353 640702600615000440000000	RESLOP: ALU[0] DEST[HI-ABS-MA] NORM $
18m0106 04354 000702400571000440000000	        DEST[CLR-DEV-FROM-INTR] $
18m0106 04355 640041614571000000000000	        D[CONST 0] DEST[DEV-ADR] PUSHJ[APRRST] NORM $
18m0106 04356 640041614571000010000000	        D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPRST] NORM $
18m0106 04357 640041614571000040000000	        D[CONST 4] DEST[DEV-ADR] PUSHJ[CTYRST] NORM $
18m0106 04360 640041614571000100000000	        D[CONST 10] DEST[DEV-ADR] PUSHJ[DSKRST] NORM $
18m0106 04361 640041614571000070000000	        D[CONST 7] DEST[DEV-ADR] PUSHJ[TAPRST] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

18m0106                               	.REPEAT DLS [;18m0106                               	 9 JAN 80  BO
18m0106 04362 640041614571000200000000	        D[CONST DLSDEV] DEST[DEV-ADR] PUSHJ[DLSRST] NORM $
18m0106                               	]DLS
18m0106                               	.REPEAT VC [ 18m0106                               	; VC
18m0106                               	.REPEAT IMP [;18m0106                               	IMP
18m0106                               	.REPEAT LPT [
18m0106                               	LPT
18m0106                               	.REPEAT STANSW [;18m0106                               	REPEAT STANSW
18m0106 04363 640041614571000060000000	        D[CONST 6] DEST[DEV-ADR] PUSHJ[CLKRST] NORM $
18m0106 04364 640041614571000060000000	        D[CONST 6] DEST[DEV-ADR] PUSHJ[TYMRST] NORM $
18m0106 04365 640041614571000060000000	        D[CONST 6] DEST[DEV-ADR] PUSHJ[PI-RESET] NORM $
18m0106 04366 640702400571000440000000	DOHALT: DEST[CLR-DEV-FROM-INTR] NORM $
18m0106 04367 640701614571000013400000	STPLOP: D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
18m0106 04370 140700030171000440040000	        MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
18m0106 04371 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
18m0106 04372 640702214575000103600000	        D[CONST 10] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $
18m0106 04373 440700000571000440100000	        MAPF[10] CYLEN[IOB-OUT] $; SET PROG HALT LIGHT
18m0106 04374 640721600615000440600000	        ALU[0] DEST[DEV-ADR MA] SPEC[MA_PC] NORM $
18m0106 04375 640706000550400443620000	        FIXM1 SPEC[IOB-OUT] $
18m0106 04376 000700004571000440060000	        D[MEM] MAPF[6] CYLEN[LONG] $
18m0106 04377 640700000571000443400000	        SPEC[IOB-IN] NORM $
18m0106 04400 140710030571000440040000	        D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $
18m0106 04401 451140000571000440000000	        D[AR] COND[OBUS<0] JUMP[BRPNT] C600 $; J IF BRK POINT SW
18m0106 04402 640700000571000443400000	        SPEC[IOB-IN] NORM $
18m0106 04403 140710030571000440040000	STPLP1: D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $ ;GET SW BITS
18m0106 04404 530140000571020010000000	        D[AR] ROT[10] MASK[1] COND[-OBUS=0] JUMP[RESW2] C550 $  ;J IF RESET SW
18m0106 04405 640700000171030110000000	        D[AR] ROT[14] MASK[11] DEST[Q] NORM $
18m0106 04406 450140014675010073404403	        D[CONST 7] ROT[4] ALU[-D&Q] COND[OBUS=0] SPEC[IOB-IN] JUMP[STPLP1] C600 $; LOOP
18m0106                               	 IF NO SW
18m0106 04407 640700000571000443600000	        SPEC[IOB-OUT] NORM $
18m0106 04410 440700000571000440040000	        MAPF[4] CYLEN[IOB-OUT] $        ;CLR SW FF'S
18m0106                               	        .DEFINE SWTEST 18m0106                               	NORSW2: SWTEST[18m0106 04411 530140000571010010000000	D[AR] ROT[4] MASK[1] COND[-OBUS=0] JUMP [ CONSW ] C550 $
18m0107                               	]       SWTEST[18m0107 04412 530140000571012010000000	D[AR] ROT[5] MASK[1] COND[-OBUS=0] JUMP [ STRTSW ] C550 $
18m0108                               	]       SWTEST[18m0108 04413 530040000571022010000000	D[AR] ROT[11] MASK[1] COND[-OBUS=0] PUSHJ [ DEPTSW ] C550 $
18m0109                               	]       SWTEST[18m0109 04414 530040000571024010000000	D[AR] ROT[12] MASK[1] COND[-OBUS=0] PUSHJ [ DEPNSW ] C550 $
18m0110                               	]       SWTEST[18m0110 04415 530040000571026010000000	D[AR] ROT[13] MASK[1] COND[-OBUS=0] PUSHJ [ EXMTSW ] C550 $
18m0111                               	]       SWTEST[18m0111 04416 530040000571030010000000	D[AR] ROT[14] MASK[1] COND[-OBUS=0] PUSHJ [ EXMNSW ] C550 $
18m0112 04417 640141614571000003404403	]       D[CONST 0] DEST[DEV-ADR] SPEC[IOB-IN] JUMP[STPLP1] NORM $       ;LOOP
18m0112                               	
18m0112 04420 640700000571000443400000	RESW2:  SPEC[IOB-IN] SHORT $
18m0112 04421 140710030571000440000000	        D[IOD] DEST[AR]  CYLEN[IOB-IN] $        ;DOUBLE CHECK RESET SW
18m0112 04422 150140000571020010004411	        D[AR] ROT[10] MASK[1] COND[OBUS=0] JUMP[NORSW2] CYLEN[IOB-IN] $ ;DOUBLE CHECK
18m0112                               	 RESET SW
18m0112 04423 640140000571000440004350	        JUMP[RESET] NORM $
18m0112 04424 640704600571000230000000	STRTSW: D[AR] MASK[23] DEST[PC] NORM $
18m0112 04425 640722600615000440600000	CONSW:  ALU[0] SPEC[MA_PC] DEST[MA HI-ABS-MA] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

18m0112 04426 640701614571000013400000	        D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
18m0112 04427 140700030171000440040000	        MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
18m0112 04430 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
18m0112 04431 640702214635000073600000	        D[CONST 7] ALU[D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $
18m0112 04432 440700000571000440100000	        MAPF[10] CYLEN[IOB-OUT] $; CLEAR PROG HALT LIGHT
18m0112 04433 640706000550400440010000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
18m0112 04434 540530604571000441602174	        D[MEM] DEST[IR-ALL AR MA] DISP[2174] SPEC[PC+1-IF] CYLEN[DISP] $; IGNORE STOP SW
18m0112                               	
18m0112                               	
18m0112 04435 640162600571000233400000	DEPTSW: D[AR] MASK[23] DEST[MA HI-ABS-MA] SPEC[IOB-IN] JUMP[DEPSW1] NORM $
18m0112 04436 640720024433000443400000	DEPNSW: D[MA] ALU[D+1] DEST[MA] NORM SPEC[IOB-IN] $
18m0112 04437 140704230571000440020000	DEPSW1: D[IOD] DEST[MEMSTO] MAPF[2] CYLEN[IOB-IN] $
18m0112 04440 662300000571000440000000	        MAPF[TEMP] COND[-MA-AC] POPJ CYLEN[MEMSTO] $
18m0112 04441 640300005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] POPJ NORM $
18m0112                               	
18m0112 04442 640162600571000230000000	EXMTSW: D[AR] MASK[23] DEST[MA HI-ABS-MA] JUMP[EXMSW1] NORM $
18m0112 04443 640160024433000440000000	EXMNSW: D[MA] ALU[D+1] DEST[MA] JUMP[EXMSW1] NORM $
18m0112                               	;NOTE: This subroutine is called by DATAO PI, which displays in the lights
18m0112 04444 640706000550400440020000	SETLTS: FIXM1 $                 ;Take page faults, if any.
18m0112 04445 640706000550400440000000	EXMSW1: ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[TEMP] CYLEN[FIXM] $
18m0112 04446 640700000571000443600000	        SPEC[IOB-OUT] NORM $
18m0112 04447 000300004571000440020000	        D[MEM] MAPF[2] CYLEN[LONG] POPJ $
18m0112 04450 640700000171000270000000	BRPNT:  D[AR] MASK[27] DEST[Q] NORM $
18m0112 04451 470140020537000270004425	        D[PC] MASK[27] ALU[D-Q] COND[-OBUS=0] JUMP[CONSW] C600 $
18m0112 04452 640140000571000443404403	        SPEC[IOB-IN] JUMP[STPLP1] NORM $
18m0112                               	
18m0112                               	        .USE[18m0112                               	XLIST
18m0113 02772 662104205571044440002032	 LIST ]MOVSS1:  D[MEM] ROT[18.] ACSEL[AC] DEST[AC MEMSTO] MEMST OND[-MA-AC]
18m0113                               	 LBJUMP[MSMAIN] NORM ]$
18m0113                               	
18m0113 02773 662104205473000440002032	MOVNS1: D[MEM] ALU[0-D] ACSEL[AC] DEST[AC MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM
18m0113                               	 ]$
18m0113                               	
18m0113 02774 643130005570400000400000	HLLZS1: ACSEL[MA] D[MEM] COND[AC=0] DEST[AC AR MA] SPEC[LEFT&MA_PC] LBJUMP[HSMAIN] NORM $
18m0113                               	
18m0113                               	
18m0113 02775 643130005570444000400000	HRLZS1: ACSEL[MA] D[MEM] ROT[18.] COND[AC=0] DEST[AC AR MA] SPEC[LEFT&MA_PC]
18m0113                               	 LBJUMP[HSMAIN] NORM $
18m0113                               	
18m0113 02776 643130005570400220600000	HRRZS1: ACSEL[MA] D[MEM] MASK[18.] COND[AC=0] DEST[AC AR MA] SPEC[MA_PC] LBJUMP[HSMAIN]
18m0113                               	 NORM $
18m0113                               	
18m0113 02777 643130005570444220600000	HLRZS1: ACSEL[MA] D[MEM] ROT[18.] MASK[18.] COND[AC=0] DEST[AC AR MA] SPEC[MA_PC]
18m0113                               	 LBJUMP[HSMAIN] NORM $
18m0113                               	
18m0113                               	        .USE[18m0113                               	XLIST
18m0114 03426 640160001561000220602027	 LIST ]HRAR:    D[AR] MASK[18.] ALU[DORAC] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1]
18m0114                               	 NORM $
18m0114                               	
18m0114 03427 640160001561000000402027	HLAR:   D[AR] SPEC[LEFT&MA_PC] MASK[0] ALU[DORAC] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM
18m0114                               	 $
18m0114                               	
18m0114 03430 662104200571000000202032	HLLEM1: D[AR] MASK[0] SPEC[LEFT] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0114                               	
18m0114 03431 662104200571044000202032	HRLEM1: D[AR] ROT[18.] MASK[0] SPEC[LEFT] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN]
18m0114                               	 NORM ]$
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

18m0114                               	
18m0114 03432 662104200571044220002032	HLREM1: D[AR] ROT[18.] MASK[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0114                               	
18m0114 03433 662104200571000220002032	HRREM1: D[AR] MASK[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0114                               	
18m0114                               	        .USE[18m0114                               	XLIST
18m0115                               	 LIST ] .PAIR
18m0115                               	. \ 2 + .
18m0116 03444 640700001571000440000000	]HSMAIN:        ACSEL[AC] D[AR] DEST[AC] NORM $
18m0116 03445 640146000550400440022030	        FIXM1 JUMP[MAIN2] $
18m0116                               	        .PAIR
18m0116                               	. \ 2 + .
18m0117 03446 640160000571000440602027	]HSMN1: SPEC[MA_PC] DEST[MA] JUMP[MAIN1] CYLEN[MEMSTO] $
18m0117 03447 640160005571000440602027	        D[MEM] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[MEMSTO] $
18m0117                               	        .PAIR
18m0117                               	. \ 2 + .
18m0118 03450 662104210575000220002032	]HLLOS1:        D[MASK 22] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM
18m0118                               	 ]$
18m0118 03451 662104211575000220002032	        D[MASK 22] ALU[DORQ] DEST[MEMSTO AC] ACSEL[AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN]
18m0118                               	 NORM ]$
18m0118                               	        .PAIR
18m0118                               	. \ 2 + .
18m0119 03452 662104210575044220002032	]HRROS1:        D[MASK 22] ROT[18.] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC]
18m0119                               	 LBJUMP[MSMAIN] NORM ]$
18m0119 03453 662104211575044220002032	        D[MASK 22] ROT[18.] ALU[DORQ] DEST[MEMSTO AC] ACSEL[AC] MEMST OND[-MA-AC]
18m0119                               	 LBJUMP[MSMAIN] NORM ]$
18m0119                               	        .PAIR
18m0119                               	. \ 2 + .
18m0120 03454 663100010235044220000000	]HLLES1:        D[MASK 22] ROT[18.] ALU[D&Q] DEST[Q] COND[-AC=0] LBJUMP[HLLES2] NORM $
18m0120 03455 663100000571000440003450	        COND[-AC=0] LBJUMP[HLLOS1] NORM $
18m0120                               	        .PAIR
18m0120                               	. \ 2 + .
18m0121 03456 663100010235000220000000	]HRRES1:        D[MASK 22] ALU[D&Q] DEST[Q] COND[-AC=0] LBJUMP[HLLES2] NORM $
18m0121 03457 663100000571000440003452	        COND[-AC=0] LBJUMP[HRROS1] NORM $
18m0121                               	        .USE[18m0121                               	XLIST
18m0122                               	 LIST ] .PAIR
18m0122                               	. \ 2 + .
18m0123 03470 662104200555000440002032	]HLLES2:        ALU[Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0123 03471 662104201555000440002032	        ALU[Q] ACSEL[AC] DEST[MEMSTO AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0123                               	        .PAIR
18m0123                               	. \ 2 + .
18m0124 03472 640140000571000440002026	]HMV:   JUMP[MAIN] NORM $
18m0124 03473 640140000571000440002400	        JUMP[MOVE] NORM $
18m0124                               	        .PAIR
18m0124                               	. \ 2 + .
18m0125 03474 662104200575044440002032	]HHS:   D[AR] ROT[18.] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0125 03475 662104201575044440002032	        D[AR] ROT[18.] ALU[DORQ] ACSEL[AC] DEST[MEMSTO AC] MEMST OND[-MA-AC]
18m0125                               	 LBJUMP[MSMAIN] NORM ]$
18m0125                               	        .USE[18m0125                               	XLIST
18m0126                               	 LIST ] .PAIR
18m0126                               	. \ 2 + .
18m0127 03526 640160000571000440602027	]HLSZ:  SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
18m0127 03527 640160011561000220602027	HOR:    D[MASK 22] ACSEL[AC] ALU[DORAC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $
18m0127                               	        .PAIR
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

18m0127                               	. \ 2 + .
18m0128 03530 640160000571000440602027	]HRSZ:  SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
18m0128 03531 640160011561044220602027	HOL:    D[MASK 22] ACSEL[AC] ROT[18.] ALU[DORAC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM
18m0128                               	 $
18m0128                               	        .PAIR
18m0128                               	. \ 2 + .
18m0129 03532 640700000171044440000000	]HRLM1: D[AR] ROT[18.] DEST[Q] NORM $
18m0129 03533 662104204575000220002032	HLLM1:  D[MEM] MASK[18.] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0129                               	
18m0129                               	        .PAIR   . \ 2 + .
18m0129                               	];(??) Added TVR-Apr80
18m0129 03534 640700000171044440000000	HLRM1:  D[AR] ROT[18.] DEST[Q] NORM $
18m0129 03535 662104204575000000202032	HRRM1:  D[MEM] MASK[0] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN]
18m0129                               	 NORM ]$
18m0129                               	
18m0129                               	        .USE[18m0129                               	XLIST
18m0130                               	 LIST ] .PAIR
18m0130                               	. \ 2 + .
18m0131 03504 645140000571000440000000	]JRST1: COND[USER] JUMP[JRST8] NORM $; ILLEGAL IF USER MODE
18m0131 03505 530140034571030010000000	        D[IR] ROT[14] MASK[1] COND[-OBUS=0] JUMP[JRST2] C550 $
18m0131 03506 640140000571000440000000	        JUMP[JRST4] NORM $
18m0131 03507 530140034571032010000000	JRST4:  D[IR] ROT[15] MASK[1] COND[-OBUS=0] JUMP[JRST3] C550 $
18m0131 03510 530140034571026010000000	JRST5:  D[IR] ROT[13] MASK[1] COND[-OBUS=0] JUMP[JRST9] C550 $;J TO STOP SWITCH IF HALT
18m0131 03511 530140034571024010000000	        D[IR] ROT[12] MASK[1] COND[-OBUS=0] JUMP[PI-DISMISS] C550 $; J IF DISMISS BIT ON
18m0131                               	
18m0131 03512 640160000571000440602027	        JUMP[MAIN1] NORM SPEC[MA_PC] DEST[MA] $
18m0131 03513 665140000571000440004366	JRST9:  COND[EXEC] JUMP[DOHALT] NORM $; HALT IF EXEC MODE
18m0131                               	JRST8:  MUUO1
18m0131 03514 640150020171000440002101	D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
18m0132                               	]
18m0132 03515 640700020171000440000000	JRST2:  D[PC] DEST[Q] SHORT $
18m0132 03516 640700014235074010000000	        D[CONST 1] ROT[36] ALU[D&Q] DEST[Q] SHORT $
18m0132 03517 640145400575000440003507	        D[AR] ALU[DORQ] DEST[CRYOV] JUMP[JRST4] NORM $
18m0132                               	        .USE[18m0132                               	XLIST
18m0133 03544 640700014171074010000000	 LIST ]JRST3:   D[CONST 1] ROT[36] DEST[Q] SHORT $
18m0133 03545 640145420575000440003510	        D[PC] ALU[DORQ] DEST[CRYOV] JUMP[JRST5] NORM $
18m0133                               	
18m0133 03546 510140000635100440002026	JFCL1:  D[AR] ROT[40] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $;TEST SELECTED FLAGS
18m0133 03547 640705400675100440000000	        D[AR] ROT[40] ALU[-D&Q] DEST[CRYOV] SHORT $;CLEAR FLAGS
18m0133 03550 640164634571000440002027	        DOJUMP $
18m0133 03551 640704624433000442240000	JSR2:   D[MA] ALU[D+1] DEST[PC] SPEC[CLR-HALF] MAPF[STO] NORM $
18m0133 03552 640160005570400440602027	        ACSEL[MA] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
18m0133 03553 640704624433000440000000	JSA1:   D[MA] ALU[D+1] DEST[PC] SHORT $
18m0133 03554 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0133 03555 640706000550400440020000	JRA1:   FIXM1 $
18m0133 03556 640700005571000440000000	        ACSEL[AC] D[MEM] DEST[AC] CYLEN[FIXM+1] $
18m0133 03557 640164634571000220002027	        D[IR] MASK[18.] DEST[PC MA] JUMP[MAIN1] NORM $
18m0133                               	
18m0133                               	        .USE[18m0133                               	XLIST
18m0134 04453 640720604571000440000000	 LIST ]MUJSR:   D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
18m0134 04454 642144200571000440003551	        D[AR] DEST[MEMSTO] COND[MA-AC] JUMP[JSR2] NORM $
18m0134 04455 640164624433000442242027	        D[MA] ALU[D+1] DEST[MA PC] MAPF[STO] SPEC[CLR-HALF] JUMP[MAIN1] CYLEN[MEMSTO] $
18m0134 04456 640720604571000440000000	MUJSP:  D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
18m0134 04457 640140001571000440002553	        D[AR] ACSEL[AC] DEST[AC] JUMP[JSP1] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

18m0134 04460 640720604571000440000000	MUJSA:  D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
18m0134 04461 640150001171000440003553	        D[AR] ACSEL[AC] DEST[O_AC AR] JUMP[JSA1] NORM $
18m0134 04462 640720604571000440000000	MUJSYS: D[MEM] DEST[IR-ALL MA] SHORT $
18m0134 04463 510140034571066110002211	        D[IR] ROT[33] MASK[11] COND[OBUS=0] JUMP[JSYS3] C550 $; J IF EX JSYS
18m0134 04464 640706000550400440150000	MUJSM1: ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[MAPFTR] CYLEN[FIXM] $
18m0134 04465 640704604571000220000000	        D[MEM] MASK[18.] DEST[PC] NORM $; JUMP TO RIGHT HALF
18m0134 04466 640720004571044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $; GET READY TO STORE
18m0134 04467 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
18m0134                               	
18m0134                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

19m0134                               	;CTYDSP AREA51 CTYINT CTYIOT CTYDI CTYDO CTYCO CTYCI CTYCI2 CTYCI1 CTYCI9 CTYCI8 CTYCI3
19m0134                               	 CTYCO1 CTYCO3 CTYCO4 CTYCO5 CTYRST ctyrs1 AREA52 CTYCZ CTYCS
19m0134                               	;------------------------------------------------------------------------------
19m0134                               	;
19m0134                               	;       CTY - Console Teletype                          Device 120
19m0134                               	;
19m0134                               	;------------------------------------------------------------------------------
19m0134                               	
19m0134                               	;
19m0134                               	;A-MEM Usage
19m0134                               	;
19m0134       0	CTY-DISP = 0            ;Instruction and interrupt dispatch
19m0134       1	CTY-CONT = 1            ;Control bits for UART, etc.
19m0134       2	CTY-STATUS = 2          ;Firmware status
19m0134                               	
19m0134                               	;
19m0134                               	;*** Meanings of hardware bits should be documented here.
19m0134                               	;
19m0134                               	;MAPF values
19m0134                               	
19m0134                               	.REPEAT NTP [
19m0134       0	TTY.DI = 0      ;read data
19m0134       12	TTY.WD = 12     ;write data
19m0134       14	TTY.WC = 14     ;write control
19m0134                               	  ];NTP
19m0134                               	
19m0134                               	.REPEAT OTP [
19m0134                               	;OTP
19m0134                               	
19m0134                               	;*$*$*  This ORG is ready to be flushed.  It only remains to test the code
19m0134                               	;       and merge the AREAs
19m0134                               	
19m0134                               	        .ORG[XLIST
19m0134                               	 LIST ];CTY IOT DISPATCH TABLE
19m0134                               	
19m0134                               	CTYDSP: ILGIOT 19m0134 05100 000140000571000440002026	 JUMP [MAIN] ]$ ;BLKI
19m0134 05101 000700000571000440000000	        NOP $
19m0134 05102 640700050171000443400000	        D[CTY-STATUS + 10] DEST[Q] SPEC[IOB-IN] NORM $ ;DATAI
19m0134 05103 140150030571000440000000	        MAPF[TTY.DI] D[IOD] DEST[AR] JUMP[CTYDI] CYLEN[IOB-IN] $
19m0134                               	        ILGIOT 19m0134 05104 000140000571000440002026	 JUMP [MAIN] ]$ ;BLKO
19m0134 05105 000700000571000440000000	        NOP $
19m0134 05106 640706000550400440020000	        FIXM1 $         ;DATAO
19m0134 05107 640140050171000440000000	        D[CTY-STATUS + 10] DEST[Q] JUMP[CTYDO] NORM $ ; GET CONI BITS
19m0134 05110 640700050171000070000000	        D[CTY-STATUS + 10] MASK[7] DEST[Q] NORM $ ;CONO, GET CONI BITS
19m0134 05111 640140034275100070000000	        D[IR] MASK[7] ROT[40] ALU[-D&Q] DEST[Q] JUMP[CTYCO] NORM $ ;CLR THE CLR BITS
19m0134 05112 640040050171000443400000	        D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
19m0134                               	                ; CONI, GET BITS
19m0134 05113 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
19m0134 05114 640040050171000443400000	        D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
19m0134                               	                ;CONSZ, GET BITS
19m0134 05115 640140034171000220000000	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
19m0134 05116 640040050171000443400000	        D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
19m0134                               	                ;CONSO, GET CONI BITS
19m0134 05117 640140034171000220000000	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
19m0134                               	;$*$*$ We may not be able to afford this in the future...  TVR-Apr80
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

19m0134                               	LPTDSP:
19m0134                               	.REPEAT 1 - LPT [
19m0134                               	     .REPEAT 10 [I19m0134                               	LGIOT 19m0134 05120 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05121 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05122 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05123 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05124 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05125 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05126 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05127 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05130 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05131 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05132 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05133 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05134 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05135 000700000571000440000000	        NOP $
19m0134                               	]LGIOT 19m0134 05136 000140000571000440002026	 JUMP [MAIN] ]$
19m0134 05137 000700000571000440000000	        NOP $
19m0134                               	].REPEAT 10
19m0134                               	].REPEAT 1 - LPT
19m0134                               	
19m0134                               	.REPEAT LPT [   19m0134                               	.REPEAT LPT
19m0134                               	
19m0134                               	AREA51: ;$*$*$ Start code from here for now.  This should go away
19m0134                               	
19m0134                               	
19m0134                               	: 2130 ;CTY and 60 HZ CLOCK INTS COME HERE
19m0134                               	
19m0134                               	CTYINT:
19m0134                               	  .REPEAT NTP [;19m0134                               	With new tape controller, 60HZ clk shares DEV 4 w/ CTY.
19m0134 02130 640700000571000443400000	        START-IN SHORT $
19m0134 02131 440710030771000440050000	        MAPF[5] D[IOD] ALU[NOTD] DEST[AR] C600 $
19m0134                               	                ;Read the NET interface status...
19m0134 02132 530140000571000010000000	        D[AR] MASK[1] C550 -OBUS=0 JUMP[CLKINT] $
19m0134                               	                ;Is 60HZ clk requesting an int. ? Jump if so.
19m0134 02133 640140000571000440000000	        NORM JUMP[CTYIN1] $
19m0134                               	                ;Else it is the CTY's turn.
19m0134                               	: 2144
19m0134                               	      ];NTP
19m0134                               	
19m0134 02144 640040050171000443400000	CTYIN1: D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
19m0134                               	                ; DO A CONI, GET BITS
19m0134 02145 640702244571000113600000	        D[CTY-CONT + 10] MASK[11] DEST[IOD] SPEC[IOB-OUT] NORM $; DISABLE INTS
19m0134 02146 440710050171000030140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] D[CTY-STATUS + 10] MASK[3] DEST[Q AR] $
19m0134                               	                ; GET PI CHAN
19m0134 02147 640142400571000440000000	        NORM  DEST[CLR-DEV-FROM-INTR] JUMP[PIGEN] $;CAUSE INTR.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

19m0134                               	
19m0134                               	;$*$*$ This one is referenced off the MAP dispatch
19m0134                               	: 5210
19m0134                               	        .PAIR
19m0134                               	. \ 2 + .
19m0135                               	]       UIOTRP[19m0135 05210 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
19m0135                               	]$
19m0135                               	CTYIOT: IOTDIS 19m0135 05211 640700034171034050000000	D[IR] ROT[16] MASK[5] DEST[Q] NORM $
19m0135 05212 540540014575014510000000	        D[CONST 51] ROT[6] ALU[DORQ] SDISP CYLEN[C500] $
19m0136                               	]
19m0136 05213 640700414675000403000000	CTYDI:  D[CONST 40] ALU[-D&Q] DEST-A-MEM DEST[CTY-STATUS] NORM $; CLR TTI FLAG
19m0136 05214 640700014171006100000000	        D[CONST 10] ROT[3] DEST[Q] SHORT $
19m0136 05215 640702244575000443600000	        D[CTY-CONT + 10] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] SHORT $;CLR RCV. CHR
19m0136 05216 440700000571000440140000	        MAPF[TTY.WC]  CYLEN[IOB-OUT] $
19m0136 05217 640702244571000443600000	        D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] SHORT $
19m0136 05220 440700000571000440140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] $
19m0136 05221 662104200571000100002032	        D[AR] MASK[10] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
19m0136 05222 640702204571000443600000	CTYDO:  D[MEM] DEST[IOD] SPEC[IOB-OUT] NORM $;SEND CHR.
19m0136 05223 440700014275000100120000	        MAPF[TTY.WD] CYLEN[IOB-OUT] D[CONST 10] ALU[-D&Q] DEST[Q] $;CLR TTO FLAG
19m0136 05224 640702244433000443600000	        D[CTY-CONT + 10] ALU[D+1] DEST[IOD] SPEC[IOB-OUT] NORM $
19m0136                               	                ;ENABLE UART STB
19m0136                               	        MAPF[TTY.WC] CYLEN[IOB-OUT]
19m0136 05225 440700414575000203140000	                        D[CONST 20] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM $
19m0136                               	                ;SET TTO BUSY
19m0136 05226 640702244571000443600000	        D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] NORM $;CLR UART STB
19m0136 05227 450140014635000070142026	        MAPF[TTY.WC] CYLEN[IOB-OUT] D[CONST 7] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] $ ; DONE
19m0136                               	 IF NO PI CHAN
19m0136 05230 640700044171000440000000	        D[CTY-CONT + 10] DEST[Q] SHORT $; GET IOB-OUT BITS
19m0136 05231 640702214175022043600000	        D[CONST 4] ROT[11] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] NORM $ ;ENABLE XMT INT
19m0136 05232 440140200555000443142026	        MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[Q] DEST[CTY-CONT] DEST-A-MEM JUMP[MAIN] $
19m0136 05233 640700014235006170000000	CTYCO:  D[CONST 17] ROT[3] ALU[D&Q] DEST[Q] NORM $;CLR PI BITS
19m0136 05234 640140434575000073000000	        D[IR] MASK[7] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM JUMP[CTYCO1] NORM $
19m0136                               	                ;OR IN NEW PI BITS
19m0136 05235 140704430571000440000000	CTYCI:  MAPF[TTY.DI] D[IOD] DEST[HOLD] CYLEN[IOB-IN] $;GET UART BITS
19m0136 05236 640702244571000443600000	        D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] NORM $
19m0136 05237 170140004571054010140000	        MAPF[TTY.WC] D[MEM] ROT[26] MASK[1] COND[-OBUS=0] JUMP[CTYCI1]
19m0136                               	 CYLEN[MAX,IOB-OUT,C550] $; J IF RCV RDY
19m0136 05240 640150014275006100000000	CTYCI2: D[CONST 10] ROT[3] ALU[-D&Q] DEST[Q AR] JUMP[CTYCI9] NORM $;CLR TTI BUSY
19m0136 05241 530140014635000400005240	CTYCI1: D[CONST 40] ALU[D&Q] COND[-OBUS=0] JUMP[CTYCI2] C550 $;J IF TTI FLAG ON
19m0136 05242 640710014335006100000000	        D[CONST 10] ROT[3] ALU[D#Q] DEST[Q AR] NORM $;COMPL BUSY.
19m0136 05243 530140014635006100000000	        D[CONST 10] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[CTYCI9] C550 $;J IF BUSY NOW ON
19m0136 05244 640710014175000400000000	        D[CONST 40] ALU[DORQ] DEST[Q AR] NORM $; SET TTI FLAG
19m0136 05245 530140004571052010000000	CTYCI9: D[MEM] ROT[25] MASK[1] COND[-OBUS=0] JUMP[CTYCI8] C550 $;J IF XMT RDY
19m0136 05246 640300414575000203000000	        D[CONST 20] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM POPJ NORM $
19m0136                               	                ;SET BUSY -- NOTE, NO "AR DEST" IS CORRECT
19m0136 05247 510140014635000200000000	CTYCI8: D[CONST 20] ALU[D&Q] COND[OBUS=0] JUMP[CTYCI3] C550 $; J IF BUSY OFF
19m0136 05250 640700014175000100000000	        D[CONST 10] ALU[DORQ] DEST[Q] NORM $; SET FLAG
19m0136 05251 640300414675000203000000	CTYCI3: D[CONST 20] ALU[-D&Q] DEST[CTY-STATUS] DEST-A-MEM POPJ NORM $ ;CLR BUSY
19m0136 05252 640700034171102100000000	CTYCO1: D[IR] ROT[41] MASK[10] DEST[Q] NORM $; GET SET&CLR BITS
19m0136 05253 010140014635006100000000	        D[CONST 10] ROT[3] ALU[D&Q] COND[OBUS=0] JUMP[CTYCO4] $
19m0136                               	                ; J IF CLR TTI FLAG OFF
19m0136 05254 640700044171000110000000	        D[CTY-CONT + 10] MASK[11] DEST[Q] NORM $;GET IOB-OUT BITS
19m0136 05255 640702214575006103600000	        D[CONST 10] ROT[3] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $
19m0136                               	                ;GET CLR RCV RDY BIT
19m0136 05256 440700000571000440140000	CTYCO3: MAPF[TTY.WC] CYLEN[IOB-OUT] $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

19m0136 05257 640702200555000443600000	        ALU[Q] DEST[IOD] SPEC[IOB-OUT] NORM $;CLR IT
19m0136 05260 440700000571000440140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] $
19m0136 05261 640700044171000110000000	CTYCO4: D[CTY-CONT + 10] MASK[11] DEST[Q] NORM $; GET IOB-OUT BITS
19m0136 05262 510140050571000030000000	        D[CTY-STATUS + 10] MASK[3] COND[OBUS=0] JUMP[CTYCO5] C550 $
19m0136                               	                ; J IF NO PI CHAN
19m0136 05263 640700014175022020000000	        D[CONST 2] ROT[11] ALU[DORQ] DEST[Q] SHORT $; ENBL RCV INT
19m0136 05264 510140050571102020000000	        D[CTY-STATUS + 10] ROT[41] MASK[2] COND[OBUS=0] JUMP[CTYCO5] C550 $
19m0136                               	                ; J IF NO OUT FLAG OR BUSY
19m0136 05265 640700014175022040000000	        D[CONST 4] ROT[11] ALU[DORQ] DEST[Q] SHORT $;ENBL XMT INT
19m0136 05266 640702200555000443600000	CTYCO5: ALU[Q] DEST[IOD] SPEC[IOB-OUT] SHORT $; FIX INT ENBLS
19m0136 05267 440140200555000443142026	        MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[Q] DEST[CTY-CONT] DEST-A-MEM JUMP[MAIN] $
19m0136                               	; **** HERE IS DEFN. OF CTY UART CONSTANTS ****
19m0136                               	
19m0136 05270 640701614571000040000000	CTYRST: D[CONST 4] DEST[DEV-ADR] NORM $
19m0136 05271 640702414171014040000000	        D[CONST 4] ROT[6] DEST[Q CLR-DEV-FROM-INTR] NORM $
19m0136 05272 640700214175000743000000	        D[CONST 74] ALU[DORQ] DEST[Q CTY-CONT] DEST-A-MEM NORM $
19m0136 05273 640702214575014033600000	        D[CONST 3] ROT[6] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $; RESET UART
19m0136 05274 440700400615000443140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[0] DEST[CTY-STATUS] DEST-A-MEM $
19m0136 05275 640142200555000443600000	        ALU[Q] DEST[IOD] SPEC[IOB-OUT] NORM JUMP[CTYRS1] $
19m0136                               	    .USE[XLIST
19m0136                               	 LIST ] ;$*$*$*$ Temporary ****
19m0136                               	CTYRS1:
19m0136                               	;Setup entry vectors: IOT vector in left half, interrupt vector in right half   
19m0136 03566 440700014171060510140000	        MAPF[TTY.WC] CYLEN[IOB-OUT] D[CONST (CTYDSP / 100)] ROT[18. + 6.] DEST[Q] $
19m0136                               	                ;High order 6 IOT bits
19m0136 03567 640700014175044000000000	        D[CONST (CTYDSP \ 100)] ROT[18.] ALU[DORQ] DEST[Q] NORM $
19m0136                               	                ;Low order 6 IOT bits
19m0136 03570 640700014175014210000000	        D[CONST (CTYINT / 100)] ROT[6.] ALU[DORQ] DEST[Q] NORM $
19m0136                               	                ;High order 6 interrupt bits
19m0136                               	        D[CONST (CTYINT \ 100)] ROT[0] ALU[DORQ]
19m0136 03571 640300014575000303000000	                        SPEC[DEST-A-MEM] DEST[CTY-DISP] POPJ NORM $
19m0136                               	                ;Low order 6 interrupt bits
19m0136                               	                ;Finish setting up vectors and return.
19m0136                               	
19m0136                               	AREA52: ;$*$*$* Recover what space may be left???
19m0136                               	
19m0136                               	;;;     .USE[AREA206]
19m0136                               	;;;     debuguse = .
19m0136                               	
19m0136                               	;;;:2074        ;%$#@#$% SLOEXP didn't redefine AREA206 properly??? $*$*$*$
19m0136                               	
19m0136                               	        .USE[19m0136                               	XLIST
19m0137                               	 LIST ]
19m0137                               	        .PAIR
19m0137                               	. \ 2 + .
19m0138 04470 530140000635000440002026	]CTYCZ: D[AR] ALU[D&Q] COND[-OBUS=0] JUMP[MAIN] C550 $
19m0138 04471 640164620433000440002027	        DOSKIP $
19m0138 04472 510140000635000440002026	CTYCS:  D[AR] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $
19m0138 04473 640164620433000440002027	        DOSKIP $
19m0138                               	
19m0138                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

20m0138                               	;$*$*$ This code should set up dispatch and interrupt vectors.  It will have to
20m0138                               	;      be moved to the end of regular disk stuff.  TVR-Apr80
20m0138 04474 640702200615000443600000	DSKRST: ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $
20m0138                               	          ;SET DSK CTRL COMMAND REGISTER TO 0 (DISABLES INTS).
20m0138                               	        MAPF[4] D[CONST 2] DEST[IOD] SPEC[IOB-OUT]
20m0138 04475 440702214571000023640000	                                CYLEN[IOB-OUT] $
20m0138                               	          ;NOW RESET THE CONTROLLER.
20m0138 04476 440300200615000443070000	        MAPF[7] ALU[0] DEST[1] DEST-A-MEM  CYLEN[IOB-OUT]  POPJ $
20m0138                               	          ;ALSO CLEAR THE PI CHANNEL ASSIGNMENT.
20m0138                               	
20m0138                               	SET-DSK-OUT:
20m0138 04477 665141614571000100000000	        D[CONST 10] DEST[DEV-ADR] NORM COND[-USER] JUMP[SDSKO2] $
20m0138                               	        UIOTRP[20m0138 04500 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
20m0138                               	]$
20m0138                               	                ;Watch for IOT-USER mode.
20m0138 04501 640312204571000443600000	SDSKO2: D[MEM] DEST[IOD AR] SPEC[IOB-OUT] NORM POPJ $
20m0138                               	
20m0138                               	;Kludge to allow disk controller status IOTs from IOT-USER Mode.  This is
20m0138                               	;so a wizard can look at the state of the disk controller from MDDT (or UEDDT).
20m0138                               	UDSKST: UIOTRP[20m0138 04502 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
20m0138                               	]$
20m0138                               	                ;Ignore SPEC[IOB-IN] we just did and trap if in user mode.
20m0138 04503 000700034171024120000000	        D[IR] ROT[8 + 1 + 1] MASK[10.] DEST[Q] $
20m0138                               	                ;Extract opcode
20m0138 04504 000700014175000010000000	        D[CONST 1] ALU[DORQ] DEST[Q] $
20m0138                               	                ;Skip first micro instruction that got us here
20m0138 04505 540540014575022023400000	        D[CONST 2] ROT[9.] ALU[DORQ] SDISP CYLEN[DISP] SPEC[IOB-IN] $
20m0138                               	                ;Dispatch again to finish instruction
20m0138                               	
20m0138                               	;$*$*$ This code should set up dispatch and interrupt vectors.  It will have to
20m0138                               	;      be moved to the end of regular disk stuff.  TVR-Apr80
20m0138                               	TYMRST:         ;RESET TYMNET INTERFACE
20m0138 04506 640040014171000010000000	        D[CONST 1] DEST[Q] PUSHJ[DEV6CL] NORM $
20m0138                               	.REPEAT TYMNET [
20m0138 04507 640140000571000440000000	        JUMP[TYMRS1] NORM $     ;SET INITIAL COROUTINE ADR, INT ENBLS.
20m0138                               	]TYMNET
20m0138                               	.REPEAT 1 - tymnet [
20m0138                               	 1 - tymnet
20m0138                               	
20m0138                               	;$*$*$ This code should set up dispatch and interrupt vectors.  TVR-Apr80
20m0138                               	
20m0138                               	 .REPEAT OTP [
20m0138                               	;OTP
20m0138                               	
20m0138                               	 .REPEAT NTP [
20m0138                               	
20m0138                               	CLKRST:         ;Fall in to CLKCLR
20m0138 04510 640701614571000043600000	CLKCLR: START-OUT D[CONST 4] DEST[DEV-ADR] NORM $
20m0138                               	                ;Clear clk flag.
20m0138 04511 440702250571064442470000	CLKENB: MAPF[7] D[12] SPEC[A-MEM-APR] ROT[26.] DEST[IOD] C600 $
20m0138                               	                ;Get the APR conditions wd, put CLK INT ENB bit in bit 35.
20m0138 04512 640700000571000443600000	        START-OUT NORM $
20m0138 04513 440300000571000440060000	        MAPF[6] C600 POPJ $
20m0138                               	                ;SET OR CLEAR THE HARDWARE INTRPT. ENB. ACCORDING TO
20m0138                               	                ; STATE OF CLK INT ENB BIT IN APR 
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

20m0138                               	  ];NTP
20m0138                               	
20m0138                               	.REPEAT OTP [ 20m0138                               	;OTP
20m0138                               	
20m0138                               	;$*$*$*$* This should be moved to CFKNYD.SLO   TVR-Sep80
20m0138                               	  .REPEAT NTP [
20m0138                               	
20m0138                               	TAPRST:  ;RESET THE TAPE CONTROLLER.
20m0138 04514 640701614571000070000000	        D[CONST 7] DEST[DEV-ADR] NORM $ ;SELECT DEVICE.
20m0138 04515 000702200615000443600000	        START-OUT ALU[0]  DEST[IOD] $
20m0138                               	         ;Turn off "FORMATTER ENABLE"
20m0138 04516 000700000571000440020000	        MAPF[2] LONG $
20m0138                               	          ;Fall in to TIMRST.
20m0138                               	
20m0138 04517 640701614571000050000000	TIMRST: D[CONST 5] DEST[DEV-ADR] NORM $
20m0138 04520 640702214571000013600000	        START-OUT D[CONST TIMER] DEST[IOD] NORM $
20m0138                               	                ;Enable timer interrupts if TIMER is 1, else disable them.
20m0138 04521 440700200615000443100000	        MAPF[10] ALU[0] DEST[1] DEST-A-MEM C600 $
20m0138                               	                ;Clear pi channel
20m0138 04522 640300600615000443000000	        ALU[0] DEST[3] DEST-A-MEM NORM POPJ $
20m0138                               	                ;Clear timer reg.
20m0138                               	   ];NTP
20m0138                               	
20m0138                               	APRRST:
20m0138                               	.REPEAT F2SW [
20m0138 04523 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $   ;Clear Addr. Break
20m0138                               	]REPEAT F2SW
20m0138 04524 440300400615000442610000	        MAPF[1] ALU[0] DEST[APRSTS] SPEC[A-MEM-APR&DEST-A-MEM] CYLEN[IOB-OUT] POPJ $
20m0138                               	;$*$*$ This code should set up dispatch and interrupt vectors.  TVR-Apr80
20m0138                               	
20m0138 04525 640302400571000440000000	CLRDEVINT:         DEST[CLR-DEV-FROM-INTR] POPJ NORM $
20m0138                               	                ;CLEAR FLAG WHICH CAUSES DEV-ADR TO BE
20m0138                               	                ; ADR OF LAST INTERRUPTING DEVICE,
20m0138                               	                ; SO THE DEV-ADR REGISTER WILL WORK AGAIN.
20m0138                               	
20m0138                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

21m0138                               	;------------------------------------------------------------------------------
21m0138                               	;
21m0138                               	;       PI - Priority Interrupt Service                 Device 4
21m0138                               	;
21m0138                               	;------------------------------------------------------------------------------
21m0138                               	
21m0138                               	;PI SYSTEM USE OF APR AMEM---
21m0138                               	; 4     MEM PAR ERR(BIT 19), MEM PAR ERR INTRPT ENB(BIT 20),
21m0138                               	;        PI SYSTEM ON(BIT 28) CHN1-7 ON (BITS 29-35)
21m0138                               	; 5     WAITING RQ 1-7 (11-18)  IN PROG 1-7 (29-35)
21m0138                               	; 6     RQ COUNTS - 4-BIT FIELDS, CHN. 7 AT RIGHT END OF WORD.
21m0138                               	;
21m0138                               	;Other uses of APR AMEM are documented at the beginning 
21m0138                               	
21m0138                               	PI-GET-CHN:     ;MAKE BINARY CHN. NO. FROM MASK IN AR.
21m0138 04526 640710000571070440000000	        D[AR] ROT[34] DEST[AR] NORM $
21m0138                               	                ;PUT RQ 1 INTO BIT 1
21m0138 04527 640720014571000060000000	        D[CONST 6] DEST[MA] NORM $
21m0138                               	                ;MA WILL GET 7-CHN (FOR USE IN SHIFTING)
21m0138                               	PIL1:   D[AR] ROT[1] DEST[AR] C550
21m0138 04530 511150000571002440000000	           COND[OBUS<0] JUMP[PIGETMASK] $ ;FOUND FIRST BIT ?
21m0138 04531 640160024531000440004530	        D[MA] ALU[D-1] DEST[MA] NORM JUMP[PIL1] $
21m0138                               	                ;NO. DECREMENT COUNT AND LOOP.
21m0138 04532 640701224571000440000000	PIGETMASK:      D[MA] DEST[ROTR] NORM $ ;LOAD ROTATE AMT.
21m0138                               	        D[CONST 1] ROT[R] DEST[AR] NORM 
21m0138 04533 640310014571200010000000	          POPJ $        ;MAKE MASK OF FIRST BIT ONLY IN AR.
21m0138                               	
21m0138                               	
21m0138                               	PI-CHECK-RQS:    ;SEE IF IT IS TIME TO TAKE AN INTRPT.
21m0138                               	.REPEAT STANSW [        21m0138                               	.REPEAT STANSW
21m0138                               	.REPEAT 1 - STANSW [
21m0138                               	        D[15] SPEC[A-MEM-APR] ROT[18.] MASK[7] DEST[AR]
21m0138 04534 510150064571044072402026	          C550 COND[OBUS=0] JUMP[MAIN] $ ;ANY RQ'S ?
21m0138                               	].REPEAT 1 -STANSW
21m0138 04535 640041600615000440004526	        ALU[0] DEST[DEV-ADR] NORM PUSHJ[PI-GET-CHN] $
21m0138                               	                ;GET UNARY CHN NO. IN AR, SHIFT AMT. IN MA, ROTR
21m0138 04536 531140060571070440002026	        D[14] ROT[34] C550 COND[-OBUS<0] JUMP[MAIN] $
21m0138                               	                ;EXIT IF PI SYS NOT ON.
21m0138 04537 640700010171200070000000	        D[MASK 7] ROT[R] DEST[Q] NORM $
21m0138                               	                ;MASK OF CHN AND ALL HIGHER CHNS.
21m0138 04540 530140064635000440002026	        D[15] ALU[D&Q] C550 COND[-OBUS=0] JUMP[MAIN] $
21m0138                               	                ;EXIT IF THIS OR HIGHER CHN IN PROGRESS.
21m0138 04541 640700000171000440000000	        D[AR] DEST[Q] NORM $ ;MOVE UNARY CHN # TO Q.
21m0138 04542 510140060635000440002026	        D[14] ALU[D&Q] C550 COND[OBUS=0] JUMP[MAIN] $
21m0138                               	                ;EXIT IF CHN NOT ON.
21m0138 04543 640701224571004440000000	        D[MA] ROT[2] DEST[ROTR] NORM $
21m0138                               	                ;GET SHIFT AMT 4 TIMES LARGER, TO ACCESS CNT FIELD
21m0138 04544 640700014171200010000000	        D[CONST 1] ROT[R] DEST[Q] NORM $
21m0138                               	                ;A ONE ALIGNED WITH RQ CNT FIELD FOR THIS CHN.
21m0138 04545 640704470137000440000000	        D[16] ALU[D-Q] DEST[Q HOLD] NORM $
21m0138                               	                ;DECREMENT OUR WAITING RQ COUNT.
21m0138 04546 640700070335000440000000	        D[16] ALU[D#Q] DEST[Q] NORM $ ;DID WE OVERFLOW ?
21m0138 04547 530140014635200200004547	        D[CONST 20] ROT[R] ALU[D&Q] COND[-OBUS=0] C550 JUMP[.] $
21m0138                               	          ;LOOP HERE FOREVER IF WE OVERFLOWED 4-BIT CNT FIELD
21m0138 04550 640701404171000443000000	        D[MEM] DEST[6 Q] DEST-A-MEM NORM $
21m0138                               	                ;PUT BACK WORD OF RQ COUNTS.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

21m0138                               	        D[CONST 17] ROT[R] ALU[D&Q] C550
21m0138 04551 530140014635200170000000	          COND[-OBUS=0] JUMP[PIINTGO] $ ;JUMP IF OUR COUNT NEQ 0
21m0138 04552 640140000371044440000000	        D[AR] ROT[18.] ALU[NOTD] DEST[Q] NORM JUMP[PIL11] $
21m0138                               	                ;MASK FOR CLEARING THE WAITING RQ BIT.
21m0138 04553 640700014371000000000000	PIINTGO:        D[CONST 0] ALU[NOTD] DEST[Q] NORM $
21m0138                               	                ;DON'T CLEAR THE BIT, RQ'S STILL WAITING
21m0138 04554 640700064235000440000000	PIL11:  D[15] ALU[D&Q] DEST[Q] NORM $
21m0138                               	                ;GET STATUS B, EITHER DO OR DO NOT CLEAR RQ BIT
21m0138 04555 640701200575000443000000	        D[AR] ALU[DORQ] DEST[5] DEST-A-MEM NORM $
21m0138                               	                ;SET IN PROGRESS BIT, STORE STATUS B.
21m0138 04556 640710020171000440000000	        D[PC] DEST[Q AR] NORM $ ;GET PC INTO Q, AR.
21m0138 04557 640705410635076430000000	        D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $ ;CLR USR MODE
21m0138                               	
21m0138                               	;;;     D[MA] ROT[18.] ALU[DORQ] DEST[1] DEST-A-MEM NORM $
21m0138                               	;;; This is an obsolete bug trap -- DWP 9/80
21m0138                               	
21m0138                               	 ;; FOLLOWING INSTR. IS DEBUGGING AID
21m0138 04560 640700014171000560000000	        D[CONST 56] DEST[Q] NORM $
21m0138                               	                ;PREPARE TO CALC. INTRPT. ADDRESS.
21m0138 04561 640160024477002440002105	        D[MA] ROT[1] ALU[Q-D] DEST[MA] NORM JUMP[PIMUUO] $
21m0138                               	                ;FETCH INTRPT. INSTR AND GO INTERPRET IT.
21m0138                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

22m0138                               	PIGEN:   ;ENTER WITH CHN IN AR TO REQUEST INTRPT.
22m0138 04562 640041600615000440004525	        ALU[0] DEST[DEV-ADR] NORM PUSHJ[CLRDEVINT] $
22m0138 04563 640700060171000440000000	        D[14] DEST[Q] NORM $
22m0138                               	        D[CONST 1] ROT[18.] ALU[D+Q] DEST[4] DEST-A-MEM
22m0138 04564 640701014435044013000000	                NORM $
22m0138 04565 640700014171000070000000	        D[CONST 7] DEST[Q] NORM $
22m0138                               	                ;7-CHN IS AMT TO SHIFT BY FOR MASK BIT.
22m0138                               	        D[AR] MASK[3] ALU[Q-D] DEST[MA] NORM
22m0138 04566 640060000477000030004532	          PUSHJ[PIGETMASK] $ ;LOAD ROTR, FORM MASK IN AR
22m0138 04567 531140060571070440000000	PIGEN1: D[14] ROT[34] C550 COND[-OBUS<0] JUMP[PIGENWT] $
22m0138                               	                ;BRANCH IF PI SYS NOT ON.
22m0138 04570 640700010171200070000000	        MASK[7] D[2] ROT[R] DEST[Q] NORM $
22m0138                               	                ;MASK OF CHN AND ALL HIGHER CHNS.
22m0138 04571 530140064635000440000000	        D[15] ALU[D&Q] C550 COND[-OBUS=0] JUMP[PIGENWT] $
22m0138                               	                ;BRANCH IF THIS OR HIGHER CHN IN PROGRESS.
22m0138 04572 640700000171000440000000	        D[AR] DEST[Q] NORM $ ;MOVE UNARY CHN # TO Q.
22m0138 04573 530140060635000440004553	        D[14] ALU[D&Q] C550 COND[-OBUS=0] JUMP[PIINTGO] $
22m0138                               	                ;IF CHN ON, GO TAKE INTRPT.
22m0138                               	PIGENWT:          ;INTRPT CANNOT HAPPEN NOW, SO SET A WAITING RQ.
22m0138 04574 640701224571004440000000	        D[MA] ROT[2] DEST[ROTR] NORM $
22m0138                               	                ;GET SHIFT AMT 4 TIMES LARGER, TO GET CNT FIELD
22m0138 04575 640700014171200010000000	        D[CONST 1] ROT[R] DEST[Q] NORM $
22m0138                               	                ;A ONE ALIGNED WITH RQ CNT FIELD FOR THIS CHN.
22m0138 04576 640704470035000440000000	        D[16] ALU[D+Q] DEST[Q HOLD] NORM $
22m0138                               	                ;INCREMENT OUR WAITING RQ COUNT.
22m0138 04577 530140014635200100004601	        D[CONST 10] ROT[R] ALU[D&Q] COND[-OBUS=0] C550 JUMP[. + 2] $
22m0138                               	          ;DON'T LET COUNT GET HIGHER THAN 7.
22m0138 04600 640701404571000443000000	        D[MEM] DEST[6] DEST-A-MEM NORM $
22m0138                               	                ;PUT BACK WORD OF RQ COUNTS.
22m0138 04601 640700064171000440000000	        D[15] DEST[Q] NORM $
22m0138                               	                ;GET STATUS B.
22m0138                               	        D[AR] ROT[18.] ALU[DORQ] DEST[5] DEST-A-MEM
22m0138 04602 640141200575044443002026	           NORM JUMP[MAIN] $ ;SET WAITING RQ BIT.
22m0138                               	
22m0138                               	PI-DISMISS:
22m0138                               	        D[15] SPEC[A-MEM-APR] MASK[7] DEST[AR]
22m0138 04603 530050064571000072404526	          C550 COND[-OBUS=0] PUSHJ[PI-GET-CHN] $
22m0138 04604 640700064171000442400000	        D[15] SPEC[A-MEM-APR] DEST[Q] NORM $
22m0138                               	        D[AR] ALU[-D&Q] DEST[5] SPEC[A-MEM-APR&DEST-A-MEM]
22m0138 04605 640141200675000442604534	                NORM JUMP[PI-CHECK-RQS] $
22m0138                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

23m0138                               	PICONO:  ;Here from any CONO PI,
23m0138 04606 640710024571000070000000	        D[MA] MASK[7]  DEST[AR] NORM $
23m0138 04607 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
23m0138 04610 640700060171000440000000	        D[14]  DEST[Q] NORM $ ;GET STATUS A
23m0138 04611 531140024571052440000000	        D[MA] ROT[21.]  C550 COND[-OBUS<0] JUMP[PIL7] $
23m0138 04612 640700014175036010000000	        D[CONST 1] ROT[35. - 20.] ALU[DORQ] DEST[Q] NORM $ 
23m0138                               	         ; TURN ON PAR ERR INTRPT ENB.
23m0138 04613 531140024571050440000000	PIL7:   D[MA] ROT[20.]  C550 COND[-OBUS<0] JUMP[PIL8] $
23m0138 04614 640700014275036010000000	        D[CONST 1] ROT[35. - 20.] ALU[-D&Q] DEST[Q] NORM $ 
23m0138                               	         ;TURN OFF PAR ERR INT ENB
23m0138 04615 531140024571046440000000	PIL8:   D[MA] ROT[19.] C550 COND[-OBUS<0] JUMP[PIL9] $
23m0138 04616 640700014275040010000000	        D[CONST 1] ROT[35. - 19.] ALU[-D&Q] DEST[Q] NORM $ 
23m0138                               	         ;CLEAR MEM PAR ERR FLAG
23m0138 04617 513040024571012440000000	PIL9:   D[MA] ROT[5]  C550 COND[OBUS18] PUSHJ[PI-RESET] $
23m0138 04620 533140024571024440000000	        D[MA] ROT[12]  C550 COND[-OBUS18] JUMP[PIL3] $
23m0138 04621 640700014175016010000000	        D[CONST 1] ROT[7] ALU[DORQ] DEST[Q] NORM $ ; PI ON
23m0138 04622 533140024571022440000000	PIL3:   D[MA] ROT[11]  C550 COND[-OBUS18] JUMP[PIL4] $
23m0138 04623 640700014275016010000000	        D[CONST 1] ROT[7] ALU[-D&Q] DEST[Q] NORM $ ; PI OFF
23m0138 04624 533140024571016440000000	PIL4:   D[MA] ROT[7]  C550 COND[-OBUS18] JUMP[PIL5] $
23m0138 04625 640700000175000440000000	        D[AR] ALU[DORQ] DEST[Q] NORM $ ; CHNS ON
23m0138 04626 533140024571020440000000	PIL5:   D[MA] ROT[10]  C550 COND[-OBUS18] JUMP[PIL6] $
23m0138 04627 640700000275000440000000	        D[AR] ALU[-D&Q] DEST[Q] NORM $ ; CHNS OFF
23m0138 04630 640701000555000443000000	PIL6:   ALU[Q] DEST[4] DEST-A-MEM NORM $
23m0138 04631 533140024571014440004534	        D[MA] ROT[6]  C550 COND[-OBUS18] JUMP[PI-CHECK-RQS] $
23m0138 04632 640700000073000070000000	        D[AR] MASK[7] ALU[0-D] DEST[Q] NORM $
23m0138                               	                ;GENERATED INTRPTS REQUESTED. CHECK TO
23m0138                               	                ; MAKE SURE ONLY ONE CHN IS SPECIFIED.
23m0138 04633 640700000235000070000000	        D[AR] MASK[7] ALU[D&Q] DEST[Q] NORM $
23m0138                               	        D[AR] MASK[7] ALU[D-Q] C600
23m0138 04634 470140000537000070004634	          COND[-OBUS=0] JUMP[.] $ ;HANG HERE IF MORE THAN ONE.
23m0138 04635 640050000571000070004526	        D[AR] MASK[7]  DEST[AR] NORM PUSHJ[PI-GET-CHN] $
23m0138                               	                ;GET BINARY CHN. NUMBER AND UNARY MASK.
23m0138 04636 640140000571000440004567	        NORM JUMP[PIGEN1] $ ;GO GENERATE REQUEST.
23m0138                               	
23m0138                               	
23m0138                               	PICONISUB:
23m0138 04637 640700060171000222400000	        D[14] SPEC[A-MEM-APR] MASK[18.] DEST[Q] NORM $
23m0138                               	          ;GET SYS ON AND CHN ON BITS.
23m0138 04640 640710064571000102400000	        D[15] SPEC[A-MEM-APR] MASK[10] DEST[AR] NORM $
23m0138                               	          ;GET PI IN PROG BITS
23m0138 04641 640710000175020440000000	        D[AR] ROT[10] ALU[DORQ] DEST[AR Q] NORM $
23m0138 04642 640710064571044102400000	        D[15] SPEC[A-MEM-APR] ROT[18.] MASK[10] DEST[AR] NORM $
23m0138                               	          ;GET WAITING RQ BITS, AND RETURN IN LEFT HALF.
23m0138 04643 640310000175044440000000	        D[AR] ROT[18.] ALU[DORQ] DEST[AR Q] NORM POPJ $
23m0138                               	
23m0138                               	PI-RESET:
23m0138 04644 640701000615000442600000	        ALU[0] DEST[4] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
23m0138 04645 640701200615000442600000	        ALU[0] DEST[5] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
23m0138 04646 640301400215000442600000	        ALU[0] DEST[6 Q] SPEC[A-MEM-APR&DEST-A-MEM] NORM POPJ $
23m0138                               	
23m0138                               	;;;     ALU[0] DEST[1] SPEC[A-MEM-APR&DEST-A-MEM] NORM POPJ $
23m0138                               	;;; This is an obsolete bug trap -- DWP 9/80
23m0138                               	
23m0138                               	END-OF-PI-CODE:
23m0138                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

24m0138                               	;; MBOOT MOVED TO PAGE WITH REST OF TAPE STUFF
24m0138                               	
24m0138                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

25m0138                               	;MAPIOT MAPIO1 MAPCO0 MAPCOB MAPCOC MFT1 MFT1A MFT1D MFRD MFOTH MBLT3 SETHLF QORCRY
25m0138                               	 SETHFU BWRTA1 MBLT2 MAPCWT MAPCW1 MAPCW2
25m0138                               	;------------------------------------------------------------------------------
25m0138                               	;
25m0138                               	;       BBN Pager - Map CONO Dispatch Table
25m0138                               	;
25m0138                               	;*** What these things do should documented here.  It's hard enough to find it
25m0138                               	;*** elsewhere!  TVR-Apr80
25m0138                               	;
25m0138                               	;       This code is all BBN dependent.  It will be replaced for other pagers.
25m0138                               	;
25m0138                               	;------------------------------------------------------------------------------
25m0138                               	
25m0138                               	        .ORG[XLIST
25m0138                               	 LIST ];$*$*$ This should be fixed
25m0138                               	
25m0138 05200 640140000571000440000000	        JUMP[MAPCO0] NORM $               ;CONO 0
25m0138 05201 640145000571000440000000	        DEST[CLR-MAP] JUMP[MAPCO1] NORM $ ;CONO 1 -- START MAP CLEARING
25m0138 05202 640150020171000440002125	        UAOP1 D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]$                               ;CONO 2
25m0138                               	 -- Ill. Instruction
25m0138 05203 640145000571000440000000	        DEST[CLR-MAP] JUMP[MAPCO1] NORM $ ;CONO 3 -- START MAP CLR
25m0138 05204 640141614571000010000000	        D[CONST 1] DEST[DEV-ADR] JUMP[MAPCO4] NORM $; CONO 4
25m0138 05205 640141614571000010000000	        D[CONST 1] DEST[DEV-ADR] JUMP[MAPCO4] NORM $; CONO 5
25m0138 05206 640140000571000440000000	        JUMP[MAPCO6] NORM $               ;CONO 6
25m0138 05207 640145000571000440000000	        DEST[CLR-MAP] JUMP[MAPCO7] NORM $ ;CONO 7
25m0138                               	
25m0138                               	        .USE[25m0138                               	XLIST
25m0139                               	 LIST ]                 ;$*$*$  This is truely silly.  The CTY code appears
25m0139                               	                        ;       after the map dispatch and the map code
25m0139                               	                        ;       after the CTY dispatch!
25m0139                               	        .PAIR
25m0139                               	. \ 2 + .
25m0140                               	]       UIOTRP[25m0140 05140 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
25m0140                               	]$
25m0140 05141 531140034571022440002026	MAPIOT: D[IR] ROT[9.] COND[-OBUS<0] JUMP[MAIN] C550 $ ;NOP IF DEV. 20
25m0140 05142 510140014735000140000000	        D[CONST 14] ALU[D#Q] COND[OBUS=0] JUMP[MAPIO1] C550 $; IS IT CONO ?
25m0140 05143 510140014735000130000000	        D[CONST 13] ALU[D#Q] COND[OBUS=0] JUMP[MAPDO] C550 $; NO IS IT DATAO?
25m0140                               	        ILGIOT 25m0140 05144 000140000571000440002026	 JUMP [MAIN] ]$   ;ELSE ILLEGAL
25m0140 05145 640700034171000030000000	MAPIO1: D[IR] MASK[3] DEST[Q] NORM $
25m0140 05146 440540014575014520000000	        D[CONST 52] ROT[6] ALU[DORQ] SDISP C600 $
25m0140 05147 640041614571000010000000	MAPCO0: D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $
25m0140 05150 640700050171000440000000	        D[12] DEST[Q] NORM $; GET SIGN BIT = ENBL FOR EXEC 0-77777
25m0140 05151 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
25m0140 05152 640702234571000023600000	        D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] SHORT $
25m0140 05153 440745014571000200100000	        MAPF[10] CYLEN[IOB-OUT] DEST[CLR-MAP] D[CONST 20] LLOAD $; TURN OFF MAPPING &
25m0140                               	 START CLEARING MAP
25m0140 05154 500240000571000440005154	        LOOP [.] C550 $  ;WAIT FOR MAP CLR TO FINISH -- OTHERWISE THE
25m0140                               	                ; READS OF 71 AND 72 BELOW DON'T HAPPEN (ON F2 #1).
25m0140 05155 640720014571000710000000	        D[CONST 71] DEST[MA] SHORT $; FETCH MAGIC LOC
25m0140 05156 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] CYLEN[FIXM]  $; WAIT FOR DATA
25m0140 05157 640710004571000130000000	        D[MEM] MASK[13] DEST[AR] SHORT $
25m0140 05160 640701000571022443000000	        D[AR] ROT[11] DEST-A-MEM DEST[4] NORM $; MBR
25m0140 05161 640710004571044130000000	        D[MEM] ROT[18.] MASK[13] DEST[AR] SHORT $
25m0140 05162 640700200571022443000000	        D[AR] ROT[11] DEST-A-MEM DEST[1] NORM $; UBR
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

25m0140                               	.REPEAT 1 - WAITS [
25m0140 05163 640710004571056050000000	        D[MEM] ROT[27] MASK[5] DEST[AR] SHORT $
25m0140 05164 640700600571010443000000	        D[AR] ROT[4] DEST-A-MEM DEST[3] NORM $; AC BASE REG
25m0140                               	].REPEAT 1 - WAITS
25m0140 05165 450150004473016030000000	        D[MEM] ROT[7] MASK[3] ALU[0-D] DEST[AR] COND[OBUS=0] JUMP[MAPCOB] C600 $; ADDRS
25m0140                               	 LIMIT, J IF 0
25m0140 05166 640710000571000030000000	        D[AR] MASK[3] DEST[AR] SHORT $
25m0140 05167 640150000571034440000000	        D[AR] ROT[16] DEST[AR] JUMP[MAPCOC] NORM $; FORM SMALLEST ILLEGAL ADDRESS
25m0140 05170 640710014571034200000000	MAPCOB: D[CONST 20] ROT[16] DEST[AR] SHORT $
25m0140 05171 640700014235106010000000	MAPCOC: D[CONST 1] ROT[43] ALU[D&Q] DEST[Q] SHORT $; GET SIGN BIT = ENBL FOR EXEC 0-77777
25m0140                               	
25m0140 05172 640710400575000443000000	        D[AR] ALU[DORQ] DEST-A-MEM DEST[AR 2] NORM $; ADDRS LIMIT
25m0140                               	.REPEAT WAITS [
25m0140                               	.REPEAT WAITS
25m0140 05173 640720014571000720000000	        D[CONST 72] DEST[MA] SHORT $; GET NEXT WORD
25m0140 05174 000700004171000440000000	        D[MEM] DEST[Q] LONG $   ;LONG to wait for data to arrive.
25m0140 05175 640141214675064013000000	        D[CONST 1] ROT[32] ALU[-D&Q] DEST-A-MEM DEST[5] JUMP[MAPCOE] NORM $; AGE &
25m0140                               	 PROCESS BITS
25m0140                               	
25m0140                               	;------------------------------------------------------------------------------
25m0140                               	;
25m0140                               	;       MAP FAULT DISPATCHES COME HERE (6100 + MAPF*4 )
25m0140                               	;
25m0140                               	;       MAP traps happen on next micro instruction after a MEMSTO or STRT-WRT.
25m0140                               	;       They also happen after micro instruction containing a DEST[FIXMAC...],
25m0140                               	;       as in FIXM1 for example.  The trap happens by forcing an unconditional
25m0140                               	;       jump to an address determined by MAP-DISP register and the MAPF of
25m0140                               	;       field of the failing micro instruction.  Otherwise, that micro
25m0140                               	;       instruction is executed normally.
25m0140                               	;       
25m0140                               	;       This code should be the same for all kinds of maps.  However, it will
25m0140                               	;       be necessary to define symbolically the trap code, i.e. the thing that
25m0140                               	;       is usually being loaded left half of Q.  After doing that, and updating
25m0140                               	;       necessary state of PC and flags, the code leave by jumping to MFT1B,
25m0140                               	;       the map dependent page fault/page fill code, with fault code in Q and
25m0140                               	;       failing address in the MA.
25m0140                               	;
25m0140                               	; ***   As you will notice, there are NO spare trap codes.  If you need one,
25m0140                               	; ***   talk to me about a scheme for fixing this and improving page fault
25m0140                               	; ***   recovery.  TVR-Apr80
25m0140                               	;
25m0140                               	;------------------------------------------------------------------------------
25m0140                               	        .ORG[XLIST
25m0140                               	 LIST ];Fixed by hardware to xx100
25m0140 06100 000140000571000440006100	        JUMP[.] $   ;ILLEGAL MAP FAULT -- MICROCODE BUG IF YOU GET HERE
25m0140                               	.REPEAT XUCODE [
25m0140                               	:16100  ;copy for high mem
25m0140 16100 000140000571000440006100	        JUMP[6100] $
25m0140                               	]XUCODE
25m0140                               	        ;**** Consider looking at STOP switch in the future.    TVR - Mar80
25m0140                               	        ;
25m0140                               	        ;To find out non-destructively how you lost, start at 2003 (on an F2)
25m0140                               	        ;you will be stopped at PC+1, assuming you lose trying to display
25m0140                               	        ;that instruction in the lights (i.e. (PC) not mapped in)
25m0140                               	        ;
25m0140                               	        ;You can get here by examining/depositing a location in the
25m0140                               	        ;hardware map (i.e. it may only be asking for a page-fill cycle).
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

25m0140                               	: 6104  ;EXECUTE (&INDIRECT) FAULTS HERE
25m0140 06104 640700014171044020000000	MFT1:   D[CONST 2] ROT[18.] DEST[Q] NORM $; CODE FOR EXECUTE
25m0140 06105 640701614571000010000000	MFT1A:  D[CONST 1] DEST[DEV-ADR] NORM $
25m0140 06106 640702400571000443400000	MFT1D:  DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
25m0140 06107 140150230571000030040000	        D[IOD] MASK[3] DEST[AR IR-ADR] JUMP[MFT1B] MAPF[4] CYLEN[IOB-IN] $
25m0140                               	: 6110  ;NORMAL READ FAULT
25m0140 06110 640700014171044100000000	MFRD:   D[CONST 10] ROT[18.] DEST[Q] NORM $;CODE FOR RD
25m0140 06111 640144620531000440006105	MFOTH:  D[PC] ALU[D-1] DEST[PC] JUMP[MFT1A] NORM $
25m0140                               	.REPEAT XUCODE [
25m0140                               	:16110  ;NORMAL READ FAULT -High mem duplicate instr.
25m0140 16110 640700014171044100000000	        D[CONST 10] ROT[18.] DEST[Q] NORM $;CODE FOR RD
25m0140                               	]XUCODE
25m0140                               	: 6114  ;RMW HERE, DECREMENTS PC
25m0140 06114 640140014171044140006111	        D[CONST 14] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $
25m0140                               	.REPEAT XUCODE [
25m0140                               	:16114  ;RMW -High mem duplicate instr.
25m0140 16114 640140014171044140006111	        D[CONST 14] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $
25m0140                               	]XUCODE
25m0140                               	: 6120  ;WRITES (NORMAL) HERE (NO DECREMENT PC)
25m0140 06120 640702414171044040000000	        D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $
25m0140 06121 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
25m0140 06122 640701600571000443000000	        D[AR] DEST-A-MEM DEST[7] NORM $;SAVE STORE DATA
25m0140 06123 640160034571000220006106	        D[IR] MASK[18.] DEST[MA] NORM JUMP[MFT1D] $; RESTORE MA
25m0140                               	.REPEAT XUCODE * VID [
25m0140                               	: 16124 ; 5-- BLT-RD IN HIGH MEM (DPY-RD)
25m0140                               	;;;     JUMP[DPYRD] NORM $
25m0140                               	]XUCODE * VID
25m0140                               	: 6124 ; 5-- BLT-RD
25m0140 06124 640704621171000220000000	        D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC] NORM $; RESTORE PC & DEST ADR
25m0140 06125 640700014171044100000000	        D[CONST 10] ROT[18.] DEST[Q] SHORT $; CODE FOR RD
25m0140 06126 640140001561044000206111	MBLT3:  D[AR] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC] JUMP[MFOTH] NORM $; GET
25m0140                               	 SRC ADR
25m0140                               	.REPEAT XUCODE * VID [
25m0140                               	: 16130 ; 6-- BLT-WRT IN HIGH MEM (DPY-WRT)
25m0140                               	;;;     JUMP[DPYWRT] NORM $
25m0140                               	]XUCODE * VID
25m0140                               	: 6130 ;6-- BLT-WRT
25m0140 06130 640724621171000220600000	        D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC MA] SPEC[MA_PC] NORM $; RESTORE PC, GET
25m0140                               	 DEST ADR
25m0140 06131 640710000455000440000000	        ALU[Q-1] DEST[AR] NORM $;  ADJUST SRC ADR
25m0140 06132 640140014171044040006126	        D[CONST 4] ROT[18.] DEST[Q] JUMP[MBLT3] NORM $; CODE FOR WRT
25m0140                               	: 6134 ;7-- BLT-RDA
25m0140 06134 640700001571000440000000	        ACSEL[AC] D[AR] DEST[AC] NORM $; NEW DEST ADR
25m0140 06135 640140014171044100006111	        D[CONST 10] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $; CODE FOR RD
25m0140                               	: 6140 ; 10-- BLT-WRTA
25m0140 06140 640702414171044040000000	        D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; CODE FOR WRT
25m0140 06141 640040024171000220000000	        D[MA] MASK[18.] DEST[Q] PUSHJ[BWRTA1] NORM $; GET MA, SAVE STORE DAT
25m0140 06142 510140000735000220000000	        D[AR] MASK[18.] ALU[D#Q] COND[OBUS=0] JUMP[MBLT2] C550 $
25m0140 06143 640160000055000440000000	        ALU[Q-1] DEST[Q MA] JUMP[MBLT2] NORM $; CORRECT MA
25m0140                               	: 6144 ;11-- BYTE-ILD
25m0140 06144 640040000571000440000000	        PUSHJ[SETHLF] NORM $; SET HALF
25m0140 06145 640140000571000440006110	        JUMP[6110] NORM $; NORMAL READ
25m0140                               	;Page fault in the middle of a interruptable instruction.  Set HALF (BIS)
25m0140                               	;flag as part of page fault processing so that instruction gets restarts in
25m0140                               	;the proper way.
25m0140 06146 645140014171074020000000	SETHLF: D[CONST 2] ROT[36] DEST[Q] COND[USER] JUMP[SETHFU] NORM $;BIT 4--HALF
25m0140                               	                ;Get ready to set HALF (BIS) flag.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

25m0140                               	                ;Watch for special case of User page fault from Exec. TVR-May80
25m0140 06147 640305420575000440000000	QORCRY: D[PC] ALU[DORQ] DEST[CRYOV] POPJ NORM $;SET HALF
25m0140                               	: 6150 ;12 -- BYTE-IDP
25m0140 06150 640040000571000440006146	        PUSHJ[SETHLF] NORM $; SET HALF
25m0140 06151 640140000571000440006114	        JUMP[6114] NORM $;NORMAL RMW
25m0140                               	;When a DEST[CRYOV] is done, the EXEC shift register is cleared (set) to
25m0140                               	;whatever the user bit in the new CRYOV is.  This destroys the information
25m0140                               	;about which space a page fault came from on XCTR (XCT mapped) instruction.
25m0140                               	;We turn it on explicitly here.  Note that since a user cannot do a XCTR,
25m0140                               	;we only have to worry about the case of being in EXEC mode and getting a
25m0140                               	;user mode page fault.  TVR-May80
25m0140 06152 640705420575000440000000	SETHFU: D[PC] ALU[DORQ] DEST[CRYOV] NORM $
25m0140                               	                ;Set the half flag.
25m0140                               	                ;Don't return yet, we need to reset EXEC-SR
25m0140 06153 640305614571022170000000	        SET-TEMP-USER POPJ $
25m0140                               	                ;Remember that the page fault was from a user page!!
25m0140                               	: 6154 ;13 -- BYTE-IND
25m0140 06154 640040000571000440006146	        PUSHJ[SETHLF] NORM $; SET HALF
25m0140 06155 640140000571000440006104	        JUMP[6104] NORM $; NORMAL INDIRECT
25m0140                               	: 6160 ;BLT-WRTB -- XCT MAPPED BLT STORES
25m0140 06160 640702414171044040000000	        D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; CODE FOR WRT
25m0140 06161 640040024171000220000000	        D[MA] MASK[18.] DEST[Q] PUSHJ[BWRTA1] NORM $; GET MA, SAVE STORE DAT
25m0140 06162 640700014171044040000000	        D[CONST 4] ROT[18.] DEST[Q] NORM $
25m0140 06163 640140001571000440006111	        D[AR] ACSEL[AC] DEST[AC] JUMP[MFOTH] NORM $; RESTORE AC
25m0140                               	: 6164 ;-- MAPFTR -- TRAP WHIILE FETCHING JSYS TARGET
25m0140 06164 640702414171044500000000	        D[CONST 50] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; PI CODE
25m0140 06165 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
25m0140 06166 640141600571000443006111	        D[AR] DEST-A-MEM DEST[7] JUMP[MFOTH] NORM $
25m0140                               	: 6170 ;PPOP-- 16 -- POP & POPJ FETCH- RE-INCR PDL PNTR -- THEN LIKE READ FAULT
25m0140 06170 640140015421001000006110	        D[CONST 1,,1] ACSEL[AC] ALU[D+AC] DEST[AC] JUMP[MFRD] NORM $
25m0140                               	: 6174 ;17-- WRITES WITH RELEVANT ADRS IN MA (NO DECR PC)
25m0140 06174 640702414171044040000000	        D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $
25m0140 06175 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $
25m0140 06176 640141604571000443006106	        D[MEM] DEST-A-MEM DEST[7] JUMP[MFT1D] NORM $;SAVE STORE DATA
25m0140 06177 640701614571000010000000	BWRTA1: D[CONST 1] DEST[DEV-ADR] NORM $
25m0140 06200 640301604571000443000000	        D[MEM] DEST-A-MEM DEST[7] POPJ NORM $
25m0140 06201 640700000077000220000000	MBLT2:  D[AR] MASK[18.] ALU[Q-D] DEST[Q] SHORT $; COUNT HOW MANY WORDS MOVED
25m0140 06202 640710000435044440000000	        D[AR] ROT[18.] ALU[Q+D] DEST[AR] SHORT $;FORM NEW SRC
25m0140 06203 640700025571000220000000	        ACSEL[AC] D[MA] MASK[18.] DEST[AC] SHORT $;NEW DEST
25m0140 06204 640700014171044040000000	        D[CONST 4] ROT[18.] DEST[Q] NORM $
25m0140 06205 640140001561044000206111	        D[AR] ACSEL[AC] ROT[18.] SPEC[LEFT] ALU[DORAC] DEST[AC] JUMP[MFOTH] NORM $; OR IN
25m0140                               	 NEW SRC
25m0140                               	
25m0140       6206	OTHER = .       ;$*$*$ This is the end of the fix areas, In'Sh'Allah  TVR-Apr80
25m0140                               	
25m0140                               	: 5340  ;$*$*$ The APR dispatch ends at 5340.
25m0140                               	
25m0140                               	;*$*$* Fudge area accounting
25m0140       5340	AREA53 = .
25m0140                               	        .USE[25m0140                               	XLIST
25m0141                               	 LIST ]
25m0141 05340 640740000555000440000000	MAPCWT: ALU[Q] LLOAD NORM $
25m0141 05341 000240000571000440005341	        LOOP[.] CYLEN[LONG] $; WAIT FOR MAP TO CLEAR
25m0141 05342 640702214571000043600000	        D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $;TURN ON MAP
25m0141 05343 151140000571000440100000	        MAPF[10] D[AR] COND[OBUS<0] JUMP[MAPCW9] CYLEN[MAX,IOB-OUT,C550] $; J IF WHOLE
25m0141                               	 MAP ON (INCLUDING EXEC 0-77777)- DONE
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

25m0141 05344 640740014571000770100000	MAPCW1: D[CONST 77]  MAPF[10] LLOAD NORM $
25m0141 05345 640710020571000440000000	MAPCW2: D[PC]  DEST[AR] SHORT $;SAVE FLAGS
25m0141 05346 640725400615000440000000	        ALU[0] DEST[MA CRYOV] SHORT $;INIT MA, SET EXEC
25m0141 05347 640700014171014100000000	        D[CONST 10] ROT[6]  DEST[Q] SHORT $
25m0141                               	
25m0141                               	 .REPEAT NEWMAP [
25m0141 05350 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $ ; -- FOR WRITING MAP
25m0141 05351 640700000571000443600000	        SPEC[IOB-OUT] SHORT $  ;SET FIRST PART OF 
25m0141                               	           ; EXEC MAP TO POINT TO "NULL MAP" LOCS(UNMAPPED)
25m0141 05352 240700024571000220020000	        MAPF[2] D[MA] MASK[18.] C800 $ ;MAP DATA COMES FROM OBUS.
25m0141 05353 640260024435000440005351	        D[MA] ALU[D+Q] DEST[MA] LOOP[. - 2] NORM $;LOOP
25m0141                               	   ]; NEWMAP
25m0141                               	
25m0141                               	 .REPEAT 1 - NEWMAP [
25m0141                               	; 1 - NEWMAP
25m0141                               	
25m0141 05354 640702234571000033600000	        D[IR] MASK[3]  DEST[IOD] SPEC[IOB-OUT] SHORT $; RESTORE MAP
25m0141 05355 440145400571000440102026	        D[AR]  DEST[CRYOV] JUMP[MAIN] MAPF[10] CYLEN[IOB-OUT] $; RESTORE FLAGS, DONE
25m0141                               	;------------------------------------------------------------------------------
25m0141                               	;       End map trap code which is common to all maps.
25m0141                               	;------------------------------------------------------------------------------
25m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

26m0141                               	;MAPCOA MAPCOE MAPCO1 MAPCOG MAPCO4 MPOFF1 MAPOFF MAPCO6 MAPCO7 MAPCW9 MAPDO MFUS MFA3
26m0141                               	 MFA7 MFA6 MFA4 MFT1B MFHIEX MFA1 MFA2 MFB3 MFTYP1 MFTYP0
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	;       BBN MAP CONO, continued
26m0141                               	;
26m0141                               	;       This code will need to be rewritten for another kind of map.
26m0141                               	;
26m0141                               	;------------------------------------------------------------------------------
26m0141 05356 640702400571000443400000	MAPCOA: DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
26m0141 05357 140300230571000030040000	        D[IOD]  MASK[3] DEST[IR-ADR] MAPF[4] POPJ CYLEN[IOB-IN] $;GET MAP, ECC & OV ENBL
26m0141                               	 BITS
26m0141 05360 640701600615000440000000	MAPCOE: ALU[0] DEST[DEV-ADR] SHORT $
26m0141 05361 640702234571000033600000	        D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE MAP STATE
26m0141 05362 440140014171000010105340	        MAPF[10] D[CONST 1] DEST[Q] JUMP[MAPCWT] CYLEN[IOB-OUT] $
26m0141 05363 640041614571000010005356	MAPCO1: D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $;GET ENABLE BITS IN IR
26m0141 05364 640710050571000440000000	        D[12] DEST[AR] NORM $; GET SIGN BIT = ENBL EXEC 0-77777
26m0141 05365 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
26m0141 05366 640140014171000050005340	        D[CONST 5] DEST[Q] JUMP[MAPCWT] NORM $
26m0141 05367 640701614571000010000000	MAPCOG: D[CONST 1] DEST[DEV-ADR] NORM $
26m0141 05370 640700050171000430000000	        D[12] MASK[43] DEST[Q] NORM $
26m0141 05371 640710034571000010000000	        D[IR] MASK[1] DEST[AR] SHORT $;GET LOW BIT OF CONO
26m0141 05372 640700400575106443000000	        D[AR] ROT[43] ALU[DORQ] DEST-A-MEM DEST[2] NORM $;GET SIGN BIT = EXEC 0-77777 MAP
26m0141                               	 ENBL
26m0141 05373 640700000571000443400000	        SPEC[IOB-IN] SHORT $
26m0141 05374 140700030171000030040000	        MAPF[4] D[IOD] MASK[3] DEST[Q] CYLEN[IOB-IN] $
26m0141 05375 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
26m0141 05376 640702214575000043600000	        D[CONST 4] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] SHORT $
26m0141 05377 440300214575000040100000	        D[CONST 4] ALU[DORQ] DEST[IR-ADR] MAPF[10] POPJ CYLEN[IOB-OUT] $;TURN ON MAP
26m0141 05400 640042400571000443400000	MAPCO4: DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] NORM PUSHJ[MAPOFF] $
26m0141                               	
26m0141 05401 440140000571000440102026	MPOFF1: MAPF[10] CYLEN[IOB-OUT] JUMP[MAIN] $; DONE
26m0141 05402 140700230571000030040000	MAPOFF: D[IOD] MASK[3] DEST[IR-ADR] MAPF[4] CYLEN[IOB-IN] $
26m0141 05403 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
26m0141 05404 640302234571000023600000	        D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM POPJ $
26m0141                               	
26m0141 05405 640042400571000440005367	MAPCO6: DEST[CLR-DEV-FROM-INTR] PUSHJ[MAPCOG] NORM $
26m0141 05406 640140000571000440005344	        JUMP[MAPCW1] NORM $
26m0141 05407 000042400571000440005367	MAPCO7: DEST[CLR-DEV-FROM-INTR] PUSHJ[MAPCOG] CYLEN[LONG] $
26m0141 05410 000700000571000440000000	        CYLEN[LONG] $; WAIT FOR MAP TO CLEAR
26m0141 05411 000700000571000440000000	        CYLEN[LONG] $
26m0141 05412 640740000615000440000000	MAPCW9: ALU[0] LLOAD NORM $; SET UP ONLY PAGE 0
26m0141 05413 640140000571000440005345	        JUMP[MAPCW2] NORM $
26m0141                               	
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	;DATAO CLEARS THE "ASSOCIATIVE" REGISTER MAPPING THE ADDRESS OF THE DATAO
26m0141                               	; THIS REPLACES CONO 2.
26m0141                               	;------------------------------------------------------------------------------
26m0141 05414 640041614571000010005356	MAPDO:  D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $;GET MAP BITS
26m0141                               	 .REPEAT 1 - NEWMAP [ 26m0141 05415 640702214571000043600000	        D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $;TURN ON MAP
26m0141 05416 440700000571000440100000	        MAPF[10] CYLEN[IOB-OUT] $
26m0141                               	 .REPEAT NEWMAP [
26m0141 05417 640700000571000443600000	        SPEC[IOB-OUT] SHORT $  ;REQUEST MAP WRITE CYCLE.
26m0141 05420 240700014571064010020000	        MAPF[2] D[CONST 1] ROT[32] C800 $ ]
26m0141                               	 .REPEAT 1 - NEWMAP [
26m0141                               	          ;CLR MAP ENTRY ASSOCIATED WITH MA
26m0141 05421 240702234571000033600000	        D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] C800 $; RESTORE ENABLES
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

26m0141 05422 440140000571000440102026	        MAPF[10] CYLEN[IOB-OUT] JUMP[MAIN] $
26m0141                               	
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	;
26m0141                               	;       BBN MAP - Handle map trap and page fill cycles.
26m0141                               	;
26m0141                               	;       This code will need to be rewritten for another kind of map.
26m0141                               	;
26m0141                               	;------------------------------------------------------------------------------
26m0141 05423 640700050171000400000000	MFUS:   D[12] MASK[40] DEST[Q] NORM $;GET LIMIT REG
26m0141 05424 471140024537000440000000	        D[MA] ALU[D-Q] COND[-OBUS<0] JUMP[MTRPAL] C600 $;J IF MA PAST ADDRS LIMIT
26m0141 05425 640140044171000440000000	        D[11] DEST[Q] JUMP[MFA1] NORM $;GET USER BASE REG.
26m0141                               	
26m0141 05426 530140004571024010000000	MFA3:   D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFA4] C550 $ ;J IF MODIF. BIT ON
26m0141 05427 640700600571000440000000	MFA7:   D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
26m0141 05430 640701400571000443000000	        D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
26m0141 05431 640710014575056010000000	        D[CONST 1] ROT[27] ALU[DORQ] DEST[AR] SHORT $; TURN ON WRT-PREVENT, SAVE NEW MAP
26m0141                               	 WORD
26m0141 05432 640140004171000330000000	MFA6:   D[MEM] MASK[33] DEST[Q] JUMP[MFA5] NORM $; GET CST ENTRY, GO DO
26m0141 05433 510140034571054010005427	MFA4:   D[IR] ROT[26] MASK[1] COND[OBUS=0] JUMP[MFA7] C550 $; J IF NO WRT-PERMIT
26m0141 05434 640700600571000440000000	        D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
26m0141 05435 640701400571000443000000	        D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
26m0141 05436 640150010635060430005432	        D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] JUMP[MFA6] NORM $; CLEAR WRT-PREVENT
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	; Enter here with fault code in Q and address in MA to handle page fault or
26m0141                               	; page fill cycle.  MAP-EXEC-SR (i.e. USER condition) is still undisturbed.
26m0141                               	;------------------------------------------------------------------------------
26m0141 05437 645150024575000220005423	MFT1B:  D[MA] MASK[18.] ALU[DORQ] DEST[AR] COND[USER] JUMP[MFUS] NORM $;GET FAILED ADDRS,
26m0141                               	 J IF USER
26m0141 05440 640700024171050020000000	        D[MA] ROT[24] MASK[2] DEST[Q] NORM $; HIGH ORDER 2 BITS
26m0141 05441 450140014537000030000000	        D[CONST 3] ALU[D-Q] COND[OBUS=0] JUMP[MFHIEX] C600 $; J IF PRIVATELY MAPPED PART
26m0141                               	
26m0141 05442 640140014171014300000000	        D[CONST 30] ROT[6] DEST[Q] JUMP[MFA1] NORM $; PAGE TAB @ 3000
26m0141 05443 640700060171000440000000	MFHIEX: D[14] DEST[Q] NORM $
26m0141 05444 640701600615000440000000	MFA1:   ALU[0] DEST[DEV-ADR] NORM $
26m0141 05445 640702234571000023600000	        D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM $ ;CLEAR MAPPING
26m0141 05446 440701634571000033100000	        D[IR] MASK[3] DEST-A-MEM DEST[APRENB] MAPF[10] CYLEN[IOB-OUT] $
26m0141                               	                ;SAVE AR, ECC INT
26m0141 05447 640722624435066110000000	        D[MA] ROT[33] MASK[11] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE ENTRY
26m0141                               	
26m0141 05450 640700214571030160000000	        D[CONST 16] ROT[14] DEST[IR-ADR] NORM $; PREPARE INITIAL PERMIT BITS
26m0141 05451 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
26m0141 05452 640700014171000030000000	MFA2:   D[CONST 3] DEST[Q] CYLEN[FIXM] $; DON'T CLEAR IND PNTR. COUNT, WAIT FOR FETCH
26m0141 05453 640700004175044440000000	        D[MEM] ROT[18.] ALU[DORQ] DEST[Q] CYLEN[FIXM+1] $;GET PERMIT BITS
26m0141 05454 640700234635000440000000	        D[IR] ALU[D&Q] DEST[IR-ADR] SHORT $; AND THEM IN
26m0141 05455 530140004571026030000000	        D[MEM] ROT[13] MASK[3] COND[-OBUS=0] JUMP[MFTR1] C550 $; CHECK FOR TRAP BITS
26m0141 05456 510140004571032010000000	MFB3:   D[MEM] ROT[15] MASK[1] COND[OBUS=0] JUMP[MFTR2] C550 $; J IF NO ACCESS PERMIT
26m0141 05457 510140004171004020000000	        D[MEM] ROT[2] MASK[2] DEST[Q] COND[OBUS=0] JUMP[MFTYP0] C550 $; GET TYPE CODE, J
26m0141                               	 IF 0
26m0141 05460 510140000055000440000000	        ALU[Q-1] DEST[Q] COND[OBUS=0] JUMP[MFTYP1] C550 $; J IF 1
26m0141 05461 530140000055000440000000	        ALU[Q-1] DEST[Q] COND[-OBUS=0] JUMP[MFTR3] C550 $; J IF NOT 2
26m0141 05462 530140034571106010000000	        D[IR] ROT[43] MASK[1] COND[-OBUS=0] JUMP[MFTR41] C550 $; TYPE 2, J IF >2 INDR.
26m0141                               	 PNTRS
26m0141 05463 640700234433000440000000	        D[IR] ALU[D+1] DEST[IR-ADR] SHORT $; COUNT IND. PNTRS
26m0141 05464 640700004171066150000000	        D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET PAGE TABLE #
26m0141 05465 640701404571000443000000	        D[MEM] DEST-A-MEM DEST[6] NORM $; SAVE PNTR
26m0141 05466 640722614435030020000000	        D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE PNTR
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

26m0141 05467 640700070171000110000000	        D[16] MASK[11] DEST[Q] CYLEN[FIXM] $; GET PAGE #, WAIT FOR MEM
26m0141 05470 530140004571044040000000	        D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR4] C550 $; PAGE OUT-OF-CORE?
26m0141 05471 640704404571000130000000	        D[MEM] MASK[13] DEST[HOLD] NORM $
26m0141 05472 640162604575022440005452	        D[MEM] ROT[11] ALU[DORQ] DEST[MA HI-ABS-MA] JUMP[MFA2] NORM $; LOOP
26m0141 05473 640700004171066150000000	MFTYP1: D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET SHARED PAGE #
26m0141 05474 640722614435030020000000	        D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH SHARED PNTR
26m0141 05475 640700014171030120000000	MFTYP0: D[CONST 12] ROT[14] DEST[Q] CYLEN[FIXM] $; GET R-X MASK
26m0141 05476 450140034635000440005500	        D[IR] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C600 $; J IF NEITHER R NOR X
26m0141 05477 640700234575000440000000	        D[IR] ALU[DORQ] DEST[IR-ADR] NORM $; TURN ON R AND X
26m0141 05500 640700034371056030000000	        D[IR] ROT[27] MASK[3] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX ENBL BITS,
26m0141                               	 INVERTED
26m0141 05501 530140004571044040000000	        D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR5] CYLEN [C550] $; J IF
26m0141                               	 OUT-OF-CORE
26m0141 05502 530140000235042030000000	        D[AR] ROT[21] MASK[3] ALU[D&Q] DEST[Q] COND[-OBUS=0] JUMP[MFTR6] C550 $; J IF
26m0141                               	 ILLEGAL ACCESS TYPE (RWX)
26m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

27m0141                               	;MFA5 JSMFR MFTR1 MFTR10 MFB5 MFB4 MFC1 MFTR2 MTRPAL MFTR3 MFTR4 MFTR5 MFTR6 MFTR7 MFTR9
27m0141                               	 MFTR41 MAPRST MAPRSS MAPRSL
27m0141 05503 640700004171000130000000	        D[MEM] MASK[13] DEST[Q] SHORT $; GET ABS PAGE #
27m0141 05504 640722614575014400000000	        D[CONST 40] ROT[6] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; GET CORE STATUS ENTRY
27m0141 05505 640700034371024440000000	        D[IR] ROT[12] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX DISABLES
27m0141 05506 640700014235052240000000	        D[CONST 24] ROT[25] ALU[D&Q] DEST[Q] SHORT $; GET ONLY R & X
27m0141 05507 640700014035052040000000	        D[CONST 4] ROT[25] ALU[D+Q] DEST[Q] SHORT $; MOVE X BIT LEFT 1
27m0141 05510 640700024175022240000000	        D[MA] ROT[11] MASK[24] ALU[DORQ] DEST[Q] SHORT $; OR IN PAGE ADDRS
27m0141 05511 510140004571006030000000	        D[MEM] ROT[3] MASK[3] COND[OBUS=0] JUMP[MFTR7] C550 $; J IF CST AGE SAYS TRAP
27m0141 05512 510140000571040010005426	        D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFA3] C550 $;J IF NO WRT RQ
27m0141 05513 640700200571000440000000	        D[AR] DEST[IR-ADR] SHORT $; SAVE ORRIGINAL MA
27m0141 05514 640701400571000443000000	        D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
27m0141 05515 640710010635060430000000	        D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] SHORT $; TURN OFF WRT PREVENT, SAVE NEW MAP
27m0141                               	 WORD
27m0141 05516 640700014171064010000000	        D[CONST 1] ROT[32] DEST[Q] SHORT $; GET MODIFICATION BIT
27m0141 05517 640700004175000320000000	        D[MEM] MASK[32] ALU[DORQ] DEST[Q] SHORT $; OR INTO CST WORD
27m0141 05520 640704464575000440000000	MFA5:   D[15] ALU[DORQ] DEST[HOLD] NORM $;OR IN AGE, ETC
27m0141 05521 640700024171000440000000	        D[MA] DEST[Q] SHORT $; SAVE CST ADDRS
27m0141                               	
27m0141 05522 640722634571000220000000	        D[IR] MASK[18.] DEST[MA HI-ABS-MA] NORM $; GET ORIGINAL MA
27m0141                               	
27m0141                               	 .REPEAT NEWMAP [
27m0141 05523 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $ ;NOW TURN MAP ON.
27m0141 05524 640702214571000043600000	        D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $
27m0141 05525 440700000571000443700000	        MAPF[10] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
27m0141 05526 240700000571000440020000	        MAPF[2] D[AR] C800$; LOAD MAP
27m0141 05527 000700000571000440000000	  NOP $ ;%%%%%%% FOR DEBUGGING $$$$$$$$
27m0141                               	  ]; NEWMAP
27m0141                               	
27m0141                               	 .REPEAT 1 - NEWMAP [
27m0141                               	; 1-NEWMAP
27m0141                               	
27m0141 05530 240702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] C800 $ ;MAP OFF
27m0141 05531 465140000571000440105533	        MAPF[10] CYLEN[IOB-OUT] COND[-USER] JUMP[. + 2] $
27m0141                               	
27m0141 05532 640705614571022170000000	        D[CONST 17] ROT[11] DEST[MAP-EXEC-SR] NORM $
27m0141 05533 640724000555000440000000	        ALU[Q] DEST[MA STRT-WRT] NORM $; STORE CST
27m0141                               	
27m0141                               	.REPEAT 1 - WAITS [;27m0141                               	Damnit. TENEX isn't the only operating system for a PDP-10!
27m0141                               	   ;Now add 1 to abs. loc. 30 of main mem (for statistics keeping)
27m0141 05534 640720014571000300000000	        D[CONST 30] DEST[MA] NORM $
27m0141 05535 640700000571000440000000	        NORM $
27m0141 05536 640704204433000440000000	        D[MEM] ALU[D+1] DEST[MEMSTO] NORM $
27m0141                               	].REPEAT 1 - WAITS
27m0141                               	
27m0141 05537 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
27m0141 05540 640710070571000440000000	        D[16] DEST[AR] NORM $
27m0141 05541 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
27m0141 05542 640702274571000443600000	        D[10 + APRENB] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN MAP BACK ON, ETC.
27m0141                               	        MAPF[10] CYLEN[MAX,IOB-OUT,C550]
27m0141 05543 170140000571032010100000	                        D[AR] ROT[15] MASK[1] COND[-OBUS=0] JUMP[JSMFR] $
27m0141                               	                ; DO SPECIAL JSYS STUFF IF APPROPRIATE
27m0141 05544 510140000571040010002026	        D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MAIN]  C550 $; DONE IF NO WRT
27m0141 05545 530140000571036010002026	        D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MAIN] C550 $; DONE IF READ
27m0141 05546 640720000571000220000000	        D[AR] MASK[18.] DEST[MA] SHORT $;GET ORRIG. MA
27m0141 05547 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

27m0141 05550 640144274571000440002033	        D[17] DEST[MEMSTO] JUMP[MSMAIN1] NORM $; STORE THE STORE DATA, & PROCEDE
27m0141 05551 640720000571000220000000	JSMFR:  D[AR] MASK[18.] DEST[MA] NORM $
27m0141 05552 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
27m0141 05553 640150074571000440004464	        D[17] DEST[AR] JUMP[MUJSM1] NORM $; RESTORE STORE DATA
27m0141                               	
27m0141 05554 530140004571022010000000	MFTR1:  D[MEM] ROT[11] MASK[1] COND[-OBUS=0] JUMP[MFTR9] C550 $; J IF TRAP TO USER
27m0141 05555 530140004571024010000000	        D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFTR10] C550 $;J IF WRT TRAP
27m0141 05556 640140004571000440000000	        D[MEM] JUMP[MFTR2] NORM $; TREAT BOTH "TRAP-TO-MON" CODES AS IMMEDIATE
27m0141 05557 510140000571040010005456	MFTR10: D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFB3] C550 $; WRT RQ? J IF NO
27m0141 05560 640700014171074440000000	        D[CONST 44] ROT[36] DEST[Q] SHORT $; GET ERROR CODE BITS -- WRT TRAP
27m0141                               	MFB5:
27m0141 05561 645150000175000440005563	MFB4:   D[AR] ALU[DORQ] DEST[AR Q] COND[USER] JUMP[. + 2] NORM $; OR ERROR BITS IN, J IF
27m0141                               	 USER MODE
27m0141 05562 640710014575044010000000	        D[CONST 1] ROT[18.] ALU[DORQ] DEST[AR] NORM $; TURN ON EXEC BIT
27m0141 05563 640700014171014050000000	        D[CONST 5] ROT[6] DEST[Q] SHORT $
27m0141 05564 640700014175000710000000	        D[CONST 71] ALU[DORQ] DEST[Q] SHORT $; FORM 571
27m0141 05565 640722660575000440000000	        D[14] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; ADD PSB (MON BASE TAB)
27m0141 05566 640704200571000440000000	        D[AR] DEST[MEMSTO] CYLEN[FIXM] $; STORE ERROR BITS THERE
27m0141 05567 510140000571040010000000	        D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFC1] C550 $; J IF NO WRT RQ
27m0141 05570 530140000571036010000000	        D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MFC1] C550 $; J IF RD RQ
27m0141 05571 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] SHORT $; GO TO 572
27m0141 05572 640704274571000440000000	        D[17] DEST[MEMSTO] NORM $; SAVE STORE DATA
27m0141 05573 640701600615000440000000	MFC1:   ALU[0] DEST[DEV-ADR] CYLEN[MEMSTO] $
27m0141 05574 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN OFF MAP
27m0141 05575 440702600615000440100000	        MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $
27m0141 05576 640720014571000700000000	        D[CONST 70] DEST[MA] SHORT $; FETCH TRAP INSTR
27m0141 05577 640701600615000440000000	        ALU[0] DEST[DEV-ADR] CYLEN[FIXM] $
27m0141 05600 640702274571000443600000	        D[10 + APRENB] DEST[IOD] SPEC[IOB-OUT] SHORT $; TURN ON MAP
27m0141 05601 440710020171000440100000	        D[PC] DEST[Q AR] MAPF[10] CYLEN[IOB-OUT] $
27m0141 05602 640705410635076430000000	        D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $;CLR USER
27m0141 05603 640140014171004550002106	        D[CONST 55] ROT[2] DEST[Q] JUMP[MUUO44] NORM $
27m0141 05604 640140014171074410005561	MFTR2:  D[CONST 41] ROT[36] DEST[Q] JUMP[MFB5] NORM $; ASCCESS PERMISSION TRAP
27m0141                               	MTRPAL:
27m0141 05605 640700014171074400000000	MFTR3:  D[CONST 40] ROT[36] DEST[Q] SHORT $
27m0141 05606 640140014175066010005561	        D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB5] NORM $; ILLEGAL PT ENTRY TYPE,
27m0141                               	 ADDRESS LIMIT
27m0141                               	MFTR4:  ;ALL THESE ARE NOT-IN-CORE
27m0141 05607 640140014171074220005561	MFTR5:  D[CONST 22] ROT[36] DEST[Q] JUMP[MFB5] NORM $; NOT-IN-CORE
27m0141 05610 510140014635000050005613	MFTR6:  D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[. + 3] C550 $; J IF NO R OR X ERROR
27m0141 05611 640700014175066040000000	        D[CONST 4] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN "R OR X ERROR" BIT
27m0141 05612 510140014635000020005614	        D[CONST 2] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C550 $; J IF NO W ERROR
27m0141 05613 640700014175066020000000	        D[CONST 2] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN W ERROR BIT
27m0141 05614 640700014275000070000000	        D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
27m0141 05615 640140014175074400005561	        D[CONST 40] ROT[36] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; GROUP 2
27m0141 05616 640140014171074100005561	MFTR7:  D[CONST 10] ROT[36] DEST[Q] JUMP[MFB4] NORM $; AGE ERR -- GROUP 0
27m0141 05617 640140014171074420005561	MFTR9:  D[CONST 42] ROT[36] DEST[Q] JUMP[MFB4] NORM $; USER TRAP
27m0141 05620 640700014171074200000000	MFTR41: D[CONST 20] ROT[36] DEST[Q] NORM $; GROUP 1
27m0141 05621 640140014175066010005561	        D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; TOO MANY INDR. PNTRS
27m0141                               	;------------------------------------------------------------------------------
27m0141                               	;Reset map.  Clear entire map to zero.  This is because even though the map
27m0141                               	;will stop stores from happening, fetches still happen irregardless of state
27m0141                               	;of map and if map points at non-existent memory (on for example, an immediate
27m0141                               	;mode instruction), the machine will get a spurious ECC interrupt.
27m0141                               	;
27m0141                               	;It is assumed that the device address is set to 1 when this thing is called.
27m0141                               	;------------------------------------------------------------------------------
27m0141 05622 640705614571022000000000	MAPRST: SET-TEMP-EXEC $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

27m0141                               	                ;Begin at the beginning of EXEC space.
27m0141 05623 640700014171022010000000	        D[CONST 1] ROT[9.] DEST[Q] SHORT $
27m0141                               	                ;Increment for MA
27m0141 05624 640720014537044010000000	MAPRSS: D[CONST 1] ROT[18.] ALU[D-Q] DEST[MA] NORM $
27m0141                               	                ;Start at the top and work down.
27m0141                               	MAPRSL:
27m0141                               	.REPEAT 1 - NEWMAP [
27m0141                               	.REPEAT 1 - NEWMAP
27m0141                               	.REPEAT NEWMAP [
27m0141 05625 640700000571000443600000	        START-OUT SHORT $
27m0141 05626 640700014571064010020000	        MAPF[2] D[CONST 1] ROT[35. - 9.] NORM $
27m0141                               	                ;Set mapping to zero, Invalid
27m0141 05627 262160024537000440005625	        D[MA] ALU[D-Q] DEST[MA] COND[-MA-AC] JUMP[. - 2] C800 $
27m0141                               	                ;Repeat for each page in this space
27m0141                               	].REPEAT NEWMAP
27m0141 05630 665145614571022170005624	        SET-TEMP-USER COND[-USER] JUMP[MAPRSS] $
27m0141                               	                ;Repeat once more if currently doing EXEC space. This
27m0141                               	                ;time for USER space.  We can do this because EXEC-SR is
27m0141                               	                ;latched at the end of the cycle.
27m0141 05631 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
27m0141 05632 640702214571000013600000	        D[CONST 1] DEST[IOD] SPEC[IOB-OUT] NORM $
27m0141 05633 440702014571000030140000	        MAPF[14] CYLEN[IOB-OUT] D[CONST 3] DEST[MAP-DISP] $
27m0141 05634 000303600571000440000000	        DEST[CLR-MI-ERR] POPJ $ ;Done
27m0141                               	
27m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

28m0141                               	;JSYS1 JSYS2 UMOVX XCT1 XCTUMV XCT5 XCT4 XCT6 XCT3 XCT13 XCT18 XCT12 XCT11 XDISP XCT2
28m0141                               	 XCTAC XCTSTK XCTS1 XCTS2 XCT10 XCTBLG XCTBYT XBY1 XBY4 XBY15 XBY14 XBY13 XBY3
28m0141                               	;------------------------------------------------------------------------------
28m0141                               	;
28m0141                               	;       BBN added instructions.  Sometimes used by other than TENEX
28m0141                               	;
28m0141                               	;------------------------------------------------------------------------------
28m0141 05635 640706000550400440020000	JSYS1:  FIXM1 $
28m0141 05636 640710020571000440000000	        D[PC] DEST[AR] NORM $   ;SAVE PC & FLAGS
28m0141 05637 640704604571000220000000	        D[MEM] MASK[18.] DEST[PC] NORM $; JUMP TO RIGHT HALF
28m0141 05640 640720004571044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $
28m0141 05641 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
28m0141 05642 510140014635074010005644	JSYS2:  C550 D[CONST 1] ROT[36] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] $; J IF EXEC MODE
28m0141 05643 640705600615000440000000	        ALU[0] DEST[MAP-EXEC-SR]  NORM $; TEMP TURN OFF USER
28m0141 05644 640700014171014100000000	        D[CONST 10] ROT[6] DEST[Q] SHORT $
28m0141 05645 640720024575000440000000	        D[MA] ALU[DORQ] DEST[MA] SHORT $; FETCH POINTER WORD
28m0141 05646 640706000550400440020000	        FIXM1  $
28m0141 05647 640704604571000220000000	        D[MEM] MASK[18.] DEST[PC] NORM $; J TO RIGHT HALF
28m0141 05650 640700020171000440000000	        D[PC] DEST[Q] SHORT $
28m0141 05651 511140000571012440005653	        D[AR] ROT[5] C550 COND[OBUS<0] JUMP[. + 2] $
28m0141                               	                ;If we came from exec mode, then we...
28m0141 05652 640700014175070010000000	        D[CONST 1] ROT[34] ALU[DORQ] DEST[Q] SHORT $
28m0141                               	                ; ...TURN ON FLAG BIT 7
28m0141 05653 640705414675074010000000	        D[CONST 1] ROT[36] ALU[-D&Q] DEST[CRYOV] SHORT $; TURN OFF USER
28m0141 05654 640720004571044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $; LEFT HALF
28m0141 05655 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$; STORE PC
28m0141                               	
28m0141                               	  .DEFINE JCFM 28m0141                               	
28m0141 05656 645140000571000440002100	UMOVX:  COND[USER] JUMP[MUUO] NORM $
28m0141 05657 640700004171000440000000	        D[MEM] DEST[Q] NORM $
28m0141 05660 640704414435102010000000	        D[CONST 1] ROT[41] ALU[D+Q] DEST[HOLD] NORM $
28m0141 05661 640140014171000050000000	        D[CONST 5] DEST[Q] JUMP[XCTUMV] NORM $
28m0141                               	
28m0141                               	;------------------------------------------------------------------------------
28m0141                               	;
28m0141                               	;       XCTR - Execute Relocated
28m0141                               	;
28m0141                               	;       If in Exec mode and the AC field of the XCT instruction is non-zero,
28m0141                               	;       it means do some of the references from User mode if PC bit (?),
28m0141                               	;       meaning JSYS from Moniter, is not set.
28m0141                               	;
28m0141                               	;       This code is not map dependent, although other maps (like ITS) may code
28m0141                               	;       the bits in the AC field differently, requiring some rewriting.
28m0141                               	;
28m0141                               	;       Warning:  This code is complex and prone to bugs.  Many probably lurk
28m0141                               	;                 in the cracks.  If you find one, please document it even if
28m0141                               	;                 no solution seems to appear.
28m0141                               	;------------------------------------------------------------------------------
28m0141 05662 640704620531000440000000	XCT1:   D[PC] ALU[D-1] DEST[PC] NORM $
28m0141 05663 645140000571000440000000	        COND[USER] JUMP[XCT2] NORM $
28m0141 05664 640700034171032040000000	        D[IR] ROT[15] MASK[4] DEST[Q] SHORT $; SAVE XCT AC FLD
28m0141 05665 664170604571000440000000	XCTUMV: D[MEM] DEST[AR IR-ALL MA] COND[-MEM-IDX-IND] JUMP[XCT3] NORM $
28m0141 05666 510140034571044040020000	XCT5:   D[IR] ROT[18.] MASK[4] COND[OBUS=0] JUMP[XCT4] C550 MAPF[2] $; J IF NO IDX FLD
28m0141 05667 000730234420400220000000	        D[IR] MASK[18.] ALU[IX+D] DEST[MA IR-ADR AR] $; DO INDEX
28m0141 05670 510140034571034010020000	XCT4:   D[IR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XCT3] C550 MAPF[2] $; J IF NO INDR
28m0141 05671 530040014635000100000000	        D[CONST 10] ALU[D&Q] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF ADDR CALC USER
28m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

28m0141                               	XCT6:
28m0141 05672 640706000550400440010000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-IND] CYLEN[FIXM] $
28m0141                               	;;;     FIXM1 $
28m0141                               	;;;             ;It was overdecrementing PC  TVR-Mar80
28m0141 05673 640705614571022000000000	        SET-TEMP-EXEC $
28m0141 05674 644170404571000440005666	        D[MEM] DEST[AR IR-23 MA] COND[MEM-IDX-IND] JUMP[XCT5] NORM $
28m0141 05675 640700200555000440020000	XCT3:   ALU[Q] DEST[IR-ADR] SHORT  MAPF[2] $; SAVE XCT AC FLD
28m0141 05676 640700034171016070000000	        D[IR] ROT[7] MASK[7] DEST[Q] SHORT $; GET HO 7 BITS OF OPCODE
28m0141 05677 510140014735000540000000	        D[CONST 54] ALU[D#Q] COND[OBUS=0] JUMP[XCTSTK] C550 $; J IF STACK GROUP
28m0141 05700 510140014735000270000000	        D[CONST 27] ALU[D#Q] COND[OBUS=0] JUMP[XCTBYT] C550 $; J IF BYTE GROUP
28m0141 05701 510140014735000520000000	        D[CONST 52] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLG] C550 $; J IF GROUP WITH BLT IN IT
28m0141                               	
28m0141 05702 640700034171000040000000	XCT13:  D[IR] MASK[4] DEST[Q] SHORT $; GET XCT AC FLD
28m0141 05703 510140014635000050000000	XCT18:  D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[XDISP] C550 $; J IF NEITHER RELEVANT BIT
28m0141 05704 642140000571000440000000	        COND[MA-AC] JUMP[XCT10] NORM $; J IF EF ADR IS AC
28m0141                               	        JCFM[28m0141 05705 530140020571020010000000	D[PC] ROT[10] MASK[1] COND[-OBUS=0] JUMP[XDISP] C550 $;J IF CALL FM MON];J IF CALL FM MON
28m0141                               	
28m0141 05706 510140014635000010000000	        D[CONST 1] ALU[D&Q] COND[OBUS=0] JUMP[XCT11] C550 $;J IF BIT OFF
28m0141 05707 510140014635000040000000	        D[CONST 4] ALU[D&Q] COND[OBUS=0] JUMP[XCT12] C550 $; J IF OTHER BIT OFF
28m0141 05710 640145614571022030000000	        D[CONST 03] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET SRC & DEST TO USER
28m0141                               	
28m0141 05711 640145614571022020000000	XCT12:  D[CONST 02] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET DEST TO USER
28m0141 05712 640705614571022010000000	XCT11:  D[CONST 01] ROT[11] DEST[MAP-EXEC-SR] NORM $; SET SRC TO USER
28m0141 05713 540520224571000441602000	XDISP:  D[MA] DEST[MA IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
28m0141 05714 540530604571000441602174	XCT2:   D[MEM] DEST[IR-ALL AR MA] DISP[2174] SPEC[PC+1-IF] CYLEN[DISP] $
28m0141                               	XCTAC:
28m0141                               	.REPEAT 1 - WAITS [
28m0141 05715 640704400551000440000000	        ACSEL[AC] ALU[AC] DEST[HOLD]  SHORT $; SAVE AC
28m0141 05716 640702425571000440000000	        ACSEL[AC] DEST[CLR-DEV-FROM-INTR AC] D[MA] SHORT $; GET AC ADDRS
28m0141 05717 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $
28m0141 05720 640700055421000440000000	        ACSEL[AC] D[13] ALU[D+AC] DEST[AC] SHORT $; ADD IN AC BASE REG.
28m0141 05721 640700015421022750000000	        ACSEL[AC] D[CONST 75] ROT[11] ALU[D+AC] DEST[AC] SHORT $
28m0141 05722 640700015421036070000000	        ACSEL[AC] D[CONST 7] ROT[17] ALU[D+AC] DEST[AC] NORM $
28m0141 05723 640320005171000440000000	        D[MEM] ACSEL[AC] DEST[O_AC MA] POPJ NORM $
28m0141                               	].REPEAT 1 - WAITS
28m0141                               	.REPEAT WAITS [
28m0141                               	.REPEAT WAITS
28m0141                               	XCTSTK:
28m0141                               	;;;     COND[-MA-AC] JUMP[XCT13] NORM $; J IF EF ADR NOT AC (TREAT NORMALLY)
28m0141 05724 510140034171022020005702	        D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LOW ORDER
28m0141                               	 BITS OF OP CODE, J IF PUSHJ
28m0141 05725 510140014735000030005702	        D[CONST 3] ALU[D#Q] COND[OBUS=0] JUMP[XCT13] C550 $; J IF POPJ
28m0141                               	.repeat 0[
28m0141                               	.repeat 0
28m0141 05726 510140014735000020000000	        D[CONST 2] ALU[D#Q] COND[OBUS=0] JUMP[XPOP1] C550 $; J IF POP
28m0141 05727 640140000571000440000000	        JUMP[XPUSH1] NORM $
28m0141                               	                ;Someday, move code over here (when we have space)
28m0141                               	
28m0141 05730 640040000571000440005715	XCT10:  PUSHJ[XCTAC] NORM $; FIX EF ADR
28m0141 05731 540500224571000041622000	        MAPF[2] D[MA] MASK[4] DEST[IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
28m0141 05732 510140034171022020005702	XCTBLG: D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LO BITS OF
28m0141                               	 OPCODE, J IF EXCH
28m0141 05733 510140014735000010000000	        D[CONST 1] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLT] C550 $; J IF BLT
28m0141 05734 640140034171000040005703	        D[IR] MASK[4] DEST[Q] JUMP[XCT18] NORM $; GET XCT AC FLD, PROCEDE
28m0141                               	
28m0141 05735 530040034571104012000000	XCTBYT: D[IR] ROT[42] MASK[1] SPEC[PC+1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF
28m0141                               	 B.P. FETCH IS NOT EXEC
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

28m0141 05736 510140034571022010020000	XBY1:   D[IR] ROT[11] MASK[1] COND[OBUS=0] JUMP[XBY3] C550 MAPF[2] $;J IF BP WILL BE INCR
28m0141                               	
28m0141 05737 640706000550400440020000	        FIXM1 $
28m0141 05740 640710004171000440000000	        D[MEM] DEST[AR Q] NORM $; GET BP
28m0141 05741 640705614571022000000000	XBY4:   SET-TEMP-EXEC $
28m0141 05742 664160000571000220000000	        D[AR] MASK[18.] DEST[MA] COND[-MEM-IDX-IND] JUMP[XBY13] NORM $; J IF BP HAS NO
28m0141                               	 IDX OR INDR
28m0141 05743 510141000571044040020000	XBY15:  D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[XBY14] C550 MAPF[2] $; J IF
28m0141                               	 NO IX FLD
28m0141 05744 640700010235044220000000	        D[MASK 22] ROT[18.] ALU[D&Q] DEST[Q] NORM $
28m0141 05745 640710000420000220000000	        D[AR] MASK[18.] ACSEL[REG] ALU[D+AC] DEST[AR] SHORT $
28m0141 05746 640730000175000220000000	        D[AR] MASK[18.] ALU[DORQ] DEST[Q AR MA] SHORT $
28m0141 05747 510140000571034010020000	XBY14:  D[AR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XBY13] C550 MAPF[2] $; J IF NO INDR
28m0141 05750 530040034571106010000000	        D[IR] ROT[43] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF BP ADR CALC IS
28m0141                               	 USER
28m0141 05751 640706000550400440020000	        FIXM1 $
28m0141 05752 640705614571022000000000	        SET-TEMP-EXEC $
28m0141 05753 640710000571030140000000	        D[AR] ROT[14] MASK[14] DEST[AR] SHORT $
28m0141 05754 640700000171060440000000	        D[AR] ROT[30] DEST[Q] SHORT $
28m0141 05755 644170004175000270005743	        D[MEM] MASK[27] ALU[DORQ] DEST[Q AR MA] COND[MEM-IDX-IND] JUMP[XBY15] NORM $
28m0141 05756 030040034571000010020000	XBY13:  D[IR] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] MAPF[2] $; MAKE MA OK
28m0141 05757 510140034571020010022625	        D[IR] ROT[10] MASK[1] COND[OBUS=0] JUMP[LDB5] C550 MAPF[2] $; DISTINGUISH LOADS
28m0141                               	 FROM DEPOSITS, J IF LOAD
28m0141 05760 640140000571000440002637	        JUMP[DPB5] NORM $
28m0141                               	
28m0141 05761 640706200550400440030000	XBY3:   FIXM2 $
28m0141 05762 656150004171000440005741	        D[MEM] DEST[AR Q] COND[HALF] JUMP[XBY4] NORM $;GET BP, J IF NO INCR
28m0141 05763 657051400571030060004035	        D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $; GET S
28m0141                               	 FLD, HANDLE OVERFLOW
28m0141 05764 662154200077074440005766	        D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $; SUB S
28m0141                               	 FROM P
28m0141 05765 640700005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] NORM $
28m0141 05766 640040000571000440006146	        PUSHJ[SETHLF] NORM $; SET HALF
28m0141 05767 640140000571000440005741	        JUMP[XBY4] NORM $; (IN CASE OF MAP FAULTS)
28m0141                               	
28m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

29m0141                               	;XFIXMA XCTBLT XBLTL XPUSH1 XPDLO2 XPOP1 XPOP2 XPOP3
29m0141 05770 642140000571000440005715	XFIXMA: COND[MA-AC] JUMP[XCTAC] NORM $; J IF ADDRS IS AC
29m0141 05771 530300020571020010020000	        D[PC] ROT[10] MASK[1] COND[-OBUS=0] POPJ C550 MAPF[2] $; LEAVE IF CALL FM MON
29m0141 05772 640705614571022170000000	        SET-TEMP-USER $
29m0141 05773 640320024571000440000000	        D[MA] DEST[MA] POPJ NORM $
29m0141                               	
29m0141                               	;;;;;.USE[OTHER]  DWP 9-19-80
29m0141                               	
29m0141 05774 640710025171000442000000	XCTBLT: D[MA] SPEC[PC+1] DEST[O_AC AR] NORM $; END ADR IN AC, AC IN AR
29m0141 05775 640720000571044220000000	XBLTL:  D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $; GET WORD
29m0141 05776 530040034571104010005770	        D[IR] ROT[42] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; FIX IF USER ADDRS
29m0141 05777 640706000550400440070000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BLT-RDA] CYLEN[FIXM] $
29m0141 06000 640700004171000440000000	        D[MEM] DEST[Q] SHORT $; GET DATA WORD
29m0141 06001 640720000571000220000000	        D[AR] MASK[18.] DEST[MA] SHORT $; GET DEST ADR
29m0141 06002 530045634571000010005770	        D[IR] MASK[1] DEST[MAP-EXEC-SR] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $;FIX MA ADDRS
29m0141 06003 640704200555000440000000	        ALU[Q] DEST[MEMSTO] SHORT $
29m0141 06004 471140000523000220144344	        D[AR] MASK[18.] ALU[D-AC] MAPF[BLT-WRTB] COND[-OBUS<0] JUMP[BLTA12] C600 $
29m0141 06005 662145614171001000006007	        D[CONST 1,,1] DEST[Q MAP-EXEC-SR] COND[-MA-AC] JUMP[. + 2] NORM $
29m0141 06006 640700005570400440000000	        D[MEM] ACSEL[MA] DEST[AC] SHORT $
29m0141 06007 640150000435000440005775	        D[AR] ALU[D+Q] DEST[AR] JUMP[XBLTL] NORM $; TEST FOR INTERPT HERE ? *****
29m0141                               	
29m0141                               	;Special case for PUSH.  Check for AC reference from stack pointer
29m0141 06010 510140034571000010005702	XPUSH1: D[IR] MASK[1] COND[OBUS=0] JUMP[XCT13] C550 $
29m0141                               	                ;If not mapping stack references, it's simple
29m0141 06011 530040034571104012005770	        D[IR] ROT[36. - 2] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] SPEC[PC+1] C550$
29m0141                               	                ;Make sure we're referring to the right place here.
29m0141                               	                ;Also, we're now executing the instruction (PC+1)
29m0141 06012 640706000550400440020000	        FIXM1 $ ;Check page faults for effective address part.
29m0141 06013 640710004571000440000000	        D[MEM] DEST[AR] NORM $
29m0141                               	                ;Copy away the thing that we want to push
29m0141 06014 515160015421001000000000	        D[CONST 1,,1] ALU[D+AC] DEST[AC MA] COND[CRY0] JUMP[XPDLO2] C550 $
29m0141                               	                ;Advance frame pointer and check for overflow
29m0141 06015 640040000571000440005770	        PUSHJ[XFIXMA] NORM $
29m0141                               	                ;Decide whether to map destination.
29m0141 06016 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
29m0141                               	                ;Finish instruction. We're done
29m0141 06017 640040000571000440005770	XPDLO2: PUSHJ[XFIXMA] NORM $
29m0141                               	                ;Fixup AC references
29m0141 06020 640140000571000440000000	        JUMP[PDLO2] NORM $
29m0141                               	                ;Done.  Take stack overflow trap
29m0141                               	
29m0141                               	;Special case for POP.  Check for AC reference from stack pointer
29m0141 06021 640700034171022442000000	XPOP1:  D[IR] ROT[11] DEST[Q] NORM SPEC[PC+1] $
29m0141                               	                ;Save bit meaning 'source from user' in format that can
29m0141                               	                ;be fed easily to EXEC-SR
29m0141                               	                ;Now we're executing the PUSH (implied by PC+1)
29m0141 06022 640700224571000440000000	        D[MA] DEST[IR-ADR] NORM $
29m0141                               	                ;Restore normal effective address 
29m0141 06023 640720015063001000000000	        ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC] NORM $
29m0141                               	                ;Update AC and MA for stack reference
29m0141 06024 530040014635022040005770	        D[CONST 4] ROT[11] ALU[D&Q] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $
29m0141                               	                ;Fixup stack addressing if user AC
29m0141 06025 640706000550400440160000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
29m0141                               	                ;Check for page faults
29m0141 06026 640710004571000440000000	        D[MEM] DEST[AR] NORM $
29m0141                               	                ;Find somewhere safer for thing to push
29m0141                               	        D[CONST 1] ROT[11] ALU[D&Q] DEST[MAP-EXEC-SR]
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

29m0141 06027 510145614635022010000000	                        COND[OBUS=0] JUMP[XPOP3] C550 $
29m0141                               	                ;Set appropriate mode to do store in
29m0141 06030 640720034571000220000000	        D[IR] MASK[22] DEST[MA] NORM $
29m0141                               	                ;Extract address and fetch it from the appropriate page.
29m0141 06031 642040000571000440005715	        COND[MA-AC] PUSHJ[XCTAC] NORM $
29m0141                               	                ;Fixup AC addressing if needed.  (We can't combine this and
29m0141                               	                ;previous instruction because MA is strobed at end of cycle.
29m0141                               	                ;We can't call XFIXMA because it uses SET-TEMP-USER which
29m0141                               	                ;would affect the next instruction fetch. Sigh...)
29m0141 06032 515140014421001000000000	XPOP2:  D[CONST 1,,1] ALU[D+AC] COND[CRY0] JUMP[PDLO5] C550 $
29m0141                               	                ;Try for overflow again.  Take it if you need it.
29m0141 06033 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
29m0141                               	                ;Write out thing we POP'ped
29m0141 06034 640160034571000220006032	XPOP3:  D[IR] MASK[22] DEST[MA] NORM JUMP[XPOP2] $
29m0141                               	                ;Extract address and don't do anything special about it
29m0141                               	
29m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

30m0141                               	;APRDSP PIDSP AREA53 APRCO APRCO2 APRCO3 APRIEN APRC1 APRC2 APRCHK APRCK1 APDINT APRCI
30m0141                               	 APRCII APRDI APIOT
30m0141                               	;------------------------------------------------------------------------------
30m0141                               	;
30m0141                               	;       APR and PI instructions
30m0141                               	;
30m0141                               	;------------------------------------------------------------------------------
30m0141                               	        .ORG[XLIST
30m0141                               	 LIST ] ;APR & PI IOT DISP TABLE
30m0141                               	APRDSP: ILGIOT 30m0141 05300 000140000571000440002026	 JUMP [MAIN] ]$; BLKI APR
30m0141 05301 000700000571000440000000	        NOP $
30m0141 05302 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $; DATAI -- RD SW
30m0141 05303 640142400571000443400000	        DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] JUMP[APRDI] NORM $
30m0141                               	        ILGIOT 30m0141 05304 000140000571000440002026	 JUMP [MAIN] ]$ ;BLKO APR
30m0141 05305 000700000571000440000000	        NOP $
30m0141 05306 000140000571000440002026	        JUMP[MAIN] $; DATAO
30m0141 05307 000700000571000440000000	        NOP $
30m0141 05310 640700034171000130000000	        D[IR] MASK[13] DEST[Q] NORM $; GET CONO BITS
30m0141 05311 640140014275012330000000	        D[CONST 33] ROT[5] ALU[-D&Q] DEST[Q] JUMP[APRCO] NORM $
30m0141 05312 640040000571000440000000	        PUSHJ[APRCI] NORM $; CONI -- GET BITS IN AR & Q
30m0141 05313 662104200571000220002032	        D[AR] MASK[18.] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
30m0141 05314 640040000571000440000000	        PUSHJ[APRCI] NORM $; CONSZ -- GET BITS IN AR & Q
30m0141 05315 640140034171000220004470	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
30m0141 05316 640040000571000440000000	        PUSHJ[APRCI] NORM $; CONSO -- GET BITS IN AR & Q
30m0141 05317 640140034171000220004472	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
30m0141                               	PIDSP:  .REPEAT 3[ 30m0141                               	ILGIOT 30m0141 05320 000140000571000440002026	 JUMP [MAIN] ]$
30m0141 05321 000700000571000440000000	        NOP $
30m0141                               	]ILGIOT 30m0141 05322 000140000571000440002026	 JUMP [MAIN] ]$
30m0141 05323 000700000571000440000000	        NOP $
30m0141                               	]ILGIOT 30m0141 05324 000140000571000440002026	 JUMP [MAIN] ]$
30m0141 05325 000700000571000440000000	        NOP $
30m0141                               	]       ;DATAO PI -- Set lights
30m0141 05326 640041614571000000004444	        D[CONST 0] DEST[DEV-ADR] PUSHJ[SETLTS] NORM $   ;Just like examine...?
30m0141 05327 640140000571000440002026	        JUMP[MAIN] SHORT $
30m0141 05330 640140000571000440004606	        JUMP[PICONO] NORM $; PI CONO
30m0141 05331 000700000571000440000000	        NOP $
30m0141 05332 640040000571000440004637	        PUSHJ[PICONISUB] NORM $; CONI -- GET BITS IN AR & Q
30m0141 05333 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
30m0141 05334 640040000571000440004637	        PUSHJ[PICONISUB] NORM $; CONSZ -- GET BITS IN AR & Q
30m0141 05335 640140034171000220004470	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
30m0141 05336 640040000571000440004637	        PUSHJ[PICONISUB] NORM $; CONSO -- GET BITS IN AR & Q
30m0141 05337 640140034171000220004472	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
30m0141                               	
30m0141                               	
30m0141                               	   .USE[30m0141                               	XLIST
30m0142                               	 LIST ]
30m0142 04647 640710014675006010000000	APRCO:  D[CONST 1] ROT[3] ALU[-D&Q] DEST[AR] SHORT $
30m0142 04650 640700034371106210000000	        D[IR] ROT[43] MASK[21] ALU[NOTD] DEST[Q] SHORT $
30m0142                               	                ; GET CLR BITS
30m0142 04651 640700014275000070000000	        D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

30m0142                               	                ; Remove PI assignment
30m0142 04652 640702450235000442400000	        D[10 + APRSTS] SPEC[A-MEM-APR] ALU[D&Q] DEST[Q CLR-DEV-FROM-INTR] SHORT $
30m0142                               	                ; CLEAR INDICATED BITS
30m0142 04653 640710400575000442600000	        D[AR] ALU[DORQ] SPEC[A-MEM-APR&DEST-A-MEM] DEST[APRSTS AR] NORM $
30m0142                               	                ; SET INDICATED BITS & CHAN
30m0142 04654 510140034571102010000000	        D[IR] ROT[41] MASK[1] COND[OBUS=0] JUMP[APRCO2] C550 $
30m0142                               	                ; J IF NO CLR OVERFLOW BIT
30m0142 04655 640705420571000430000000	        D[PC] MASK[43] DEST[CRYOV] SHORT $; CLR OV
30m0142                               	                ; Remove overflow bit from current PC flags
30m0142 04656 510140034571074010000000	APRCO2: D[IR] ROT[36] MASK[1] COND[OBUS=0] JUMP[APRCO3] C550 $
30m0142                               	                ; J IF NO CLR FLT OV
30m0142 04657 640700010171102430000000	        D[MASK 43] ROT[41] DEST[Q] SHORT $
30m0142                               	                ; Remove bit from current PC flags
30m0142 04660 640705420635000440000000	        D[PC] ALU[D&Q] DEST[CRYOV] SHORT $
30m0142                               	                ; CLR FLT OV
30m0142 04661 530040034571066010004510	APRCO3: D[IR] ROT[33] MASK[1] COND[-OBUS=0] PUSHJ[CLKCLR] C550 $
30m0142                               	                ; CLR CLOCK FLAG IF INDICATED
30m0142                               	;       ---
30m0142                               	
30m0142                               	; TEMP **** APRCI:
30m0142 04662 640042400571000440000000	APRIEN: PUSHJ[APRCII] DEST[CLR-DEV-FROM-INTR] NORM $
30m0142                               	                ; GET APR CONI BITS
30m0142 04663 640701614571000013400000	        D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
30m0142                               	                ; Select and read MAP and ECC enablings
30m0142 04664 140700030171000030040000	        D[IOD] MAPF[4] MASK[3] DEST[Q] CYLEN[IOB-IN] $
30m0142 04665 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
30m0142                               	                ; For some pecular reason, the thing we read from device 1 is
30m0142                               	                ; written in device 0???
30m0142 04666 510140000571000030000000	        D[AR] MASK[3] COND[OBUS=0] JUMP[APRC1] C550 $
30m0142                               	                ; Jump if no PI channel.  We don't want to enable arithmetic
30m0142                               	                ; micro-interrupts in that case.
30m0142 04667 510140000571100010000000	        D[AR] ROT[40] MASK[1] COND[OBUS=0] JUMP[APRC1] C550 $
30m0142                               	                ; J IF NO OV INT ENBL
30m0142                               	                ; *** Don't both enables need to be checked???
30m0142 04670 640142214575000023600000	        D[CONST 2] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] JUMP[APRC2] NORM $; ENABLE OV INT
30m0142                               	                ; Turn on arithmetic interrupts
30m0142 04671 640702214675000023600000	APRC1:  D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
30m0142                               	                ; Turn off arithmetic interrupts
30m0142 04672 440140000171000440100000	APRC2:  MAPF[10] CYLEN[IOB-OUT] D[AR] DEST[Q] JUMP[APRCK1] $
30m0142                               	                ; Finish turning arithmetic interrupts off or on, and we're done
30m0142                               	
30m0142                               	;Check for clock interrupts (and other things)
30m0142 04673 640040000571000440000000	APRCHK: PUSHJ[APRCI] NORM $; GET CONI BITS IN AR & Q
30m0142                               	
30m0142                               	APRCK1:
30m0142                               	.REPEAT 1 - WAITS [
30m0142 04674 510140000571000030002026	        D[AR] MASK[3] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF PI=0
30m0142 04675 530140000571040010000000	        D[AR] ROT[20] MASK[1] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF PDLOV INT
30m0142 04676 640700000235106440000000	        D[AR] ROT[43] ALU[D&Q] DEST[Q] SHORT $; AND MASK WITH FLAG
30m0142 04677 530140014635006110000000	        D[CONST 11] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF OV INT
30m0142 04700 510140014635014100002026	        D[CONST 10] ROT[6] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF NO CLOCK INT
30m0142                               	
30m0142                               	;       \ /
30m0142                               	].REPEAT 1 - WAITS
30m0142                               	.REPEAT WAITS [
30m0142                               	.REPEAT WAITS
30m0142                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

30m0142                               	;       \ /     (Falls thru from APRCK1)
30m0142 04701 640150000171000030004562	APDINT: D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; GET CHAN #, CAUSE INTERRUPT
30m0142                               	
30m0142                               	APRCI:  ;TEMP -- LATER WE FIX OV
30m0142 04702 640040000571000440000000	APRCII: PUSHJ[CLKRDFLG] NORM $
30m0142                               	         ;Get CLOCK FLAG in AR 35, rest of AR = 0
30m0142                               	        .DEFINE APRGBT 30m0142                               	        APRGBT[30m0142 04703 640700020171002010000000	D[PC] ROT[1] MASK[1] DEST[Q] SHORT $
30m0142 04704 640710000575014440000000	        D[AR] ROT[6] ALU[DORQ] DEST[AR] SHORT $
30m0143                               	]       APRGBT[30m0143 04705 640700020171010010000000	D[PC] ROT[4] MASK[1] DEST[Q] SHORT $
30m0143 04706 640710000575102440000000	        D[AR] ROT[41] ALU[DORQ] DEST[AR] SHORT $
30m0144                               	]       APRGBT[30m0144 04707 640700020171016010000000	D[PC] ROT[7] MASK[1] DEST[Q] SHORT $
30m0144 04710 640710000575066440000000	        D[AR] ROT[33] ALU[DORQ] DEST[AR] SHORT $
30m0145 04711 640700000171036440000000	]       D[AR] ROT[17] DEST[Q] SHORT $; SET FLAGS
30m0145                               	.REPEAT 1 - WAITS [
30m0145 04712 640310050175000442400000	        D[10 + APRSTS] SPEC[A-MEM-APR] ALU[DORQ] DEST[Q AR] NORM POPJ $
30m0145                               	].REPEAT 1 - WAITS
30m0145                               	
30m0145                               	.REPEAT WAITS [
30m0145                               	.REPEAT WAITS
30m0145                               	
30m0145 04713 162104230571000440022032	APRDI:  MAPF[2] D[IOD] DEST[MEMSTO] COND[-MA-AC] LBJUMP[MSMAIN] CYLEN[IOB-IN] $
30m0145                               	
30m0145                               	        .PAIR
30m0145                               	. \ 2 + .
30m0146                               	]       UIOTRP[30m0146 04714 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
30m0146                               	]$                      ;Trap if not IOT-USER Mode
30m0146                               	APIOT:  IOTDIS[30m0146 04715 640700034171034050000000	D[IR] ROT[16] MASK[5] DEST[Q] NORM $
30m0146 04716 540540014575014530000000	        D[CONST 53] ROT[6] ALU[DORQ] SDISP CYLEN[C500] $
30m0147                               	]
30m0147                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

31m0147                               	;PDLO1 PDLO2 PDLO5 PDLO3 PDLO4 PDLO6 PDLMEM PDLOE PDLO SOED STOPS SOVRS SECCS SOEDOV
31m0147                               	
31m0147 04717 640040000571000440000000	PDLO1:  PUSHJ[PDLO] NORM $ ;SET PDLO BIT
31m0147 04720 640714220571000440000000	        D[PC] DEST[AR MEMSTO] NORM $
31m0147 04721 662104634571000222370000	        MAPF[MASTO] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] COND[-MA-AC] LBJUMP[PDLMEM]
31m0147                               	 NORM $
31m0147 04722 640040000571000440000000	PDLO2:  PUSHJ[PDLO] NORM $; SET FLAG
31m0147 04723 662104200571000440000000	PDLO5:  D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PDLMEM] NORM $
31m0147 04724 640706000550400440160000	PDLO3:  ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
31m0147 04725 640050004571000440000000	        D[MEM] DEST[AR] PUSHJ[PDLO] NORM $
31m0147 04726 640160034571000220004723	        D[IR] MASK[18.] DEST[MA] JUMP[PDLO5] NORM $
31m0147 04727 640706000550400440160000	PDLO4:  ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
31m0147 04730 640040000571000440000000	        PUSHJ[PDLO] NORM $
31m0147 04731 640144604571000220000000	        D[MEM] MASK[18.] DEST[PC] JUMP[PDLOE] NORM $
31m0147                               	;PDLOV from ADJSP
31m0147 04732 640040000571000440000000	PDLO6:  PUSHJ[PDLO] NORM $
31m0147 04733 640140000571000440000000	        JUMP[PDLOE] NORM $
31m0147                               	
31m0147                               	        .PAIR
31m0147                               	. \ 2 + .
31m0148 04734 640700005570400440170000	]PDLMEM:        ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] MAPF[MASTO] $
31m0148                               	PDLOE:  MAPF[MASTO] D[10 + APRSTS] MASK[3] DEST[AR] SPEC[A-MEM-APR]
31m0148 04735 640150050571000032574562	        JUMP[PIGEN] NORM $; CHAN # IN AR, TRY INTERRUPT
31m0148                               	
31m0148 04736 640700050171000442400000	PDLO:   D[10 + APRSTS] SPEC[A-MEM-APR] DEST[Q] NORM $; APR CONI WORD
31m0148                               	        D[CONST 1] ROT[20] ALU[DORQ] SPEC[A-MEM-APR&DEST-A-MEM] DEST[APRSTS]
31m0148 04737 640300414575040012600000	                        NORM POPJ $
31m0148                               	                ;SET PDLOV BIT
31m0148                               	
31m0148                               	        .USE[31m0148                               	XLIST
31m0149                               	 LIST ]
31m0149                               	.REPEAT F3SW [
31m0149                               	 ;; END OF .REPEAT F3SW
31m0149                               	
31m0149                               	;(ECC-UNC moved to bottom of page)
31m0149                               	
31m0149                               	 .REPEAT F2SW [ 31m0149                               	
31m0149                               	
31m0149 06035 640141614571000010004366	STOPS:  D[CONST 1] DEST[DEV-ADR] JUMP[DOHALT] NORM $
31m0149                               	
31m0149 06036 531142420571000443406041	SOVRS:  D[PC] COND[-OBUS<0] SPEC[IOB-IN] JUMP[. + 3] DEST[CLR-DEV-FROM-INTR] C550 $
31m0149                               	                ; J IF NO OV
31m0149 06037 140702430171000440040000	        D[IOD] MAPF[4] DEST[Q CLR-DEV-FROM-INTR] CYLEN[IOB-IN] $
31m0149 06040 530140014635000020000000	        D[CONST 2] ALU[D&Q] COND[-OBUS=0] JUMP[SOEDOV] C550 $ ;J IF OV INT EN
31m0149 06041 000140000571000440006041	        JUMP[.] $ ; HOW COULD WE GET HERE?
31m0149                               	
31m0149 06042 640701614571000013400000	SECCS:  D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
31m0149 06043 140704430171000440020000	        D[IOD] MAPF[2] DEST[Q HOLD] CYLEN[IOB-IN] $
31m0149 06044 640700054171000042400000	        D[10 + ECCSVP] SPEC[A-MEM-APR] MASK[4] DEST[Q] NORM $
31m0149                               	.REPEAT 1 - XUCODE [
31m0149                               	.REPEAT 1 - XUCODE
31m0149                               	.REPEAT XUCODE [
31m0149                               	        D[MASK 9.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
31m0149 06045 640712410575010113400000	          NORM SPEC[IOB-IN] $  ;;17760 IS NEW LOC. OF ERROR LOG.
31m0149                               	].REPEAT XUCODE
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

31m0149 06046 140700030171000440040000	        MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
31m0149                               	 ;;;;;  D[CONST 1] ROT[7] ALU[D&Q] COND[-OBUS=0] JUMP[.] C550 $
31m0149                               	
31m0149 06047 140707400615000440000000	        ALU[0] DEST[MUCODE-HI] CYLEN[MUSTO] $
31m0149 06050 640700004171000440000000	        D[MEM] DEST[Q] NORM $
31m0149 06051 140707610635052420000000	        D[MASK 42] ROT[25] ALU[D&Q] DEST[MUCODE-LO] CYLEN[MUSTO] $
31m0149 06052 640700600433000442600000	        D[AR] ALU[D+1] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
31m0149 06053 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
31m0149 06054 640702400571000443400000	        DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
31m0149 06055 140700230571000440040000	        D[IOD] DEST[IR-ADR]  MAPF[4] CYLEN[IOB-IN] $
31m0149 06056 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
31m0149                               	;NOTE:  This conflicts with the use of the lights by diagnostics.
31m0149 06057 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;PUT JUNK IN LIGHTS
31m0149 06060 440700000555000443620000	        MAPF[2] ALU[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ;LTS_OBUS
31m0149 06061 440703600571000440100000	        MAPF[10] DEST[CLR-MI-ERR] CYLEN[IOB-OUT] $; TURN OFF MAP
31m0149 06062 640700200555000443000000	        ALU[Q] DEST[A-MEM-ECC-DATA] DEST-A-MEM NORM $
31m0149                               	          ;Save info for reading via opcode 750.  
31m0149 06063 640722604571000440000000	        D[MEM] DEST[MA HI-ABS-MA] NORM $; GET DATA
31m0149 06064 540700000571000440000000	        CYLEN[C500] $;WAIT
31m0149 06065 640704204571000440000000	        D[MEM] DEST[MEMSTO] NORM $; RE-STORE IT
31m0149 06066 640700000571000440000000	        NORM $; WAIT -- FOR LUCK
31m0149 06067 640702234571000443600000	        D[IR] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE STATE OF MAP, ETC.
31m0149 06070 440702600615000440100000	         MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $;
31m0149 06071 640143600571000440002026	        DEST[CLR-MI-ERR] JUMP[MAIN] NORM $
31m0149                               	
31m0149                               	  ];; END OF .REPEAT F2SW
31m0149                               	
31m0149 06072 640701600615000440000000	SOEDOV: ALU[0] DEST[DEV-ADR] NORM $
31m0149 06073 640702214675000023600000	        D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
31m0149 06074 440040000571000440104702	        MAPF[10] CYLEN[IOB-OUT] PUSHJ[APRCII] $; GET CONI BITS
31m0149 06075 640150000171000030004562	        D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; DO INTR.
31m0149                               	
31m0149                               	;$*$*$*$ No space left in NORMAL by now...
31m0149                               	        .USE[31m0149                               	XLIST
31m0150                               	 LIST ]
31m0150                               	ECC-UNC:  ;SEE IF WE SHOULD GIVE INTERRUPT FOR HARD ECC ERR
31m0150                               	          ;RETURN TO CALLER IF NOT, BUT STILL SET PAR ERR FLAG.
31m0150 06206 640700060171000440000000	        D[14] DEST[Q] NORM $
31m0150                               	         ;FIRST, SET PAR ERR FLAG IN PI CONI BITS.
31m0150                               	        D[CONST 1] ROT[35. - 19.] ALU[DORQ] 
31m0150 06207 640711014575040013000000	                DEST[AR 4] DEST-A-MEM NORM $
31m0150 06210 531300000571036440000000	        D[AR] ROT[35. - 20.] C550 COND[-OBUS<0] POPJ $
31m0150                               	         ;IF PAR ERR INTRPT ENABLE OFF, DO NO MORE.
31m0150 06211 510310050171000030000000	        D[10 + APRSTS] MASK[3] DEST[Q AR] C550 COND[OBUS=0] POPJ $
31m0150                               	         ;IF APR PI CHAN IS 0, DON'T GIVE INTRPT.
31m0150 06212 640343600571000440004562	        DEST[CLR-MI-ERR] NORM JPOP[PIGEN] $ 
31m0150                               	         ;CLEAR ERR FF AND GIVE INTERRUPT ON APR CHANNEL.
31m0150                               	
31m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

32m0150                               	;; 60 HZ CLOCK READING AND INTERRUPT ROUTINES
32m0150                               	
32m0150                               	 .REPEAT OTP [
32m0150                               	 ;OTP
32m0150                               	
32m0150                               	
32m0150                               	 .REPEAT NTP [ 32m0150                               	;We branch here from CTYINT if intrpt. is really 60HZ CLK.
32m0150                               	
32m0150 06213 640702200615000443600000	CLKINT: START-OUT ALU[0] DEST[IOD] NORM $
32m0150                               	          ;Clear hardware int. enb. for 60HZ CLK.
32m0150 06214 440700000571000440060000	        MAPF[6] C600 $
32m0150                               	  ];NTP
32m0150                               	
32m0150                               	.REPEAT TYMNET [
32m0150 06215 440042400571000440000000	        DEST[CLR-DEV-FROM-INTR] PUSHJ[TYMCLK] C600 $
32m0150                               	          ;Start up TYMNET interface if needed.
32m0150                               	]TYMNET
32m0150 06216 440142400571000440004673	        DEST[CLR-DEV-FROM-INTR] JUMP[APRCHK] C600 $     
32m0150                               	          ;Cause PI on APR channel if enabled, and exit.
32m0150                               	
32m0150                               	CLKRDFLG:  ;Put hardware 60HZ CLK FLAG into AR35.
32m0150 06217 640701614571000063400000	        START-IN D[CONST 6] DEST[DEV-ADR] NORM $
32m0150                               	          ;Select device 6.
32m0150 06220 140310030571106010050000	        MAPF[5] D[IOD] ROT[34. + 1] MASK[1] DEST[AR] CYLEN[IOB-IN] POPJ $
32m0150                               	          ;Get bit and return.
32m0150                               	
32m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

33m0150                               	.REPEAT NTP [ 33m0150                               	;Ucode for KENNEDY or PERTEC formatter and DMA tape controller.
33m0150                               	
33m0150                               	  .REPEAT 1 - TAPE [
33m0150                               	
33m0150                               	  .REPEAT TAPE [ 33m0150                               	 ;New (DMA tape controller, Pertec compatible fmtr )
33m0150                               	.INSERT TAPE.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- F2X

01m0001                               	;-------------------------------------------------------------------------------
01m0001                               	;
01m0001                               	;       Ucode for KENNEDY or PERTEC formatter and DMA tape controller.
01m0001                               	;
01m0001                               	;-------------------------------------------------------------------------------
01m0001                               	.REPEAT XUCODE [
01m0001                               	        .USE[XLIST
01m0001                               	 LIST ];If 8K u-mem present, put tape code there.
01m0001                               	   ]
01m0001                               	;TAPE READING AND WRITING CODE
01m0001                               	; A-MEM USEAGE:
01m0001                               	;               0       DISPATCH ADDR.
01m0001       0	TPMODE =        0       ;DATA PACKING MODE 
01m0001                               	;                        BIT 0: 0=PDP-10 CORE-DUMP, 1=INDUSTRY (32-bit mode)
01m0001                               	;                        BIT 1: NRZI Kluge Mode (to read old CCRMA & SCI tapes)
01m0001                               	;               1       Used by FMNBWT and TRCHECK for NRZI Kluge Mode info.
01m0001                               	;               2       Used by KNYGOA and TRCHECK for NRZI Kluge Mode info.
01m0001                               	;               3       DON'T USE... Storing into it clobbers IR left !
01m0001                               	;               4       Next mem adr of xfer (STRTDC) -- 0 during non-data ops
01m0001                               	;               5       Remaining word count in current WCMA (STRTDC)
01m0001                               	;               6       Not currently used-- will be  Data Channel PC
01m0001                               	;               7       RETRY COUNT (WRITE); 400000,,STARTING-MA (READ)
01m0001                               	
01m0001                               	;MAPF values
01m0001                               	
01m0001       4	TP.RS = 4       ;read status (from formatter)
01m0001       2	TP.RC = 2       ;read control (controller status and un-fifo'd read data)
01m0001                               	
01m0001       2	TP.WF = 2       ;write formatter (send ctrl bits to formatter)
01m0001       4	TP.WM = 4       ;write mode control reg.
01m0001       1	TP.WC = 1       ;write control reg.
01m0001       5	TP.MR = 5       ;give Master Reset
01m0001       3	TP.WMA = 3      ;write (load) the CNTMA reg. (count and MA)
01m0001                               	
01m0001                               	KNYCLR:  ;RESET the formatter and drive.
01m0001                               	
01m0001 10001 000702200615000443600000	KNYRS1: START-OUT ALU[0]  DEST[IOD] $
01m0001                               	                ;Turn off "FORMATTER ENABLE"
01m0001 10002 000300000571000440020000	        MAPF[TP.WF] LONG POPJ $
01m0001                               	
01m0001                               	   ;725 - OBSOLETE VERSION OF READ
01m0001                               	
01m0001                               	  .PAIR
01m0001                               	. \ 2 + .
01m0002                               	]  UIOTRP[01m0002 10004 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0002                               	]$
01m0002                               	
01m0002 10005 640040214571014140000000	TAPERD: D[CONST 14] ROT[6] DEST[IR-ADR] NORM PUSHJ[KNYRGO] $
01m0002                               	                ;Fake a word count of 1400
01m0002 10006 640041024571000443000000	        D[MA] DEST[4] DEST-A-MEM NORM PUSHJ[TRP2] $
01m0002 10007 640140001555000440000000	        ALU[Q] DEST[AC] ACSEL[AC] NORM JUMP[GOMAIN] $
01m0002                               	                ;Move status into AC.
01m0002                               	
01m0002                               	; KNYRGO -- Called to start tape motion on reads.
01m0002 10010 640040000571000440000000	KNYRGO: NORM PUSHJ[DCINIT] $
01m0002                               	                ;Init the data channel.
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- F2X

01m0002 10011 640710040571002010000000	        D[10 + TPMODE]  ROT[1] MASK[1] DEST[AR] NORM $
01m0002                               	                ;Get the 32-bit mode flag.
01m0002 10012 640702200571014443600000	        START-OUT D[AR] ROT[35. - 29.] DEST[IOD] NORM $
01m0002                               	                ;Position it for the hardware.
01m0002 10013 440140014171000000040000	        MAPF[TP.WM] D[CONST 0] DEST[Q]   C-OUT JUMP[KNYGOA] $
01m0002                               	                ;Send command to formatter.
01m0002                               	
01m0002                               	  ;Send a tape-motion command to the formatter.  Call with command bits
01m0002                               	  ;  (except for FMTR ENABLE and GO) in Q.  Clobbers Q, HOLD, AR
01m0002 10014 000040014175022013400000	KNYGOA: START-IN D[CONST 1] ROT[35. - 26.] ALU[DORQ] DEST[Q] PUSHJ[FMNBWT] $
01m0002                               	          ;Add the FMTR ENBL bit to the command word.
01m0002                               	          ;Wait for FORMATTER NOT BUSY.
01m0002 10015 640700404571000443000000	        D[MEM] DEST[2] DEST-A-MEM NORM $
01m0002                               	          ;Save status bits returned by FMNBWT for use by TRCHECK
01m0002 10016 440702214735004013600000	        START-OUT D[CONST 1] ROT[35. - 33.] ALU[D#Q] DEST[IOD] C-OUT $
01m0002                               	          ;Set the GO bit to fmtr (except: on RWD, CLEAR the bit !)
01m0002 10017 000702214675004013620000	        MAPF[TP.WF] START-OUT D[CONST 1] ROT[35. - 33.] ALU[-D&Q] DEST[IOD] $
01m0002                               	          ;Send command word again, without GO bit.
01m0002 10020 000300000571000440020000	        MAPF[TP.WF] LONG POPJ $
01m0002                               	
01m0002                               	
01m0002                               	FMNBWT:   ;Wait for formatter to be not busy.
01m0002                               	          ;Return tape status in MEM;  timeout in 164 msec.
01m0002                               	          ;Duration of loop should be 10 usec. (for TRCHECK).
01m0002 10021 640710014571034013400000	        START-IN D[CONST 1] ROT[14.] DEST[AR] NORM $
01m0002 10022 240704430571000440040000	FMNBW1: MAPF[TP.RS] D[IOD] DEST[HOLD] C800 $ ;GET STATUS BITS.
01m0002 10023 511350000531000440000000	        D[AR] ALU[D-1] DEST[AR] C550 OBUS<0 JPOP[FMTHNG] $
01m0002 10024 440740014571000160000000	        D[CONST 14.] LLOAD C600 $
01m0002 10025 540240000571000440000025	        C500 LOOP[.] $
01m0002                               	          ;We execute this instr. 15. times, for a 7.5 usec delay.
01m0002 10026 531140004571016443400022	        START-IN D[MEM] ROT[7] C550 -OBUS<0 JUMP[FMNBW1] $
01m0002                               	          ;check for 'BUSY'
01m0002 10027 640300200571000443000000	        D[AR] DEST[1] DEST-A-MEM NORM POPJ $
01m0002                               	          ;Save ending timeout count (for TRCHECK)
01m0002 10030 640040000571000440000001	FMTHNG: NORM PUSHJ[KNYRS1] $
01m0002                               	                ;Blast the formatter.
01m0002 10031 000340015571074420000000	        D[CONST 42] ROT[30.] DEST[AC] JPOP[GOMAIN] $
01m0002                               	                ;Return error code for 'hung fmtr' and abort.
01m0002                               	
01m0002                               	NCNTWT:   ;Wait for TP CNT GO to be off.
01m0002                               	          ;Return tape status in MEM;  timeout in 164 msec.
01m0002                               	          ;Duration of loop should be 10 usec. (for TRCHECK).
01m0002 10032 240704430571000440020000	NCNTW1: MAPF[TP.RC] D[IOD] DEST[HOLD] C800 $ ;GET STATUS BITS.
01m0002 10033 511310000531000440000000	        D[AR] ALU[D-1] DEST[AR] C550 OBUS<0 POPJ $
01m0002                               	          ;Exit if we time out-- probably just a short record.
01m0002 10034 440740014571000160000000	        D[CONST 14.] LLOAD C600 $
01m0002 10035 540240000571000440000035	        C500 LOOP[.] $
01m0002                               	          ;We execute this instr. 15. times, for a 7.5 usec delay.
01m0002 10036 511140004571046443400032	        START-IN D[MEM] ROT[19.] C550 OBUS<0 JUMP[NCNTW1] $
01m0002                               	          ;check for not TP CNT GO
01m0002 10037 640300200571000443000000	        D[AR] DEST[1] DEST-A-MEM NORM POPJ $
01m0002                               	          ;Save ending timeout count (for TRCHECK)
01m0002                               	
01m0002                               	
01m0002                               	;INITIALIZE DATA CHANNEL
01m0002                               	
01m0002 10040 640740014571000103600000	DCINIT: START-OUT D[CONST 8.] LLOAD NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- F2X

01m0002                               	                ;Give TP MR
01m0002 10041 440702200615000443650000	        MAPF[TP.MR] START-OUT ALU[0] DEST[IOD] C600 $
01m0002                               	                ;Load 0 into cntma (the COUNT and MA registers)
01m0002 10042 440702210571054143630000	        MAPF[TP.WMA] START-OUT D[MASK 12.] ROT[35. - 13.] DEST[IOD] C600 $
01m0002                               	                ;Load cntma again-- since COUNT is currently  0, this will 
01m0002                               	                ; force BUF CNT to be 0.  But, we put -1 into COUNT this
01m0002                               	                ; time, which, with BUF CNT = 0, will make BUF CNT load
01m0002                               	                ; properly when STARTDC loads cntma.
01m0002 10043 440702214571000023630000	        MAPF[TP.WMA] START-OUT D[CONST 2] DEST[IOD] C600 $
01m0002                               	                ;Set MBUSY
01m0002 10044 500240000571000440010044	        MAPF[TP.WC] C550 LOOP[.] $
01m0002                               	                ;Wait for a few usec.  This clears mem rq.
01m0002 10045 640702200615000443600000	        START-OUT ALU[0] DEST[IOD] NORM $
01m0002                               	                ;Clr MBUSY
01m0002 10046 440300000571000440010000	        MAPF[TP.WC] C600 POPJ $
01m0002                               	
01m0002                               	;START DATA CHANNEL to write or read a record.  Transfer up to C(IR-ADR) words;
01m0002                               	;  starting address is in A-MEM[4].
01m0002                               	
01m0002 10047 640701234571000223000000	STRTDC: D[IR] MASK[18.] NORM DEST[5] DEST-A-MEM $
01m0002                               	                ;Initialize word count
01m0002 10050 640700214571034013000000	        D[CONST 1] ROT[14.] DEST[1] DEST-A-MEM NORM $
01m0002                               	                ;Initialize timeout count (for NCNTWT and FMNBWT)
01m0002 10051 440040000571000440000000	STDC1:  MAPF[0] C600 PUSHJ[DCGO] $
01m0002                               	          ;start xfer -- MAPF is relevant if we looped back here on READ
01m0002 10052 440050044571000443400032	        MAPF[0] START-IN D[11] DEST[AR] C600 PUSHJ[NCNTW1] $
01m0002                               	          ;Wait for TP CNT GO to be off (continue with current timeout count)
01m0002                               	          ;MAPF is relevant if we came from DCGWR below.
01m0002 10053 531140074571000440000051	        D[17] C550 -OBUS<0 JUMP[STDC1] $
01m0002                               	          ;Jump if this is a WRITE operation.
01m0002 10054 531140000571000443600051	        START-OUT D[AR] C550 -OBUS<0 JUMP[STDC1] $
01m0002                               	          ;READ op, so set MEM RQ to store last word.
01m0002                               	          ;Jump unless we timed out waiting for end of last COUNT.
01m0002 10055 440150044571000443400022	WCDONE: MAPF[0] START-IN D[11] DEST[AR] C600 JUMP[FMNBW1] $
01m0002                               	          ;Enter FMNBWT with the timeout count left from NCNTWT.
01m0002                               	          ;The MAPF sets MEM RQ if we have fallen in from previous instr.
01m0002 10056 510354464171000440000055	DCGO:   D[15] DEST[Q AR HOLD] C550 OBUS=0 JPOP[WCDONE] $
01m0002                               	                ;Get remaining word count. If =0, we are done.
01m0002 10057 511140014477014140000000	        D[CONST 14] ROT[6] ALU[Q-D] C550 OBUS<0 JUMP[DCG1] $
01m0002                               	                ;Jump if it is less than 1400
01m0002 10060 640710014171014140000000	         D[CONST 14] ROT[6] DEST[Q AR] NORM $   
01m0002                               	                ;It is not. Use 1400 instead.
01m0002 10061 640701204537000443000000	DCG1:   D[MEM] ALU[D-Q] DEST[5] DEST-A-MEM NORM $
01m0002                               	                ;Decrement remaining WC by amount of current WC.
01m0002 10062 640704460571000440000000	        D[14] DEST[HOLD] SHORT $
01m0002                               	                ;Get current starting adr
01m0002 10063 640701004435000443000000	        D[MEM] ALU[D+Q] DEST[4] DEST-A-MEM NORM $
01m0002                               	                ;Increment it by current WC.
01m0002 10064 511140040571000440000066	        D[10 + TPMODE] C550 OBUS<0 JUMP[. + 2] $
01m0002                               	                ;Are we in 32-bit mode ?  Jump if so.
01m0002 10065 640150000435004440000067	         D[AR] ROT[2] ALU[D+Q] DEST[AR] NORM JUMP[. + 2] $
01m0002                               	                ;Form byte count (=5*word count).
01m0002 10066 640710000571004440000000	         D[AR] ROT[2] ALU[D] DEST[AR] NORM $
01m0002                               	                ;Form byte count (=4*word count).
01m0002 10067 640710000531000440000000	        D[AR] ALU[D-1] DEST[AR] NORM $
01m0002                               	                ;Adjust count to be right for hdwr.
01m0002 10070 640700000171054440000000	        D[AR] ROT[35. - 13.] DEST[Q] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- F2X

01m0002                               	                ;Align count at bit 13.
01m0002 10071 640702204575000243600000	        START-OUT D[MEM] MASK[20.] ALU[DORQ] DEST[IOD] NORM $
01m0002                               	                ;Include mem addr and load into COUNT, MA
01m0002                               	                ;Also sets BUF CNT to 0 (if IN) or 5 (if OUT)-- this
01m0002                               	                ; depends on COUNT not =0 and BUF CNT not = 4 or 5
01m0002 10072 440702214571000023630000	        MAPF[TP.WMA] START-OUT D[CONST 2] DEST[IOD] C600 $
01m0002                               	                ;Set M BUSY
01m0002 10073 440700000571000443610000	        MAPF[TP.WC] START-OUT C600 $
01m0002                               	                ;Set CNT GO
01m0002 10074 451300074571000440130000	        MAPF[13] D[17] C600 OBUS<0 POPJ $
01m0002                               	                ;Return if this is a READ op.
01m0002 10075 530300064571000443600000	DCGWR:  START-OUT D[15] C550 -OBUS=0 POPJ $
01m0002                               	                ;Set MEM RQ to fetch first word.
01m0002                               	                ;Return unless this is the last WCMA in the record.
01m0002 10076 440702214571000123600000	        MAPF[0] START-OUT D[CONST 12] DEST[IOD] C600  $
01m0002                               	                ;Last one.  Set TP ENB LAST BYTE as well as M BUSY
01m0002 10077 440300000571000440010000	        MAPF[TP.WC] C600 POPJ $
01m0002                               	
01m0002                               	
01m0002                               	  ;Here to do the data xfer for a read operation.
01m0002 10100 640700060171000440000000	TRP2:   D[14] DEST[Q] SHORT $
01m0002                               	          ;We must save initial mem. adr. for NRZI KLUGE stuff..
01m0002 10101 640041614575106013000047	        D[CONST 1] ROT[35.] ALU[DORQ] DEST[7] DEST-A-MEM NORM PUSHJ[STRTDC] $
01m0002                               	          ;Flag op. as a READ, start the data channel
01m0002 10102 000140000571000440000000	        JUMP[TRCHKB] $
01m0002                               	
01m0002                               	TRCHECK:        
01m0002 10103 000040000571000440000021	        PUSHJ[FMNBWT] $
01m0002                               	          ;wait for formatter not busy.
01m0002 10104 531140004571100440000000	TRCHKB: D[MEM] ROT[32.] C550 -OBUS<0 JUMP[TRERR] $
01m0002                               	          ;check for hard error status.
01m0002 10105 531140004571102440000000	TRCHA:  D[MEM] ROT[33.] C550 -OBUS<0 JUMP[TREOF] $
01m0002                               	          ;Jump if EOF seen by formatter
01m0002 10106 640700000215000440000000	        ALU[0] DEST[Q] NORM $
01m0002                               	                ;Flag no errors.
01m0002 10107 640700000571000443400000	TRDONE: START-IN NORM $
01m0002 10110 440710030571000443420000	        MAPF[TP.RC] START-IN D[IOD] DEST[AR] C600  $  
01m0002                               	          ;Get data channel status bits.
01m0002 10111 240701230175000253030000	        MAPF[3] D[IOD] MASK[21.] ALU[DORQ] DEST[Q 5] DEST-A-MEM C800 $
01m0002                               	          ;Include ending MA value in status info.
01m0002 10112 531140000571046440000000	        D[AR] ROT[19.] C550 -OBUS<0 JUMP[TPMAOK] $
01m0002                               	          ;If TP CNT GO is off,
01m0002 10113 530140000531060033400000	        START-IN D[AR] ROT[24.] MASK[3] ALU[D-1] C550 -OBUS=0 JUMP[TPMAOK] $
01m0002                               	          ;  or if BUF CNT is not =1, then right no. of words were stored.
01m0002 10114 640701200055000443000000	         ALU[Q-1] DEST[Q 5] DEST-A-MEM NORM $
01m0002                               	           ;Otherwise, 1 extra word was stored, so decrement ending MA.
01m0002 10115 511140004571014440000000	TPMAOK: D[MEM] ROT[6] C550 OBUS<0 JUMP[TRCRET] $        
01m0002                               	          ;Done if not in NRZI mode.
01m0002 10116 531140040571002440000000	        D[10 + TPMODE] ROT[1] C550 -OBUS<0 JUMP[TRCRET] $
01m0002                               	          ;Also done if not in NRZI Kluge Mode,
01m0002 10117 510140060571000440000000	        D[14] C550 OBUS=0 JUMP[TRCRET] $
01m0002                               	          ; or if this was not a data-xfer operation.
01m0002 10120 531140050571030440000000	        D[12] ROT[12.] C550 -OBUS<0 JUMP[TRCRET] $
01m0002                               	          ;Neither do we check for EOF if we started at BOT (see KNYGOA)
01m0002                               	
01m0002                               	    ;In NRZI Kluge Mode, detect EOF by timing.
01m0002 10121 640704474077000240000000	        D[17] MASK[20.] ALU[Q-D] DEST[Q HOLD] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- F2X

01m0002                               	          ;Get number of words xferred (= ending MA minus starting MA )
01m0002 10122 640700004035004440000000	        D[MEM] ROT[2] ALU[D+Q] DEST[Q] NORM $
01m0002                               	          ;Get no. of bytes (=5* no. of words)
01m0002 10123 640700044035000240000000	        D[11] MASK[20.] ALU[D+Q] DEST[Q] NORM $
01m0002                               	          ;Add remaining timeout count from FMNBWT
01m0002 10124 640700014137034010000000	        D[CONST 1] ROT[14.] ALU[D-Q] DEST[Q] NORM $
01m0002                               	          ;Get no. of byte-times not accounted for by bytes xfrd.
01m0002                               	  .REPEAT 1 - 75IPS [
01m0002                               	  .REPEAT 75IPS [
01m0002 10125 533140014537014150000000	        D[CONST 15] ROT[6.] ALU[D-Q] C550 COND[-OBUS18] JUMP[TRCRET] $
01m0002                               	       ]          ;Jump if it is not more than appropriate for a record gap.
01m0002 10126 640040000571000440000000	        NORM PUSHJ[TAPEBR] $
01m0002                               	          ;Too long.  Assume an EOF was passed.  Back up over record read.
01m0002 10127 000040000571000440000021	        PUSHJ[FMNBWT] $
01m0002 10130 640300014171074600000000	        D[CONST 60] ROT[30.] DEST[Q] NORM POPJ $
01m0002                               	          ;Return EOF status.
01m0002                               	
01m0002 10131 511140060131000220000000	TRCRET: D[14] MASK[18.] ALU[D-1] DEST[Q] C550 OBUS<0 JUMP[TRCX] $
01m0002                               	          ;Get last loc. of input buffer (<0 iff non-data xfer operation)
01m0002 10132 640704400615000440000000	        ALU[0] DEST[HOLD] NORM $
01m0002                               	          ;Prepare to clear the part of the input buffer we didn't use.
01m0002                               	  .REPEAT NEWMAP [
01m0002 10133 640705200741000440000000	        ALU[-1] DEST[MAP-DISABLE] NORM $
01m0002                               	          ;Disable mapping.
01m0002                               	           ]  .REPEAT 1 - NEWMAP [
01m0002 10134 640720064531000440000000	        D[15] ALU[D-1] DEST[MA] NORM $
01m0002 10135 511140024475000440000137	        D[MA] ALU[Q-D-1] C550 OBUS<0 JUMP[. + 2] $
01m0002 10136 640164024433000440000135	        D[MA] ALU[D+1] DEST[MA STRT-WRT] NORM JUMP[. - 1] $
01m0002                               	  .REPEAT NEWMAP [
01m0002 10137 640705200615000440000000	        ALU[0] DEST[MAP-DISABLE] NORM $
01m0002                               	          ;Enable mapping.
01m0002                               	         ]  .REPEAT 1 - NEWMAP [
01m0002 10140 640300064171000440000000	TRCX:   D[15] DEST[Q] NORM POPJ $       
01m0002                               	          ;Recover ending status and return.
01m0002                               	
01m0002 10141 640140014171074600000107	TREOF:  D[CONST 60] ROT[30.] DEST[Q]  NORM JUMP[TRDONE] $
01m0002 10142 511140004571014440000144	TRERR:  D[MEM] ROT[6] C550 OBUS<0 JUMP[. + 2] $ 
01m0002                               	          ;Always check hard error if not in NRZI mode.
01m0002 10143 511140040571002440000105	        D[10 + TPMODE] ROT[1] C550 OBUS<0 JUMP[TRCHA] $
01m0002                               	          ;If NRZI, don't check if in kluge mode.
01m0002 10144 640140014171074500000107	        D[CONST 50] ROT[30.] DEST[Q] NORM JUMP[TRDONE] $
01m0002                               	          ;Flag hard read error to progm.
01m0002                               	
01m0002                               	        .PAIR
01m0002                               	. \ 2 + .
01m0003                               	]       UIOTRP[01m0003 10146 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0003                               	]$
01m0003                               	TAPEMT: ;OPCODE 726 -- MTAPE FUNCTIONS.
01m0003 10147 640040000571000440000151	        NORM PUSHJ[. + 2] $
01m0003 10150 640140000571000440000000	        NORM JUMP[GOMAIN] $
01m0003                               	
01m0003 10151 510140024171000440000000	        D[MA] DEST[Q] COND[OBUS=0] JUMP[TAPERW] C550 $
01m0003 10152 510040014537000010000000	        D[CONST 1] ALU[D-Q] COND[OBUS=0] PUSHJ[TWREOF] C550 $
01m0003 10153 510040014537000130000000	        D[CONST 13] ALU[D-Q] COND[OBUS=0] PUSHJ[TERASE] C550 $
01m0003 10154 510140014537000500000000	        D[CONST 50] ALU[D-Q] COND[OBUS=0] JUMP[TPSETIND] C550 $
01m0003                               	          ;Code ?, set industry compatable mode.
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- F2X

01m0003 10155 510140014537000510000000	        D[CONST 51] ALU[D-Q] COND[OBUS=0] JUMP[TPSETDMP] C550 $
01m0003                               	          ;Code ?, set PDP-10 dump mode.
01m0003 10156 510140014537000600000000	        D[CONST 60] ALU[D-Q] COND[OBUS=0] JUMP[TPSETNK] C550 $
01m0003                               	          ;Code ?, set NRZI KLUGE mode.
01m0003 10157 510140014537000610000000	        D[CONST 61] ALU[D-Q] COND[OBUS=0] JUMP[TPCLRNK] C550 $
01m0003                               	          ;Code ?, clear NRZI KLUGE mode.
01m0003 10160 510040014537000050000000	        D[CONST 5] ALU[D-Q] COND[OBUS=0] PUSHJ[TAPEFR] C550 $
01m0003 10161 510040014537000060000000	        D[CONST 6] ALU[D-Q] COND[OBUS=0] PUSHJ[TAPEBR] C550 $
01m0003 10162 640041000615000443000103	        ALU[0] DEST[4] DEST-A-MEM NORM PUSHJ[TRCHECK] $
01m0003                               	            ;Wait for op. to finish and get ending status in Q.
01m0003                               	            ; The 0 in A-MEM[4] prevents TRCHECK from clearing read buf !
01m0003 10163 640340001555000440000000	        ALU[Q] DEST[AC] NORM JPOP[GOMAIN] $
01m0003                               	            ;Return status to caller in his AC (same as READ)
01m0003                               	
01m0003                               	
01m0003                               	TWREOF:  ;WRITE AN END OF FILE (TAPE MARK)
01m0003 10164 640700014171016010000000	        D[CONST 1] ROT[35. - 28.] DEST[Q] NORM $ 
01m0003                               	          ;Get WFM (WRITE EOF) cmd bit for formatter
01m0003 10165 640144414575032010000000	TERAS1: D[CONST 1] ROT[35. - 22.] ALU[DORQ] DEST[HOLD] NORM JUMP[KNYMTP] $  
01m0003                               	          ;Add WRT CMD bit and start command.
01m0003                               	
01m0003 10166 640140014171014030000165	TERASE: D[CONST 3] ROT[35. - 29.] DEST[Q] NORM JUMP[TERAS1] $
01m0003                               	          ;ERASE A 3.75" GAP ON THE TAPE (get WFM and ERASE bits for formatter)
01m0003                               	
01m0003 10167 640700000571000443600000	KNYMTP: START-OUT NORM $
01m0003                               	          ;Give TP MR to clear mode, error status
01m0003 10170 440040004171000440050014	        MAPF[TP.MR] D[MEM] DEST[Q] C-OUT PUSHJ[KNYGOA] $
01m0003                               	          ;Put command bits in Q and start formatter.
01m0003 10171 640702214571022013600000	        START-OUT D[CONST 1] ROT[35. - 26.] DEST[IOD] NORM $
01m0003                               	                ;Clear all command bits except FORMATTER ENABLE.
01m0003 10172 000300000341000440020000	        MAPF[TP.WF] ALU[-1] DEST[Q] LONG POPJ $
01m0003                               	                ;Put -1 in Q in case we are returning to TAPEMT.
01m0003                               	
01m0003                               	TAPERW: ;REWIND
01m0003 10173 640144414571000240000167	        D[CONST 24] DEST[HOLD] NORM JUMP[KNYMTP] $
01m0003                               	          ;RWD AND GO BITS -- KNYGOA WILL DELETE THE GO BIT !
01m0003                               	
01m0003                               	TAPEFR: ;SKIP FORWARD ONE RECORD.
01m0003 10174 640144414571000000000167	        D[CONST 0] DEST[HOLD] NORM JUMP[KNYMTP] $
01m0003                               	          ;START A READ, BUT IGNORE THE DATA.
01m0003                               	
01m0003                               	TAPEBR: ;SKIP BACKWARD ONE RECORD.
01m0003 10175 640144414571020010000167	        D[CONST 1] ROT[35. - 27.] DEST[HOLD] NORM JUMP[KNYMTP] $
01m0003                               	          ;JUST A READ BACKWARD, WITH THE DATA IGNORED.
01m0003                               	
01m0003                               	TPSETIND:       ;Set industry compatable mode
01m0003 10176 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10177 000140014575106013000000	        D[CONST 1] ROT[35.] ALU[DORQ] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	          ;Set appropriate bit and done
01m0003                               	TPSETDMP:       ;Set PDP-10 Dump Mode
01m0003 10200 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10201 000140014675106013000000	        D[CONST 1] ROT[35.] ALU[-D&Q] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	          ;Clear industry compatable mode and done.
01m0003                               	
01m0003                               	TPSETNK:        ;Enter NRZI KLUGE mode.
01m0003 10202 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10203 000140014575104013000000	        D[CONST 1] ROT[34.] ALU[DORQ] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- F2X

01m0003                               	          ;Set appropriate bit and done
01m0003                               	TPCLRNK:          ;Leave NRZI KLUGE mode.
01m0003 10204 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10205 000140014675104013000000	        D[CONST 1] ROT[34.] ALU[-D&Q] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	
01m0003                               	TAPERS: ;OPCODE 727 -- READ STATUS BITS FROM TAPE DRIVE.
01m0003                               	
01m0003                               	.DEFINE TSS[01m0003                               	
01m0003 10206 640702200615000443600000	        START-OUT ALU[0] DEST[IOD] NORM $
01m0003                               	          ;CLEAR THE MODE CTRL REGISTER.
01m0003                               	        MAPF[TP.WM] START-OUT 
01m0003 10207 440702214571022013640000	         D[CONST 1] ROT[35. - 26.] DEST[IOD] C-OUT $
01m0003                               	          ;ENABLE THE FORMATTER.
01m0003 10210 240700000215000443420000	        MAPF[TP.WF] START-IN ALU[0] DEST[Q] C800 $
01m0003                               	          ;READ STATUS BITS.
01m0003 10211 240710030771000440040000	        MAPF[TP.RS] D[IOD] ALU[NOTD] DEST[AR] C800 $
01m0003                               	          ;NOW RE-ARRANGE THE BITS
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 3 OF AR TO BIT 30. OF Q.
01m0003 10212 640704400571010010000000	        D[AR] ROT[1 + 3] MASK[1] DEST[HOLD] NORM $
01m0003 10213 640700004175012440000000	        D[MEM] ROT[35. - 30.] ALU[DORQ] DEST[Q] NORM $ ];ON LINE
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 11. OF AR TO BIT 31. OF Q.
01m0003 10214 640704400571030010000000	        D[AR] ROT[1 + 11.] MASK[1] DEST[HOLD] NORM $
01m0003 10215 640700004175010440000000	        D[MEM] ROT[35. - 31.] ALU[DORQ] DEST[Q] NORM $ ];REWINDING
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 4 OF AR TO BIT 32. OF Q.
01m0003 10216 640704400571012010000000	        D[AR] ROT[1 + 4] MASK[1] DEST[HOLD] NORM $
01m0003 10217 640700004175006440000000	        D[MEM] ROT[35. - 32.] ALU[DORQ] DEST[Q] NORM $ ];FILE PROTECT
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 12. OF AR TO BIT 33. OF Q.
01m0003 10220 640704400571032010000000	        D[AR] ROT[1 + 12.] MASK[1] DEST[HOLD] NORM $
01m0003 10221 640700004175004440000000	        D[MEM] ROT[35. - 33.] ALU[DORQ] DEST[Q] NORM $ ];LOAD POINT
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 10. OF AR TO BIT 34. OF Q.
01m0003 10222 640704400571026010000000	        D[AR] ROT[1 + 10.] MASK[1] DEST[HOLD] NORM $
01m0003 10223 640700004175002440000000	        D[MEM] ROT[35. - 34.] ALU[DORQ] DEST[Q] NORM $ ];READY
01m0003                               	        TSS[01m0003                               	 ;MOVE BIT 34. OF AR TO BIT 35. OF Q.
01m0003 10224 640704400571106010000000	        D[AR] ROT[1 + 34.] MASK[1] DEST[HOLD] NORM $
01m0003 10225 640700004175000440000000	        D[MEM] ROT[35. - 35.] ALU[DORQ] DEST[Q] NORM $ ];END OF TAPE
01m0003                               	        ALU[Q] DEST[MEMSTO] NORM
01m0003 10226 662104200555000440000000	                COND[-MA-AC] LBJUMP[HIGHSMAIN] $
01m0003                               	
01m0003                               	
01m0003                               	        .PAIR
01m0003                               	. \ 2 + .
01m0004                               	]       UIOTRP[01m0004 10230 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0004                               	]$
01m0004                               	TAPENR: ;730, AC/COUNT.  READ WHOLE RECORD, STORING UP TO COUNT WORDS STARTING AT EFF
01m0004                               	 ADR.
01m0004                               	         ;SWAP AC AND IR, THEN DO TAPERX.
01m0004 10231 640140235171000440000000	        D[IR] DEST[O_AC IR-ADR] ACSEL[AC]  NORM JUMP[TAPERX] $ 
01m0004                               	
01m0004                               	        .PAIR
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

01m0004                               	. \ 2 + .
01m0005                               	]       UIOTRP[01m0005 10232 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0005                               	]$
01m0005                               	TAPERX: ;732 - (AC) IS START ADDR., E IS # OF WORDS TO READ.
01m0005 10233 640040000571000440000010	        NORM PUSHJ[KNYRGO] $ ;GET TAPE STARTED.
01m0005 10234 640041000551000443000100	        ALU[AC] ACSEL[AC] DEST[4] DEST-A-MEM PUSHJ[TRP2] NORM $ ;READ REC.
01m0005 10235 031140000571040440000000	        D[AR] ROT[16.] -OBUS<0 JUMP[TNRP3] $
01m0005                               	                ;Was record longer than word count ?
01m0005                               	                ;Jump unless FIFO RDY FOR BUF is on, indicating
01m0005                               	                ;  that tape supplied more bytes after count ran out.
01m0005 10236 640700014175074440000000	        D[CONST 44] ROT[30.] ALU[DORQ] DEST[Q] NORM $ ;YES, SET BIT 3.
01m0005 10237 640340001555000440000000	TNRP3:  ALU[Q] DEST[AC] ACSEL[AC] JPOP[GOMAIN] NORM $  ;NO, NOT TOO LONG.
01m0005                               	                ;MOVE STATUS INTO AC.
01m0005                               	
01m0005                               	
01m0005                               	UTAPWR: UIOTRP[01m0005 10240 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0005                               	]$
01m0005                               	
01m0005                               	TAPEWR: ;731, AC/ADR, E/+COUNT.  WRITE RECORD OF +COUNT
01m0005                               	        ; WORDS, DATA FROM ADR.
01m0005                               	        ;SET AC:=0 IF OPERATION COMPLETED SUCCESSFULLY.
01m0005                               	        ; SET AC:=<SETZ> + HIGHEST ADR READ IF REACHED
01m0005                               	        ; EOT DURING OPERATION (CURRENTLY THIS IS THE ONLY
01m0005                               	        ; ERROR CONDITION.)  OPERATION IS COMPLETED EVEN
01m0005                               	        ; IF EOT IS PASSED.
01m0005                               	
01m0005 10241 640701614571000123000000	        D[CONST 10.] DEST[7] DEST-A-MEM NORM $
01m0005                               	          ;SET UP ERROR RETRY COUNT.
01m0005 10242 640040000571000440000040	TWRTRY: NORM PUSHJ[DCINIT] $
01m0005                               	                ;Init. the data channel
01m0005 10243 640710040571002010000000	        D[10 + TPMODE]  ROT[1] MASK[1] DEST[AR] NORM $
01m0005                               	                ;Get the 32-bit mode flag.
01m0005 10244 640700000171014440000000	        D[AR] ROT[35. - 29.] DEST[Q] NORM $
01m0005                               	                ;Position it for the hardware.
01m0005 10245 640702214575016013600000	        START-OUT D[CONST 1] ROT[35. - 28.] ALU[DORQ] DEST[IOD] NORM $
01m0005                               	                ;Set the OUT bit.
01m0005 10246 000040014171032010040014	        MAPF[TP.WM] D[CONST 1] ROT[35. - 22.] DEST[Q] PUSHJ[KNYGOA] $
01m0005                               	                ;Issue WRITE command to formatter.
01m0005 10247 640041000551000443000047	        ALU[AC] DEST[4] DEST-A-MEM NORM PUSHJ[STRTDC] $
01m0005                               	                ;Get word count and start the channel.
01m0005 10250 031140004571100440000000	        D[MEM] ROT[32.] -OBUS<0 JUMP[TWERR] $ ;Test HARD ERR.
01m0005 10251 640700001615000440000000	        ALU[0] DEST[AC] NORM $ ;We return 0 in AC if no EOT.
01m0005 10252 511140004571104440000000	        D[MEM] ROT[34.] C550 OBUS<0 JUMP[GOMAIN] $
01m0005                               	         ;If no EOT seen, all done.
01m0005 10253 640140015561074600000000	        D[CONST 60] ROT[35. - 5] ALU[DORAC] DEST[AC] NORM JUMP[GOMAIN] $
01m0005                               	         ;Turn on bit 0 to indicate EOT seen during operation.
01m0005                               	
01m0005                               	TWERR:  ;;Error occurred during write. Backspace, erase gap, and retry.
01m0005 10254 640040000571000440000001	        NORM PUSHJ[KNYRS1] $ 
01m0005                               	          ;Blast the tape formatter and drive 
01m0005 10255 531140074131000440000000	        D[17] ALU[D-1] DEST[Q] C550 -OBUS<0 JUMP[TWER1] $
01m0005                               	          ;See if we have had to many retry's already...
01m0005 10256 000140015571074500000000	        D[CONST 50] ROT[30.] DEST[AC] JUMP[GOMAIN] $
01m0005                               	           ;Hopeless. Give error return to prgm.
01m0005 10257 640041600555000443000175	TWER1:  ALU[Q] DEST[7] DEST-A-MEM NORM PUSHJ[TAPEBR] $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- F2X

01m0005                               	         ;Start a BACKSPACE RECORD command.
01m0005 10260 640040000571000443400021	        START-IN NORM PUSHJ[FMNBWT] $ 
01m0005                               	         ;Wait for completion.
01m0005 10261 000040000571000440000166	        PUSHJ[TERASE] $
01m0005                               	         ;Start erasing a 3.75" gap.
01m0005 10262 640040000571000443400021	        START-IN NORM PUSHJ[FMNBWT] $ 
01m0005                               	         ;Wait for completion.
01m0005 10263 640140000571000440000242	        NORM JUMP[TWRTRY] $
01m0005                               	          ;Start write op again.
01m0005                               	
01m0005                               	
01m0005                               	;BOOTSTRAP LOADER FOR MACROCODE.
01m0005                               	
01m0005                               	 .ORG[01m0005                               	XLIST
01m0006                               	 LIST ]
01m0006 05000 000340000571000440005001	MBOOT:  JPOP[. + 1] $
01m0006                               	         ;The . + 1 is to make the lights look familiar for the operator...
01m0006 05001 000140000571000440000000	        JUMP[MBOOTA] $
01m0006                               	         ;MBOOTA takes us to MBOOTH, whether or not that is in high u-mem.
01m0006                               	
01m0006                               	.REPEAT XUCODE [ 01m0006                               	;If 8K u-mem, put this code in upper 4K
01m0006       5002	AREA50 = .
01m0006                               	 .USE[01m0006                               	XLIST
01m0006                               	 LIST ] ];XUCODE
01m0006                               	
01m0006 10264 000041614571000070000001	MBOOTH: D[CONST 7] DEST[DEV-ADR] PUSHJ[KNYCLR] $ ;RESET TAPE CTRL
01m0006 10265 640042600615000440000000	        ALU[0] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
01m0006 10266 640042614571044010000000	        D[CONST 1] ROT[18.] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
01m0006 10267 000041614571000070000010	        D[CONST 7] DEST[DEV-ADR] CYLEN[LONG] PUSHJ[KNYRGO] $
01m0006                               	                ;SELECT DEVICE 7, START READ.
01m0006 10270 640040000571000440000000	        NORM PUSHJ[KNYWAIT] $
01m0006 10271 240044430771000443420000	        MAPF[TP.RC] START-IN D[IOD] ALU[NOTD] DEST[HOLD] C800 PUSHJ[MBTBYX] $ 
01m0006                               	                ;Read 1st byte of new record.
01m0006 10272 640162600615000440000000	        ALU[0] DEST[MA HI-ABS-MA] NORM JUMP[P2A] $
01m0006                               	                ;Clear high-order MA and enter reading loop.
01m0006                               	
01m0006 10273 640060024433000440000000	P2:     D[MA] ALU[D+1] DEST[MA] PUSHJ[MBTBYTE] NORM $
01m0006 10274 640040004171070440000000	P2A:    D[MEM] ROT[34] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10275 640040004175050440000000	        D[MEM] ROT[24] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10276 640040004175030440000000	        D[MEM] ROT[14] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10277 640040004175010440000000	        D[MEM] ROT[4] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10300 640144204575000040000273	        D[MEM] MASK[4]  ALU[DORQ] DEST[MEMSTO] NORM JUMP[P2] $
01m0006                               	
01m0006 10301 640720000615000440000000	CCLR:   ALU[0] DEST[MA] NORM $
01m0006 10302 640704200615000440000000	        ALU[0] DEST[MEMSTO] NORM $
01m0006 10303 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
01m0006 10304 470140024571000220000302	        D[MA] MASK[18.] COND[-OBUS=0] JUMP[. - 2] C600 $
01m0006 10305 640300000571000440000000	        POPJ NORM $
01m0006                               	
01m0006                               	MBTBYTE:
01m0006 10306 640740014571002353400000	        START-IN D[CONST 35] ROT[1] LLOAD NORM $
01m0006                               	                ;Ask tape for a byte and status thereof
01m0006                               	                ;Set loop counter to do timeout
01m0006                               	                ;(TIMEOUT ABOUT 78 USEC)
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- F2X

01m0006 10307 240244430571000440020000	MBTBY1: MAPF[TP.RC] D[IOD] DEST[HOLD] C800 LOOP[MBTBY2] $
01m0006                               	                ;Read byte and status.  Byte comes complemented.
01m0006                               	                ;Result is put in HOLD to avoid synchronizer problems
01m0006                               	                ;Do timeout check and branch if still waiting
01m0006 10310 640040000571000443400000	        START-IN NORM PUSHJ[MBTCHECK] $
01m0006                               	                ;Byte wasn't ready in time.  Go find out why
01m0006 10311 000040000571000440000010	        PUSHJ[KNYRGO] $ ;START NEXT RECORD.
01m0006 10312 640040000571000440000000	        NORM PUSHJ[KNYWAIT] $
01m0006 10313 240044430771000443420000	        MAPF[TP.RC] START-IN D[IOD] ALU[NOTD] DEST[HOLD] C800 PUSHJ[MBTBYX] $ 
01m0006                               	                ;Read 1st byte of new record.
01m0006 10314 640340000571000440000274	        NORM JPOP[P2A] $
01m0006                               	                ;Go for another record
01m0006                               	;       ---
01m0006                               	MBTBY2:
01m0006 10315 531140004571064443400307	        START-IN D[MEM] ROT[26.] -OBUS<0 C550 JUMP[MBTBY1] $
01m0006                               	                ;Check for byte ready (this is a two instruction loop)
01m0006                               	                ;Start getting byte and status again in case we have
01m0006                               	                ;  to loop
01m0006 10316 240704430771000443420000	        START-IN MAPF[TP.RC] D[IOD] ALU[NOTD] DEST[HOLD] C800 $
01m0006                               	                ;READ THE DATA AGAIN (NOW THAT IT'S STABLE !)
01m0006 10317 500304404571000100010000	MBTBYX: MAPF[1] D[MEM] MASK[10] DEST[HOLD] C550 POPJ $
01m0006                               	                ;MAPF[1] clears byte ready
01m0006                               	                ;Extract data byte from other status information
01m0006                               	
01m0006                               	;       ---
01m0006                               	
01m0006                               	KNYWAIT: ;Wait for first byte of read data (BOOTSTRAP mode only)
01m0006 10320 640700000571000443400000	        START-IN SHORT $
01m0006 10321 640710014571030773410000	        MAPF[1] START-IN D[CONST 77] ROT[12.] DEST[AR] NORM $
01m0006                               	                ;Clear read data ready flag
01m0006 10322 440704430571000440020000	KNYW1:  MAPF[TP.RC] D[IOD] DEST[HOLD] C600 $
01m0006 10323 511300004571064443400000	        START-IN D[MEM] ROT[26.] OBUS<0 POPJ C550 $
01m0006                               	                ;Return if READ DATA RDY is now on.
01m0006 10324 530150000531000443400322	        START-IN D[AR] ALU[D-1] DEST[AR] C550 -OBUS=0 JUMP[KNYW1] $
01m0006 10325 640300000571000440000000	        NORM POPJ $
01m0006                               	
01m0006 10326 640040000571000443400021	MBTCHECK:       START-IN NORM PUSHJ[FMNBWT] $
01m0006                               	          ;WAIT FOR FORMATTER IDLE.
01m0006 10327 531140004571100440000000	        D[MEM] ROT[32.] C550 -OBUS<0 JUMP[MBTERR] $
01m0006                               	          ;CHECK FOR ERROR STATUS.
01m0006 10330 511300004571102440000000	        D[MEM] ROT[33.] C550 OBUS<0 POPJ $
01m0006                               	          ;IF END OF FILE NOT SEEN, RETURN FOR MORE, ELSE DONE.
01m0006 10331 640700000215000440000000	        ALU[0] DEST[Q] NORM $ ;CLEAR LIGHTS TO INDICATE NO ERRORS.
01m0006 10332 000341600615000443600333	MBTDNX: START-OUT ALU[0] DEST[DEV-ADR] JPOP[. + 1] $
01m0006                               	                ;Setup to display code in lights
01m0006 10333 000340000555000443620334	        START-OUT MAPF[2] ALU[Q] JPOP[. + 1] $  ;LOAD LIGHTS FROM Q, CLR SW FF'S
01m0006 10334 000700000571000443440000	D1:     MAPF[4] START-IN $
01m0006                               	           ;CHECK START AND CONT SWITCHES.  RD NEXT FILE ON CONT
01m0006 10335 000710030571000440040000	        MAPF[4] D[IOD] DEST[AR] $
01m0006                               	        D[AR]  ROT[5] MASK[2] DEST[AR]
01m0006 10336 010150000571012020000334	                COND[OBUS=0] JUMP[D1] CYLEN[LONG] $
01m0006                               	                ;WAIT FOR A SWITCH.
01m0006 10337 530140000571000010000000	        D[AR] MASK[1] COND[-OBUS=0] JUMP[GOMSTART] C550 $
01m0006                               	           ;  ... START MAIN MICROCODE ON START SWITCH.
01m0006 10340 640700000571000443600000	        START-OUT NORM $  ;CLEAR SWITCH FF'S
01m0006 10341 000340000571000440040264	        MAPF[4] JPOP[MBOOTH] CYLEN[LONG] $
01m0006                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- F2X

01m0006                               	GOMSTART: ;Branch to MSTART
01m0006                               	        GETADR[ ;Place the 12-bit value of MSTART in Q.
01m0006 10342 640700014171014400000000	        D[CONST (77 & (MSTART / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
01m0006 10343 440140014175000000000000	        D[CONST (MSTART \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOLOW] $
01m0006                               	
01m0006 10344 000140014371000000000332	MBTERR: D[CONST 0] ALU[NOTD] DEST[Q] JUMP[MBTDNX] $
01m0006                               	;       ---
01m0006                               	
01m0006                               	  .ORG[01m0006                               	XLIST
01m0007                               	 LIST ]
01m0007 02150 000140000571000440002150	        JUMP[.] $       ;Hang if any interrupts from device 7 occur.
01m0007                               	
01m0007                               	    .USE[XLIST
01m0007                               	 LIST ] ;RETURN TO OLD LOC. CTR.
01m0007                               	
01m0007                               	MBOOTA: GETADR[ ;Place the 12-bit value of MBOOTH in Q.
01m0007 06221 640700014171014020000000	        D[CONST (77 & (MBOOTH / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
01m0007 06222 440140014175000640000000	        D[CONST (MBOOTH \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOHIGH] $
01m0007                               	        

SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

33m0150                               	  ]
33m0150                               	  ];NTP
33m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

34m0150                               	.REPEAT KNYTAPE [ 34m0150                               	;ENDX OF KENNEDY TAPE CODE
34m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

35m0150                               	.REPEAT TLXTAPE [ 35m0150                               	;ENDX OF TELEX TAPE CODE
35m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

36m0150                               	.REPEAT SLOWTAPE [ 36m0150                               	;END OF SLOW TAPE CODE
36m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

37m0150                               	.REPEAT 125TAPE [ 37m0150                               	;END OF SLOW 125 IPS TAPE CODE
37m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

38m0150                               	;TAPE DISPATCH
38m0150                               	
38m0150                               	 .REPEAT 1 - XUCODE [ 38m0150                               	;1 - XUCODE
38m0150                               	
38m0150                               	
38m0150                               	 .REPEAT XUCODE [ 38m0150                               	;If we don't have extended ucode memory, these are different.
38m0150                               	
38m0150                               	.OPCODE[LIST 
38m0150                               	 LIST            ];TAPE IOTS
38m0150                               	
38m0150                               	;725 - Obsolete version of read (no word count, E = core address.)
38m0150                               	        GETADR[ ;Place the 12-bit value of TAPERD in Q.
38m0150 03652 640700014171014000000000	        D[CONST (77 & (TAPERD / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03653 440140014175000050000000	        D[CONST (TAPERD \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;726 - MTAPE
38m0150                               	        GETADR[ ;Place the 12-bit value of TAPEMT in Q.
38m0150 03654 640700014171014010000000	        D[CONST (77 & (TAPEMT / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03655 440140014175000470000000	        D[CONST (TAPEMT \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;727 - READ STATUS
38m0150                               	        GETADR[ ;Place the 12-bit value of TAPERS in Q.
38m0150 03656 640700014171014020000000	        D[CONST (77 & (TAPERS / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03657 440140014175000060000000	        D[CONST (TAPERS \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;730 - OBSOLETE ! --read 1 record, store up to (AC) words starting at E.
38m0150                               	        GETADR[ ;Place the 12-bit value of TAPENR in Q.
38m0150 03660 640700014171014020000000	        D[CONST (77 & (TAPENR / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03661 440140014175000310000000	        D[CONST (TAPENR \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;731 - WRITE 1 record of E words starting from CORE LOC IN AC.
38m0150                               	        GETADR[ ;Place the 12-bit value of TAPEWR in Q.
38m0150 03662 640700014171014020000000	        D[CONST (77 & (TAPEWR / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03663 440140014175000410000000	        D[CONST (TAPEWR \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;732 - READ 1 record, store up to E words starting at (AC).
38m0150                               	        GETADR[ ;Place the 12-bit value of TAPERX in Q.
38m0150 03664 640700014171014020000000	        D[CONST (77 & (TAPERX / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03665 440140014175000330000000	        D[CONST (TAPERX \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	
38m0150                               	  ];XUCODE
38m0150                               	
38m0150                               	.RELOC
38m0150                               	USE[38m0150                               	XLIST
38m0151                               	 LIST ]]
38m0151 06223 025141614571000070000000	TAPDSP: D[CONST 7] DEST[DEV-ADR] COND[-USER] JUMP[GOHIGH] $
38m0151                               	         ;Load device code for tape, test for user mode.
38m0151                               	        UIOTRP[38m0151 06224 010140020571016010002100	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
38m0151                               	]$
38m0151                               	         ;In user mode-- trap unless IOT USER
38m0151                               	
38m0151                               	GOHIGH:  ;Jump into high part of umemory, using 12-bit addr. in Q
38m0151 06225 440540014433022120000000	        D[CONST (XUCODE * 10) + 2] ROT[9.] ALU[D+1] C600 SDISP $
38m0151                               	          ;This takes us to loc. 2001 and pre-sets the 10000 bit.
38m0151                               	 .ORG[38m0151                               	XLIST
38m0152 02001 000540014575030010000000	 LIST ] D[CONST XUCODE] ROT[12.] ALU[DORQ] SDISP $
38m0152                               	          ;This finally takes us to loc. 10000+[Q] 
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

38m0152                               	
38m0152                               	 .RELOC
38m0152                               	USE[38m0152                               	XLIST
38m0153                               	 LIST ]]
38m0153                               	  .REPEAT XUCODE [
38m0153                               	.USE[XLIST
38m0153                               	 LIST ]$
38m0153                               	     ]
38m0153                               	 .PAIR
38m0153                               	. \ 2 + .
38m0154                               	]HIGHSMAIN:
38m0154 10346 640140005570400440000000	        D[MEM] ACSEL[MA] DEST[AC] NORM JUMP[GOMAIN] $
38m0154 10347 640140000571000440000000	        NORM JUMP[GOMAIN] $
38m0154                               	
38m0154                               	GOMAIN: GETADR[ ;Place the 12-bit value of MAIN in Q.
38m0154 10350 640700014171014200000000	        D[CONST (77 & (MAIN / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0154 10351 440700014175000260000000	        D[CONST (MAIN \ 100)] ALU[DORQ] DEST[Q] C600 ] $        ;Do extended mode jump to
38m0154                               	 MAIN.
38m0154                               	
38m0154                               	GOLOW:   ;Jump to loc. in lower 4K indicated by contents of Q.
38m0154                               	
38m0154                               	   .REPEAT XUCODE [
38m0154 10352 440540000615000440000000	        ALU[0] C600 SDISP $
38m0154                               	         ;This goes to loc. 10000 and pre-clears the 10000 bit.
38m0154                               	 .ORG[38m0154                               	XLIST
38m0154                               	 LIST ]   ];XUCODE
38m0154                               	
38m0154 10000 440540000555000440000000	        C600 ALU[Q] SDISP $
38m0154                               	         ;Now we actually go to low u-mem.
38m0154                               	
38m0154                               	.USE[38m0154                               	XLIST
38m0155                               	 LIST ]
38m0155                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

39m0155                               	
39m0155                               	
39m0155                               	;------------------------------------------------------------------------------
39m0155                               	;
39m0155                               	;       FooVision
39m0155                               	;
39m0155                               	;------------------------------------------------------------------------------
39m0155                               	.REPEAT VID [
39m0155                               	.INSERT VID.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

01m0001                               	COMMENT \               VID.SLO
01m0001                               	
01m0001                               	This is the microcode for vector display i/o.
01m0001                               	There are two basic macro instructions:
01m0001                               	        VIDIN AC,E:     770000,,0
01m0001                               	                        input from VID with i/o sub sel = ac
01m0001                               	                        to contents of effective address.
01m0001                               	        VIDOUT AC,E:    771000,,0
01m0001                               	                        output from contents of effective address
01m0001                               	                        to VID with i/o sub sel = ac
01m0001                               	
01m0001                               	These get dispatched to by 700 series iots
01m0001                               	(although the format is more like a non-iot instruction.)
01m0001                               	
01m0001                               	;OPDEF's for FooVision:
01m0001                               	OPDEF   VIDIN   [770000,,0]     ;In to CPU from FooVision (AC=MAPF)
01m0001                               	OPDEF   VIDOUT  [771000,,0]     ;Out from CPU to FooVision (AC=MAPF)
01m0001                               	OPDEF   VLDDAT  [VIDOUT 1,]     ;36 bit format or B,G,R 8 bits each
01m0001                               	OPDEF   VSYDAT  [VIDIN 1,]      ;Synthesize DATA (also to (E))
01m0001                               	OPDEF   VLDADR  [VIDOUT 2,]     ;16 bits right justified
01m0001                               	OPDEF   VSYADR  [VIDIN 2,]      ;Synthesize ADR (also to (E))
01m0001                               	OPDEF   VLDBAK  [VIDOUT 3,]     ;IOB 4-11 (of 36 bit word, 0=MSB)
01m0001                               	OPDEF   VOEVID  [VIDIN 4,]      ;36 bit format palette(3),(11*PIXEL(3))
01m0001                               	OPDEF   VOECOL  [VIDIN 5,]      ;B,G,R 8 bits each right justified
01m0001                               	OPDEF   VWECOL  [VIDIN 6,]      ;Write enable color map - (E) trashed
01m0001                               	OPDEF   VWEVID  [VIDIN 7,]      ;Write enable video buffer - (E) trashed
01m0001                               	OPDEF   VLDCOL  [VIDOUT 10,]    ;36 bit mask XORed with synthesized data
01m0001                               	OPDEF   VLDSIZ  [VIDOUT 11,]    ;OFFSET,,SIZE (in WDS/FLD (11 PXLS/WD))
01m0001                               	OPDEF   VLDCTR  [VIDOUT 12,]    ;B0=video resolution (vs. high res B/W)
01m0001                               	                                ;B1=add (don't overwrite)
01m0001                               	                                ;B2=carry
01m0001                               	                                ;B3=interlace
01m0001                               	                                ;B4=NTSC color
01m0001                               	OPDEF   VLDPIX  [VIDOUT 13,]    ;Inten.(3 bit),line (9 bit),,pixel(10 bit)
01m0001                               	OPDEF   VLDOFF  [VIDOUT 14,]    ;Y offset,,X offset
01m0001                               	OPDEF   VWEDIV  [VIDIN 16,]     ;Write enable divide table - (E) trashed
01m0001                               	OPDEF   VWENTS  [VIDIN 17,]     ;Write enable NTSC table - (E) trashed
01m0001                               	
01m0001                               	There are three additional instructions which simulate part of the
01m0001                               	Stanford-III vector display:
01m0001                               	
01m0001                               	OPDEF   DPYINI  [772000,,0]     ;Initialize display
01m0001                               	OPDEF   DPYOUT  [773000,,0]     ;Interpret Stanford-III display format
01m0001                               	OPDEF   DPYADD  [767000,,0]     ;Append Stanford-III display format
01m0001                               	
01m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

02m0001                               	        DPYINI POGB     ;Take a block of 64 words at E (which contain
02m0001                               	                        ;pointers to "shadow" pieces-of-glass, fonts,
02m0001                               	                        ;and various other state (used in interrupts)).
02m0001                               	                        ;Zero all POG lengths, and blank screen.
02m0001                               	
02m0001                               	POGB:   <POG0 LENGTH(15 bits RJ),,BEGINING-POG-BUFFER>
02m0001                               	POGB+1: <POG1 LENGTH(15 bits RJ),,BEGINING-POG-BUFFER>
02m0001                               	        ...
02m0001                               	POGB+15:<POG15 LENGTH(15 bits RJ),,BEGINING-POG-BUFFER>
02m0001                               	                                ;These are pointers to blocks of memory where
02m0001                               	                                ;the display list for the previous piece of
02m0001                               	                                ;glass is copied. This data is subtracted
02m0001                               	                                ;from the image by DPYOUT before adding the
02m0001                               	                                ;new display list.
02m0001                               	
02m0001                               	POGB+16:<POG0 XMAX,,XMIN>       ;Window boundaries
02m0001                               	POGB+17:<POG1 XMAX,,XMIN>
02m0001                               	        ...
02m0001                               	POGB+31:<POG15 XMAX,,XMIN>
02m0001                               	
02m0001                               	POGB+32:<POG0 YMAX,,YMIN>       ;Note: These are internal (- at top) coords.
02m0001                               	POGB+33:<POG1 YMAX,,YMIN>
02m0001                               	        ...
02m0001                               	POGB+47:<POG15 YMAX,,YMIN>
02m0001                               	
02m0001                               	POGB+48:<LAST COLOR,,LAST FONT> ;Pointers to fonts (2K each)
02m0001                               	POGB+49:<FONT 1>
02m0001                               	POGB+50:<FONT 2>
02m0001                               	        ...
02m0001                               	POGB+55:<FONT 7>
02m0001                               	
02m0001                               	POGB+56:<REMAINING LENGTH>      ;State for interrupt recovery
02m0001                               	POGB+57:<DISPLAY BUFFER POINTER,,PIECE OF GLASS POINTER>
02m0001                               	POGB+58:<MICRO RETURN ADDRESS>
02m0001                               	POGB+59:<COLOR MASK,,MASK>      ;Non VIC2 only
02m0001                               	POGB+60:<INTERLACED LINE 000000>;Non VIC2 only
02m0001                               	POGB+61:<X0,,X1>
02m0001                               	POGB+62:<Y0,,Y1>
02m0001                               	POGB+63:
02m0001                               	
02m0001                               	POGB+64:<AMEM[0]>
02m0001                               	POGB+65:<AMEM[1]>
02m0001                               	        ...
02m0001                               	POGB+71:<AMEM[7]>
02m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

03m0001                               	        DPYOUT POG,E    ;Similar to the stanford instruction. Takes
03m0001                               	       (DPYADD)         ;a pointer and length for the display list
03m0001                               	                        ;for the piece of glass and puts it on the
03m0001                               	                        ;screen, deleting (or adding to) the previous
03m0001                               	                        ;contents of that piece of glass.
03m0001                               	
03m0001                               	E:      <LENGTH>,,<BEGINING>
03m0001                               	
03m0001                               	Below are the two objects (vectors and characters) implemented from
03m0001                               	the Stanford-III display system:
03m0001                               	
03m0001                               	Long Word Vector:
03m0001                               	!00 10!11 21!22 24!25  27!28!29!30 31!32  35!
03m0001                               	!  X  !  Y  ! BRT ! SIZE !  !M !  T  ! 0110 !
03m0001                               	BRT(color):             SIZE:           M:              T:
03m0001                               	0=no change             0=no change     0=relative      0=visible
03m0001                               	1=white                 1=font 1        1=absolute      1=end point
03m0001                               	2=red                   .                               2=invisible
03m0001                               	3=yellow                .                               3=undefined
03m0001                               	4=green                 .                                 (end point)
03m0001                               	5=blue                  .
03m0001                               	6=magenta               .
03m0001                               	7=white(colored)        7=font 7
03m0001                               	
03m0001                               	CHaRacter:
03m0001                               	!00 06!07 13!14 20!21 27!28 34!35!
03m0001                               	! CH1 ! CH2 ! CH3 ! CH4 ! CH5 !1 !
03m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

04m0001                               	Vector algorithms:
04m0001                               	X(Y)=X(Y-1)+DXDY
04m0001                               	INTEN(Y,INT(X(Y)))=     3*(1-FRACT(X))          if A3DYDX GEQ 3
04m0001                               	                        3-A3DYDX*FRACT(X)       if A3DYDX < 3
04m0001                               	INTEN(Y,INT(X(Y))+1)=   3*FRACT(X)              if A3DYDX GEQ 3
04m0001                               	                        3-A3DYDX*(1-FRACT(X))   if A3DYDX < 3
04m0001                               	INTEN(Y,INT(X(Y))-K)=INTEN(Y,INT(X(Y))-(K-1))-A3DYDX
04m0001                               	INTEN(Y,INT(X(Y))+K)=INTEN(Y,INT(X(Y))+(K-1))-A3DYDX
04m0001                               	where:
04m0001                               	FRACT(X)        =fractional part of X
04m0001                               	INT(X)          =integer part of X
04m0001                               	X(Y)            =X(growing left to right) position as a function of
04m0001                               	                        Y(growing top to bottom)
04m0001                               	INTEN(Y,X)      =intensity as a function of position
04m0001                               	DXDY            =slope of X vs. Y
04m0001                               	A3DYDX          =three times the absolute value of the slope of Y vs. X
04m0001                               	
04m0001                               	The compromise color/grey level coding is as follows:
04m0001                               	
04m0001                               	per word:       0       1       2       3       4       5       6       7
04m0001                               	per pixel:
04m0001                               	        0       sync    black   black   black   black   black   black   black
04m0001                               	        1       sync    W 1     W 1     W 1     W 1     W 1     W 1     W 1
04m0001                               	        2       sync    W 2     W 2     W 2     W 2     W 2     W 2     W 2
04m0001                               	        3       sync    W 3     W 3     W 3     W 3     W 3     W 3     W 3
04m0001                               	        4       sync    W 4     R 3     Y 3     G 3     B 3     M 3     W 4
04m0001                               	        5       sync    W 5     R 3     Y 3     G 3     B 3     M 3     W 5
04m0001                               	        6       sync    W 6     R 3     Y 3     G 3     B 3     M 3     W 6
04m0001                               	        7       sync    W 7     R 3     Y 3     G 3     B 3     M 3     W 7
04m0001                               	
04m0001                               	B/W objects are clipped to intensity level 3. Colored objects are always
04m0001                               	either intensity 0 (blank) or intensity 4. This will make the overlapping
04m0001                               	of a colored object over one B/W object always come out colored and of the
04m0001                               	correct intensity.
04m0001                               	
04m0001                               	Note that two overlapping colored objects will cancel. Also note that a
04m0001                               	colored object overlapping two B/W objects which already overlap will not
04m0001                               	come out correctly colored. Finally, it is still only possible to have
04m0001                               	one color per word, i.e. two differently colored objects in the same word
04m0001                               	will overwrite eachother.
04m0001                               	
04m0001                               	
04m0001                               	This code will take interrupts correctly, but not map faults, since it is
04m0001                               	in general impossible to save all ones state so that one can restart.
04m0001                               	Specifically, there is no provision currently for saving the micro PC
04m0001                               	from which you faulted.
04m0001                               	
04m0001                               	To get around this failing, it is necessary to "touch" (i.e., reference)
04m0001                               	each page that the display list might require. This has an unplesant
04m0001                               	interaction with the scheduler in Tenex, which will frequently not allow
04m0001                               	the page touching loop to terminate (it has to get all the pages mapped
04m0001                               	before it can let the code run). To get around this, the code turns off the
04m0001                               	real time clock before touching and turns it back on after touching so that
04m0001                               	the code can interrupt as usual. This prevents scheduling due to interrupts
04m0001                               	from the real time clock during page validation cycles (map operations
04m0001                               	where the physical memory is actually there, but the map is invalid, usually
04m0001                               	due to map CONOs.)
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

04m0001                               	\
04m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

05m0001                               	;Note that VIDTAB (the dispatch table) must appear before VIDIN
05m0001                               	;and VIDOUT due to forward referencing problems.
05m0001                               	
05m0001       0	        %VIDFOO = 0
05m0001                               	
05m0001                               	VIDTAB:         ;dispatch table used by both VIDIN and VIDOUT.
05m0001                               	.REPEAT 16.
05m0001 06226 240144430571000440000000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       1	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06227 240144430571000440010000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       2	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06230 240144430571000440020000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       3	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06231 240144430571000440030000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       4	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06232 240144430571000440040000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       5	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06233 240144430571000440050000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       6	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06234 240144430571000440060000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       7	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06235 240144430571000440070000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       10	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06236 240144430571000440100000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       11	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06237 240144430571000440110000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       12	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06240 240144430571000440120000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       13	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06241 240144430571000440130000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       14	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06242 240144430571000440140000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       15	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06243 240144430571000440150000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       16	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06244 240144430571000440160000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       17	        %VIDFOO = %VIDFOO + 1
05m0001                               	]05m0001 06245 240144430571000440170000	MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       20	        %VIDFOO = %VIDFOO + 1
05m0001                               	]       ;i/o sub sel = ac. input data and hold for memory write.
05m0001                               	
05m0001 06246 640700014171014620000000	VIDIN:  D[CONST (VIDTAB / 100)] ROT[6] DEST[Q] NORM$
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

05m0001                               	                ;form high order 6 bits of table dispatch.
05m0001 06247 640700014175000260000000	        D[CONST (VIDTAB \ 100)] ALU[DORQ] DEST[Q] NORM$
05m0001                               	                ;or in low order 6 bits of table dispatch.
05m0001 06250 440540034435032043400000	        D[IR] ROT[13.] MASK[4] ALU[D+Q] SDISP START-IN C600$
05m0001                               	                ;add ac field and dispatch. start input.
05m0001                               	
05m0001 06251 640702204571000440000000	VIDOUT: D[MEM] DEST[IOD] NORM$
05m0001                               	                ;put contents effective address into iod output register.
05m0001 06252 640700014171014620000000	        D[CONST (VIDTAB / 100)] ROT[6] DEST[Q] NORM$
05m0001                               	                ;form high order 6 bits of table dispatch.
05m0001 06253 640700014175000260000000	        D[CONST (VIDTAB \ 100)] ALU[DORQ] DEST[Q] NORM$
05m0001                               	                ;or in low order 6 bits of table dispatch.
05m0001 06254 440540034435032043600000	        D[IR] ROT[13.] MASK[4] ALU[D+Q] SDISP START-OUT C600$
05m0001                               	                ;add ac field and dispatch. start output.
05m0001                               	
05m0001                               	VIDCOM:         ;common completion.
05m0001 06255 451140034571020440002026	        D[IR] ROT[8]    COND[OBUS<0] JUMP[MAIN] C600$
05m0001                               	                ;if VIDOUT, done. jump main.
05m0001 06256 662104000571000440002032	        STRT-WRT MEMST$OND[-MA-AC] LBJUMP[MSMAIN] NORM ]
05m0001                               	                ;if VIDIN, write as in movem.
05m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

06m0001                               	;Main A-MEM:
06m0001       1	        INTEN,,FRACT    = 1     ;For storage of vector display word
06m0001       7	        POG,,POGB       = 7     ;Left by DPYINI
06m0001                               	
06m0001                               	.REPEAT XUCODE [
06m0001                               	        .USE[XLIST
06m0001                               	 LIST ];If 8K u-mem present, put video code there.
06m0001                               	]
06m0001                               	;This macro saves the address given as its argument so that returns
06m0001                               	;from interrupts can resume operation there. Jumps to VIDINT, which
06m0001                               	;saves AMEM, then goes to MAIN.
06m0001                               	
06m0001                               	;WARNING! WARNING !WARNING
06m0001                               	;THIS PIECE-OF-SHIT ASSEMBLER WON'T ACCEPT COMPOUND MACRO ARGUMENTS.
06m0001                               	;I.E., YOU MUST EVALUATE ARGUMENTS BEFORE INVOKING A MACRO.
06m0001                               	
06m0001                               	;ALSO, IF YOU CHANGE THE LENGTH OF THIS MACRO, REMEMBER TO ALTER THE
06m0001                               	;JUMP[. + 9]'S IN VIDRGT AND VIDLFT.
06m0001                               	
06m0001                               	.DEFINE VIDSAV[06m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

07m0001                               	;DPYINI
07m0001                               	;Save the POG block pointer for use by DPYOUT.
07m0001 10353 640701614571000040000000	VIDDPI: D[CONST 4] DEST[DEV-ADR] NORM $
07m0001                               	                ;DEV-ADR=INTERRUPT
07m0001 10354 640702214571000003600000	        D[CONST 0] DEST[IOD] START-OUT NORM $
07m0001                               	                ;TURN OFF INTERRUPTS (SO WE DON'T GO TO THE SCHEDULER)
07m0001 10355 240700000571000440060000	        MAPF[6] C800 $
07m0001                               	                ;BIT 35 = ON/OFF
07m0001 10356 640701614571000360000000	        D[CONST 36] DEST[DEV-ADR] NORM $
07m0001                               	                ;DEV-ADR=36
07m0001 10357 640701634571000223000000	        D[IR] MASK[18.] DEST[POG,,POGB] DEST-A-MEM NORM $
07m0001                               	                ;POG,,POGB=0,,E
07m0001                               	
07m0001                               	;Zero all lengths.
07m0001 10360 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
07m0001                               	                ;Q=POGB.
07m0001 10361 640704400615000440000000	        ALU[0] DEST[HOLD] NORM $
07m0001                               	                ;HOLD=0
07m0001 10362 640724014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
07m0001                               	                ;MA=POGB+56.    write (0) 
07m0001 10363 640746214571000170030000	        MAPF[NORM-WRT] DEST[FIXMAC-MAPF-WRT] D[CONST 15.] LLOAD NORM $
07m0001                               	                ;Touch          Loop 16 times
07m0001 10364 640720000555000440000000	VIDIN1: ALU[Q] DEST[MA] NORM $
07m0001                               	                ;MA=Q           read
07m0001 10365 640706200017000440030000	        MAPF[NORM-WRT] ALU[Q+1] DEST[Q FIXMAC-MAPF-WRT] CYLEN[FIXM] $
07m0001                               	                ;Q=Q+1          touch
07m0001 10366 640710004571006250000000	        D[MEM] ROT[3] MASK[21.] DEST[AR] NORM $
07m0001                               	                ;AR=BACKGROUND,LENGTH,,BEGINING LSH 3 MASK 21 (LENGTH=0)
07m0001 10367 640704200571102440000000	        D[AR] ROT[36. - 3] DEST[MEMSTO] NORM $
07m0001                               	                ;HOLD=BACKGROUND,0,,BEGINING    write
07m0001                               	
07m0001                               	;Initialize the remaining length counter for this piece of glass.
07m0001 10370 640710004531000220000000	        D[MEM] MASK[18.] ALU[D-1] DEST[AR] NORM $
07m0001                               	                ;AR=BEGINING POG-1
07m0001 10371 640720000531000440000000	        D[AR] ALU[D-1] DEST[MA] NORM $
07m0001                               	                ;MA=BEGINING -2  read max length
07m0001 10372 640700000571000440020000	        MAPF[NORM-RD] NORM $
07m0001                               	                ;WAIT
07m0001 10373 640704404571000440000000	        D[MEM] DEST[HOLD] NORM $
07m0001                               	                ;HOLD=MAX LENGTH        Sigh. HOLD and MEM really are different
07m0001 10374 640724000571000440000000	        D[AR] DEST[MA] STRT-WRT NORM $
07m0001                               	                ;MA=BEGINING-1  write remaining length
07m0001 10375 640246200571000440030364	        MAPF[NORM-WRT] DEST[FIXMAC-MAPF-WRT] LOOP[VIDIN1] CYLEN[FIXM] $
07m0001                               	                ;touch and loop
07m0001                               	
07m0001                               	;Turn interrupts back on.
07m0001 10376 640701614571000040000000	        D[CONST 4] DEST[DEV-ADR] NORM $
07m0001                               	                ;DEV-ADR=INTERRUPT
07m0001 10377 640702214571000013600000	        D[CONST 1] DEST[IOD] START-OUT NORM $
07m0001                               	                ;TURN ON INTERRUPTS
07m0001 10400 240700000571000440060000	        MAPF[6] C800 $
07m0001                               	                ;BIT 35 = ON/OFF
07m0001 10401 640701614571000360000000	        D[CONST 36] DEST[DEV-ADR] NORM $
07m0001                               	                ;DEV-ADR=36
07m0001                               	
07m0001                               	;Clear screen.
07m0001                               	        D[CONST 44] ROT[30.] DEST[IOD] START-OUT 
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

07m0001 10402 656142214571074443600000	                COND[HALF] JUMP[VIDNTR] NORM $
07m0001                               	                ;IOD=440000,,000000     Check HALF
07m0001 10403 240700014171014070120000	VIDHER: MAPF[12] D[CONST 7] ROT[6] DEST[Q] C800 $
07m0001                               	                ;VLDCTR (overwrite)     Q=7*64 (past vert. sync)
07m0001 10404 640710014571006360000000	        D[CONST 30.] ROT[3] DEST[AR] NORM $
07m0001                               	                ;AR=240. (major loops)
07m0001 10405 640740014571000710000000	VIDIN2: D[CONST 57.] LLOAD NORM $
07m0001                               	                ;Loop 58. times
07m0001 10406 640700014035000060000000	        D[CONST 6] ALU[Q+D] DEST[Q] NORM $
07m0001                               	                ;Q=Q+6 (past horiz. sync)
07m0001 10407 240702200555000443600000	VIDIN3: ALU[Q] DEST[IOD] START-OUT C800 $
07m0001                               	                ;IOD=Q
07m0001 10410 240700000571000440020000	        MAPF[2] C800 $
07m0001                               	                ;VLDADR
07m0001 10411 240702214571102073600000	        D[CONST 7] ROT[33.] DEST[IOD] START-OUT C800 $
07m0001                               	                ;IOD=700000,,000000
07m0001 10412 240700000571000443410000	        MAPF[1] START-IN C800 $
07m0001                               	                ;VLDDAT (blank)
07m0001 10413 240700000571000440070000	        MAPF[7]  C800 $
07m0001                               	                ;VWEVID
07m0001 10414 240700000571000440000000	        C800 $
07m0001                               	                ;WAIT
07m0001 10415 240702214435034013600000	        D[CONST 1] ROT[14.] ALU[Q+D] DEST[IOD] START-OUT C800 $
07m0001                               	                ;IOD=Q+1 FIELD
07m0001 10416 240700000571000440020000	        MAPF[2] C800 $
07m0001                               	                ;VLDADR
07m0001 10417 240702214571102073600000	        D[CONST 7] ROT[33.] DEST[IOD] START-OUT C800 $
07m0001                               	                ;IOD=700000,,000000
07m0001 10420 240700000571000443410000	        MAPF[1] START-IN C800 $
07m0001                               	                ;VLDDAT (blank)
07m0001                               	        MAPF[7] ALU[Q+1] DEST[Q]
07m0001 10421 241140000017000440070000	                COND[INTRPT] JUMP[VIDNTI] C800 $
07m0001                               	                ;VWEVID         Q=Q+1   If interrupt, save state
07m0001 10422 240240000571000440000407	VIDIN4: LOOP[VIDIN3] C800 $
07m0001                               	                ;loop
07m0001                               	        D[AR] ALU[D-1] DEST[AR]
07m0001 10423 470150000531000440000405	                COND[-OBUS=0] JUMP[VIDIN2] C600 $
07m0001                               	                ;AR=AR-1        if 0, done.
07m0001                               	
07m0001                               	;Done.
07m0001 10424 640141600615000442200350	        ALU[0] DEST[DEV-ADR] SPEC[CLR-HALF] JUMP[GOMAIN] NORM $
07m0001                               	                ;Reset device address, clear HALF
07m0001                               	
07m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

08m0001                               	;Interrupt init
08m0001 10425 640704400555000440000000	VIDNTI: ALU[Q] DEST[HOLD] NORM $
08m0001                               	                ;HOLD=Q
08m0001 10426 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
08m0001                               	                ;Q=POGB
08m0001 10427 640724014435014010000000	        D[CONST 1] ROT[6] ALU[Q+D] DEST[MA] STRT-WRT NORM $
08m0001                               	                ;MA=POGB+64.    write old Q
08m0001 10430 640706200571000440030000	        MAPF[NORM-WRT] DEST[FIXMAC-MAPF-WRT] CYLEN[FIXM] $
08m0001                               	                ;TOUCH
08m0001 10431 640704400571000440000000	        D[AR] DEST[HOLD] NORM $
08m0001                               	                ;HOLD=AR
08m0001 10432 640724014437014010000000	        D[CONST 1] ROT[6] ALU[D+Q+1] DEST[MA] STRT-WRT NORM $
08m0001                               	                ;MA=POGB+65.    write old AR
08m0001 10433 640706200571000440030000	        MAPF[NORM-WRT] DEST[FIXMAC-MAPF-WRT] CYLEN[FIXM] $
08m0001                               	                ;TOUCH
08m0001 10434 640700014171076010000000	        D[CONST 1] ROT[35. - 4] DEST[Q] NORM $
08m0001                               	                ;Q=BIT 4 ON
08m0001 10435 640704620531000440000000	        D[PC] ALU[D-1] DEST[PC] NORM $
08m0001                               	                ;PC=PC-1
08m0001 10436 640705420575000440000000	        D[PC] ALU[DORQ] DEST[CRYOV] NORM $
08m0001                               	                ;Set HALF flag
08m0001 10437 640141600615000440000350	        ALU[0] DEST[DEV-ADR] JUMP[GOMAIN] NORM $
08m0001                               	                ;Reset dev and disp to intrpt
08m0001                               	
08m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

09m0001                               	;Return from init interupt.
09m0001 10440 240700074171000220120000	VIDNTR: MAPF[12] D[10 + POG,,POGB] MASK[18.] DEST[Q] C800 $
09m0001                               	                ;VLDCTR         Q=POGB
09m0001 10441 640720014437014010000000	        D[CONST 1] ROT[6] ALU[D+Q+1] DEST[MA] NORM $
09m0001                               	                ;MA=POGB+65.    read old AR
09m0001                               	        MAPF[NORM-RD] D[CONST 30.] ROT[3] DEST[Q FIXMAC-MAPF-RD]
09m0001 10442 640706014171006360020000	                CYLEN[FIXM] $
09m0001                               	                ;TOUCH          Q=240.
09m0001                               	        D[MEM] MASK[18.] ALU[Q-D]
09m0001 10443 451140004477000220000403	                COND[OBUS<0] JUMP[VIDHER] C600 $
09m0001                               	                ;Check for half word error (i.e. HALF left from another inst)
09m0001 10444 640710004571000220000000	        D[MEM] MASK[18.] DEST[AR] NORM $
09m0001                               	                ;Restore AR
09m0001 10445 240700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] C800 $
09m0001                               	                ;Q=POGB
09m0001 10446 640720014435014010000000	        D[CONST 1] ROT[6] ALU[Q+D] DEST[MA] NORM $
09m0001                               	                ;MA=POGB+64.    read old Q
09m0001 10447 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
09m0001                               	                ;TOUCH
09m0001                               	        D[MEM] MASK[6] DEST[Q]
09m0001 10450 530140004171000060000000	                COND[-OBUS=0] JUMP[VIDNR1] C550 $
09m0001                               	                ;Old Q mod 6.
09m0001 10451 640700014171014010000000	        D[CONST 1] ROT[6] DEST[Q] NORM $
09m0001                               	                ;If Q=0, Q=64.
09m0001 10452 640740014537014010000000	VIDNR1: D[CONST 1] ROT[6] ALU[D-Q] LLOAD NORM $
09m0001                               	                ;Count=remaining till end of line
09m0001 10453 640140004171000440000422	        D[MEM] DEST[Q] JUMP[VIDIN4] NORM $
09m0001                               	                ;Restore Q and resume from interrupt
09m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

10m0001                               	;DPYOUT (DPYADD) main loop
10m0001 10454 640700014171076010000000	VIDDPA: D[CONST 1] ROT[35. - 4] DEST[Q] NORM $
10m0001                               	                ;Q=BIT 4 ON
10m0001 10455 640705420575000440000000	        D[PC] ALU[DORQ] DEST[CRYOV] NORM $
10m0001                               	                ;SET HALF FLAG
10m0001                               	
10m0001                               	;FooVision device address (also AMEM block)
10m0001 10456 640701614571000040000000	VIDDPO: D[CONST 4] DEST[DEV-ADR] NORM $
10m0001                               	                ;DEV-ADR=INTERRUPT
10m0001 10457 640702214571000003600000	        D[CONST 0] DEST[IOD] START-OUT NORM $
10m0001                               	                ;TURN OFF INTERRUPTS (SO WE DON'T GO TO THE SCHEDULER)
10m0001 10460 240700000571000440060000	        MAPF[6] C800 $
10m0001                               	                ;BIT 35 = ON/OFF
10m0001 10461 640701614571000360000000	        D[CONST 36] DEST[DEV-ADR] NORM $
10m0001                               	                ;DEV-ADR=36
10m0001                               	
10m0001                               	;Save AC=POG in AMEM
10m0001 10462 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10463 640710034571032040000000	        D[IR] ROT[13.] MASK[4] DEST[AR] NORM $
10m0001                               	                ;AR=POG=AC
10m0001 10464 640701600575044443000000	        D[AR] ROT[18.] ALU[DORQ] DEST[POG,,POGB] DEST-A-MEM NORM $
10m0001                               	                ;POG,,POGB=AC,,POGB
10m0001                               	
10m0001                               	;"Touch" the first and last words of the POG block, so we don't
10m0001                               	;have to worry about map faulting on them later.
10m0001 10465 640720074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q MA] NORM $
10m0001                               	                ;Q,MA=POGB
10m0001 10466 640706200571000440030000	        MAPF[NORM-WRT] DEST[FIXMAC-MAPF-WRT] CYLEN[FIXM] $
10m0001                               	                ;TOUCH FIRST WORD
10m0001 10467 640710014531006110000000	        D[CONST 11] ROT[3] ALU[D-1] DEST[AR] NORM $
10m0001                               	                ;AR=71.
10m0001 10470 640720000435000440000000	        D[AR] ALU[D+Q] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+71.
10m0001 10471 640706200571000440030000	        MAPF[NORM-WRT] DEST[FIXMAC-MAPF-WRT] CYLEN[FIXM] $
10m0001                               	                ;TOUCH LAST WORD
10m0001                               	
10m0001                               	;Touch E. If left half E (=length of display list)=0, don't bother to
10m0001                               	;touch display list.
10m0001 10472 640720034571000220000000	        D[IR] MASK[18.] DEST[MA] NORM $
10m0001                               	                ;MA=E
10m0001 10473 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH
10m0001 10474 640710004571000220000000	        D[MEM] MASK[18.] DEST[AR] NORM $
10m0001                               	                ;AR=BEGINING
10m0001 10475 510140004571000000200000	        D[MEM] SPEC[LEFT] COND[OBUS=0] JUMP[VIDTDE] C550 $
10m0001                               	                ;If LENGTH=0, don't touch (but do continue)
10m0001                               	
10m0001                               	;Touch the display list. Start with the first word, touch every
10m0001                               	;512.th word until run off end. Then touch last word.
10m0001 10476 640720000171000440000000	VIDTDL: D[AR] DEST[Q MA] NORM $
10m0001                               	                ;Q,MA=AR (initially begining of display list)
10m0001                               	        MAPF[NORM-RD] D[CONST 1] ROT[9.] ALU[Q+D]
10m0001 10477 640716014035022010020000	                DEST[AR Q FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;AR,Q=AR+1 PAGE         touch (post inc)
10m0001 10500 640720034571000220000000	        D[IR] MASK[18.] DEST[MA] NORM $
10m0001                               	                ;MA=E
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

10m0001 10501 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;WAIT
10m0001 10502 640700004077000220000000	        D[MEM] MASK[18.] ALU[Q-D] DEST[Q] NORM $
10m0001                               	                ;Q=AR-BEGINING
10m0001                               	        D[MEM] ROT[18.] MASK[18.] ALU[D-Q-1] DEST[Q]
10m0001 10503 471140004135044220000476	                COND[-OBUS<0] JUMP[VIDTDL] C600 $
10m0001                               	                ;Q=LENGTH-(AR-BEGINING)-1       if<0 done
10m0001 10504 640720000435000440000000	        D[AR] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=BEGINING+LENGTH-1
10m0001 10505 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH LAST PAGE
10m0001                               	
10m0001                               	;Touch the POG buffer for this POG. Same as for display list.
10m0001                               	;(POGn-2)=POG maximum length
10m0001                               	;(POGn-1)=POG words left
10m0001 10506 640700074171000220000000	VIDTDE: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10507 640720074435044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+POG    read begining pog buffer
10m0001 10510 640700000571000440020000	        MAPF[NORM-RD] NORM $
10m0001                               	                ;wait
10m0001 10511 640710004171000220000000	        D[MEM] MASK[18.] DEST[Q AR] NORM $
10m0001                               	                ;AR,Q=0,,BEGINING POG BUFFER
10m0001 10512 640720014477000020000000	        D[CONST 2] ALU[Q-D] DEST[MA] NORM $
10m0001                               	                ;MA=POGN-2      read maximum length
10m0001 10513 640706200571000440030000	        MAPF[NORM-WRT] DEST[FIXMAC-MAPF-WRT] CYLEN[FIXM] $
10m0001                               	                ;TOUCH -2nd word
10m0001 10514 640710004575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[AR] NORM $
10m0001                               	                ;AR=MAXIMUM LENGTH,,BEGINING POG
10m0001 10515 640700200571000443000000	        D[AR] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
10m0001                               	                ;INTEN,,FRACT=MAXIMUM LENGTH,,BEGINING POG
10m0001 10516 640720000171000440000000	VIDTNL: D[AR] DEST[Q MA] NORM $
10m0001                               	                ;Q,MA=AR
10m0001                               	        MAPF[NORM-WRT] D[CONST 1] ROT[9.] ALU[Q+D]
10m0001 10517 640706214035022010030000	                DEST[Q FIXMAC-MAPF-WRT] CYLEN[FIXM] $
10m0001                               	                ;AR,Q=AR+1 PAGE         touch (post inc)
10m0001 10520 640710014477066010000000	        D[CONST 1] ROT[18. + 9.] ALU[Q-D] DEST[AR] NORM $
10m0001                               	                ;AR=AR+(-1000,,1000)
10m0001 10521 640700000171000000200000	        D[AR] SPEC[LEFT] DEST[Q] NORM $
10m0001                               	                ;Q=REMAINING LENGTH,,0
10m0001                               	        D[CONST 1] ROT[18.] ALU[Q-D]
10m0001 10522 471140014477044010000516	                COND[-OBUS<0] JUMP[VIDTNL] C600 $
10m0001                               	                ;If LENGTH LEQ 0, done
10m0001 10523 640700044131044170000000	        D[10 + INTEN,,FRACT] ROT[18.] MASK[15.] ALU[D-1] DEST[Q] NORM $
10m0001                               	                ;Q=LENGTH-1
10m0001 10524 640720044435000220000000	        D[10 + INTEN,,FRACT] MASK[18.] ALU[D+Q] DEST[MA] NORM $
10m0001                               	                ;MA=BEGINING+LENGTH-1
10m0001 10525 640706200571000440030000	        MAPF[NORM-WRT] DEST[FIXMAC-MAPF-WRT] CYLEN[FIXM] $
10m0001                               	                ;TOUCH LAST WORD
10m0001                               	
10m0001                               	;Touch all 7 fonts. Same as above.
10m0001                               	VIDTNE:
10m0001 10526 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10527 640710014435000600000000	        D[CONST 48.] ALU[Q+D] DEST[AR] NORM $
10m0001                               	                ;AR=POGB+48
10m0001 10530 640740014571000060000000	        D[CONST 6] LLOAD NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

10m0001                               	                ;LOOP 7 TIMES
10m0001 10531 640730000433000440000000	VIDTFL: D[AR] ALU[D+1] DEST[MA AR] NORM $
10m0001                               	                ;MA,AR=AR+1
10m0001 10532 640700000571000440000000	        NORM $
10m0001                               	                ;WAIT
10m0001 10533 640720004171000220000000	        D[MEM] MASK[18.] DEST[MA Q] NORM $
10m0001                               	                ;MA,Q=FONT 1
10m0001 10534 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH PAGE
10m0001                               	.REPEAT 3
10m0001 10535 640720014035022010000000	D[CONST 1] ROT[9.] ALU[Q+D] DEST[MA Q] NORM $
10m0001                               	                ;MA,Q=Q+1 PAGE
10m0001 10536 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH PAGE
10m0001                               	]10m0001 10537 640720014035022010000000	D[CONST 1] ROT[9.] ALU[Q+D] DEST[MA Q] NORM $
10m0001                               	                ;MA,Q=Q+1 PAGE
10m0001 10540 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH PAGE
10m0001                               	]10m0001 10541 640720014035022010000000	D[CONST 1] ROT[9.] ALU[Q+D] DEST[MA Q] NORM $
10m0001                               	                ;MA,Q=Q+1 PAGE
10m0001 10542 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH PAGE
10m0001 10543 640700014131022010000000	]       D[CONST 1] ROT[9.] ALU[D-1] DEST[Q] NORM $
10m0001                               	                ;Q=1 PAGE - 1 WORD
10m0001 10544 640720024435000440000000	        D[MA] ALU[D+Q] DEST[MA] NORM $
10m0001                               	                ;MA=LAST WORD OF FONT
10m0001 10545 640246000571000440020531	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] LOOP[VIDTFL] CYLEN[FIXM] $
10m0001                               	                ;TOUCH PAGE     LOOP
10m0001                               	
10m0001                               	;Turn interrupts back on.
10m0001 10546 640701614571000040000000	        D[CONST 4] DEST[DEV-ADR] NORM $
10m0001                               	                ;DEV-ADR=INTERRUPT
10m0001 10547 640702214571000013600000	        D[CONST 1] DEST[IOD] START-OUT NORM $
10m0001                               	                ;TURN ON INTERRUPTS
10m0001 10550 240700000571000440060000	        MAPF[6] C800 $
10m0001                               	                ;BIT 35 = ON/OFF
10m0001 10551 640701614571000360000000	        D[CONST 36] DEST[DEV-ADR] NORM $
10m0001                               	                ;DEV-ADR=36
10m0001                               	
10m0001                               	;If length rememaining not 0, return from interrupt.
10m0001 10552 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10553 640720014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+56.    read LENGTH REMAINING
10m0001 10554 640700000571000440020000	        MAPF[NORM-RD] NORM $
10m0001                               	                ;WAIT
10m0001 10555 530140004571000440000000	        D[MEM] COND[-OBUS=0] JUMP[VIDRET] C550 $
10m0001                               	                ;If LENGTH REMAINING NEQ 0, return from interrupt
10m0001                               	
10m0001                               	;Check HALF flag to see if DPYADD.
10m0001 10556 676140000571000440000000	        COND[-HALF] JUMP[VIDMHL] NORM $
10m0001                               	                ;If HALF, DPYADD
10m0001                               	
10m0001                               	;Form the display list and POG buffer pointers.
10m0001 10557 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

10m0001                               	                ;Q=POGB
10m0001 10560 640720074435044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+POG    read LENGTH,,BEGINING
10m0001 10561 640700000571000440020000	        MAPF[NORM-RD] NORM $
10m0001                               	                ;WAIT
10m0001 10562 640700004171000220000000	        D[MEM] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=0,,BEGINING
10m0001 10563 640700004035044170000000	        D[MEM] ROT[18.] MASK[15.] ALU[Q+D] DEST[Q] NORM $
10m0001                               	                ;Q=0,,BEGINING+LENGTH
10m0001 10564 640720034571000440000000	        D[IR] DEST[MA] NORM $
10m0001                               	                ;MA=E   read BEGINING
10m0001 10565 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;WAIT
10m0001 10566 640704404575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[HOLD] NORM $
10m0001                               	                ;HOLD=DISP BEGINING,,POG BEGINING+LENGTH
10m0001 10567 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10570 640724014435000710000000	        D[CONST 57.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=POGB+57.    write DISP BEGINING,,POG BEGINING
10m0001 10571 640700000571000440020000	        MAPF[NORM-RD] NORM $
10m0001                               	                ;WAIT
10m0001                               	
10m0001                               	;Get length of display list and load control register
10m0001                               	;with code for addition. Add to length in POG.
10m0001 10572 640720034571000220000000	        D[IR] MASK[18.] DEST[MA] NORM $
10m0001                               	                ;MA=E           read LENGTH
10m0001                               	        MAPF[NORM-RD] D[10 + POG,,POGB] MASK[18.] DEST[Q FIXMAC-MAPF-RD]
10m0001 10573 640706074171000220020000	                CYLEN[FIXM] $
10m0001                               	                ;Q=POGB
10m0001 10574 640714404571044170000000	        D[MEM] ROT[18.] MASK[15.] DEST[AR HOLD] NORM $
10m0001                               	                ;AR,HOLD=LENGTH
10m0001 10575 640724014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=POGB+56.    write LENGTH
10m0001 10576 640702214571074643620000	        MAPF[NORM-RD] D[CONST 64] ROT[30.] DEST[IOD] START-OUT NORM $
10m0001                               	                ;IOD=640000,,000000
10m0001 10577 640720074435044220120000	        MAPF[12] D[10 + POG,,POGB] ROT[18.] MASK[18.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;VLDCTR (add)   MA=POGB+POG     read BACK,LENGTH,,BEGIN
10m0001 10600 640700000171044440020000	        MAPF[NORM-RD] D[AR] ROT[18.] DEST[Q] NORM $
10m0001                               	                ;Q=LENGTH,,0
10m0001 10601 640144204435000440000000	        D[MEM] ALU[D+Q] DEST[MEMSTO] JUMP[VIDMLL] NORM $
10m0001                               	                ;HOLD=BACK,LENGTH+LENGTH,,BEGIN write
10m0001                               	
10m0001                               	;This is the outermost loop. It is gone through twice, once with
10m0001                               	;first-half-done off subtracting the previous POG buffer, then with
10m0001                               	;first-half-done on adding the display list and copying into the
10m0001                               	;POG buffer.
10m0001                               	
10m0001                               	;Form the display list and POG buffer pointers.
10m0001 10602 640700074171000220000000	VIDMHL: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10603 640720074435044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+POG    read LENGTH,,BEGINING
10m0001 10604 640700000571000440020000	        MAPF[NORM-RD] NORM $
10m0001                               	                ;WAIT
10m0001 10605 640710004171000220000000	        D[MEM] MASK[18.] DEST[Q AR] NORM $
10m0001                               	                ;AR Q=0,,BEGINING
10m0001 10606 640720034571000440000000	        D[IR] DEST[MA] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

10m0001                               	                ;MA=E   read BEGINING
10m0001 10607 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;WAIT
10m0001 10610 640704404575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[HOLD] NORM $
10m0001                               	                ;HOLD=DISP BEGINING,,POG BEGINING
10m0001 10611 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10612 640724014435000710000000	        D[CONST 57.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=POGB+57.    write DISP BEGINING,,POG BEGINING
10m0001                               	
10m0001                               	;Initialize the remaining length counter for this piece of glass.
10m0001 10613 640700000171000440020000	        MAPF[NORM-RD] D[AR] DEST[Q] NORM $
10m0001                               	                ;Q=BEGINING POG
10m0001 10614 640720014477000020000000	        D[CONST 2] ALU[Q-D] DEST[MA] NORM $
10m0001                               	                ;MA=BEGINING -2  read max length
10m0001 10615 640700000571000440020000	        MAPF[NORM-RD] NORM $
10m0001                               	                ;WAIT
10m0001 10616 640704404571000440000000	        D[MEM] DEST[HOLD] NORM $
10m0001                               	                ;HOLD=MAX LENGTH        Sigh. HOLD and MEM really are different
10m0001 10617 640724000531000440000000	        D[AR] ALU[D-1] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=BEGINING-1  write remaining length
10m0001                               	
10m0001                               	;Check for first half done.
10m0001 10620 656140000571000440020000	        MAPF[NORM-RD] COND[HALF] JUMP[VIDMHH] NORM $
10m0001                               	                ;IF -HALF:
10m0001                               	
10m0001                               	;If first half not done, get length of POG buffer and load the control
10m0001                               	;register with the code for subtraction.
10m0001 10621 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10622 640720074435044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+POG    read LENGTH,,BEGINING
10m0001 10623 640700000571000440020000	        MAPF[NORM-RD] NORM $
10m0001                               	                ;WAIT
10m0001 10624 640704404571044170000000	        D[MEM] ROT[18.] MASK[15.] DEST[HOLD] NORM $
10m0001                               	                ;HOLD=LENGTH
10m0001 10625 640724014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=POGB+56.    write LENGTH
10m0001 10626 640702214571074743620000	        MAPF[NORM-RD] D[CONST 74] ROT[30.] DEST[IOD] START-OUT NORM $
10m0001                               	                ;IOD=740000,,000000
10m0001 10627 240140000571000440120000	        MAPF[12] JUMP[VIDMLL] C800 $
10m0001                               	                ;VLDCTR (subtract)
10m0001                               	
10m0001                               	;If first half done, get length of display list and load control register
10m0001                               	;with code for addition. Put length in POG.
10m0001 10630 640720034571000220000000	VIDMHH: D[IR] MASK[18.] DEST[MA] NORM $
10m0001                               	                ;MA=E           read LENGTH
10m0001                               	        MAPF[NORM-RD] D[10 + POG,,POGB] MASK[18.] DEST[Q FIXMAC-MAPF-RD]
10m0001 10631 640706074171000220020000	                CYLEN[FIXM] $
10m0001                               	                ;Q=POGB
10m0001 10632 640714404571044170000000	        D[MEM] ROT[18.] MASK[15.] DEST[AR HOLD] NORM $
10m0001                               	                ;AR,HOLD=LENGTH
10m0001 10633 640724014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=POGB+56.    write LENGTH
10m0001 10634 640702214571074643620000	        MAPF[NORM-RD] D[CONST 64] ROT[30.] DEST[IOD] START-OUT NORM $
10m0001                               	                ;IOD=640000,,000000
10m0001 10635 640720074435044040120000	        MAPF[12] D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[Q+D] DEST[MA] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

10m0001                               	                ;VLDCTR (add)   MA=POGB+POG     read BACK,LENGTH,,BEGIN
10m0001 10636 640700000171044440020000	        MAPF[NORM-RD] D[AR] ROT[18.] DEST[Q] NORM $
10m0001                               	                ;Q=LENGTH,,0
10m0001 10637 640710004571006250000000	        D[MEM] ROT[3] MASK[21.] DEST[AR] NORM $
10m0001                               	                ;AR=BACK,LENGTH,,BEGIN LSH3 ROT21 (LENGTH=0)
10m0001 10640 000704200575102440000000	        D[AR] ROT[36. - 3] ALU[DORQ] DEST[MEMSTO] $
10m0001                               	                ;HOLD=BACK,LENGTH,,BEGIN        write
10m0001                               	
10m0001                               	;This is the display list or POG buffer loop. It extracts words and
10m0001                               	;determines whether they are characters or vectors.
10m0001                               	
10m0001                               	;If length = 0, go to end of half-done loop.
10m0001 10641 640700074171000220000000	VIDMLL: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10642 640720014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+56.    read LENGTH
10m0001 10643 640700000571000440020000	        MAPF[NORM-RD] NORM $
10m0001                               	                ;NORM
10m0001 10644 510140004571000220000000	        D[MEM] MASK[18.] COND[OBUS=0] JUMP[VIDMHE] C550 $
10m0001                               	                ;If LENGTH=0, end
10m0001                               	
10m0001                               	;Check and update remaining length.
10m0001 10645 640720074435044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+POG    read length,,BEGINING
10m0001 10646 640700000571000440020000	        MAPF[NORM-RD] NORM $
10m0001                               	                ;WAIT
10m0001 10647 640720004531000220000000	        D[MEM] MASK[18.] ALU[D-1] DEST[MA] NORM $
10m0001                               	                ;MA=BEGINING-1  read length remaining
10m0001 10650 640700000571000440020000	        MAPF[NORM-RD] NORM $
10m0001                               	                ;WAIT
10m0001                               	        D[MEM] ALU[D-1] DEST[MEMSTO]
10m0001 10651 451144204531000440000000	                COND[OBUS<0] JUMP[VIDMHE] C600 $
10m0001                               	                ;HOLD=REMAINING LENGTH-1        write remaining length
10m0001                               	                ;If length remaining-1<0, end this half(add or sub)
10m0001                               	
10m0001                               	;Read pointers and chech half.
10m0001 10652 640720014435000710000000	        D[CONST 57.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+57.    read DISP LIST PTR,,POG BUFF PTR
10m0001 10653 656140000571000440020000	        MAPF[NORM-RD] COND[HALF] JUMP[VIDMLH] NORM $
10m0001                               	                ;If -HALF
10m0001                               	
10m0001                               	;If first half not done, read from POG buffer.
10m0001 10654 640720004571000220000000	        D[MEM] MASK[18.] DEST[MA] NORM $
10m0001                               	                ;MA=POG BUFF PTR        read POG WORD
10m0001 10655 640140000571000440020000	        MAPF[NORM-RD] JUMP[VIDMLE] NORM $
10m0001                               	                ;WAIT
10m0001                               	
10m0001                               	;If first half done, read from display list and copy into POG buffer.
10m0001 10656 640720004571044220000000	VIDMLH: D[MEM] ROT[18.] MASK[18.] DEST[MA] NORM $
10m0001                               	                ;MA=DISP LIST PTR       read DISPLAY WORD
10m0001 10657 640700000571000440020000	        MAPF[NORM-RD] NORM $
10m0001                               	                ;WAIT
10m0001 10660 640710004571000440000000	        D[MEM] DEST[AR] NORM $
10m0001                               	                ;AR=DISPLAY WORD
10m0001 10661 640720014435000710000000	        D[CONST 57.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+57.    read DISP LIST PTR,,POG BUFF PTR
10m0001 10662 640700000571000440020000	        MAPF[NORM-RD] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

10m0001                               	                ;WAIT
10m0001 10663 640700004171000220000000	        D[MEM] MASK[18.] DEST[Q]  NORM $
10m0001                               	                ;Q=POG BUFF PTR
10m0001 10664 640704400571000440000000	        D[AR] DEST[HOLD] NORM $
10m0001                               	                ;HOLD=DISPLAY WORD
10m0001 10665 640724000555000440000000	        ALU[Q] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=POG BUFF PTR        write DISPLAY WORD
10m0001 10666 640704400571000440020000	        MAPF[NORM-RD] D[AR] DEST[HOLD] NORM $
10m0001                               	                ;HOLD=DISPLAY WORD
10m0001                               	;;;Please note the above kludge. This is necessary because HOLD
10m0001                               	;;;forgets its data whenever MA changes, even on a write (contrary
10m0001                               	;;;to the explanation in the microcode manual).
10m0001                               	
10m0001                               	;Decode opcode of display word (character or vector).
10m0001 10667 640700204571000443000000	VIDMLE: D[MEM] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
10m0001                               	                ;INTEN,,FRACT=NEXT WORD
10m0001                               	        D[MEM] MASK[1]
10m0001 10670 530140004571000010000000	                COND[-OBUS=0] JUMP[VIDCHI] C550 $
10m0001                               	                ;If bit 35=1, character
10m0001 10671 640700004171000040000000	        D[MEM] MASK[4] DEST[Q] NORM $
10m0001                               	                ;Q=4 LSB'S
10m0001                               	        D[CONST 06] ALU[Q#D]
10m0001 10672 510140014735000060000000	                COND[OBUS=0] JUMP[VIDVCI] C550 $
10m0001                               	                ;If 4 lsb's=0110, vector
10m0001                               	
10m0001                               	;Decrement length, and increment pointers.
10m0001 10673 640700074171000220000000	VIDDON: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10674 640720014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+56.    read LENGTH
10m0001 10675 640700000571000440020000	        MAPF[NORM-RD] NORM $
10m0001                               	                ;WAIT
10m0001 10676 640704204531000440000000	        D[MEM] ALU[D-1] DEST[MEMSTO] NORM $
10m0001                               	                ;HOLD=LENGTH-1  write LENGTH
10m0001 10677 640720014435000710000000	        D[CONST 57.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+57.    read DISP LIST PTR,,POG BUFF PTR
10m0001 10700 640700014171001000020000	        MAPF[NORM-RD] D[CONST 1,,1] DEST[Q] NORM $
10m0001                               	                ;Q=1,,1
10m0001 10701 640144204435000440000641	        D[MEM] ALU[D+Q] DEST[MEMSTO] JUMP[VIDMLL] NORM $
10m0001                               	                ;HOLD=DISP LIST PTR,,POG BUFF PTR + 1,,1        write
10m0001                               	
10m0001                               	;Zero length remaining (so won't try to recover from interrupt).
10m0001 10702 640704400615000440000000	VIDMHE: ALU[0] DEST[HOLD] NORM $
10m0001                               	                ;HOLD=0
10m0001 10703 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10704 640724014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=POGB+56.    write LENGTH REMAINING
10m0001                               	
10m0001                               	;If first half done, terminate. If not, set HALF flag and loop
10m0001 10705 656140000571000440020000	        MAPF[NORM-RD] COND[HALF] JUMP[VIDEND] NORM $
10m0001                               	                ;If HALF, end
10m0001 10706 640700014171076010000000	        D[CONST 1] ROT[35. - 4] DEST[Q] NORM $
10m0001                               	                ;Q=bit 4 on
10m0001 10707 640145420575000440000602	        D[PC] ALU[DORQ] DEST[CRYOV] JUMP[VIDMHL] NORM $
10m0001                               	                ;Set HALF flag and loop
10m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

11m0001                               	;Interrupt and End
11m0001                               	;Save AMEM and go to MAIN to take interrupt.
11m0001 10710 640144620531000440020000	VIDINT: MAPF[NORM-RD] D[PC] ALU[D-1] DEST[PC] JUMP[VIDSAM] NORM $
11m0001                               	                ;PC=PC-1
11m0001 10711 640700000571000442200000	VIDEND: SPEC[CLR-HALF] NORM $
11m0001                               	                ;Clear HALF
11m0001 10712 640700074171000220000000	VIDSAM: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
11m0001                               	                ;Q=POGB
11m0001 10713 640700014035014010000000	        D[CONST 1] ROT[6] ALU[Q+D] DEST[Q] NORM $
11m0001                               	                ;Q=POGB+64.
11m0001       0	        %VIDFOO = 0
11m0001                               	.REPEAT 8.
11m0001 10714 640704440571000440020000	MAPF[NORM-RD] D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10715 640724014435000000000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       1	        %VIDFOO = %VIDFOO + 1
11m0001                               	]11m0001 10716 640704444571000440020000	MAPF[NORM-RD] D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10717 640724014435000010000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       2	        %VIDFOO = %VIDFOO + 1
11m0001                               	]11m0001 10720 640704450571000440020000	MAPF[NORM-RD] D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10721 640724014435000020000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       3	        %VIDFOO = %VIDFOO + 1
11m0001                               	]11m0001 10722 640704454571000440020000	MAPF[NORM-RD] D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10723 640724014435000030000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       4	        %VIDFOO = %VIDFOO + 1
11m0001                               	]11m0001 10724 640704460571000440020000	MAPF[NORM-RD] D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10725 640724014435000040000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       5	        %VIDFOO = %VIDFOO + 1
11m0001                               	]11m0001 10726 640704464571000440020000	MAPF[NORM-RD] D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10727 640724014435000050000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       6	        %VIDFOO = %VIDFOO + 1
11m0001                               	]11m0001 10730 640704470571000440020000	MAPF[NORM-RD] D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10731 640724014435000060000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       7	        %VIDFOO = %VIDFOO + 1
11m0001                               	]11m0001 10732 640704474571000440020000	MAPF[NORM-RD] D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10733 640724014435000070000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       10	        %VIDFOO = %VIDFOO + 1
11m0001 10734 640141600615000440020350	]       MAPF[NORM-RD] ALU[0] DEST[DEV-ADR] JUMP[GOMAIN] NORM $
11m0001                               	                ;Reset device address, dispatch to interrupt or next instr.
11m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

12m0001                               	;Recovery
12m0001                               	;Restore AMEM.
12m0001 10735 640700074171000220000000	VIDRET: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
12m0001                               	                ;Q=POGB
12m0001 10736 640700014035014010000000	        D[CONST 1] ROT[6] ALU[Q+D] DEST[Q] NORM $
12m0001                               	                ;Q=POGB+64.
12m0001       0	        %VIDFOO = 0
12m0001                               	.REPEAT 8.
12m0001 10737 640720014435000000000000	D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10740 640700000571000440020000	        MAPF[NORM-RD] NORM $
12m0001                               	                ;WAIT
12m0001 10741 640700004571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       1	        %VIDFOO = %VIDFOO + 1
12m0001                               	]12m0001 10742 640720014435000010000000	D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10743 640700000571000440020000	        MAPF[NORM-RD] NORM $
12m0001                               	                ;WAIT
12m0001 10744 640700204571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       2	        %VIDFOO = %VIDFOO + 1
12m0001                               	]12m0001 10745 640720014435000020000000	D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10746 640700000571000440020000	        MAPF[NORM-RD] NORM $
12m0001                               	                ;WAIT
12m0001 10747 640700404571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       3	        %VIDFOO = %VIDFOO + 1
12m0001                               	]12m0001 10750 640720014435000030000000	D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10751 640700000571000440020000	        MAPF[NORM-RD] NORM $
12m0001                               	                ;WAIT
12m0001 10752 640700604571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       4	        %VIDFOO = %VIDFOO + 1
12m0001                               	]12m0001 10753 640720014435000040000000	D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10754 640700000571000440020000	        MAPF[NORM-RD] NORM $
12m0001                               	                ;WAIT
12m0001 10755 640701004571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       5	        %VIDFOO = %VIDFOO + 1
12m0001                               	]12m0001 10756 640720014435000050000000	D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10757 640700000571000440020000	        MAPF[NORM-RD] NORM $
12m0001                               	                ;WAIT
12m0001 10760 640701204571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       6	        %VIDFOO = %VIDFOO + 1
12m0001                               	]12m0001 10761 640720014435000060000000	D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10762 640700000571000440020000	        MAPF[NORM-RD] NORM $
12m0001                               	                ;WAIT
12m0001 10763 640701404571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       7	        %VIDFOO = %VIDFOO + 1
12m0001                               	]12m0001 10764 640720014435000070000000	D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10765 640700000571000440020000	        MAPF[NORM-RD] NORM $
12m0001                               	                ;WAIT
12m0001 10766 640701604571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       10	        %VIDFOO = %VIDFOO + 1
12m0001                               	]
12m0001                               	;Check for first half done.
12m0001                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q]
12m0001 10767 656140074171000220000000	                COND[HALF] JUMP[VIDRIH] NORM $
12m0001                               	                ;Q=POGB         If -HALF
12m0001                               	
12m0001                               	;If first half not done, default color = modified last color
12m0001                               	;and xor mask = -1.
12m0001 10770 640720014435000600000000	        D[CONST 48.] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+48.    read LAST COLOR
12m0001 10771 640710014531102010020000	        MAPF[NORM-RD] D[CONST 1] ROT[33.] ALU[D-1] DEST[AR] NORM $
12m0001                               	                ;AR=077777,,777777
12m0001 10772 640700004171000440000000	        D[MEM] DEST[Q] NORM $
12m0001                               	                ;Q=LAST COLOR,,LAST FONT
12m0001                               	        D[MEM] ROT[2] MASK[2]
12m0001 10773 510140004571004020000000	                COND[OBUS=0] JUMP[VIDRIM] C550 $
12m0001                               	                ;If color>1
12m0001 10774 640700014175102070000000	        D[CONST 7] ROT[33.] ALU[DORQ] DEST[Q] NORM $
12m0001                               	                ;Q=COLOR 7 (WHITE FROM COLOR)
12m0001                               	VIDRIM:
12m0001                               	.REPEAT VIC2 [
12m0001                               	VIC2
12m0001                               	.REPEAT 1 - VIC2 [
12m0001 10775 640704400575000440000000	        D[AR] ALU[DORQ] DEST[HOLD] NORM $
12m0001                               	                ;MEM=MODIFIED LAST COLOR 77777,,777777
12m0001 10776 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
12m0001                               	                ;Q=POGB
12m0001 10777 640724014435000730000000	        D[CONST 59.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
12m0001                               	                ;MA=POGB+59     write <COLOR MASK,,MASK>
12m0001 11000 640140000571000440020000	        MAPF[NORM-RD] JUMP[VIDRIE] NORM $
12m0001                               	                ;WAIT
12m0001                               	]1-VIC2
12m0001                               	
12m0001                               	;If first half done, default color = last color, and xor mask = 0.
12m0001 11001 640720014435000600000000	VIDRIH: D[CONST 48.] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+48.    read LAST COLOR
12m0001 11002 640710014531102010020000	        MAPF[NORM-RD] D[CONST 1] ROT[33.] ALU[D-1] DEST[AR] NORM $
12m0001                               	                ;AR=077777,,777777
12m0001 11003 640700004171000440000000	        D[MEM] DEST[Q] NORM $
12m0001                               	                ;Q=LAST COLOR,,LAST FONT
12m0001                               	.REPEAT VIC2 [
12m0001                               	VIC2
12m0001                               	.REPEAT 1 - VIC2 [
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

12m0001 11004 640704400675000440000000	        D[AR] ALU[-D&Q] DEST[HOLD] NORM $
12m0001                               	                ;MEM=LAST COLOR 00000,,000000
12m0001 11005 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
12m0001                               	                ;Q=POGB
12m0001 11006 640724014435000730000000	        D[CONST 59.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
12m0001                               	                ;MA=POGB+59     write <COLOR MASK,,MASK>
12m0001 11007 640700000571000440020000	        MAPF[NORM-RD] NORM $
12m0001                               	                ;WAIT
12m0001                               	]1-VIC2
12m0001                               	
12m0001                               	;Dispatch to saved microcode address to resume from interrupt.
12m0001 11010 240700074171000220100000	VIDRIE: MAPF[10] D[10 + POG,,POGB] MASK[18.] DEST[Q] C800 $
12m0001                               	                ;VLDCOL         Q=POGB
12m0001 11011 640720014435000720000000	        D[CONST 58.] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+58.    read SAVE ADR
12m0001 11012 640700000571000440020000	        MAPF[NORM-RD] NORM $
12m0001                               	                ;WAIT
12m0001 11013 540540004571000440000000	        D[MEM] SDISP C500 $
12m0001                               	                ;Dispatch on SAVE ADR
12m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

13m0001                               	;Character A-MEM:
13m0001                               	
13m0001       0	        WORD,,PIXEL3    = 0
13m0001       1	        YSIZE-1,,FONTPTR = 1
13m0001       2	        XMAX,,XMIN      = 2
13m0001       3	        YMAX,,YMIN      = 3
13m0001       4	        COLOR           = 4
13m0001       5	        XSIZE3,,XSIZE   = 5
13m0001       6	        LINE,,BYTEPTR   = 6
13m0001       7	        POG,,POGB       = 7
13m0001                               	
13m0001                               	;Note: The zeroth word of the font contains HEIGHT,,WIDTH
13m0001                               	;for that font.
13m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

14m0001                               	;Character body
14m0001                               	
14m0001                               	;Get initial word and 3*pixel.
14m0001 11014 640700074171000220000000	VIDCHI: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=POGB
14m0001 11015 640720014435000750000000	        D[CONST 61.] ALU[Q+D] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+61.    read X0,,X1
14m0001 11016 640700014131014050020000	        MAPF[NORM-RD] D[CONST 5] ROT[6] ALU[D-1] DEST[Q] NORM $
14m0001                               	                ;Q=319.
14m0001 11017 640710004435000220000000	        D[MEM] MASK[18.] ALU[D+Q] DEST[AR] NORM $
14m0001                               	                ;AR=X1+319. (0=left hand edge)
14m0001 11020 640710000171000220000000	        D[AR] MASK[18.] DEST[Q AR] NORM $
14m0001                               	                ;Q,AR=X1+319. (eliminate carry across halfwords)
14m0001 11021 640050000435002440000000	        D[AR] ROT[1] ALU[D+Q] DEST[AR] PUSHJ[VIDD33] NORM $
14m0001                               	                ;AR=3*(corrected X coordinate), divide by 33
14m0001 11022 640700004575044443000000	        D[MEM] ROT[18.] ALU[DORQ] DEST[WORD,,PIXEL3] DEST-A-MEM NORM $
14m0001                               	                ;WORD,,PIXEL3=QUOTIENT,,REMAINDER
14m0001                               	
14m0001                               	;Initialize line and byte pointers.
14m0001 11023 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+62.    read Y0,,Y1
14m0001 11024 640700014171060040020000	        MAPF[NORM-RD] D[CONST 4] ROT[18. + 6] DEST[Q] NORM $
14m0001                               	                ;Q=256,,0
14m0001 11025 640700004035044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[D+Q] DEST[Q] NORM $
14m0001                               	                ;Q=Y1+256.,,0
14m0001 11026 640701414575000073000000	        D[CONST 7] ALU[DORQ] DEST[LINE,,BYTEPTR] DEST-A-MEM NORM $
14m0001                               	                ;LINE,,BYTEPTR=Y1+256.,,7
14m0001                               	
14m0001                               	;Form XMAX,,XMIN
14m0001 11027 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=POGB
14m0001 11030 640700074035044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[Q+D] DEST[Q] NORM $
14m0001                               	                ;Q=POGB+POG
14m0001 11031 640720014435000200000000	        D[CONST 16.] ALU[Q+D] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+16.+POG        read XMAX,,XMIN
14m0001 11032 640700000571000440020000	        MAPF[NORM-RD] NORM $
14m0001                               	                ;WAIT
14m0001 11033 640700404571000443000000	        D[MEM] DEST[XMAX,,XMIN] DEST-A-MEM NORM $
14m0001                               	                ;XMAX,,XMIN
14m0001                               	
14m0001                               	;Form YMAX,,YMIN
14m0001 11034 640700024171000440000000	        D[MA] DEST[Q] NORM $
14m0001                               	                ;Q=MA
14m0001 11035 640720014435000200000000	        D[CONST 16.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+32.+POG        read YMAX,,YMIN
14m0001 11036 640700000571000440020000	        MAPF[NORM-RD] NORM $
14m0001                               	                ;WAIT
14m0001 11037 640700604571000443000000	        D[MEM] DEST[YMAX,,YMIN] DEST-A-MEM NORM $
14m0001                               	                ;YMAX,,YMIN
14m0001                               	
14m0001                               	;Test HALF flag.
14m0001                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q]
14m0001 11040 656140074171000220000000	                COND[HALF] JUMP[VIDCHH] NORM $
14m0001                               	                ;Q=POGB         if -HALF
14m0001                               	
14m0001                               	;If not HALF, subtract old image with color=last color.
14m0001 11041 640720014435000600000000	        D[CONST 48.] ALU[D+Q] DEST[MA] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

14m0001                               	                ;MA=POGB+48.    read LAST COLOR
14m0001 11042 640710014531102010020000	        MAPF[NORM-RD] D[CONST 1] ROT[33.] ALU[D-1] DEST[AR] NORM $
14m0001                               	                ;AR=077777,,777777
14m0001 11043 640700004171000440000000	        D[MEM] DEST[Q] NORM $
14m0001                               	                ;Q=LAST COLOR,,LAST FONT
14m0001                               	        D[MEM] ROT[2] MASK[2]
14m0001 11044 510140004571004020000000	                COND[OBUS=0] JUMP[VIDCHM] C550 $
14m0001                               	                ;If color>1
14m0001 11045 640700014175102070000000	        D[CONST 7] ROT[33.] ALU[DORQ] DEST[Q] NORM $
14m0001                               	                ;Q=COLOR 7 (WHITE FROM COLOR)
14m0001                               	VIDCHM:
14m0001 11046 640141000575000443000000	        D[AR] ALU[DORQ] DEST[COLOR] DEST-A-MEM JUMP[VIDSCL] NORM $
14m0001                               	                ;COLOR=modified last color 77777,,777777
14m0001                               	
14m0001                               	;If HALF, add new image with last color.
14m0001 11047 640720014435000600000000	VIDCHH: D[CONST 48.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+48.    read LAST COLOR
14m0001 11050 640710014531102010020000	        MAPF[NORM-RD] D[CONST 1] ROT[33.] ALU[D-1] DEST[AR] NORM $
14m0001                               	                ;AR=077777,,777777
14m0001 11051 640700004171000440000000	        D[MEM] DEST[Q] NORM $
14m0001                               	                ;Q=LAST COLOR,,LAST FONT
14m0001 11052 640701000675000443000000	        D[AR] ALU[-D&Q] DEST[COLOR] DEST-A-MEM NORM $
14m0001                               	                ;COLOR=LAST COLOR 00000,,000000
14m0001                               	
14m0001                               	;This is the character scanning loop.
14m0001                               	
14m0001                               	;Set up font pointer. Flush nulls.
14m0001 11053 640700074171000220000000	VIDSCL: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=POGB
14m0001 11054 640720014435000710000000	        D[CONST 57.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+57.    read DISPLAY BUFFER POINTER
14m0001 11055 656140000571000440020000	        MAPF[NORM-RD] COND[HALF] JUMP[VIDSC1] NORM $
14m0001                               	                ;If -HALF
14m0001 11056 640160004571000220000000	        D[MEM] MASK[18.] DEST[MA] JUMP[VIDSC2] NORM $
14m0001                               	                ;MA=POG PTR     read
14m0001 11057 640720004571044220000000	VIDSC1: D[MEM] ROT[18.] MASK[18.] DEST[MA] NORM $
14m0001                               	                ;MA=DISP PTR    read
14m0001 11060 640701270571000440020000	VIDSC2: MAPF[NORM-RD] D[10 + LINE,,BYTEPTR] DEST[ROTR] NORM $
14m0001                               	                ;ROTR=LINE,,BYTEPTR
14m0001                               	        D[MEM] ROT[R] MASK[7] DEST[AR]
14m0001 11061 510150004571200070000000	                COND[OBUS=0] JUMP[VIDSCN] C550 $
14m0001                               	                ;AR=ASCII       if 0, next character
14m0001 11062 640720014435000600000000	        D[CONST 48.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+48.    read LAST FONT
14m0001 11063 640700000171010440020000	        MAPF[NORM-RD] D[AR] ROT[4] DEST[Q] NORM $
14m0001                               	                ;Q=0,,ASCII*16.
14m0001 11064 640700204435000223000000	        D[MEM] MASK[18.] ALU[D+Q] DEST[YSIZE-1,,FONTPTR] DEST-A-MEM NORM $
14m0001                               	                ;YSIZE-1,,FONTPTR=0,,LAST FONT+ASCII*16.
14m0001                               	
14m0001                               	;Get width and 3*width of character.
14m0001 11065 640700044171000220000000	        D[10 + YSIZE-1,,FONTPTR] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=FONTPTR
14m0001 11066 640720014435000170000000	        D[CONST 15.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=FONTPTR+15.         read YSIZE,,XSIZE
14m0001 11067 640700000571000440020000	        MAPF[NORM-RD] NORM $
14m0001                               	                ;WAIT
14m0001 11070 640710004171000220000000	        D[MEM] MASK[18.] DEST[AR Q] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

14m0001                               	                ;AR,Q=0,,XSIZE
14m0001 11071 640700000035044440000000	        D[AR] ROT[18.] ALU[D+Q] DEST[Q] NORM $
14m0001                               	                ;Q=XSIZE,,XSIZE
14m0001 11072 640701200435046443000000	        D[AR] ROT[18. + 1] ALU[D+Q] DEST[XSIZE3,,XSIZE] DEST-A-MEM NORM $
14m0001                               	                ;XSIZE3,,XSIZE=XSIZE*3,,XSIZE
14m0001                               	
14m0001                               	;Initialize YSIZE-1
14m0001 11073 640700004171000000200000	        D[MEM] SPEC[LEFT] DEST[Q] NORM $
14m0001                               	                ;Q=YSIZE,,0
14m0001 11074 640700044175000440000000	        D[10 + YSIZE-1,,FONTPTR] ALU[DORQ] DEST[Q] NORM $
14m0001                               	                ;Q=YSIZE,,FONTPTR
14m0001 11075 640700214477044013000000	        D[CONST 1] ROT[18.] ALU[Q-D] DEST[YSIZE-1,,FONTPTR] DEST-A-MEM NORM $
14m0001                               	                ;YSIZE-1,,FONTPTR
14m0001                               	
14m0001                               	;Increment position one character width (right or down).
14m0001 11076 640710004171000000200000	        D[MEM] SPEC[LEFT] DEST[Q AR] NORM $
14m0001                               	                ;AR,Q=YSIZE,,0
14m0001                               	        D[MEM] ROT[18.] SPEC[LEFT] ALU[Q-D]
14m0001 11077 451140004477044000200000	                COND[OBUS<0] JUMP[VIDCCS] C600 $
14m0001                               	                ;If YSIZE-XSIZE<0, sideways
14m0001                               	
14m0001                               	;Update normal X0,,X1.
14m0001 11100 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=POGB
14m0001 11101 640720014435000750000000	        D[CONST 61.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+61.    read X0,,X1
14m0001 11102 640700000571000440020000	        MAPF[NORM-RD] NORM $
14m0001                               	                ;WAIT
14m0001 11103 640700004171000220000000	        D[MEM] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=0,,X1
14m0001 11104 640710064435000220000000	        D[10 + XSIZE3,,XSIZE] MASK[18.] ALU[D+Q] DEST[AR] NORM $
14m0001                               	                ;AR=0,,X1+XSIZE
14m0001 11105 640700004171044000200000	        D[MEM] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
14m0001                               	                ;Q=X1,,0
14m0001 11106 640704200575000220000000	        D[AR] MASK[18.] ALU[DORQ] DEST[MEMSTO] NORM $
14m0001                               	                ;HOLD=X1,,X1+XSIZE      write X0,,X1
14m0001                               	
14m0001                               	;Update normal Y0,,Y1.
14m0001 11107 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+62.    read Y0,,Y1
14m0001 11110 640700000571000440020000	        MAPF[NORM-RD] NORM $
14m0001                               	                ;WAIT
14m0001 11111 000700004171000220000000	        D[MEM] MASK[18.] DEST[Q] $
14m0001                               	                ;Q=0,,Y1
14m0001 11112 640144204575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] JUMP[VIDCCL] NORM $
14m0001                               	                ;HOLD=Y1,,Y1    write Y0,,Y1
14m0001                               	
14m0001                               	;Update sideways X0,,X1.
14m0001 11113 640700074171000220000000	VIDCCS: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=POGB
14m0001 11114 640720014435000750000000	        D[CONST 61.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+61.    read X0,,X1
14m0001 11115 640700000571000440020000	        MAPF[NORM-RD] NORM $
14m0001                               	                ;WAIT
14m0001 11116 000700004171000220000000	        D[MEM] MASK[18.] DEST[Q] $
14m0001                               	                ;Q=0,,X1
14m0001 11117 640704204575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

14m0001                               	                ;HOLD=X1,,X1    write X0,,X1
14m0001                               	
14m0001                               	;Update sidways Y0,,Y1.
14m0001 11120 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+62.    read Y0,,Y1
14m0001 11121 640700000571000440020000	        MAPF[NORM-RD] NORM $
14m0001                               	                ;WAIT
14m0001 11122 640700004171000220000000	        D[MEM] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=0,,Y1
14m0001 11123 640710000477044440000000	        D[AR] ROT[18.] ALU[Q-D] DEST[AR] NORM $
14m0001                               	                ;AR=0,,Y1-YSIZE
14m0001 11124 640700004171044000200000	        D[MEM] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
14m0001                               	                ;Q=Y1,,0
14m0001 11125 640704200575000220000000	        D[AR] MASK[18.] ALU[DORQ] DEST[MEMSTO] NORM $
14m0001                               	                ;HOLD=Y1,,Y1-YSIZE      write Y0,,Y1
14m0001                               	
14m0001                               	;Check X limits.
14m0001 11126 640720024531000440000000	VIDCCL: D[MA] ALU[D-1] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+61             read X0,,X1
14m0001 11127 640700000571000440020000	        MAPF[NORM-RD] NORM $
14m0001                               	                ;WAIT
14m0001 11130 640700004171000000200000	        D[MEM] SPEC[LEFT] DEST[Q] NORM $
14m0001                               	                ;Q=X0,,0
14m0001                               	        D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] ALU[Q-D]
14m0001 11131 451140050477044000200000	                COND[OBUS<0] JUMP[VIDCHE] C600 $
14m0001                               	                ;if X0,,0-XMIN,,0<0 skip
14m0001 11132 640700064035044000200000	        D[10 + XSIZE3,,XSIZE] ROT[18.] SPEC[LEFT] ALU[D+Q] DEST[Q] NORM $
14m0001                               	                ;Q=X0,,0+XSIZE,,0
14m0001                               	        D[10 + XMAX,,XMIN] SPEC[LEFT] ALU[D-Q]
14m0001 11133 451140050537000000200000	                COND[OBUS<0] JUMP[VIDCHE] C600 $
14m0001                               	                ;if XMAX,,0-(X0+XSIZE),,0<0 skip
14m0001                               	
14m0001                               	;Check Y limits.
14m0001 11134 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+62             read Y0,,Y1
14m0001 11135 640700000571000440020000	        MAPF[NORM-RD] NORM $
14m0001                               	                ;WAIT
14m0001 11136 640700004171000000200000	        D[MEM] SPEC[LEFT] DEST[Q] NORM $
14m0001                               	                ;Q=Y0,,0
14m0001                               	        D[10 + YMAX,,YMIN] ROT[18.] SPEC[LEFT] ALU[Q-D]
14m0001 11137 451140054477044000200000	                COND[OBUS<0] JUMP[VIDCHE] C600 $
14m0001                               	                ;if Y0,,0-YMIN,,0<0 skip
14m0001 11140 640700044035000000200000	        D[10 + YSIZE-1,,FONTPTR] SPEC[LEFT] ALU[D+Q] DEST[Q] NORM $
14m0001                               	                ;Q=Y0,,0+YSIZE-1,,0
14m0001 11141 640700014035044010000000	        D[CONST 1] ROT[18.] ALU[D+Q] DEST[Q] NORM $
14m0001                               	                ;Q=Y0,,0+YSIZE,,0
14m0001                               	        D[10 + YMAX,,YMIN] SPEC[LEFT] ALU[D-Q]
14m0001 11142 451140054537000000200000	                COND[OBUS<0] JUMP[VIDCHE] C600 $
14m0001                               	                ;if YMAX,,0-(Y0+YSIZE),,0<0 skip
14m0001                               	
14m0001                               	;This is the scan line loop for characters.
14m0001                               	
14m0001                               	;Put up first word of this line for this character.
14m0001 11143 640700044171000220000000	VIDCHL: D[10 + YSIZE-1,,FONTPTR] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=FONTPTR
14m0001 11144 640720044435044220000000	        D[10 + YSIZE-1,,FONTPTR] ROT[18.] MASK[18.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=FONTPTR+YSIZE-1     read DATA
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

14m0001 11145 640700014171000410020000	        MAPF[NORM-RD] D[CONST 33.] DEST[Q] NORM $
14m0001                               	                ;Q=33.
14m0001 11146 640701240477000220000000	        D[10 + WORD,,PIXEL3] MASK[18.] ALU[Q-D] DEST[ROTR] NORM $
14m0001                               	                ;ROTR=33.-PIXEL3
14m0001 11147 640701440477000220000000	        D[10 + WORD,,PIXEL3] MASK[18.] ALU[Q-D] DEST[MASKR] NORM $
14m0001                               	                ;MASKR=33.-PIXEL3
14m0001 11150 640044404571201000000000	        D[MEM] ROT[R] MASK[R] DEST[HOLD] PUSHJ[VIDPUT] NORM $
14m0001                               	                ;HOLD=DATA ROT (33.-PIXEL) MASK (33.-PIXEL)     do it
14m0001                               	
14m0001                               	;Determine if there is another word.
14m0001 11151 240700040171000220070000	        MAPF[7] D[10 + WORD,,PIXEL3] MASK[18.] DEST[Q] C800 $
14m0001                               	                ;Q=PIXEL3       VWEVID
14m0001 11152 640700064035044220000000	        D[10 + XSIZE3,,XSIZE] ROT[18.] MASK[18.] ALU[D+Q] DEST[Q] NORM $
14m0001                               	                ;Q=PIXEL3+XSIZE3
14m0001                               	        D[CONST 33.] ALU[D-Q]
14m0001 11153 471140014537000410000000	                COND[-OBUS<0] JUMP[VIDCHS] C600 $
14m0001                               	                ;If 33.-(PIXEL3+XSIZE3)<0
14m0001                               	
14m0001                               	;If there is a second word, put it up.
14m0001 11154 640700040171000440000000	        D[10 + WORD,,PIXEL3] DEST[Q] NORM $
14m0001                               	                ;Q=WORD,,PIXEL
14m0001 11155 640700014435044013000000	        D[CONST 1] ROT[18.] ALU[Q+D] DEST[WORD,,PIXEL3] DEST-A-MEM NORM $
14m0001                               	                ;Temporarally increment WORD
14m0001 11156 640720024571000440000000	        D[MA] DEST[MA] NORM $
14m0001                               	                ;Read line of data again. (Not enough state.)
14m0001 11157 640700014171000360000000	        D[CONST 30.] DEST[Q] NORM $
14m0001                               	                ;Q=30.
14m0001 11160 640701240477000220000000	        D[10 + WORD,,PIXEL3] MASK[18.] ALU[Q-D] DEST[ROTR] NORM $
14m0001                               	                ;ROTR=30.-PIXEL3
14m0001 11161 640710004571200410000000	        D[MEM] ROT[R] MASK[33.] DEST[AR] NORM $
14m0001                               	                ;AR=DATA ROT (30.-PIXEL3) MASK 33.
14m0001 11162 640700014171002410000000	        D[CONST 33.] ROT[1] DEST[Q] NORM $
14m0001                               	                ;Q=66.
14m0001 11163 640700040077000220000000	        D[10 + WORD,,PIXEL3] MASK[18.] ALU[Q-D] DEST[Q] NORM $
14m0001                               	                ;Q=66.-PIXEL3
14m0001 11164 640701464477044220000000	        D[10 + XSIZE3,,XSIZE] ROT[18.] MASK[18.] ALU[Q-D] DEST[MASKR] NORM $
14m0001                               	                ;MASKR=66.-PIXEL3-XSIZE3
14m0001 11165 640700000171000440000000	        D[AR] DEST[Q] NORM $
14m0001                               	                ;Q=DATA ROT(30.-PIXEL3) MASK(33.)
14m0001 11166 640044400675001000000000	        D[MASK R] ALU[-D&Q] DEST[HOLD] PUSHJ[VIDPUT] NORM $
14m0001                               	                ;HOLD=DATA ROT(30.-PIXEL3) MASK(66.-PIXEL3-XSIZE3)
14m0001 11167 640700040171000440070000	        MAPF[7] D[10 + WORD,,PIXEL3] DEST[Q] NORM $
14m0001                               	                ;Q=WORD,,PIXEL          VWEVID
14m0001 11170 640700014477044013000000	        D[CONST 1] ROT[18.] ALU[Q-D] DEST[WORD,,PIXEL3] DEST-A-MEM NORM $
14m0001                               	                ;Redecrement WORD
14m0001                               	
14m0001                               	;Check for last scan line of character (also interrupts).
14m0001 11171 240700044171000440070000	VIDCHS: MAPF[7] D[10 + YSIZE-1,,FONTPTR] DEST[Q] C800 $
14m0001                               	                ;Q=YSIZE-1,,FONTPTR     VWEVID
14m0001                               	        D[CONST 1] ROT[18.] ALU[Q-D] DEST[YSIZE-1,,FONTPTR] DEST-A-MEM
14m0001 11172 451140214477044013000000	                COND[OBUS<0] JUMP[VIDCHE] C600 $
14m0001                               	                ;If YSIZE-1<0, done
14m0001 11173 661140000571000440001143	        COND[-INTRPT] JUMP[VIDCHL] NORM $
14m0001                               	                ;If no interrupt, loop
14m0001                               	        VIDSAV[14m0001 11174 640700014171030010000000	D[CONST (VIDCHL / 10000)] ROT[12.] DEST[Q] NORM $
14m0001                               	                ;Q=high bit (SDISP loads all 16 bits)
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

14m0001 11175 640700014175014110000000	        D[CONST (77 & (VIDCHL / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
14m0001                               	                ;Q=next 6 ADR bits
14m0001 11176 640704414575000430000000	        D[CONST (VIDCHL \ 100)] ALU[QORD] DEST[HOLD] NORM $
14m0001                               	                ;Q=SAVE ADR
14m0001 11177 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=POGB
14m0001 11200 640164014435000720000710	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
14m0001                               	                ;MA=POGB+58     write SAVE ADR
14m0002                               	]               ;Interrupt
14m0002                               	
14m0002                               	;Increment position one character width (right or down).
14m0002 11201 640700044171000220000000	VIDCHE: D[10 + YSIZE-1,,FONTPTR] MASK[18.] DEST[Q] NORM $
14m0002                               	                ;Q=PONTPTR
14m0002 11202 640720014435000170000000	        D[CONST 15.] ALU[Q+D] DEST[MA] NORM $
14m0002                               	                ;MA=POGB+15.    read YSIZE,,XSIZE
14m0002 11203 640700000571000440020000	        MAPF[NORM-RD] NORM $
14m0002                               	                ;WAIT
14m0002 11204 640700004171000000200000	        D[MEM] SPEC[LEFT] DEST[Q] NORM $
14m0002                               	                ;Q=YSIZE,,0
14m0002                               	        D[MEM] ROT[18.] SPEC[LEFT] ALU[Q-D]
14m0002 11205 451140004477044000200000	                COND[OBUS<0] JUMP[VIDCE2] C600 $
14m0002                               	                ;If YSIZE-XSIZE<0, sideways
14m0002                               	
14m0002 11206 640700064171000000200000	        D[10 + XSIZE3,,XSIZE] SPEC[LEFT] DEST[Q] NORM $
14m0002                               	                ;Q=XSIZE3,,0
14m0002 11207 640700040035044000200000	        D[10 + WORD,,PIXEL3] ROT[18.] SPEC[LEFT] ALU[Q+D] DEST[Q] NORM $
14m0002                               	                ;Q=PIXEL3+XSIZE3,,0
14m0002                               	        D[CONST 33.] ROT[18.] ALU[Q-D]
14m0002 11210 451140014477044410000000	                COND[OBUS<0] JUMP[VIDCE1] C600 $
14m0002                               	                ;If PIXEL3+XSIZE3-33.<0 skip
14m0002 11211 640700014077044410000000	        D[CONST 33.] ROT[18.] ALU[Q-D] DEST[Q] NORM $
14m0002                               	                ;Q=PIXEL3+XSIZE3-33.,,0
14m0002 11212 640700000017000440000000	        ALU[Q+1] DEST[Q] NORM $
14m0002                               	                ;Q=PIXEL3+XSIZE3-33.,,1
14m0002 11213 640710000555000440000000	VIDCE1: ALU[Q] DEST[AR] NORM $
14m0002                               	                ;AR=NEW PIXEL3,,WORD OFFSET
14m0002 11214 640700040171000000200000	        D[10 + WORD,,PIXEL3] SPEC[LEFT] DEST[Q] NORM $
14m0002                               	                ;Q=WORD,,0
14m0002                               	        D[AR] ROT[18.] ALU[D+Q] DEST[WORD,,PIXEL3] DEST-A-MEM
14m0002 11215 640140000435044443000000	                JUMP[VIDSCN] NORM $
14m0002                               	                ;WORD,,PIXEL3=WORD+OFFSET,,NEW PIXEL3
14m0002                               	
14m0002 11216 640700070171000440000000	VIDCE2: D[10 + LINE,,BYTEPTR] DEST[Q] NORM $
14m0002                               	                ;Q=LINE,,BYTEPTR
14m0002 11217 640700004077000000200000	        D[MEM] SPEC[LEFT] ALU[Q-D] DEST[Q] NORM $
14m0002                               	                ;Q=LINE-YSIZE,,BYTEPTR
14m0002 11220 640701400555000443000000	        ALU[Q] DEST[LINE,,BYTEPTR] DEST-A-MEM NORM $
14m0002                               	                ;LINE-YSIZE,,BYTEPTR
14m0002                               	        
14m0002                               	
14m0002                               	;Increment byte pointer for next character.
14m0002 11221 640700070171000440000000	VIDSCN: D[10 + LINE,,BYTEPTR] DEST[Q] NORM $
14m0002                               	                ;Q=LINE,,BYTEPTR
14m0002 11222 640711414435000073000000	        D[CONST 7] ALU[Q+D] DEST[AR LINE,,BYTEPTR] DEST-A-MEM NORM $
14m0002                               	                ;AR,LINE,,BYTEPTR=LINE,,BYTEPTR+7
14m0002 11223 640700000171044000200000	        D[AR] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
14m0002                               	                ;Q=BYTEPTR+7,,0
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

14m0002                               	        D[CONST 36.] ROT[18.] ALU[D-Q]
14m0002 11224 471140014537044440001053	                COND[-OBUS<0] JUMP[VIDSCL] C600 $
14m0002                               	                ;If 36.,,0-BYTEPTR+7,,0<0
14m0002 11225 640140000571000440000673	        JUMP[VIDDON] NORM $
14m0002                               	                ;Done
14m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

15m0002                               	;Divide by 33. (Efficient till 2048./33.)
15m0002                               	
15m0002                               	;AR=DIVIDEND
15m0002                               	
15m0002 11226 640704400171076370000000	VIDD33: D[AR] ROT[36. - 5] MASK[36. - 5] DEST[Q HOLD] NORM $
15m0002                               	                ;Q,HOLD=QUOTIENT=AR/32.
15m0002 11227 640700004035012440000000	VID33L: D[MEM] ROT[5] ALU[D+Q] DEST[Q] NORM $
15m0002                               	                ;Q=33*QUOTIENT
15m0002                               	        D[AR] ALU[D-Q] DEST[Q]
15m0002 11230 471300000137000440000000	                COND[-OBUS<0] POPJ C600 $
15m0002                               	                ;Q=REMAINDER, if < 0
15m0002 11231 640144404131000440001227	        D[MEM] ALU[D-1] DEST[Q HOLD] JUMP[VID33L] NORM $
15m0002                               	                ;Q,HOLD=QUOTIENT-1      loop
15m0002                               	
15m0002                               	;MEM=QUOTIENT
15m0002                               	;Q=REMAINDER
15m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

16m0002                               	;Put up one word of video
16m0002                               	
16m0002                               	;MEM=DATA
16m0002                               	
16m0002 11232 640700070171044220000000	VIDPUT: D[10 + LINE,,BYTEPTR] ROT[18.] MASK[18.] DEST[Q] NORM $
16m0002                               	                ;Q=0,,LINE
16m0002 11233 640710044477044220000000	        D[10 + YSIZE-1,,FONTPTR] ROT[18.] MASK[18.] ALU[Q-D] DEST[AR] NORM $
16m0002                               	                ;AR=0,,LINE-(YSIZE-1)
16m0002 11234 640700000171012440000000	        D[AR] ROT[5] DEST[Q] NORM $
16m0002                               	                ;Q=0 LINE 00000
16m0002 11235 640700014275012010000000	        D[CONST 1] ROT[5] ALU[-D&Q] DEST[Q] NORM $
16m0002                               	                ;Q=0 LINE/2 000000
16m0002                               	        D[AR] ROT[36. - 1]
16m0002 11236 531140000571106440000000	                COND[-OBUS<0] JUMP[VIDPT1] C550 $
16m0002                               	                ;IF LSB[LINE]=1
16m0002 11237 640700014175034010000000	        D[CONST 1] ROT[14.] ALU[QORD] DEST[Q] NORM $
16m0002                               	                ;Q=ODD[LINE] LINE/2 000000
16m0002 11240 640700040175044060000000	VIDPT1: D[10 + WORD,,PIXEL3] ROT[18.] MASK[6] ALU[QORD] DEST[Q] NORM $
16m0002                               	                ;Q=ODD[LINE] LINE/2 WORD (=interlaced address)
16m0002                               	
16m0002 11241 640700014035014070000000	        D[CONST 7] ROT[6] ALU[Q+D] DEST[Q] NORM $
16m0002                               	                ;Q=ADR+7*64.
16m0002 11242 640702214435000063600000	        D[CONST 6] ALU[Q+D] DEST[IOD] START-OUT NORM $
16m0002                               	                ;IOD=ADR+7 lines, 6 words
16m0002                               	
16m0002 11243 240700004171000410020000	        MAPF[2] D[MEM] MASK[33.] DEST[Q] C800 $
16m0002                               	                ;VLDADR Q=DATA
16m0002                               	        D[10 + COLOR] ROT[2] MASK[2]
16m0002 11244 270040060571004020000000	                COND[-OBUS=0] PUSHJ[VIDCOL] C800 $
16m0002                               	                ;If bit(s) 0 or 1 of color on, "color" the word
16m0002 11245 240702260735000443600000	        D[10 + COLOR] ALU[D#Q] DEST[IOD] START-OUT C800 $
16m0002                               	                ;IOD=DATA XOR COLOR
16m0002 11246 240300000571000443410000	        MAPF[1] START-IN POPJ C800 $
16m0002                               	                ;VLDDAT (next line must have MAPF[7] ... C800)
16m0002                               	
16m0002                               	;Make the contents of Q be a colored data word.
16m0002                               	;If <2 make it 0, else make it 4.
16m0002 11247 640710000555000440000000	VIDCOL: ALU[Q] DEST[AR] NORM $
16m0002                               	                ;COPY Q
16m0002 11250 640700000175002440000000	        D[AR] ROT[1] ALU[DORQ] DEST[Q] NORM $
16m0002                               	                ;The 4 bit in each pixel is 1 if either the 4 or 2 bits were 1.
16m0002 11251 640700014275000330000000	        D[CONST 33] ALU[-D&Q] DEST[Q] NORM $
16m0002                               	                ;Zero the 2 and 1 bits.
16m0002 11252 640700014275014330000000	        D[CONST 33] ROT[6] ALU[-D&Q] DEST[Q] NORM $
16m0002                               	                ;Zero the 2 and 1 bits.
16m0002 11253 640700014275030330000000	        D[CONST 33] ROT[12.] ALU[-D&Q] DEST[Q] NORM $
16m0002                               	                ;Zero the 2 and 1 bits.
16m0002 11254 640700014275044330000000	        D[CONST 33] ROT[18.] ALU[-D&Q] DEST[Q] NORM $
16m0002                               	                ;Zero the 2 and 1 bits.
16m0002 11255 640700014275060330000000	        D[CONST 33] ROT[24.] ALU[-D&Q] DEST[Q] NORM $
16m0002                               	                ;Zero the 2 and 1 bits.
16m0002 11256 640300014275074730000000	        D[CONST 73] ROT[30.] ALU[-D&Q] DEST[Q] POPJ NORM $
16m0002                               	                ;Zero the 2 and 1 bits.
16m0002                               	
16m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

17m0002                               	;Vector A-MEM:
17m0002                               	
17m0002       0	        PIXEL,,FRACT    = 0
17m0002       1	        INTEN,,FRACT    = 1
17m0002       2	        XMAX,,XMIN      = 2
17m0002       3	        YMAX,,YMIN      = 3
17m0002       4	        DXDY,,FRACT     = 4
17m0002       5	        A3DYDX,,FRACT   = 5
17m0002       6	        OFFSET,,LINE    = 6
17m0002       7	        POG,,POGB       = 7
17m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

18m0002                               	;Paint line left
18m0002                               	.DEFINE VIDLFT[18m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

19m0002                               	;Paint line right
19m0002                               	.DEFINE VIDRGT[19m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

20m0002                               	;Vector Body
20m0002                               	;Extract X field from vector word (extending sign).
20m0002                               	;Shift right 1.
20m0002 11257 640710014531020010000000	VIDVCI: D[CONST 1] ROT[8.] ALU[D-1] DEST[AR] NORM $
20m0002                               	                ;AR=377
20m0002 11260 640700044171024120000000	        D[10 + INTEN,,FRACT] ROT[10.] MASK[10.] DEST[Q] NORM $
20m0002                               	                ;Q=X
20m0002                               	        D[CONST 1] ROT[9.] ALU[D&Q]
20m0002 11261 510140014635022010000000	                COND[OBUS=0] JUMP[VIDVC1] C550 $
20m0002                               	                ;IF SIGN=1
20m0002 11262 640700000175024440000000	        D[AR] ROT[10.] ALU[DORQ] DEST[Q] NORM $
20m0002                               	                ;Q=0,,776 X
20m0002 11263 640700400555000443000000	VIDVC1: ALU[Q] DEST[XMAX,,XMIN] DEST-A-MEM NORM $
20m0002                               	                ;XMAX,,XMIN=0,,X
20m0002                               	
20m0002                               	;Extract Y field from vector word (extending sign). Note the sign change.
20m0002 11264 640710044473052120000000	        D[10 + INTEN,,FRACT] ROT[21.] MASK[10.] ALU[0-D] DEST[AR] NORM $
20m0002                               	                ;Q=-Y
20m0002 11265 640700000171000120000000	        D[AR] MASK[10.] DEST[Q] NORM $
20m0002                               	                ;Q=-Y
20m0002                               	        D[CONST 1] ROT[9.] ALU[D&Q]
20m0002 11266 510140014635022010000000	                COND[OBUS=0] JUMP[VIDVC2] C550 $
20m0002                               	                ;IF SIGN=1
20m0002 11267 640710014531020010000000	        D[CONST 1] ROT[8.] ALU[D-1] DEST[AR] NORM $
20m0002                               	                ;AR=377
20m0002 11270 640700000175024440000000	        D[AR] ROT[10.] ALU[DORQ] DEST[Q] NORM $
20m0002                               	                ;Q=0,,776 Y
20m0002 11271 640700600555000443000000	VIDVC2: ALU[Q] DEST[YMAX,,YMIN] DEST-A-MEM NORM $
20m0002                               	                ;YMAX,,YMIN=0,,Y
20m0002                               	
20m0002                               	;Get default color (0=no change).
20m0002                               	        D[10 + INTEN,,FRACT] ROT[25.] MASK[3] DEST[AR]
20m0002 11272 510150044571062030000000	                COND[OBUS=0] JUMP[VIDVC3] C550 $
20m0002                               	                ;AR=BRT (color)         if=0, no change
20m0002 11273 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11274 640720014435000600000000	        D[CONST 48.] ALU[D+Q] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+48.    read LAST COLOR,,LAST FONT
20m0002 11275 640700000171102440020000	        MAPF[NORM-RD] D[AR] ROT[33.] DEST[Q] NORM $
20m0002                               	                ;Q=COLOR 00000,,000000
20m0002 11276 640704204575000220000000	        D[MEM] MASK[18.] ALU[DORQ] DEST[MEMSTO] NORM $
20m0002                               	                ;HOLD=COLOR 00000,,LAST FONT    write LAST COLOR,,LAST FONT
20m0002                               	
20m0002                               	;Get default font (0=no change).
20m0002                               	VIDVC3: D[10 + INTEN,,FRACT] ROT[28.] MASK[3]
20m0002 11277 510140044571070030000000	                COND[OBUS=0] JUMP[VIDVC4] C550 $
20m0002                               	                ;if SIZE(FONT)=0, no change
20m0002 11300 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11301 640720014035000600000000	        D[CONST 48.] ALU[D+Q] DEST[Q MA] NORM $
20m0002                               	                ;Q,MA=POGB+48   read LAST COLOR,,LAST FONT
20m0002 11302 640700000571000440020000	        MAPF[NORM-RD] NORM $
20m0002                               	                ;WAIT
20m0002 11303 640710004571000000200000	        D[MEM] SPEC[LEFT] DEST[AR] NORM $
20m0002                               	                ;AR=COLOR,,0
20m0002 11304 640720044435070030000000	        D[10 + INTEN,,FRACT] ROT[28.] MASK[3] ALU[D+Q] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+48.+SIZE
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

20m0002 11305 640700000171000440020000	        MAPF[NORM-RD] D[AR] DEST[Q] NORM $
20m0002                               	                ;Q=COLOR,,0
20m0002 11306 640704404575000220000000	        D[MEM] MASK[18.] ALU[DORQ] DEST[HOLD] NORM $
20m0002                               	                ;HOLD=COLOR,,FONT
20m0002 11307 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11310 640724014435000600000000	        D[CONST 48.] ALU[D+Q] DEST[MA] STRT-WRT NORM $
20m0002                               	                ;Q,MA=POGB+48   write LAST COLOR,,LAST FONT
20m0002                               	
20m0002                               	;Check relative.
20m0002                               	VIDVC4: MAPF[NORM-RD] D[10 + INTEN,,FRACT] ROT[29.]
20m0002 11311 511140044571072440020000	                COND[OBUS<0] JUMP[VIDVC5] C550 $
20m0002                               	                ;if relative
20m0002                               	
20m0002                               	;If relative, add previous X coordinate.
20m0002 11312 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11313 640720014435000750000000	        D[CONST 61.] ALU[D+Q] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+61.    read X0,,X1
20m0002 11314 640700050171000440020000	        MAPF[NORM-RD] D[10 + XMAX,,XMIN] DEST[Q] NORM $
20m0002                               	                ;Q=0,,X
20m0002 11315 640710004435000220000000	        D[MEM] MASK[18.] ALU[D+Q] DEST[AR] NORM $
20m0002                               	                ;AR=0,,X+X1
20m0002 11316 640700004171044000200000	        D[MEM] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=X1,,0
20m0002 11317 640704200575000220000000	        D[AR] MASK[18.] ALU[DORQ] DEST[MEMSTO] NORM $
20m0002                               	                ;HOLD=X1,,X+X1  write X0,,X1
20m0002                               	
20m0002                               	;If relative, add previous Y coordinate.
20m0002 11320 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+62.    read Y0,,Y1
20m0002 11321 640700054171000440020000	        MAPF[NORM-RD] D[10 + YMAX,,YMIN] DEST[Q] NORM $
20m0002                               	                ;Q=0,,Y
20m0002 11322 640710004435000220000000	        D[MEM] MASK[18.] ALU[D+Q] DEST[AR] NORM $
20m0002                               	                ;AR=0,,Y+Y1
20m0002 11323 640700004171044000200000	        D[MEM] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=Y1,,0
20m0002 11324 640144200575000220000000	        D[AR] MASK[18.] ALU[DORQ] DEST[MEMSTO] JUMP[VIDVC6] NORM $
20m0002                               	                ;HOLD=Y1,,Y+Y1  write Y0,,Y1
20m0002                               	
20m0002                               	;If absolute,just copy X
20m0002 11325 640700074171000220000000	VIDVC5: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11326 640720014435000750000000	        D[CONST 61.] ALU[D+Q] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+61.    read X0,,X1
20m0002 11327 640700050171000440020000	        MAPF[NORM-RD] D[10 + XMAX,,XMIN] DEST[Q] NORM $
20m0002                               	                ;Q=0,,X
20m0002 11330 640704204575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] NORM $
20m0002                               	                ;HOLD=X1,,X     write X0,,X1
20m0002                               	
20m0002                               	;If absolute, just copy Y
20m0002 11331 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+62.    read Y0,,Y1
20m0002 11332 640700054171000440020000	        MAPF[NORM-RD] D[10 + YMAX,,YMIN] DEST[Q] NORM $
20m0002                               	                ;Q=0,,Y
20m0002 11333 640704204575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] NORM $
20m0002                               	                ;HOLD=Y1,,Y     write Y0,,Y1
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

20m0002                               	
20m0002                               	;Check type code. If 0, visible vector. (For now, all others invisible.)
20m0002                               	VIDVC6: D[10 + INTEN,,FRACT] ROT[32.] MASK[2]
20m0002 11334 530140044571100020000673	                COND[-OBUS=0] JUMP[VIDDON] C550 $
20m0002                               	                ;If T NEQ 0, done
20m0002                               	
20m0002                               	;Check first half done.
20m0002                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q]
20m0002 11335 656140074171000220000000	                COND[HALF] JUMP[VIDVCH] NORM $
20m0002                               	                ;Q=POGB         If -HALF
20m0002                               	
20m0002                               	;If first half not done, color=modified last color 77777,,777777
20m0002 11336 640720014435000600000000	        D[CONST 48.] ALU[Q+D] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+48.    read LAST COLOR
20m0002 11337 640710014531102010020000	        MAPF[NORM-RD] D[CONST 1] ROT[33.] ALU[D-1] DEST[AR] NORM $
20m0002                               	                ;AR=077777,,777777
20m0002 11340 640700004171000440000000	        D[MEM] DEST[Q] NORM $
20m0002                               	                ;Q=LAST COLOR,,LAST FONT
20m0002                               	        D[MEM] ROT[2] MASK[2]
20m0002 11341 510140004571004020000000	                COND[OBUS=0] JUMP[VIDVIM] C550 $
20m0002                               	                ;If color>1
20m0002 11342 640700014175102070000000	        D[CONST 7] ROT[33.] ALU[DORQ] DEST[Q] NORM $
20m0002                               	                ;Q=COLOR 7 (WHITE FROM COLOR)
20m0002                               	VIDVIM:
20m0002                               	.REPEAT VIC2 [
20m0002                               	VIC2
20m0002                               	.REPEAT 1 - VIC2 [
20m0002 11343 640704400575000440000000	        D[AR] ALU[DORQ] DEST[HOLD] NORM $
20m0002                               	                ;MEM=MODIFIED LAST COLOR 77777,,777777
20m0002 11344 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11345 640724014435000730000000	        D[CONST 59.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
20m0002                               	                ;MA=POGB+59     write <COLOR MASK,,MASK>
20m0002 11346 640140000571000440020000	        MAPF[NORM-RD] JUMP[VIDVI0] NORM $
20m0002                               	                ;WAIT
20m0002                               	]1-VIC2
20m0002                               	
20m0002                               	;If first half done, color=default color 00000,,000000
20m0002 11347 640720014435000600000000	VIDVCH: D[CONST 48.] ALU[Q+D] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+48.    read LAST COLOR
20m0002 11350 640710014531102010020000	        MAPF[NORM-RD] D[CONST 1] ROT[33.] ALU[D-1] DEST[AR] NORM $
20m0002                               	                ;AR=077777,,777777
20m0002 11351 640700004171000440000000	        D[MEM] DEST[Q] NORM $
20m0002                               	                ;Q=LAST COLOR,,LAST FONT
20m0002                               	.REPEAT VIC2 [
20m0002                               	VIC2
20m0002                               	.REPEAT 1 - VIC2 [
20m0002 11352 640704400675000440000000	        D[AR] ALU[-D&Q] DEST[HOLD] NORM $
20m0002                               	                ;MEM=LAST COLOR 00000,,000000
20m0002 11353 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11354 640724014435000730000000	        D[CONST 59.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
20m0002                               	                ;MA=POGB+59     write <COLOR MASK,,MASK>
20m0002 11355 640700000571000440020000	        MAPF[NORM-RD] NORM $
20m0002                               	                ;WAIT
20m0002                               	]1-VIC2
20m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

20m0002                               	;Save X0,,X1 and form XMAX,,XMIN.
20m0002 11356 240700074171000440100000	VIDVI0: MAPF[10] D[10 + POG,,POGB] DEST[Q] C800 $
20m0002                               	                ;VLDCOL         Q=POGB
20m0002 11357 640720014435000750000000	        D[CONST 61.] ALU[D+Q] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+61.    read X0,,X1
20m0002 11360 640700000571000440020000	        MAPF[NORM-RD] NORM $
20m0002                               	                ;WAIT FOR MEM
20m0002 11361 640700404171000443000000	        D[MEM] DEST[Q XMAX,,XMIN] DEST-A-MEM NORM $
20m0002                               	                ;Q,XMAX,,XMIN=X0,,X1
20m0002 11362 640701004571000443000000	        D[MEM] DEST[DXDY,,FRACT] DEST-A-MEM NORM $
20m0002                               	                ;DXDY,,FRACT=X0,,X1     (for use below)
20m0002                               	        D[MEM] ROT[18.] ALU[Q-D]
20m0002 11363 471140004477044440000000	                COND[-OBUS<0] JUMP[VIDVI1] C600 $
20m0002                               	                ;If X0,,X1-X1,,X0<0
20m0002 11364 640700404571044443000000	        D[MEM] ROT[18.] DEST[XMAX,,XMIN] DEST-A-MEM NORM $
20m0002                               	                ;XMAX,,XMIN=X1,,X0
20m0002                               	
20m0002                               	;Save Y0,,Y1 and form YMAX,,YMIN.
20m0002 11365 640700074171000440000000	VIDVI1: D[10 + POG,,POGB] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11366 640720014435000760000000	        D[CONST 62.] ALU[D+Q] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+62.    read Y0,,Y1
20m0002 11367 640700000571000440020000	        MAPF[NORM-RD] NORM $
20m0002                               	                ;WAIT FOR MEM
20m0002 11370 640700604171000443000000	        D[MEM] DEST[Q YMAX,,YMIN] DEST-A-MEM NORM $
20m0002                               	                ;Q,YMAX,,YMIN=Y0,,Y1
20m0002 11371 640701204571000443000000	        D[MEM] DEST[A3DYDX,,FRACT] DEST-A-MEM NORM $
20m0002                               	                ;A3DYDX,,FRACT=Y0,,Y1   (for use below)
20m0002                               	        D[MEM] ROT[18.] ALU[Q-D]
20m0002 11372 471140004477044440000000	                COND[-OBUS<0] JUMP[VIDVI2] C600 $
20m0002                               	                ;If Y0,,Y1-Y1,,Y0<0
20m0002 11373 640700604571044443000000	        D[MEM] ROT[18.] DEST[YMAX,,YMIN] DEST-A-MEM NORM $
20m0002                               	                ;YMAX,,YMIN=Y1,,Y0
20m0002                               	
20m0002                               	;Form delta X. Check for vertical vectors.
20m0002 11374 640700060171044000200000	VIDVI2: D[10 + DXDY,,FRACT] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=X1,,0
20m0002 11375 640700060077000000200000	        D[10 + DXDY,,FRACT] SPEC[LEFT] ALU[Q-D] DEST[Q] NORM $
20m0002                               	                ;Q=DX,,0=X1,,0-X0,,0
20m0002                               	        ALU[Q] DEST[DXDY,,FRACT] DEST-A-MEM
20m0002 11376 510141000555000443000000	                COND[OBUS=0] JUMP[VIDVRV] C550 $
20m0002                               	                ;DXDY,,FRACT=DX,,0 (for use below)
20m0002                               	                ;If DX=0, vertical vector
20m0002                               	
20m0002                               	;Form delta Y. Check for horizontal vectors.
20m0002 11377 640700064171044000200000	        D[10 + A3DYDX,,FRACT] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=Y1,,0
20m0002 11400 640700064077000000200000	        D[10 + A3DYDX,,FRACT] SPEC[LEFT] ALU[Q-D] DEST[Q] NORM $
20m0002                               	                ;Q=DY,,0=Y1,,0-Y0,,0
20m0002                               	        ALU[Q] DEST[A3DYDX,,FRACT] DEST-A-MEM
20m0002 11401 510141200555000443000000	                COND[OBUS=0] JUMP[VIDHZV] C550 $
20m0002                               	                ;A3DYDX,,FRACT=DY,,0 (for use below)
20m0002                               	                ;If DY=0, horizontal vector
20m0002                               	
20m0002                               	;Form DXDY and A3DYDX.
20m0002 11402 640710060571000440000000	        D[10 + DXDY,,FRACT] DEST[AR] NORM $
20m0002                               	                ;AR=DIVIDEND=DX,,0
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

20m0002 11403 640044464571000440000000	        D[10 + A3DYDX,,FRACT] DEST[HOLD] PUSHJ[VIDDIV] NORM $
20m0002                               	                ;HOLD=DIVISOR=DY,,0     divide
20m0002 11404 640710000555000440000000	        ALU[Q] DEST[AR] NORM $
20m0002                               	                ;AR=DX/DY,,FRACT (abs val)
20m0002 11405 640700060171000440000000	        D[10 + DXDY,,FRACT] DEST[Q] NORM $
20m0002                               	                ;Q=DX
20m0002                               	        D[10 + A3DYDX,,FRACT] ALU[D#Q]
20m0002 11406 531140064735000440000000	                COND[-OBUS<0] JUMP[VIDVI3] C550 $
20m0002                               	                ;IF DX XOR DY < 0
20m0002 11407 640710000473000440000000	        D[AR] ALU[0-D] DEST[AR] NORM $
20m0002                               	                ;AR=-DX/DY (correct sign)
20m0002 11410 640704460571000440000000	VIDVI3: D[10 + DXDY,,FRACT] DEST[HOLD] NORM $
20m0002                               	                ;HOLD=DIVISOR=DX
20m0002 11411 640701000571000443000000	        D[AR] DEST[DXDY,,FRACT] DEST-A-MEM NORM $
20m0002                               	                ;DXDY,,FRACT=DX/DY,,FRACT
20m0002 11412 640050064571000440000000	        D[10 + A3DYDX,,FRACT] DEST[AR] PUSHJ[VIDDIV] NORM $
20m0002                               	                ;AR=DIVIDEND=DY         divide
20m0002 11413 640710000555000440000000	        ALU[Q] DEST[AR] NORM $
20m0002                               	                ;AR=DY/DX,,FRACT        (abs val)
20m0002 11414 640701200435002443000000	        D[AR] ROT[1] ALU[Q+D] DEST[A3DYDX,,FRACT] DEST-A-MEM NORM $
20m0002                               	                ;A3DYDX=3*ABS[DY/DX]
20m0002                               	
20m0002                               	;Initialize OFFSET,,LINE.
20m0002 11415 640700054171000220000000	        D[10 + YMAX,,YMIN] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=0,,YMIN
20m0002 11416 640701400555000443000000	        ALU[Q] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0002                               	                ;OFFSET,,LINE=0,,YMIN
20m0002                               	
20m0002                               	;Initialize PIXEL,,FRACT and form boundary limits from POG windows.
20m0002 11417 640700050171044000200000	        D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=XMIN,,0
20m0002                               	        D[10 + DXDY,,FRACT]
20m0002 11420 531140060571000440000000	                COND[-OBUS<0] JUMP[VIDVI4] C550 $
20m0002                               	                ;If slope negative
20m0002 11421 640700050171000000200000	        D[10 + XMAX,,XMIN] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=XMAX,,0
20m0002 11422 640040000555000443000000	VIDVI4: ALU[Q] DEST[PIXEL,,FRACT] DEST-A-MEM PUSHJ[VIDVLM] NORM $
20m0002                               	                ;PIXEL,,FRACT=Q         form boundary limits
20m0002                               	
20m0002                               	;Check to see what side of 45 degrees vector's slope is.
20m0002 11423 640700064171000440000000	        D[10 + A3DYDX,,FRACT] DEST[Q] NORM $
20m0002                               	                ;Q=A3DYDX,,FRACT
20m0002                               	        D[CONST 3] ROT[18.] ALU[Q-D]
20m0002 11424 451140014477044030000000	                COND[OBUS<0] JUMP[VIDLL2] C600 $
20m0002                               	                ;If A3DYDX,,FRACT-3,,0<0, other case
20m0002                               	
20m0002                               	;This is the loop for painting 1 line of vectors whose slope is between
20m0002                               	;45 degrees (inclusive) and vertical (exclusive).
20m0002                               	
20m0002                               	;Check for above window.
20m0002 11425 640700054171044000200000	VIDLL1: D[10 + YMAX,,YMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=YMIN,,0
20m0002                               	        D[10 + OFFSET,,LINE] ROT[18.] SPEC[LEFT] ALU[D-Q]
20m0002 11426 451140070537044000200000	                COND[OBUS<0] JUMP[VIDSL1] C600 $
20m0002                               	                ;If LINE,,0-YMIN,,0<0, skip line
20m0002                               	;Paint left.
20m0002 11427 640700040171000220000000	        D[10 + PIXEL,,FRACT] MASK[18.] ALU[D] DEST[Q] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

20m0002                               	                ;Q=0,,FRACT(PIXEL)
20m0002 11430 640710014137044010000000	        D[CONST 1] ROT[18.] ALU[D-Q] DEST[Q AR] NORM $
20m0002                               	                ;Q,AR=1,,0-0,,FRACT(PIXEL)
20m0002 11431 640700200435002443000000	        D[AR] ROT[1] ALU[D+Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0002                               	                ;INTEN,,FRACT=3*(1,,0-0,,FRACT(PIXEL))
20m0002                               	
20m0002                               	        VIDLFT
20m0002 11432 640700070171000220000000	D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=0,,LINE
20m0002 11433 640701400555000443000000	        ALU[Q] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0002                               	                ;OFFSET,,LINE=0,,LINE
20m0002                               	
20m0002 11434 640040000571000440000000	        PUSHJ[VIDDT1] NORM $
20m0002                               	                ;Do it
20m0002                               	
20m0002 11435 240700044171000440070000	        MAPF[7] D[10 + INTEN,,FRACT] DEST[Q] C800 $
20m0002                               	                ;Q=INTEN,,FRACT         VWEVID
20m0002 11436 640700064077000440000000	        D[10 + A3DYDX,,FRACT] ALU[Q-D] DEST[Q] NORM $
20m0002                               	                ;Q=INTEN,,FRACT-A3DYDX,,FRACT
20m0002 11437 640700200555000443000000	        ALU[Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0002                               	                ;AMEM[1]=INTEN,,FRACT-A3DYDX,,FRACT
20m0002                               	        D[CONST 4] ROT[15.] ALU[Q-D-1]
20m0002 11440 451140014475036040001451	                COND[OBUS<0] JUMP[. + 9] C600 $
20m0002                               	                ;If INTEN,,FRACT-0,,377777<0, done.
20m0002                               	
20m0002 11441 640700070171000440000000	        D[10 + OFFSET,,LINE] DEST[Q] NORM $
20m0002                               	                ;Q=OFFSET,,LINE
20m0002 11442 640701414477044013000000	        D[CONST 1] ROT[18.] ALU[Q-D] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0002                               	                ;OFFSET-1,,LINE
20m0002                               	
20m0002 11443 661140000571000440001434	        COND[-INTRPT] JUMP[. - 7] NORM $
20m0002                               	                ;Loop if no interrupt
20m0002       11434	        %VIDFOO = (. - 8)       ;NOTE: THIS FORCES EVALUATION BEFORE
20m0002                               	        VIDSAV[20m0002 11444 640700014171030010000000	D[CONST (%VIDFOO / 10000)] ROT[12.] DEST[Q] NORM $
20m0002                               	                ;Q=high bit (SDISP loads all 16 bits)
20m0002 11445 640700014175014140000000	        D[CONST (77 & (%VIDFOO / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
20m0002                               	                ;Q=next 6 ADR bits
20m0002 11446 640704414575000340000000	        D[CONST (%VIDFOO \ 100)] ALU[QORD] DEST[HOLD] NORM $
20m0002                               	                ;Q=SAVE ADR
20m0002 11447 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11450 640164014435000720000710	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
20m0002                               	                ;MA=POGB+58     write SAVE ADR
20m0002                               	]       ;       THE MACRO GETS ITS ARGUMENT.
20m0002                               	                ;Interrupt
20m0003                               	]
20m0003                               	;Paint right.
20m0003 11451 640710040171000220000000	        D[10 + PIXEL,,FRACT] MASK[18.] DEST[Q AR] NORM $
20m0003                               	                ;Q=0,,FRACT(PIXEL)
20m0003 11452 640700200435002443000000	        D[AR] ROT[1] ALU[D+Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0003                               	                ;INTEN,,FRACT=3*0,,FRACT(PIXEL)
20m0003                               	
20m0003                               	        VIDRGT
20m0003 11453 640700070171000220000000	D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
20m0003                               	                ;Q=0,,LINE
20m0003 11454 640701414575044013000000	        D[CONST 1] ROT[18.] ALU[QORD] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

20m0003                               	                ;OFFSET,,LINE=1,,LINE
20m0003                               	
20m0003 11455 640040000571000440000000	        PUSHJ[VIDDT1] NORM $
20m0003                               	                ;Do it (loop to here)
20m0003                               	
20m0003 11456 240700044171000440070000	        MAPF[7] D[10 + INTEN,,FRACT] DEST[Q] C800 $
20m0003                               	                ;Q=INTEN,,FRACT         VWEVID
20m0003 11457 640700064077000440000000	        D[10 + A3DYDX,,FRACT] ALU[Q-D] DEST[Q] NORM $
20m0003                               	                ;Q=INTEN,,FRACT-A3DYDX,,FRACT
20m0003 11460 640700200555000443000000	        ALU[Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0003                               	                ;AMEM[1]=INTEN,,FRACT-A3DYDX,,FRACT
20m0003                               	        D[CONST 4] ROT[15.] ALU[Q-D-1]
20m0003 11461 451140014475036040001472	                COND[OBUS<0] JUMP[. + 9] C600 $
20m0003                               	                ;If INTEN,,FRACT-0,,377777<0, done.
20m0003                               	
20m0003 11462 640700070171000440000000	        D[10 + OFFSET,,LINE] DEST[Q] NORM $
20m0003                               	                ;Q=OFFSET,,LINE
20m0003 11463 640701414435044013000000	        D[CONST 1] ROT[18.] ALU[Q+D] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0003                               	                ;OFFSET+1,,LINE
20m0003                               	
20m0003 11464 661140000571000440001455	        COND[-INTRPT] JUMP[. - 7] NORM $
20m0003                               	                ;Loop if no interrupt
20m0003       11455	        %VIDFOO = (. - 8)       ;NOTE: THIS FORCES EVALUATION BEFORE
20m0003                               	        VIDSAV[20m0003 11465 640700014171030010000000	D[CONST (%VIDFOO / 10000)] ROT[12.] DEST[Q] NORM $
20m0003                               	                ;Q=high bit (SDISP loads all 16 bits)
20m0003 11466 640700014175014140000000	        D[CONST (77 & (%VIDFOO / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
20m0003                               	                ;Q=next 6 ADR bits
20m0003 11467 640704414575000550000000	        D[CONST (%VIDFOO \ 100)] ALU[QORD] DEST[HOLD] NORM $
20m0003                               	                ;Q=SAVE ADR
20m0003 11470 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0003                               	                ;Q=POGB
20m0003 11471 640164014435000720000710	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
20m0003                               	                ;MA=POGB+58     write SAVE ADR
20m0003                               	]       ;       THE MACRO GETS ITS ARGUMENT.
20m0003                               	                ;Interrupt
20m0004                               	]
20m0004                               	;Reset offset and increment line.
20m0004 11472 640700070171000220000000	VIDSL1: D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
20m0004                               	                ;Q=0,,LINE
20m0004 11473 640701400417000443000000	        ALU[Q+1] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0004                               	                ;OFFSET,,LINE=0,,LINE+1
20m0004                               	
20m0004                               	;Check for below window.
20m0004 11474 640700070171044000200000	        D[10 + OFFSET,,LINE] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0004                               	                ;Q=LINE,,0
20m0004                               	        D[10 + YMAX,,YMIN] SPEC[LEFT] ALU[D-Q]
20m0004 11475 451140054537000000200000	                COND[OBUS<0] JUMP[VIDVEN] C600 $
20m0004                               	                ;If YMAX,,0-LINE,,0<0, terminate
20m0004                               	
20m0004                               	;Increment X position.
20m0004 11476 640700040171000440000000	        D[10 + PIXEL,,FRACT] DEST[Q] NORM $
20m0004                               	                ;Q=PIXEL,,FRACT
20m0004 11477 640700060035000440000000	        D[10 + DXDY,,FRACT] ALU[Q+D] DEST[Q] NORM $
20m0004                               	                ;Q=PIXEL,,FRACT+DXDY,,FRACT
20m0004 11500 640140000555000443001425	        ALU[Q] DEST[PIXEL,,FRACT] DEST-A-MEM JUMP[VIDLL1] NORM $
20m0004                               	                ;PIXEL,,FRACT=PIXEL,,FRACT+DXDY,,FRACT  loop
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

20m0004                               	
20m0004                               	;This is the loop for vectors whose slope is between 45 degrees (exclusive)
20m0004                               	;and horizontal (exclusive).
20m0004                               	
20m0004                               	;Check for above window.
20m0004 11501 640700054171044000200000	VIDLL2: D[10 + YMAX,,YMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0004                               	                ;Q=YMIN,,0
20m0004                               	        D[10 + OFFSET,,LINE] ROT[18.] SPEC[LEFT] ALU[D-Q]
20m0004 11502 451140070537044000200000	                COND[OBUS<0] JUMP[VIDSL2] C600 $
20m0004                               	                ;If LINE,,0-YMIN,,0<0, skip line
20m0004                               	
20m0004                               	;Paint left.
20m0004                               	        D[10 + PIXEL,,FRACT] ROT[36. - 2] MASK[16.] DEST[Q]
20m0004 11503 640040040171104200000000	                PUSHJ[VIDMUL] NORM $
20m0004                               	                ;Q=MULTIPLIER(0,,00 16 BIT)     multiply
20m0004 11504 640700214537044033000000	        D[CONST 3] ROT[18.] ALU[D-Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0004                               	                ;INTEN,,FRACT=3,,0-0,,DELTA*A3DYDX,,FRACT
20m0004                               	
20m0004                               	        VIDLFT
20m0004 11505 640700070171000220000000	D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
20m0004                               	                ;Q=0,,LINE
20m0004 11506 640701400555000443000000	        ALU[Q] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0004                               	                ;OFFSET,,LINE=0,,LINE
20m0004                               	
20m0004 11507 640040000571000440000000	        PUSHJ[VIDDT1] NORM $
20m0004                               	                ;Do it
20m0004                               	
20m0004 11510 240700044171000440070000	        MAPF[7] D[10 + INTEN,,FRACT] DEST[Q] C800 $
20m0004                               	                ;Q=INTEN,,FRACT         VWEVID
20m0004 11511 640700064077000440000000	        D[10 + A3DYDX,,FRACT] ALU[Q-D] DEST[Q] NORM $
20m0004                               	                ;Q=INTEN,,FRACT-A3DYDX,,FRACT
20m0004 11512 640700200555000443000000	        ALU[Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0004                               	                ;AMEM[1]=INTEN,,FRACT-A3DYDX,,FRACT
20m0004                               	        D[CONST 4] ROT[15.] ALU[Q-D-1]
20m0004 11513 451140014475036040001524	                COND[OBUS<0] JUMP[. + 9] C600 $
20m0004                               	                ;If INTEN,,FRACT-0,,377777<0, done.
20m0004                               	
20m0004 11514 640700070171000440000000	        D[10 + OFFSET,,LINE] DEST[Q] NORM $
20m0004                               	                ;Q=OFFSET,,LINE
20m0004 11515 640701414477044013000000	        D[CONST 1] ROT[18.] ALU[Q-D] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0004                               	                ;OFFSET-1,,LINE
20m0004                               	
20m0004 11516 661140000571000440001507	        COND[-INTRPT] JUMP[. - 7] NORM $
20m0004                               	                ;Loop if no interrupt
20m0004       11507	        %VIDFOO = (. - 8)       ;NOTE: THIS FORCES EVALUATION BEFORE
20m0004                               	        VIDSAV[20m0004 11517 640700014171030010000000	D[CONST (%VIDFOO / 10000)] ROT[12.] DEST[Q] NORM $
20m0004                               	                ;Q=high bit (SDISP loads all 16 bits)
20m0004 11520 640700014175014150000000	        D[CONST (77 & (%VIDFOO / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
20m0004                               	                ;Q=next 6 ADR bits
20m0004 11521 640704414575000070000000	        D[CONST (%VIDFOO \ 100)] ALU[QORD] DEST[HOLD] NORM $
20m0004                               	                ;Q=SAVE ADR
20m0004 11522 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0004                               	                ;Q=POGB
20m0004 11523 640164014435000720000710	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
20m0004                               	                ;MA=POGB+58     write SAVE ADR
20m0004                               	]       ;       THE MACRO GETS ITS ARGUMENT.
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

20m0004                               	                ;Interrupt
20m0005                               	]
20m0005                               	;Paint right.
20m0005 11524 640700040171104200000000	        D[10 + PIXEL,,FRACT] ROT[36. - 2] MASK[16.] DEST[Q] NORM $
20m0005                               	                ;Q=MULTIPLIER(0,,00 16 BIT)
20m0005 11525 640040014135040010000000	        D[CONST 1] ROT[16.] ALU[D-Q-1] DEST[Q] PUSHJ[VIDMUL] NORM $
20m0005                               	                ;Q=1-MULTIPLIER (0,,177777-16 BIT)      multiply
20m0005 11526 640700214537044033000000	        D[CONST 3] ROT[18.] ALU[D-Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0005                               	                ;INTEN,,FRACT=3,,0-0,,DELTA*A3DYDX,,FRACT
20m0005                               	
20m0005                               	        VIDRGT
20m0005 11527 640700070171000220000000	D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
20m0005                               	                ;Q=0,,LINE
20m0005 11530 640701414575044013000000	        D[CONST 1] ROT[18.] ALU[QORD] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0005                               	                ;OFFSET,,LINE=1,,LINE
20m0005                               	
20m0005 11531 640040000571000440000000	        PUSHJ[VIDDT1] NORM $
20m0005                               	                ;Do it (loop to here)
20m0005                               	
20m0005 11532 240700044171000440070000	        MAPF[7] D[10 + INTEN,,FRACT] DEST[Q] C800 $
20m0005                               	                ;Q=INTEN,,FRACT         VWEVID
20m0005 11533 640700064077000440000000	        D[10 + A3DYDX,,FRACT] ALU[Q-D] DEST[Q] NORM $
20m0005                               	                ;Q=INTEN,,FRACT-A3DYDX,,FRACT
20m0005 11534 640700200555000443000000	        ALU[Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0005                               	                ;AMEM[1]=INTEN,,FRACT-A3DYDX,,FRACT
20m0005                               	        D[CONST 4] ROT[15.] ALU[Q-D-1]
20m0005 11535 451140014475036040001546	                COND[OBUS<0] JUMP[. + 9] C600 $
20m0005                               	                ;If INTEN,,FRACT-0,,377777<0, done.
20m0005                               	
20m0005 11536 640700070171000440000000	        D[10 + OFFSET,,LINE] DEST[Q] NORM $
20m0005                               	                ;Q=OFFSET,,LINE
20m0005 11537 640701414435044013000000	        D[CONST 1] ROT[18.] ALU[Q+D] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0005                               	                ;OFFSET+1,,LINE
20m0005                               	
20m0005 11540 661140000571000440001531	        COND[-INTRPT] JUMP[. - 7] NORM $
20m0005                               	                ;Loop if no interrupt
20m0005       11531	        %VIDFOO = (. - 8)       ;NOTE: THIS FORCES EVALUATION BEFORE
20m0005                               	        VIDSAV[20m0005 11541 640700014171030010000000	D[CONST (%VIDFOO / 10000)] ROT[12.] DEST[Q] NORM $
20m0005                               	                ;Q=high bit (SDISP loads all 16 bits)
20m0005 11542 640700014175014150000000	        D[CONST (77 & (%VIDFOO / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
20m0005                               	                ;Q=next 6 ADR bits
20m0005 11543 640704414575000310000000	        D[CONST (%VIDFOO \ 100)] ALU[QORD] DEST[HOLD] NORM $
20m0005                               	                ;Q=SAVE ADR
20m0005 11544 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0005                               	                ;Q=POGB
20m0005 11545 640164014435000720000710	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
20m0005                               	                ;MA=POGB+58     write SAVE ADR
20m0005                               	]       ;       THE MACRO GETS ITS ARGUMENT.
20m0005                               	                ;Interrupt
20m0006                               	]
20m0006                               	;Increment line and reset offset.
20m0006 11546 640700070171000220000000	VIDSL2: D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
20m0006                               	                ;Q=0,,LINE
20m0006 11547 640701400417000443000000	        ALU[Q+1] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0006                               	                ;OFFSET,,LINE=0,,LINE+1
20m0006                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

20m0006                               	;Check for below window.
20m0006 11550 640700070171044000200000	        D[10 + OFFSET,,LINE] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0006                               	                ;Q=LINE,,0
20m0006                               	        D[10 + YMAX,,YMIN] SPEC[LEFT] ALU[D-Q]
20m0006 11551 451140054537000000200000	                COND[OBUS<0] JUMP[VIDVEN] C600 $
20m0006                               	                ;If YMAX,,0-LINE,,0<0, terminate
20m0006                               	
20m0006                               	;Increment X position.
20m0006 11552 640700040171000440000000	        D[10 + PIXEL,,FRACT] DEST[Q] NORM $
20m0006                               	                ;Q=PIXEL,,FRACT
20m0006 11553 640700060035000440000000	        D[10 + DXDY,,FRACT] ALU[Q+D] DEST[Q] NORM $
20m0006                               	                ;Q=PIXEL,,FRACT+DXDY,,FRACT
20m0006 11554 640140000555000443001501	        ALU[Q] DEST[PIXEL,,FRACT] DEST-A-MEM JUMP[VIDLL2] NORM $
20m0006                               	                ;PIXEL,,FRACT=PIXEL,,FRACT+DXDY,,FRACT  loop
20m0006                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

21m0006                               	;Vertical Vectors
21m0006 11555 640040000571000440000000	VIDVRV: PUSHJ[VIDVLM] NORM $
21m0006                               	                ;Form boundary limits
21m0006                               	
21m0006 11556 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
21m0006                               	                ;Q=POGB
21m0006 11557 640720014435000750000000	        D[CONST 61.] ALU[D+Q] DEST[MA] NORM $
21m0006                               	                ;MA=POGB+61.    read X0,,X1
21m0006 11560 640710050171044000220000	        MAPF[NORM-RD] D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] DEST[Q AR] NORM $
21m0006                               	                ;Q,AR=XMIN,,0   (AR for use below)
21m0006                               	        D[MEM] SPEC[LEFT] ALU[D-Q]
21m0006 11561 451140004537000000200673	                COND[OBUS<0] JUMP[VIDDON] C600 $
21m0006                               	                ;If X0,,0-XMIN,,0<0, main loop
21m0006 11562 640700050171000000200000	        D[10 + XMAX,,XMIN] SPEC[LEFT] DEST[Q] NORM $
21m0006                               	                ;Q=XMAX,,0
21m0006                               	        D[MEM] SPEC[LEFT] ALU[Q-D]
21m0006 11563 451140004477000000200673	                COND[OBUS<0] JUMP[VIDDON] C600 $
21m0006                               	                ;If XMAX,,0-X0,,0<0, main loop
21m0006                               	
21m0006 11564 640700000571000443000000	        D[AR] DEST[PIXEL,,FRACT] DEST-A-MEM NORM $
21m0006                               	                ;PIXEL,,FRACT=XMIN,,0
21m0006 11565 640700054171000220000000	        D[10 + YMAX,,YMIN] MASK[18.] DEST[Q] NORM $
21m0006                               	                ;Q=0,,YMIN
21m0006 11566 640701400555000443000000	        ALU[Q] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
21m0006                               	                ;OFFSET,,LINE=0,,YMIN
21m0006 11567 640700214571044033000000	        D[CONST 3] ROT[18.] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
21m0006                               	                ;INTEN,,FRACT=3,,0
21m0006                               	
21m0006 11570 640700054171000000200000	VIDVRL: D[10 + YMAX,,YMIN] SPEC[LEFT] DEST[Q] NORM $
21m0006                               	                ;Q=YMAX,,0
21m0006                               	        D[10 + OFFSET,,LINE] ROT[18.] SPEC[LEFT] ALU[Q-D]
21m0006 11571 451140070477044000200000	                COND[OBUS<0] JUMP[VIDVEN] C600 $
21m0006                               	                ;If YMAX,,0-LINE,,0<0 terminate
21m0006                               	
21m0006 11572 640040000571000440000000	        PUSHJ[VIDDOT] NORM $
21m0006                               	                ;Do one pixel
21m0006                               	
21m0006 11573 240700070171000220070000	        MAPF[7] D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] C800 $
21m0006                               	                ;Q=0,,LINE      VWEVID
21m0006                               	        ALU[Q+1] DEST[OFFSET,,LINE] DEST-A-MEM
21m0006 11574 661141400417000443001570	                COND[-INTRPT] JUMP[VIDVRL] NORM $
21m0006                               	                ;OFFSET,,LINE=0,,LINE+1         loop if no interrupt
21m0006                               	        VIDSAV[21m0006 11575 640700014171030010000000	D[CONST (VIDVRL / 10000)] ROT[12.] DEST[Q] NORM $
21m0006                               	                ;Q=high bit (SDISP loads all 16 bits)
21m0006 11576 640700014175014150000000	        D[CONST (77 & (VIDVRL / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
21m0006                               	                ;Q=next 6 ADR bits
21m0006 11577 640704414575000700000000	        D[CONST (VIDVRL \ 100)] ALU[QORD] DEST[HOLD] NORM $
21m0006                               	                ;Q=SAVE ADR
21m0006 11600 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
21m0006                               	                ;Q=POGB
21m0006 11601 640164014435000720000710	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
21m0006                               	                ;MA=POGB+58     write SAVE ADR
21m0007                               	]               ;Interrupt
21m0007                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

22m0007                               	;Horizontal Vectors
22m0007 11602 640040000571000440000000	VIDHZV: PUSHJ[VIDVLM] NORM $
22m0007                               	                ;Form boundary limits
22m0007                               	
22m0007 11603 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
22m0007                               	                ;Q=POGB
22m0007 11604 640720014435000760000000	        D[CONST 62.] ALU[D+Q] DEST[MA] NORM $
22m0007                               	                ;MA=POGB+62.    read Y0,,Y1
22m0007 11605 640710054171044000220000	        MAPF[NORM-RD] D[10 + YMAX,,YMIN] ROT[18.] SPEC[LEFT] DEST[Q AR] NORM $
22m0007                               	                ;Q,AR=YMIN,,0 (AR for use below)
22m0007                               	        D[MEM] SPEC[LEFT] ALU[D-Q]
22m0007 11606 451140004537000000200673	                COND[OBUS<0] JUMP[VIDDON] C600 $
22m0007                               	                ;IF Y0,,0-YMIN,,0<0, main loop
22m0007 11607 640700054171000000200000	        D[10 + YMAX,,YMIN] SPEC[LEFT] DEST[Q] NORM $
22m0007                               	                ;Q=YMAX,,0
22m0007                               	        D[MEM] SPEC[LEFT] ALU[Q-D]
22m0007 11610 451140004477000000200673	                COND[OBUS<0] JUMP[VIDDON] C600 $
22m0007                               	                ;IF YMAX,,0-Y0,,0<0, main loop
22m0007                               	
22m0007 11611 640701400571044443000000	        D[AR] ROT[18.] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
22m0007                               	                ;OFFSET,,LINE=0,,YMIN
22m0007 11612 640700050171044000200000	        D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
22m0007                               	                ;Q=XMIN,,0
22m0007 11613 640700000555000443000000	        ALU[Q] DEST[PIXEL,,FRACT] DEST-A-MEM NORM $
22m0007                               	                ;PIXEL,,FRACT=XMIN,,0
22m0007 11614 640700214571044033000000	        D[CONST 3] ROT[18.] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
22m0007                               	                ;INTEN,,FRACT=3,,0
22m0007                               	
22m0007 11615 640700050171000000200000	VIDHZL: D[10 + XMAX,,XMIN] SPEC[LEFT] DEST[Q] NORM $
22m0007                               	                ;Q=XMAX,,0
22m0007                               	        D[10 + PIXEL,,FRACT] SPEC[LEFT] ALU[Q-D]
22m0007 11616 451140040477000000200000	                COND[OBUS<0] JUMP[VIDVEN] C600 $
22m0007                               	                ;If XMAX,,0-PIXEL,,0<0, terminate
22m0007                               	
22m0007 11617 640040000571000440000000	        PUSHJ[VIDDOT] NORM $
22m0007                               	                ;Do one pixel
22m0007                               	
22m0007 11620 240700040171000440070000	        MAPF[7] D[10 + PIXEL,,FRACT] DEST[Q] C800 $
22m0007                               	                ;Q=PIXEL,,FRACT         VWEVID
22m0007                               	        D[CONST 1] ROT[18.] ALU[Q+D] DEST[PIXEL,,FRACT] DEST-A-MEM
22m0007 11621 661140014435044013001615	                COND[-INTRPT] JUMP[VIDHZL] NORM $
22m0007                               	                ;PIXEL,,FRACT=PIXEL+1,,FRACT    loop if no interrupt
22m0007                               	        VIDSAV[22m0007 11622 640700014171030010000000	D[CONST (VIDHZL / 10000)] ROT[12.] DEST[Q] NORM $
22m0007                               	                ;Q=high bit (SDISP loads all 16 bits)
22m0007 11623 640700014175014160000000	        D[CONST (77 & (VIDHZL / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
22m0007                               	                ;Q=next 6 ADR bits
22m0007 11624 640704414575000150000000	        D[CONST (VIDHZL \ 100)] ALU[QORD] DEST[HOLD] NORM $
22m0007                               	                ;Q=SAVE ADR
22m0007 11625 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
22m0007                               	                ;Q=POGB
22m0007 11626 640164014435000720000710	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
22m0007                               	                ;MA=POGB+58     write SAVE ADR
22m0008                               	]               ;Interrupt
22m0008                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

23m0008                               	;Vector endpoint cleanup (subtract away first point if visible)
23m0008 11627 640700074171000220000000	VIDVEN: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
23m0008                               	                ;Q=POGB
23m0008 11630 640720014435000760000000	        D[CONST 62.] ALU[Q+D] DEST[MA] NORM $
23m0008                               	                ;MA=POGB+62.    read Y0,,Y1
23m0008 11631 640700054171044000220000	        MAPF[NORM-RD] D[10 + YMAX,,YMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
23m0008                               	                ;Q=YMIN,,0
23m0008                               	        D[MEM] SPEC[LEFT] ALU[D-Q]
23m0008 11632 451140004537000000200673	                COND[OBUS<0] JUMP[VIDDON] C600 $
23m0008                               	                ;If Y0,,0-YMIN,,0<0, main loop
23m0008 11633 640700054171000000200000	        D[10 + YMAX,,YMIN] SPEC[LEFT] DEST[Q] NORM $
23m0008                               	                ;Q=YMAX,,0
23m0008                               	        D[MEM] SPEC[LEFT] ALU[Q-D]
23m0008 11634 451140004477000000200673	                COND[OBUS<0] JUMP[VIDDON] C600 $
23m0008                               	                ;If YMAX,,0-Y0,,0<0, main loop
23m0008 11635 640710004571000000200000	        D[MEM] SPEC[LEFT] DEST[AR] NORM $
23m0008                               	                ;AR=Y0,,0       (for use below)
23m0008                               	
23m0008 11636 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
23m0008                               	                ;Q=POGB
23m0008 11637 640720014435000750000000	        D[CONST 61.] ALU[Q+D] DEST[MA] NORM $
23m0008                               	                ;MA=POGB+62.    read X0,,X1
23m0008 11640 640700050171044000220000	        MAPF[NORM-RD] D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
23m0008                               	                ;Q=XMIN,,0
23m0008                               	        D[MEM] SPEC[LEFT] ALU[D-Q]
23m0008 11641 451140004537000000200673	                COND[OBUS<0] JUMP[VIDDON] C600 $
23m0008                               	                ;If X0,,0-XMIN,,0<0, main loop
23m0008 11642 640700050171000000200000	        D[10 + XMAX,,XMIN] SPEC[LEFT] DEST[Q] NORM $
23m0008                               	                ;Q=XMAX,,0
23m0008                               	        D[MEM] SPEC[LEFT] ALU[Q-D]
23m0008 11643 451140004477000000200673	                COND[OBUS<0] JUMP[VIDDON] C600 $
23m0008                               	                ;If XMAX,,0-X0,,0<0, main loop
23m0008                               	
23m0008 11644 640700004171000000200000	        D[MEM] SPEC[LEFT] DEST[Q] NORM $
23m0008                               	                ;Q=X0,,0
23m0008 11645 640700000555000443000000	        ALU[Q] DEST[PIXEL,,FRACT] DEST-A-MEM NORM $
23m0008                               	                ;PIXEL,,FRACT=X0,,0
23m0008 11646 640701400571044223000000	        D[AR] ROT[18.] MASK[18.] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
23m0008                               	                ;OFFSET,,LINE=0,,Y0
23m0008 11647 640040214571044053000000	        D[CONST 5] ROT[18.] DEST[INTEN,,FRACT] DEST-A-MEM PUSHJ[VIDDOT] NORM $
23m0008                               	                ;INTEN,,FRACT=5,,0      Do it
23m0008 11650 240140000571000440070673	        MAPF[7] JUMP[VIDDON] C800 $
23m0008                               	                ;VWEVID         main loop
23m0008                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

24m0008                               	;Output one pixel
24m0008 11651 640700070171000220000000	VIDDOT: D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=0,,LINE
24m0008 11652 640141400555000443000000	        ALU[Q] DEST[OFFSET,,LINE] DEST-A-MEM JUMP[VIDDT2] NORM $
24m0008                               	                ;OFFSET,,LINE=0,,LINE
24m0008                               	
24m0008                               	;Enter here for limit check  
24m0008 11653 640700040171000000200000	VIDDT1: D[10 + PIXEL,,FRACT] SPEC[LEFT] DEST[Q] NORM $
24m0008                               	                ;Q=PIXEL,,0
24m0008 11654 640710070035000000200000	        D[10 + OFFSET,,LINE] SPEC[LEFT] ALU[Q+D] DEST[Q AR] NORM $
24m0008                               	                ;AR,Q=PIXEL,,0+OFFSET,,0
24m0008                               	        D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] ALU[Q-D]
24m0008 11655 451300050477044000200000	                COND[OBUS<0] POPJ C600 $
24m0008                               	                ;IF PIXEL,,0-XMIN,,0<0, RETURN
24m0008                               	        D[10 + XMAX,,XMIN] SPEC[LEFT] ALU[D-Q]
24m0008 11656 451300050537000000200000	                COND[OBUS<0] POPJ C600 $
24m0008                               	                ;IF XMAX,,0-PIXEL,,0<0, RETURN
24m0008                               	.REPEAT VIC2 [
24m0008                               	VIC2
24m0008                               	.REPEAT 1 - VIC2 [
24m0008 11657 640700070171000220000000	VIDDT2: D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=0,,LINE
24m0008 11660 640710014435014040000000	        D[CONST 4] ROT[6] ALU[Q+D] DEST[AR] NORM $
24m0008                               	                ;AR=0,,LINE+256.
24m0008 11661 640700000171012160000000	        D[AR] ROT[5] MASK[14.] DEST[Q] NORM $
24m0008                               	                ;Q=0 LINE 00000
24m0008 11662 640700014275012010000000	        D[CONST 1] ROT[5] ALU[-D&Q] DEST[Q] NORM $
24m0008                               	                ;Q=0 LINE/2 000000
24m0008                               	        D[AR] ROT[36. - 1]
24m0008 11663 531140000571106440000000	                COND[-OBUS<0] JUMP[VIDDT3] C550 $
24m0008                               	                ;IF LSB[LINE]=1
24m0008 11664 640700014175034010000000	        D[CONST 1] ROT[14.] ALU[QORD] DEST[Q] NORM $
24m0008                               	                ;Q=ODD[LINE] LINE/2 000000
24m0008 11665 640704400555000440000000	VIDDT3: ALU[Q] DEST[HOLD] NORM $
24m0008                               	                ;MEM=INTERLACED LINE 000000
24m0008 11666 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=POGB
24m0008 11667 640724014435000740000000	        D[CONST 60.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
24m0008                               	                ;MA=POGB+60.    write INTERLACED LINE 000000 (temp)
24m0008                               	
24m0008 11670 640700014131014050020000	        MAPF[NORM-RD] D[CONST 5] ROT[6] ALU[D-1] DEST[Q] NORM $
24m0008                               	                ;Q=319.
24m0008 11671 640700040035044220000000	        D[10 + PIXEL,,FRACT] ROT[18.] MASK[18.] ALU[Q+D] DEST[Q] NORM $
24m0008                               	                ;Q=0,,PIXEL+319.
24m0008 11672 640710070435044220000000	        D[10 + OFFSET,,LINE] ROT[18.] MASK[18.] ALU[Q+D] DEST[AR] NORM $
24m0008                               	                ;Q=0,,PIXEL+0,,OFFSET+319.
24m0008 11673 640710000171000220000000	        D[AR] MASK[18.] DEST[Q AR] NORM $
24m0008                               	                ;Q,AR=0,,PIXEL+OFFSET+319.
24m0008 11674 640050000435002440001226	        D[AR] ROT[1] ALU[D+Q] DEST[AR] PUSHJ[VIDD33] NORM $
24m0008                               	                ;AR=3*corrected PIXEL   divide by 33
24m0008                               	
24m0008 11675 640710004575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[AR] NORM $
24m0008                               	                ;AR=QUOTIENT,,REMAINDER=WORD,,PIXEL
24m0008 11676 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=POGB
24m0008 11677 640720014435000740000000	        D[CONST 60.] ALU[Q+D] DEST[MA] NORM $
24m0008                               	                ;MA=POGB+60     read INTERLACED LINE 000000
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

24m0008 11700 640700000171044220020000	        MAPF[NORM-RD] D[AR] ROT[18.] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=WORD
24m0008 11701 640700004175000440000000	        D[MEM] ALU[QORD] DEST[Q] NORM $
24m0008                               	                ;Q=INTERLACED LINE 000000 + WORD (=interlaced address)
24m0008                               	
24m0008 11702 640700014035014070000000	        D[CONST 7] ROT[6] ALU[Q+D] DEST[Q] NORM $
24m0008                               	                ;Q=ADR+7*64.
24m0008 11703 640702214435000063600000	        D[CONST 6] ALU[Q+D] DEST[IOD] START-OUT NORM $
24m0008                               	                ;IOD=ADR+7 lines, 6 words
24m0008                               	
24m0008 11704 240700000171000220020000	        MAPF[2] D[AR] MASK[18.] DEST[Q] C800 $
24m0008                               	                ;VLDADR         Q=REMAINDER
24m0008 11705 640701214537000360000000	        D[CONST 30.] ALU[D-Q] DEST[ROTR] NORM $
24m0008                               	                ;ROTR=30-REMAINDER
24m0008 11706 640700044171000440000000	        D[10 + INTEN,,FRACT] DEST[Q] NORM $
24m0008                               	                ;Q=INTEN,,FRACT
24m0008 11707 640710014435036040000000	        D[CONST 4] ROT[15.] ALU[Q+D] DEST[AR] NORM $
24m0008                               	                ;AR=INTEN,,FRACT+0,,400000
24m0008 11710 640710000571044030000000	        D[AR] ROT[18.] MASK[3] DEST[AR] NORM $
24m0008                               	                ;AR=0,,INTEN
24m0008 11711 640710000571200440000000	        D[AR] ROT[R] DEST[AR] NORM $
24m0008                               	                ;AR=DATA correctly shifted
24m0008 11712 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=POGB
24m0008 11713 640720014435000730000000	        D[CONST 59.] ALU[Q+D] DEST[MA] NORM $
24m0008                               	                ;MA=POGB+59.    read COLOR MASK,,MASK
24m0008 11714 640700000171000440020000	        MAPF[NORM-RD] D[AR] DEST[Q] NORM $
24m0008                               	                ;Q=DATA
24m0008                               	        D[MEM] ROT[2] MASK[2]
24m0008 11715 530040004571004020001247	                COND[-OBUS=0] PUSHJ[VIDCOL] C550 $
24m0008                               	                ;If bit(s) 0 or 1 of color on, "color" the word
24m0008 11716 640702204735000443600000	        D[MEM] ALU[D#Q] DEST[IOD] START-OUT NORM $
24m0008                               	                ;IOD=DATA XOR COLOR
24m0008 11717 240300000571000443410000	        MAPF[1] START-IN POPJ C800 $
24m0008                               	                ;VLDDAT (next line must have MAPF[7] ... C800)
24m0008                               	]1-VIC2
24m0008                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

25m0008                               	;Compute Limits
25m0008 11720 640700074171000220000000	VIDVLM: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
25m0008                               	                ;Q=POGB
25m0008 11721 640700074035044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[Q+D] DEST[Q] NORM $
25m0008                               	                ;Q=POGB+POG
25m0008 11722 640720014435000200000000	        D[CONST 16.] ALU[Q+D] DEST[MA] NORM $
25m0008                               	                ;MA=POGB+16.+POG        read POG XMAX,,XMIN
25m0008                               	
25m0008 11723 640700050171044000220000	        MAPF[NORM-RD] D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
25m0008                               	                ;Q=XMIN,,0
25m0008                               	        D[MEM] ROT[18.] SPEC[LEFT] ALU[Q-D]
25m0008 11724 471140004477044000200000	                COND[-OBUS<0] JUMP[VIDVL1] C600 $
25m0008                               	                ;If XMIN,,0-POGXMIN,,0<0
25m0008 11725 640700050171000000200000	        D[10 + XMAX,,XMIN] SPEC[LEFT] DEST[Q] NORM $
25m0008                               	                ;Q=XMAX,,0
25m0008 11726 640700404575000223000000	        D[MEM] MASK[18.] ALU[DORQ] DEST[XMAX,,XMIN] DEST-A-MEM NORM $
25m0008                               	                ;XMAX,,XMIN=XMAX,,POGXMIN
25m0008                               	
25m0008 11727 640700050171000000200000	VIDVL1: D[10 + XMAX,,XMIN] SPEC[LEFT] DEST[Q] NORM $
25m0008                               	                ;Q=XMAX,,0
25m0008                               	        D[MEM] SPEC[LEFT] ALU[D-Q]
25m0008 11730 471140004537000000200000	                COND[-OBUS<0] JUMP[VIDVL2] C600 $
25m0008                               	                ;If POGXMAX,,0-XMAX,,0<0
25m0008 11731 640700050171000220000000	        D[10 + XMAX,,XMIN] MASK[18.] DEST[Q] NORM $
25m0008                               	                ;Q=0,,XMIN
25m0008 11732 640700004175000000200000	        D[MEM] SPEC[LEFT] ALU[DORQ] DEST[Q] NORM $
25m0008                               	                ;Q=POGXMAX,,XMIN
25m0008 11733 640700400555000443000000	        ALU[Q] DEST[XMAX,,XMIN] DEST-A-MEM NORM $
25m0008                               	                ;XMAX,,XMIN=POGXMAX,,XMIN
25m0008                               	
25m0008 11734 640700024171000440000000	VIDVL2: D[MA] DEST[Q] NORM $
25m0008                               	                ;Q=MA
25m0008 11735 640720014435000200000000	        D[CONST 16.] ALU[Q+D] DEST[MA] NORM $
25m0008                               	                ;MA=MA+16.      read POG YMAX,,YMIN
25m0008                               	
25m0008 11736 640700054171044000220000	        MAPF[NORM-RD] D[10 + YMAX,,YMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
25m0008                               	                ;Q=YMIN,,0
25m0008                               	        D[MEM] ROT[18.] SPEC[LEFT] ALU[Q-D]
25m0008 11737 471140004477044000200000	                COND[-OBUS<0] JUMP[VIDVL3] C600 $
25m0008                               	                ;If YMIN,,0-POGYMIN,,0<0
25m0008 11740 640700054171000000200000	        D[10 + YMAX,,YMIN] SPEC[LEFT] DEST[Q] NORM $
25m0008                               	                ;Q=YMAX,,0
25m0008 11741 640700604575000223000000	        D[MEM] MASK[18.] ALU[DORQ] DEST[YMAX,,YMIN] DEST-A-MEM NORM $
25m0008                               	                ;YMAX,,YMIN=YMAX,,POGYMIN
25m0008                               	
25m0008 11742 640700054171000000200000	VIDVL3: D[10 + YMAX,,YMIN] SPEC[LEFT] DEST[Q] NORM $
25m0008                               	                ;Q=YMAX,,0
25m0008                               	        D[MEM] SPEC[LEFT] ALU[D-Q]
25m0008 11743 471300004537000000200000	                COND[-OBUS<0] POPJ C600 $
25m0008                               	                ;If POGYMAX,,0-YMAX,,0<0
25m0008 11744 640700054171000220000000	        D[10 + YMAX,,YMIN] MASK[18.] DEST[Q] NORM $
25m0008                               	                ;Q=0,,YMIN
25m0008 11745 640700004175000000200000	        D[MEM] SPEC[LEFT] ALU[DORQ] DEST[Q] NORM $
25m0008                               	                ;Q=POGYMAX,,YMIN
25m0008 11746 640300600555000443000000	        ALU[Q] DEST[YMAX,,YMIN] DEST-A-MEM POPJ NORM $
25m0008                               	                ;YMAX,,YMIN=POGYMAX,,YMIN
25m0008                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

26m0008                               	;Multiply
26m0008                               	;A3DYDX,,FRACT=MULTIPLICAND(2 BIT,,16 BIT 00)   positive only
26m0008                               	;Q=MULTIPLIER(0,,00 16 BIT)                     positive only
26m0008 11747 640710064571036440000000	VIDMUL: D[10 + A3DYDX,,FRACT] ROT[15.] DEST[AR] NORM $
26m0008                               	                ;AR=MULTIPLICAND(0 17 BIT,,1 BIT 00000000000000000)
26m0008 11750 640704401215000440000000	        ACSEL[AC] ALU[0] DEST[O_AC HOLD] NORM $
26m0008                               	                ;HOLD=AC for safe keeping       AC=0
26m0008                               	;AR=MULTIPLICAND(0 17 BIT,,1 BIT 00000000000000000)
26m0008                               	;Q=MULTIPLIER(0,,00 16 BIT)
26m0008                               	;MEM=AC storage
26m0008 11751 640740014571000170000000	        D[CONST 15.] LLOAD NORM $
26m0008                               	                ;Loop 16 times
26m0008 11752 640240002021000030001752	        D[AR] ACSEL[AC] ALU[MULAC+D] DEST[D4] MASK[3] LOOP[.] NORM $
26m0008                               	                ;Add AR to AC depending on the low order bit of Q.
26m0008                               	                ;Shift AC,,Q right. High order bit of AC=OVR XOR -IOB<0
26m0008                               	;AC=PRODUCT(0 17 BIT,,18 BIT)
26m0008 11753 640710005171000440000000	        D[MEM] ACSEL[AC] DEST[O_AC AR] NORM $
26m0008                               	                ;AC=AC storage, AR=PRODUCT(0 17 BIT,,18 BIT)
26m0008 11754 640300000171052240000000	        D[AR] ROT[36. - 15.] MASK[20.] DEST[Q] POPJ NORM $
26m0008                               	                ;Q=PRODUCT(2 BIT,,18 BIT)       return
26m0008                               	;Q=PRODUCT(2 BIT,,18 BIT)
26m0008                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- F2X

27m0008                               	;Divide
27m0008                               	;AR=DIVIDEND,,0
27m0008                               	;MEM=DIVISOR,,0
27m0008 11755 531140000571000440000000	VIDDIV: D[AR]   COND[-OBUS<0] JUMP[VIDDV1] C550 $
27m0008                               	                ;If AR<0
27m0008 11756 640710000473000440000000	        D[AR] ALU[0-D] DEST[AR] NORM $
27m0008                               	                ;ABS[AR]
27m0008 11757 640710001171044440000000	VIDDV1: D[AR] ROT[18.] ACSEL[AC] DEST[O_AC AR] NORM $
27m0008                               	                ;AR LSH -18. <-> AC
27m0008 11760 640700000215000440000000	        ALU[0] DEST[Q] NORM $
27m0008                               	                ;Q=0
27m0008 11761 531140004571000440000000	        D[MEM]  COND[-OBUS<0] JUMP[VIDDV2] C550 $
27m0008                               	                ;If MEM<0
27m0008 11762 640144404473000440000000	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[VIDDV2] NORM $
27m0008                               	                ;ABS[MEM]
27m0008                               	
27m0008                               	: (. + 3) - (. \ 4)
27m0008                               	                ;.QUAD-1
27m0008 11763 640740014571000440000000	VIDDV2: D[CONST 36.] LLOAD NORM $
27m0008                               	                ;Loop 37 times
27m0008                               	
27m0008                               	VIDDVL: D[MEM] ALU[DIVAC-D] ACSEL[AC] DEST[D6] MASK[3]
27m0008 11764 451640007043000030001764	                COND[OBUS<0] SLOOP[VIDDVL] C600 $
27m0008                               	                ;Loop here if remainder positive
27m0008 11765 640310001171000440000000	        D[AR] ACSEL[AC] ALU[D] DEST[O_AC AR] POPJ NORM $
27m0008                               	                ;Swap AR <-> AC and return
27m0008                               	        D[MEM] ALU[DIVAC+D] ACSEL[AC] DEST[D6] MASK[3]
27m0008 11766 451640007001000030001764	                COND[OBUS<0] SLOOP[VIDDVL] C600 $
27m0008                               	                ;Loop here if remainder positive
27m0008 11767 640310001171000440000000	        D[AR] ACSEL[AC] DEST[O_AC AR] POPJ NORM $
27m0008                               	                ;Swap AR <-> AC and return
27m0008                               	;Q=QUOTIENT,,FRACT
27m0008                               	
27m0008                               	.REPEAT XUCODE [
27m0008                               	        .USE[XLIST
27m0008                               	 LIST ];If 8K u-mem present, return to low memory.
27m0008                               	]
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

39m0155                               	]VID
39m0155                               	        .OPCODE[39m0155                               	LIST 
39m0156                               	 LIST            ].REPEAT ((1 - VID) * (773 - 766 + 1)) [
39m0156                               	1-VID
39m0156                               	.REPEAT VID [
39m0156                               	        ILGIOT 39m0156 03754 000140000571000440002026	 JUMP [MAIN] ]$                 ;OP 766 = illegal (reserved)
39m0156 03755 000700000571000440000000	        NOP $
39m0156                               	        GETADR[ ;Place the 12-bit value of VIDDPA in Q.
39m0156 03756 640700014171014040000000	        D[CONST (77 & (VIDDPA / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
39m0156 03757 440140014175000540006225	        D[CONST (VIDDPA \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOHIGH]$   ;OP 767 = DPYADD
39m0156                               	
39m0156                               	                                        ;Note: GETADR expands to 2 words
39m0156 03760 640706200550400440030000	        FIXM2$                          ;OP 770 = VIDIN
39m0156 03761 000141614571000360006246	        D[CONST 36] DEST[DEV-ADR] JUMP[VIDIN]$
39m0156 03762 640706000550400440020000	        FIXM1$                          ;OP 771 = VIDOUT
39m0156 03763 000141614571000360006251	        D[CONST 36] DEST[DEV-ADR] JUMP[VIDOUT]$
39m0156                               	        GETADR[ ;Place the 12-bit value of VIDDPI in Q.
39m0156 03764 640700014171014030000000	        D[CONST (77 & (VIDDPI / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
39m0156 03765 440140014175000530006225	        D[CONST (VIDDPI \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOHIGH]$   ;OP 772 = DPYINI
39m0156                               	
39m0156                               	                                        ;Note: GETADR expands to 2 words
39m0156                               	        GETADR[ ;Place the 12-bit value of VIDDPO in Q.
39m0156 03766 640700014171014040000000	        D[CONST (77 & (VIDDPO / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
39m0156 03767 440140014175000560006225	        D[CONST (VIDDPO \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOHIGH]$   ;OP 773 = DPYOUT
39m0156                               	
39m0156                               	                                        ;Note: GETADR expands to 2 words
39m0156                               	]VID
39m0156                               	        .RELOC
39m0156                               	USE[39m0156                               	XLIST
39m0157                               	 LIST ]]
39m0157                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

40m0157                               	
40m0157                               	;FLOATING POINT, KA10 STYLE.
40m0157                               	;NONDISPATCH CODE.
40m0157                               	.DEFINE CFPLOW[40m0157                               	.DEFINE JINSEXP[40m0157                               	.DEFINE CINSEXP[40m0157                               	.DEFINE CFDS[40m0157                               	
40m0157                               	;***** DON'T USE A-MEM 0 FOR ANYTHING BESIDES DISPATCHES!!!     TVR-Sep80  *****
40m0157                               	;***** This must be fixed!!!!                                   TVR-Sep80  *****
40m0157 06257 640050000551000443000000	UFA1:   ALU[AC] DEST[0 AR] DEST-A-MEM PUSHJ[FADSUB] NORM $
40m0157 06260 640710041171000440000000	        D[10] DEST[AR O_AC] SHORT $
40m0157 06261 000160001571400440602027	        D[AR] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] $
40m0157                               	
40m0157                               	        .PAIR   . \ 2 + .
40m0157                               	];: 6460                ;.PAIR
40m0157 06262 640140001751000440006264	DFN1:   ALU[NOTAC] DEST[AC] JUMP[. + 2] NORM $
40m0157 06263 640700001513000440000000	        ALU[0-AC] DEST[AC] SHORT $
40m0157 06264 640700004171000440000000	        D[MEM] DEST[Q] SHORT $
40m0157 06265 640700010235066110000000	        D[MASK 9] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
40m0157 06266 662104200575000330002032	        D[AR] MASK[27.] ALU[DORQ] DEST[MEMSTO] MEMSTMA OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157                               	
40m0157                               	
40m0157 06267 640160001615000440602027	FSCZAP: ALU[0] DEST[MA AC] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0157 06270 640710000171022110000000	FSC1:   D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
40m0157 06271 531140011661066100000000	        D[MASK 8] ROT[27.] ALU[-D&AC] DEST[AC] COND[-OBUS<0] JUMP[FSC2] C550 $
40m0157 06272 640710010335000110000000	        D[MASK 9] ALU[D#Q] DEST[Q AR] SHORT $
40m0157 06273 640700011561066100000000	        D[MASK 8] ROT[27.] ALU[DORAC] DEST[AC] SHORT $
40m0157 06274 640700224435000220000000	FSC2:   D[MA] MASK[18.] ALU[D+Q] DEST[IR-ADR] SHORT $
40m0157 06275 640040000215000440000000	        ALU[0] DEST[Q] PUSHJ[NRMLIZ] NORM $
40m0157 06276 640040000171066440000000	        CINSEXP [AR] ROT[27.] DEST[Q] PUSHJ[INSEX1] NORM ]$
40m0157 06277 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0157                               	
40m0157                               	FAOS1:
40m0157                               	FAOS5:
40m0157 06300 640050000551000440000000	        ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
40m0157 06301 640160000571000440602027	        DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0157 06302 640050000551000440000000	FAOS2:  ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
40m0157 06303 640140001571400440000000	        CFPLOW [AR] ACSEL[AC+1] DEST[AC] JUMP[FPLOW] NORM ]$
40m0157 06304 640710000551000440000000	FAOS3:  ALU[AC] DEST[AR] NORM $
40m0157 06305 640701614571000110000000	        D[CONST 11] DEST[DEV-ADR] SHORT $
40m0157 06306 640040000551000443000000	        ALU[AC] DEST[0] DEST-A-MEM PUSHJ[FADSUB] NORM $
40m0157 06307 662104241171000440002032	        D[10] DEST[MEMSTO O_AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157 06310 640050000551000440000000	FAOS4:  ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
40m0157 06311 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157                               	
40m0157                               	FMP1:
40m0157                               	FMP5:
40m0157 06312 640050000551000440000000	        ALU[AC] DEST[AR] PUSHJ[FM] NORM $
40m0157 06313 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0157 06314 640050000551000440000000	FMP2:   ALU[AC] DEST[AR] PUSHJ[FM] NORM $
40m0157 06315 640140001571400440000000	        CFPLOW [AR] ACSEL[AC+1] DEST[AC] JUMP[FPLOW] NORM ]$
40m0157 06316 640710000551000440000000	FMP3:   ALU[AC] DEST[AR] NORM $
40m0157 06317 640701614571000110000000	        D[CONST 11] DEST[DEV-ADR] SHORT $
40m0157 06320 640040000551000443000000	        ALU[AC] DEST-A-MEM PUSHJ[FM] DEST[0] NORM $
40m0157 06321 662104241171000440002032	        D[10] DEST[MEMSTO O_AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157 06322 640050000551000440000000	FMP4:   ALU[AC] DEST[AR] PUSHJ[FM] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

40m0157 06323 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157                               	
40m0157                               	;Macro to test for divide by zero
40m0157                               	.DEFINE DIVTST[40m0157                               	
40m0157                               	;;;FD5: D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] NORM $     ;Not needed.  TVR-Apr80
40m0157                               	
40m0157                               	;FDV,FDVR
40m0157 06324 510140004571000330000000	FD1:    DIVTST [MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$ ;Check for divide by zero
40m0157                               	
40m0157 06325 640050004721000440000000	        CFDS [MEM] ALU[D#AC] DEST[AR] PUSHJ[FDS1] NORM]$
40m0157 06326 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0157                               	
40m0157                               	;------------------------------------------------------------------------------
40m0157                               	;LONG MODE FLOATING DIVIDE.
40m0157                               	;------------------------------------------------------------------------------
40m0157 06327 510140004571000330000000	FD2:    DIVTST [MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$
40m0157                               	 ;AR.0,IR.35:=XOR(DIVIDEND SIGN,DIVISOR SIGN).
40m0157 06330 640710004721000440000000	        D[MEM] ALU[D#AC] DEST[AR] SHORT $
40m0157 06331 640700200571002010000000	        D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
40m0157                               	 ;Flush sign & exponent from Dividend Low
40m0157 06332 640710010621400330000000	        D[MASK 27.] ALU[D&AC] ACSEL[AC+1] DEST[AR] SHORT $
40m0157 06333 640700001571422440000000	        D[AR] ROT[9] DEST[AC] ACSEL[AC+1] SHORT $
40m0157                               	 ;Positive form of Dividend to AC, AR; original form to AMEM[1]
40m0157 06334 631150200551000443000000	        ALU[AC] DEST[AR 1] DEST-A-MEM COND[-OBUS<0] JUMP[FD2A] CYLEN[C450] $
40m0157 06335 510140001513400440006337	        ALU[0-AC] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[. + 2] C550 $
40m0157 06336 640150001751000440006340	        ALU[NOTAC] DEST[AC AR] JUMP[. + 2] SHORT $
40m0157 06337 640710001513000440000000	        ALU[0-AC] DEST[AC AR] NORM $
40m0157 06340 640710014421066010000000	FD2A:   D[CONST 1] ROT[27.] ALU[AC+D] DEST[AR] NORM $
40m0157                               	         ;Add 1 to exp. of dividend, since we will do only a 27-bit divide.
40m0157 06341 640701400551400443000000	        ALU[AC] ACSEL[AC+1] DEST[6] DEST-A-MEM NORM $
40m0157                               	         ;Put low-order mantissa in AMEM[6] for FD.
40m0157 06342 640740014571000330000000	        D[CONST 27.] LLOAD NORM $ 
40m0157                               	         ;Do only a 27-bit divide, so remainder will come out right.
40m0157 06343 640040000571000440000000	        PUSHJ[FD] NORM $        
40m0157                               	         ;Perform the divide (returns: AC=quotient, AMEM[6]=remainder)
40m0157                               	 ;AC+1 gets 0 if remainder = 0.
40m0157 06344 510140071571400440000000	        D[16] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[FD2D] C550 $
40m0157                               	 ;Calculate exponent of remainder.
40m0157 06345 531140044171000440006350	        D[11]  DEST[Q] C550 -OBUS<0 JUMP[. + 3] $
40m0157                               	         ;Check sign of dividend, jump if positive.
40m0157 06346 640700200517000443000000	         ALU[0-Q] DEST[1] DEST-A-MEM NORM $
40m0157                               	          ;Negate the dividend (so the exponent will be in pos. form)
40m0157 06347 640700001513400440000000	         ACSEL[AC+1] ALU[0-AC] DEST[AC] NORM $
40m0157                               	          ;Negate the remainder.
40m0157 06350 640700044171022100000000	        D[11] ROT[9.] MASK[8] DEST[Q] NORM $
40m0157                               	         ;Recover exp. of dividend.
40m0157                               	 ;A-MEM[7] has (dividend HOW)-(divisor).
40m0157 06351 531140074571000440006353	        D[17] COND[-OBUS<0] JUMP[. + 2] C550 $
40m0157 06352 640700014077000010000000	         D[CONST 1] ALU[Q-D] DEST[Q] SHORT $
40m0157 06353 453140014077000320000000	        D[CONST 26.] ALU[Q-D] DEST[Q] COND[OBUS18] JUMP[FD2C] C600 $
40m0157                               	         ;Jump if exponent underflow.
40m0157                               	.DEFINE SWAPAC[40m0157                               	
40m0157                               	 ;SWAP QUOTIENT (AC) AND REMAINDER (AC+1)
40m0157                               	        SWAPAC
40m0157                               	;Interchange (AC) and (AC+1)
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

40m0157 06354 640710000551400440000000	        ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
40m0157 06355 640710001171000440000000	        D[AR] DEST[AR O_AC] SHORT $
40m0157 06356 640700001571400440000000	        D[AR] ACSEL[AC+1] DEST[AC] SHORT $
40m0158                               	  ] ;INSERT EXPONENT INTO REMAINDER.
40m0158 06357 640050000555000440000000	        ALU[Q] DEST[AR] PUSHJ[INSEXP] NORM $
40m0158                               	        SWAPAC
40m0158                               	;Interchange (AC) and (AC+1)
40m0158 06360 640710000551400440000000	        ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
40m0158 06361 640710001171000440000000	        D[AR] DEST[AR O_AC] SHORT $
40m0158 06362 640700001571400440000000	        D[AR] ACSEL[AC+1] DEST[AC] SHORT $
40m0159 06363 640160000571000440602027	  ]FD2D:        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0159                               	
40m0159 06364 640160001615400440602027	FD2C:   ALU[0] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0159                               	
40m0159 06365 510140004571000330000000	FD3:    DIVTST [MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$
40m0159 06366 640040000551000443000000	        ALU[AC] DEST[0] DEST-A-MEM PUSHJ[FDS] NORM $
40m0159 06367 662104241171000440002032	        D[10] DEST[MEMSTO O_AC] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0159 06370 510140004571000330000000	FD4:    DIVTST [MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$
40m0159 06371 640050004721000440000000	        CFDS [MEM] ALU[D#AC] DEST[AR] PUSHJ[FDS1] NORM]$
40m0159 06372 662104200551000440002032	        ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0159                               	
40m0159                               	;HERE ON DIVISOR=0.  SET NO DIVIDE, OVF,FLOV,RETURN.
40m0159 06373 640700020171000440000000	FPNDIV: D[PC] DEST[Q] SHORT $
40m0159 06374 640040014175056010000000	        D[CONST 1] ROT[23.] ALU[DORQ] DEST[Q] PUSHJ[SETFOV] NORM $
40m0159 06375 640160000571000440602027	        DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;NORMALIZE DOUBLE PRECISION NUMBER IN AC,Q WHOSE EXPONENT
40m0159                               	; IS IN IR-ADR.  LEAVE EXPONENT IN AR, NORMALIZED NUMBER IN AC,Q.
40m0159                               	; IF NUMBER IS 0, LEAVE 0 IN AR,AC, AND Q.
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	.DEFINE CNORM[40m0159                               	
40m0159                               	;A. Return immediately if 0.
40m0159 06376 510310000545000440000000	NRMLIZ: ALU[QORAC] DEST[AR] COND[OBUS=0] POPJ C550 $
40m0159                               	;B. Check for mantissa overflow, move exponent to AR.
40m0159 06377 640050000551000440000000	        ALU[AC] DEST[AR] PUSHJ[NORMOV] NORM $
40m0159                               	                ;Check mantissa and shift right if necessary
40m0159 06400 530300034571000220000000	        D[IR] MASK[18.] COND[-OBUS=0] POPJ C550 $
40m0159                               	                ;If we adjusted right, then we definitely don't have to
40m0159                               	                ;shift left.  We're done here.
40m0159                               	;C. Left shift until normalized.
40m0159 06401 611140000551000440000000	        ALU[AC] COND[OBUS<0] JUMP[NEGNOR] CYLEN[C450] $
40m0159                               	                ;Separate into two cases, positive and negative
40m0159 06402 530300014621064010000000	POSNOR: D[CONST 1] ROT[26.] ALU[D&AC] COND[-OBUS=0] POPJ C550 $
40m0159                               	                ;If high order bit of mantissa is one, we're done
40m0159 06403 640710000531000440000000	        D[AR] ALU[D-1] DEST[AR] SHORT $
40m0159                               	                ;Decrement the exponent
40m0159 06404 640140003145000020006402	        ALU[SH-AC] MASK[2] DEST[D6] JUMP[POSNOR] NORM $
40m0159                               	                ;Shift left and try again.
40m0159 06405 510140014621064010000000	NEGNOR: D[CONST 1] ROT[26.] ALU[D&AC] COND[OBUS=0] JUMP[NN1] C550 $
40m0159                               	                ;If high order bit of mantissa is zero, we're done
40m0159 06406 640710000531000440000000	        D[AR] ALU[D-1] DEST[AR] SHORT $
40m0159                               	                ;Decrement the exponent
40m0159 06407 640140003145000020006405	        ALU[SH-AC] MASK[2] DEST[D6] JUMP[NEGNOR] NORM $
40m0159                               	                ;Shift left and try again.
40m0159 06410 530300010621000330000000	NN1:    D[MASK 27.] ALU[D&AC] COND[-OBUS=0] POPJ C550 $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

40m0159                               	                ;Check for case of exactly -(2^n).  If it isn't, we're done
40m0159 06411 640700015561064010000000	        D[CONST 1] ROT[26.] ALU[DORAC] DEST[AC] SHORT $
40m0159                               	                ;We went one too far, backup by simply OR'ing in the relevant
40m0159                               	                ;bit in the same manner as shifting would. 
40m0159                               	                ;(*** What about Q??  TVR-Jul80)
40m0159 06412 640310000433000440000000	        D[AR] ALU[D+1] DEST[AR] POPJ NORM $
40m0159                               	                ;Increment exponent to account for simulated left shift.
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;CHECK FOR MANTISSA OVERFLOW INTO EXPONENT FIELD.  CALL WITH
40m0159                               	; AR&AC,Q: # TO NORMALIZE, IR-ADR: ITS EXPONENT.
40m0159                               	; LEAVE EXPONENT IN AR.  SET IR-ADR=0 IF NO OVERFLOW.  SET IR-ADR<>0
40m0159                               	; IF OVERFLOW, AND NORMALIZE.
40m0159                               	;
40m0159                               	;M.O. <=> [AR0<>AR8] OR [(AR8=1) AND (AR9-35=0)]
40m0159                               	;------------------------------------------------------------------------------
40m0159 06413 511140000721020440000000	NORMOV: D[AR] ROT[8] ALU[D#AC] COND[OBUS<0] JUMP[NOVYES] C550 $
40m0159                               	                ;Check to make sure AR<0>=AR<8>.  If they don't, the mantissa
40m0159                               	                ;clearly overlaps the exponent field.
40m0159 06414 530140010621000330000000	        D[MASK 27.] ALU[D&AC] COND[-OBUS=0] JUMP[NOVNO] C550 $
40m0159                               	                ;Check for AR<9:35> for zero.  If not zero, we're OK
40m0159 06415 510140014621066010000000	        D[CONST 1] ROT[27.] ALU[D&AC] COND[OBUS=0] JUMP[NOVNO] C550 $
40m0159                               	                ;Check AR<8>.  If zero, we're OK
40m0159                               	;       \ /
40m0159                               	;Mantissa has overflowed, adjust it.  Right by one should be enough.
40m0159 06416 640700002145000010000000	NOVYES: ALU[SH-AC] MASK[1] DEST[D4] SHORT $
40m0159                               	                ;Shift mantissa right (i think?)
40m0159 06417 640310234433000220000000	        D[IR] MASK[18.] ALU[D+1] DEST[AR IR-ADR] POPJ NORM $
40m0159                               	                ;Increment mantissa and flag that we changed it by setting
40m0159                               	                ;IR<18:35> to be non-zero.
40m0159                               	
40m0159                               	;Mantissa has not overflowed.
40m0159 06420 640710034571000220000000	NOVNO:  D[IR] MASK[18.] DEST[AR] SHORT $
40m0159                               	                ;Save exponent in AR
40m0159 06421 640300200615000440000000	        ALU[0] DEST[IR-ADR] POPJ NORM $
40m0159                               	                ;Zero IR<18:35> to signify success
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;INSERT EXPONENT IN AR INTO WORD IN AC.
40m0159                               	;SET FLOV,FLUN,OVF FLAGS AS REQUIRED.
40m0159                               	;PRESERVES AR, CLOBBERS Q.
40m0159                               	;------------------------------------------------------------------------------
40m0159 06422 640700000171066440000000	INSEXP: D[AR] ROT[27.] DEST[Q] NORM $
40m0159                               	                ;Move exponent into position
40m0159 06423 640700010235066100000000	INSEX1: D[MASK 8.] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
40m0159                               	                ;Flush stuff in mantissa area
40m0159 06424 640700001705000440000000	        ALU[Q#AC] DEST[AC] SHORT $
40m0159                               	                ;Fill in exponent (complementing it if (AC) is negative !)
40m0159 06425 513140000571000440000000	        D[AR] COND[OBUS18] JUMP[EXPUF] C550 $
40m0159                               	                ;Check for underflow (i.e. below range of exponent offset)
40m0159 06426 510300000571070120000000	        D[AR] MASK[10.] ROT[28.] COND[OBUS=0] POPJ C550 $
40m0159                               	                ;Check for overflow (i.e. above range of exponent offset)
40m0159 06427 640700020171000440000000	        D[PC] DEST[Q] SHORT $
40m0159                               	                ;Setup to set floating overflow
40m0159 06430 640305414575100110000000	SETFOV: D[CONST 11] ROT[32.] ALU[DORQ] DEST[CRYOV] POPJ NORM $
40m0159                               	                ;Turn on overflow and floating overflow
40m0159 06431 640700020171000440000000	EXPUF:  D[PC] DEST[Q] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

40m0159                               	                ;Setup to set no divide and floating overflow
40m0159 06432 640140014175060010006430	        D[CONST 1] ROT[24.] ALU[DORQ] DEST[Q] JUMP[SETFOV] NORM$
40m0159                               	                ;Turn on no divide, then do overflows
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;FLOATING ADD AC&AR TO MEM.  RESULT, NORMALIZED AND ROUNDED
40m0159                               	; IF REQUIRED IN AC,Q.
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	.DEFINE BLEXPS[40m0159                               	BLEXPS
40m0159                               	        ;A. + FORM EXPONENT OF AC,MEM RTO AR,Q RESP.
40m0159 06433 640710000171022110000000	FADSUB: D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
40m0159 06434 510140014635020010000000	FADSU1: D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS1] C550 $
40m0159 06435 640710010735000110000000	        D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
40m0159 06436 640700004171022110000000	FS1:    D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
40m0159 06437 510140014635020010000000	        D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS2] C550 $
40m0159 06440 640700010335000110000000	        D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
40m0159                               	        ;B. COMPUTE DIFFERENCE, SWAP OPRANDS IF AC HAS LARGER EXP.
40m0159                               	        ;   LEAVE + DIFFERENCE IN Q, DIFF -1 IN LOOP CTR.
40m0159                               	        ;   LEAVE LARGER EXPONENT IN IR-ADR.
40m0159 06441 640700200555000440000000	FS2:    ALU[Q] DEST[IR-ADR] SHORT $
40m0159 06442 471140000077000440000000	        D[AR] ALU[Q-D] DEST[Q] COND[-OBUS<0] JUMP[FS3] C600 $
40m0159 06443 640700200571000440000000	        D[AR] DEST[IR-ADR] SHORT $
40m0159 06444 640704405171000440000000	        D[MEM] DEST[HOLD O_AC] NORM $
40m0159 06445 640700000117000440000000	        ALU[0-Q] DEST[Q] NORM $
40m0159 06446 640750000455000440000000	FS3:    ALU[Q-1] DEST[AR] LLOAD NORM $
40m0159                               	        ;C. BLANK EXPONENTS.
40m0159                               	        BLEXPS[40m0159 06447 511140011561066100006451	        D[MASK 8] ROT[27.] ALU[DORAC] DEST[AC] COND[OBUS<0] JUMP[. + 2] C550 $
40m0159 06450 640700011661066100000000	        D[MASK 8] ROT[27.] ALU[-D&AC] DEST[AC] SHORT $
40m0159 06451 511140004171000440006453	        D[MEM] DEST[Q] COND[OBUS<0] JUMP[. + 2] C550 $
40m0159 06452 640144410675066100006454	        D[MASK 8] ROT[27.] ALU[-D&Q] DEST[HOLD] JUMP[. + 2] NORM $
40m0159 06453 640704410575066100000000	        D[MASK 8] ROT[27.] ALU[DORQ] DEST[HOLD] CYLEN[NORM] $
40m0160                               	]       ;D. IF DELTA EXPONENTS >62., AC GOES TO OBLIVION.
40m0160 06454 450140000033000440000000	        D[AR] ALU[D+1] DEST[Q] COND[OBUS=0] JUMP[FS5] C600 $
40m0160 06455 451140014477000770000000	        D[CONST 63.] ALU[Q-D] COND[OBUS<0] JUMP[FS4] C600 $
40m0160 06456 640700001615000440000000	        ALU[0] DEST[AC] SHORT $
40m0160 06457 640140000215000440000000	        ALU[0] DEST[Q] JUMP[FS5] NORM $
40m0160 06460 640700000215000440000000	FS4:    ALU[0] DEST[Q] SHORT $
40m0160 06461 640240002145000010006461	        ALU[SH-AC] DEST[D4] MASK[1] LOOP [.] NORM $
40m0160                               	        ;E. ADD.
40m0160 06462 640710004421000440000000	FS5:    D[MEM] ALU[D+AC] DEST[AR] SHORT $
40m0160                               	        ;F. NORMALIZE RESULT.
40m0160 06463 640700035571000440000000	        D[IR] DEST[AC] SHORT $  ;CHECK FOR UFA
40m0160 06464 510140014621100010000000	        D[CONST 1] ROT[40] ALU[D&AC] COND[OBUS=0] JUMP[UFANOR] C550 $
40m0160                               	
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;ENTER HERE WITH RESULT IN AR,Q, EXP IN IR-ADR.
40m0160                               	;------------------------------------------------------------------------------
40m0160 06465 640040001571000440006376	FPNAR:  CNORM [AR] DEST[AC] PUSHJ[NRMLIZ] NORM]$                                ;NOPE,
40m0160                               	 NORMALIZE
40m0160                               	;(Calls NRMLIZ which changes register usage from above and adjusts various
40m0160                               	;things.  "LEAVE EXPONENT IN AR, NORMALIZED NUMBER IN AC,Q.")
40m0160                               	;G. ROUND IF NECESSARY, INSERT EXPONENT INTO HIGH ORDER WORD OF RESULT.
40m0160 06466 631144400555000440000000	        ALU[Q] COND[-OBUS<0] DEST[HOLD] JUMP[NORND] CYLEN[C450] $
40m0160                               	                ;Save Q in HOLD (i.e. MEM)
40m0160                               	                ;If Q<0> is zero, don't round
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

40m0160 06467 640700034171000440000000	        D[IR] DEST[Q] NORM $
40m0160                               	                ;Get Q so we check bit meaning rounding (??? Can't this be
40m0160                               	                ;done with D[IR] ROT[7] COND[OBUS<0]... ???)
40m0160 06470 510140014635072010000000	        D[CONST 1] ROT[35] ALU[D&Q] COND[OBUS=0] JUMP[NORND] C550 $
40m0160                               	                ;Check opcode to see if rounding is requested.
40m0160                               	                ;If not, we're done
40m0160 06471 640700004171000440000000	        D[MEM] DEST[Q] SHORT $
40m0160                               	                ;Restore Q
40m0160 06472 530140010635000430000000	        D[MASK 43] ALU[D&Q] COND[-OBUS=0] JUMP[YESRND] C550 $
40m0160                               	                ;Round if Q<1:35> is non-zero (? what does this signify???)
40m0160 06473 611140000551000440006422	        ALU[AC] COND[OBUS<0] JUMP[INSEXP] CYLEN[C450] $
40m0160                               	                ;If mantissa is negative, we don't round (???)
40m0160                               	;       \ /
40m0160 06474 640700200571000440000000	YESRND: D[AR] DEST[IR-ADR] SHORT $
40m0160                               	                ;Setup IR for NRMLIZ
40m0160 06475 640040001413000440006376	        ALU[AC+1] DEST[AC] PUSHJ[NRMLIZ] NORM $
40m0160                               	                ;Increment high order word and normalize once more (???)
40m0160 06476 640140000171066440006423	        JINSEXP [AR] ROT[27.] DEST[Q] JUMP[INSEX1] NORM ]$
40m0160                               	                ;Now stick in exponent
40m0160                               	;       ---
40m0160 06477 640140004171000440006422	NORND:  D[MEM] DEST[Q] JUMP[INSEXP] NORM $
40m0160                               	                ;Restore Q and insert exponent(?)
40m0160                               	
40m0160                               	;UFA NORMALIZATION -- ONLY ON MANTISSA OVERFLOW.
40m0160 06500 450300001575000440000000	UFANOR: D[AR] ALU[DORQ] DEST[AC] COND[OBUS=0] POPJ C600 $
40m0160 06501 640040001571000440006413	        D[AR] DEST[AC] PUSHJ[NORMOV] NORM $
40m0160 06502 640140000171066440006423	        JINSEXP [AR] ROT[27.] DEST[Q] JUMP[INSEX1] NORM ]$
40m0160                               	;       ---
40m0160                               	
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;SETUP LOW ORDER FP RESULT, STORE BOTH IN AC,AC+1
40m0160                               	;ENTER WITH LOW WORD IN MEM, HIGH WORD IN AC, HIGH
40m0160                               	;WORD'S EXPONENT IN AR&AC+1.
40m0160                               	;------------------------------------------------------------------------------
40m0160 06503 640710015463400330000000	FPLOW:  D[CONST 27.] ACSEL[AC+1] ALU[AC-D] DEST[AC AR] SHORT $
40m0160 06504 530140014621416010000000	        D[CONST 1] ROT[7] ACSEL[AC+1] ALU[D&AC] COND[-OBUS=0] JUMP[ZLOW] C550 $
40m0160 06505 510140004171066330000000	        D[MEM] ROT[27.] MASK[27.] DEST[Q] COND[OBUS=0] JUMP[ZLOW] C550 $
40m0160 06506 640700001571466440000000	        D[AR] ROT[27.] ACSEL[AC+1] DEST[AC] SHORT $
40m0160 06507 640700011621466100000000	        D[MASK 8] ROT[27.] ALU[D&AC] ACSEL[AC+1] DEST[AC] SHORT $
40m0160 06510 640160001545400440602027	        ACSEL[AC+1] ALU[QORAC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0160 06511 640160001615400440602027	ZLOW:   ACSEL[AC+1] ALU[0] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0160                               	
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;
40m0160                               	;       FLOATING MULTIPLY.  AC&AR BY MEM.
40m0160                               	;
40m0160                               	;*** This code produces non-zero results if MEM=-1.0 and AC=0  !!!    TVR-Jun80
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;A. SUM OF + FORM EXPONENTS -128.+1 TO IR-ADR.  +1 BECAUSE 28
40m0160                               	; STEPS ARE USED TO PROVIDE ONE GUARD DIGIT.
40m0160 06512 640710000171022110000000	FM:     D[AR] MASK[9] ROT[9] DEST[Q AR] NORM$
40m0160                               	                ;Extract the exponent from AC (which was copied into AR)
40m0160 06513 510140014635020010000000	        D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM1] C550 $
40m0160                               	                ;Check sign bit of number.  Nothing special if positive
40m0160 06514 640710010735000110000000	        D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
40m0160                               	                ;Sign is negative, we want the one-complement of the exponent
40m0160                               	                ;field to get the actual exponent.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

40m0160 06515 640700004171022110000000	FM1:    D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
40m0160                               	                ;Extract the exponent from MEM
40m0160 06516 510140014635020010000000	        D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM2] C550 $
40m0160                               	                ;Check sign bit of number.  Nothing special if positive
40m0160 06517 640700010335000110000000	        D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
40m0160                               	                ;Sign is negative, we want the one-complement of the exponent
40m0160                               	                ;field to get the actual exponent.
40m0160 06520 640700000037000440000000	FM2:    D[AR] ALU[D+Q] CARRY DEST[Q] SHORT $
40m0160                               	                ;Add the two exponents
40m0160                               	                ;+1. FOR GUARD DIGIT.
40m0160 06521 640700214477016010000000	        D[CONST 1] ROT[7] ALU[Q-D] DEST[IR-ADR] SHORT $
40m0160                               	                ;Account for exponent bias.  Put exponent in a safe place.
40m0160                               	;B. BLANK EXPONENTS.
40m0160                               	        BLEXPS[40m0160 06522 511150010561066100006524	        D[MASK 8] ROT[27.] ALU[DORAC] DEST[AR] COND[OBUS<0] JUMP[. + 2] C550 $
40m0160 06523 640710010661066100000000	        D[MASK 8] ROT[27.] ALU[-D&AC] DEST[AR] SHORT $
40m0160 06524 511140004171000440006526	        D[MEM] DEST[Q] COND[OBUS<0] JUMP[. + 2] C550 $
40m0160 06525 640140010275066100006527	        D[MASK 8] ROT[27.] ALU[-D&Q] DEST[Q] JUMP[. + 2] NORM $
40m0160 06526 640700010175066100000000	        D[MASK 8] ROT[27.] ALU[DORQ] DEST[Q] CYLEN[SHORT] $
40m0161                               	]               ;Extend the sign to blank out the exponent field.  We will
40m0161                               	                ;now have perfectly good integers here, of 27 bit magnitude
40m0161                               	                ;(assuming that the numbers were normalized to begin with).
40m0161 06527 640040001615000440000000	        ALU[0] DEST[AC] PUSHJ[TESMUL] NORM $ ;28. STEPS.
40m0161                               	;;;     ALU[Q] DEST[AR] SHORT $ ;FLUSH SIGN IN LO WD.
40m0161 06530 640710010275000070000000	        D[MASK 7] ALU[-D&Q] DEST[Q AR] SHORT $  ;FLUSH SIGN IN LO WD.
40m0161                               	                ;Flush remenants of multiplier in low order part of
40m0161                               	                ;word.  MASK field determined empirically (35-28???)
40m0161 06531 640700000035000440000000	        D[AR] ALU[D+Q] DEST[Q] SHORT $
40m0161                               	                ;Make low order word unsigned.
40m0161 06532 640150000551000440006465	        ALU[AC] DEST[AR] JUMP[FPNAR] NORM $
40m0161                               	
40m0161                               	;28. STEP INTEGER MULTIPLY FOR USE BY FM.
40m0161 06533 640740014571000330000000	TESMUL: D[CONST 27.] LLOAD NORM $       ;LOOP 28 TIMES
40m0161 06534 640140000571000440004067	        JUMP[DOMUL1] NORM $     ;TEST.
40m0161                               	
40m0161                               	;------------------------------------------------------------------------------
40m0161                               	;SHORT STYLE FLOATING DIVIDE AC BY MEM.
40m0161                               	; XOR OF DIVISOR&DIVIDEND SIGNS IN AR BIT 0.
40m0161                               	;------------------------------------------------------------------------------
40m0161 06535 640710004721000440000000	FDS:    D[MEM] ALU[D#AC] DEST[AR] SHORT $
40m0161 06536 640700200571002010000000	FDS1:   D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
40m0161 06537 531150000551000440006541	        ALU[AC] DEST[AR] COND[-OBUS<0] JUMP[. + 2] C550 $
40m0161 06540 640710001513000440000000	        ALU[0-AC] DEST[AC AR] SHORT $
40m0161 06541 640701400615000443000000	        ALU[0] DEST[6] DEST-A-MEM NORM $
40m0161 06542 640740014571000340000000	        D[CONST 28.] LLOAD NORM $ 
40m0161                               	                ;Do only a 28-bit divide.
40m0161                               	
40m0161                               	;------------------------------------------------------------------------------
40m0161                               	;       Floating Divide
40m0161                               	;
40m0161                               	; DIVIDEND HIGH ORDER WORD IN AR, LOW IN A-MEM[6]. DIVISOR IN MEM.
40m0161                               	; BOTH IN POSITIVE FORM.  IR.35=XOR(DIVIDEND SIGN,DIVISOR SIGN).
40m0161                               	;------------------------------------------------------------------------------
40m0161                               	FD:
40m0161                               	;A. PUT DIVISOR IN + FORM, GET DIVISOR EXPONENT.
40m0161                               	;.1 Shuffle IR.35 into A-MEM[4].
40m0161 06543 640701034571000223000000	        D[IR] MASK[18.] DEST[4] DEST-A-MEM NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

40m0161                               	                ;Save IR-ADR in A-MEM
40m0161 06544 531140004171000440006546	        D[MEM] DEST[Q] COND[-OBUS<0] JUMP[. + 2] C550 $
40m0161                               	                ;Check for negative divisor
40m0161 06545 640704404073000440000000	        D[MEM] ALU[0-D] DEST[Q HOLD] NORM $
40m0161                               	                ;Negate divisor
40m0161 06546 640700204571022100000000	        D[MEM] ROT[9] MASK[8] DEST[IR-ADR] NORM $
40m0161                               	                ;Extract exponent from divisor, store in IR<18:35>
40m0161 06547 640704410675066100000000	        D[MASK 8] ROT[27.] ALU[-D&Q] DEST[HOLD] NORM $
40m0161                               	                ;Extract mantissa from divisor
40m0161                               	;B. Fetch and blank HOW Dividend exponent.
40m0161 06550 640700000171022100000000	        D[AR] ROT[9] MASK[8] DEST[Q] NORM $
40m0161                               	                ;Extract dividend exponent.
40m0161 06551 640700001571000330000000	        D[AR] MASK[27.] DEST[AC] SHORT $
40m0161                               	                ;Extract mantissa from dividend
40m0161                               	;C. Compute resultant exponent.
40m0161 06552 640700034077000220000000	        D[IR] MASK[18.] ALU[Q-D] DEST[Q] SHORT $
40m0161                               	                ;Subtract divisor exponent from dividend exponent
40m0161 06553 640700214435016010000000	        D[CONST 1] ROT[7] ALU[D+Q] DEST[IR-ADR] NORM $
40m0161                               	                ;Include exponent offset
40m0161                               	;D. Move LOW Dividend to Q.
40m0161 06554 640700070171000440000000	        D[16] DEST[Q] SHORT $
40m0161                               	;E. If divisor<=dividend,  shift dividend right, increment the
40m0161                               	        ; resultant exponent.  save diff. in A-MEM[7] for long mode.
40m0161 06555 471141604463000443000000	        D[MEM] ALU[AC-D] DEST[7] DEST-A-MEM COND[-OBUS<0] JUMP[FDAD] C600 $
40m0161                               	;F. Save exp in A-MEM[5]
40m0161 06556 640701234571000443000000	FDSHFT: D[IR] DEST[5] DEST-A-MEM NORM $
40m0161 06557 640040000571000440002170	        PUSHJ[DODIV4] NORM $    
40m0161                               	         ;Do the divide. Result DOES NOT have signs adjusted.
40m0161                               	;G. Save remainder in A-MEM[6], put quotient in AC, AR; put 0 in Q.
40m0161 06560 640701400551000443000000	        ALU[AC] DEST[6] DEST-A-MEM NORM $
40m0161 06561 640710001555000440000000	        ALU[Q] DEST[AC AR] SHORT $
40m0161 06562 640700000215000440000000	        ALU[0] DEST[Q] SHORT $
40m0161                               	;H. Prepare to round 28. bit result.
40m0161 06563 640700002145000010000000	        ALU[SH-AC] MASK[1] DEST[D4] SHORT $
40m0161                               	         ;Shift AC,Q rt 1 bit
40m0161 06564 640040264531000440006465	        D[15] ALU[D-1] DEST[IR-ADR] NORM PUSHJ[FPNAR] $ 
40m0161                               	         ;Move exp for FPNAR, normalize and insert exponent into quotient.
40m0161 06565 510300060571000010000000	        D[14] MASK[1] C550 OBUS=0 POPJ $
40m0161                               	         ;Done if positive result.
40m0161 06566 640300001513000440000000	        ALU[0-AC] DEST[AC] NORM POPJ $
40m0161                               	         ;Negate quotient.
40m0161                               	;------------------------------------------------------------------------------
40m0161                               	;HERE WHEN DIVIDEND IS >= DIVISOR.  SHIFT DIVIDEND RIGHT
40m0161                               	; AND INCREMENT RESULTANT AC.  THIS WILL ALLOW DIVIDE TO
40m0161                               	; SUCCEED IF BOTH DIVISOR & DIVIDEND WERE NORMALIZED
40m0161                               	; AND DIVISOR <> 0.
40m0161                               	;------------------------------------------------------------------------------
40m0161 06567 640700002145000020000000	FDAD:   ALU[SH-AC] MASK[2] DEST[D4] SHORT $
40m0161 06570 640140234433000220006556	        D[IR] MASK[18.] ALU[D+1] DEST[IR-ADR] JUMP[FDSHFT] NORM $
40m0161                               	
40m0161                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

41m0161                               	;ADJSP1 ADJSP2 DMOVE2 DMOVN2 DMOVM2 DMVNM2 DMVNM3 DMVNM4 DMVNM5 KAFIXP KAFIXN FIXR1
41m0161                               	 KIFIX1 FIXRN KIFIXN FIXER FIXER1 FIXER2 FIXER3
41m0161                               	;
41m0161                               	;Strays from KI instructions
41m0161                               	;
41m0161                               	
41m0161                               	.REPEAT XUCODE [
41m0161                               	 .USE[XLIST
41m0161                               	 LIST ] ;Squeeze this stuff into the space vacated by MBOOT.
41m0161                               	    ]
41m0161                               	;(ADJSP continued)
41m0161                               	;Left result is negative.  Check right side.
41m0161 05002 640710034421000220000000	ADJSP1: D[IR] MASK[22] ALU[D+AC] DEST[AR] NORM $
41m0161                               	                ;Add right half
41m0161 05003 640700010275000220000000	        D[MASK 22] ALU[-D&Q] DEST[Q] SHORT $
41m0161                               	                ;Isolate left half
41m0161 05004 640710001175000220000000	        D[AR] MASK[22] ALU[DORQ] DEST[O_AC AR] NORM $
41m0161                               	                ;Merge halves and store
41m0161 05005 533160034571000440602027	        D[IR] COND[-OBUS18] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] C550 $
41m0161                               	                ;If E was positive, it wasn't an overflow (just a bad idea)
41m0161                               	                ;Start fetching next instruction
41m0161 05006 511140000571000440002026	        D[AR] COND[OBUS<0] JUMP[MAIN] C550 $
41m0161                               	                ;If original was negative, we're OK.  Start doing next
41m0161                               	                ;instruction if no sign changed in left half
41m0161 05007 640140000571000440004732	        JUMP[PDLO6] NORM $
41m0161                               	                ;ADJSP got a PDLOV
41m0161                               	;ADJSP left result positive
41m0161 05010 640700010275000220000000	ADJSP2: D[MASK 22] ALU[-D&Q] DEST[Q] SHORT $
41m0161                               	                ;Isolate left half
41m0161 05011 000710001175000220000000	        D[AR] MASK[22] ALU[DORQ] DEST[O_AC AR] $
41m0161                               	                ;Merge halves and store
41m0161 05012 513720034571000440600000	        D[IR] COND[OBUS18] SPEC[MA_PC] DEST[MA] C550 $
41m0161                               	                ;If E was negative, it wasn't an overflow (just a bad idea)
41m0161                               	                ;Start fetching next instruction
41m0161 05013 531140000571000440002027	        D[AR] COND[-OBUS<0] JUMP[MAIN1] C550 $
41m0161                               	                ;If original was positive, we're OK.  Start doing next
41m0161                               	                ;instruction if no sign changed in left half
41m0161 05014 640140000571000440004732	        JUMP[PDLO6] NORM $
41m0161                               	                ;ADJSP got a PDLOV
41m0161                               	
41m0161                               	;(DMOVE continued)
41m0161 05015 640720024433000440000000	DMOVE2: D[MA] ALU[D+1] DEST[MA] NORM $  ;Fetch second word
41m0161 05016 640706000550400440020000	        FIXM1 $                 ;Complete fetch
41m0161 05017 640160005571400440602027	        ACSEL[AC+1] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
41m0161                               	                ;Put it in the second AC and start next instruction
41m0161                               	
41m0161                               	;(DMOVN continued)
41m0161 05020 640720024433000440000000	DMOVN2: D[MA] ALU[D+1] DEST[MA] NORM $  ;Fetch second word
41m0161 05021 640706000550400440020000	        FIXM1 $ ;Complete fetch
41m0161 05022 640720005473400440600000	        ACSEL[AC+1] D[MEM] ALU[0-D] DEST[AC MA] SPEC[MA_PC] CYLEN[FIXM+1] $
41m0161                               	                ;Negate low order word and put it in the second AC
41m0161                               	                ;Start next instruction fetch (Note that DEST[MA] is
41m0161                               	                ;really associated with SPEC[MA_PC])
41m0161                               	                ;*** Is FIXM+1 really the right thing???
41m0161                               	        ACSEL[AC+1] D[MASK 1] ROT[35.] ALU[-D&AC] DEST[AC]
41m0161 05023 670140011661506010002027	                        COND[-OBUS=0] JUMP[MAIN1] NORM $
41m0161                               	                ;Clear stupid bit 0.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

41m0161                               	                ;If the low order part is non-zero, we're done
41m0161 05024 500140001413000441202027	        ACSEL[AC] ALU[AC+1] DEST[AC] SPEC[CRYOV] JUMP[MAIN1] C550 $
41m0161                               	                ;Increment high order word and we're finally done.
41m0161                               	
41m0161                               	;(DMOVEM continued)
41m0161                               	        .PAIR
41m0161                               	. \ 2 + .
41m0162 05026 640700005571000440000000	]DMOVM2:        CYLEN[MEMSTO] ACSEL[AC] D[MEM] DEST[AC] NORM $
41m0162                               	                ;Write it also in the AC
41m0162 05027 640720024433000440000000	        CYLEN[MEMSTO] D[MA] ALU[D+1] DEST[MA] $
41m0162                               	                ;Setup to write second word
41m0162 05030 662104200551400440002032	        ACSEL[AC+1] ALU[AC] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
41m0162                               	                ;Write secord word.
41m0162                               	
41m0162                               	;(DMOVNM continued)
41m0162 05031 640700000113400440000000	DMVNM2: ACSEL[AC+1] ALU[0-AC] DEST[Q] SHORT $
41m0162                               	                ;Negate low order word.
41m0162                               	        ACSEL[AC+1] D[MASK 1] ROT[35.] ALU[-D&Q] DEST[Q]
41m0162 05032 670140010275506010000000	                        COND[-OBUS=0] JUMP[DMVNM4] NORM $
41m0162                               	                ;Clear stupid bit 0.
41m0162                               	                ;If the low order part is non-zero, no change needed to
41m0162                               	                ;high order word.
41m0162                               	        D[AR] ALU[AC+1] DEST[AR STRT-WRT] SPEC[CRYOV]
41m0162 05033 662154000413000441200000	                COND[-MA-AC] JUMP[DMVNM5] NORM $
41m0162                               	                ;Increment high order word and start first store
41m0162 05034 000140005570400440000000	DMVNM3: ACSEL[MA] D[MEM] DEST[AC] JUMP[DMVNM5] $
41m0162                               	                ;Store is to an AC, write into 2901.
41m0162 05035 002144000571000440005034	DMVNM4: DEST[STRT-WRT] COND[MA-AC] JUMP[DMVNM3] $
41m0162                               	                ;Start first store.  Jump if to an AC
41m0162 05036 640720024433000440000000	DMVNM5: D[MA] ALU[D+1] DEST[MA] NORM $
41m0162                               	                ;Finish write.  Note that due to FIXM2, we don't have to
41m0162                               	                ;worry about map faults.
41m0162                               	                ;Prepare for secord write
41m0162 05037 662104200555000440002032	        ALU[Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
41m0162                               	                ;Do final write (low order word into (E+1))
41m0162                               	
41m0162                               	;KAFIX (Opcode 247) continued
41m0162                               	;Positive number to fix
41m0162 05040 030040034171066110000000	KAFIXP: D[IR] ROT[27.] MASK[9.] DEST[Q] COND[-OBUS=0] PUSHJ[FIXER] $
41m0162                               	                ;Extract exponent adjustment factor and do fixing
41m0162 05041 640160001555000440602027	        ACSEL[AC] ALU[Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Put result into AC and we're done
41m0162                               	;Negative number to fix
41m0162 05042 030040034171066110000000	KAFIXN: D[IR] ROT[27.] MASK[9.] DEST[Q] COND[-OBUS=0] PUSHJ[FIXER] $
41m0162                               	                ;Extract exponent adjustment factor and do fixing
41m0162                               	;;;     ACSEL[AC] D[MASK R] ALU[D/#Q] DEST[AC MA]       ;*** Assembler loses!
41m0162                               	        ACSEL[AC] D[2] MASK[R] ALU[D/#Q] DEST[AC MA]    ;Sigh...
41m0162 05043 640160011775001000602027	                        SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Put sign extended result into AC and we're done
41m0162                               	
41m0162                               	;(FIXR continued)
41m0162 05044 511140004571000440000000	FIXR1:  D[MEM] COND[OBUS<0] JUMP[FIXRN] C550 $
41m0162                               	                ;Round different directions
41m0162 05045 640050015435074200006433	        D[CONST 20] ROT[30.] ALU[D+Q] DEST[AC AR] PUSHJ[FADSUB] NORM $
41m0162                               	                ;Positive. Finish making constant 0.5 and add it
41m0162 05046 640700014171000330000000	        D[CONST 33] DEST[Q] SHORT $
41m0162                               	                ;Start making magic constant
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

41m0162 05047 640154400551000440000000	        ALU[AC] DEST[AR HOLD] JUMP[FIXR2] NORM $
41m0162                               	                ;Setup for FIXER.  Rest is same as KIFIX
41m0162                               	;       ---
41m0162 05050 640050015537074600006433	FIXRN:  D[CONST 60] ROT[30.] ALU[D-Q] DEST[AC AR] PUSHJ[FADSUB] NORM $
41m0162                               	                ;Negative. Finish making constant -0.5 and add it
41m0162 05051 640700014171000330000000	        D[CONST 33] DEST[Q] SHORT $
41m0162                               	                ;Start making magic constant
41m0162 05052 640700014175014020000000	        D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] SHORT $
41m0162                               	                ;Finish making magic constant
41m0162 05053 640054400513000440000000	        ALU[0-AC] DEST[AR HOLD] PUSHJ[FIXER] NORM $
41m0162                               	                ;Setup for FIXER
41m0162 05054 640160001517000440602027	        ACSEL[AC] ALU[0-Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Negate it back again and start next instruction
41m0162                               	;       ---
41m0162                               	;(KIFIX continued)
41m0162 05055 511150004571000440000000	KIFIX1: D[MEM] DEST[AR] COND[OBUS<0] JUMP[KIFIXN] C550 $
41m0162                               	                ;Load up things for FIXER, check for positive mantissa
41m0162 05056 640040014175014020000000	FIXR2:  D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] PUSHJ[FIXER] NORM $
41m0162                               	                ;Finish making magic constant and do fix.
41m0162 05057 640160001555000440602027	        ACSEL[AC] ALU[Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Put result into AC and we're done
41m0162                               	;       ---
41m0162                               	;       ---
41m0162 05060 640700014175014020000000	KIFIXN: D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] SHORT $
41m0162                               	                ;Finish making magic constant
41m0162 05061 640054404473000440000000	        D[MEM] ALU[0-D] DEST[HOLD AR] PUSHJ[FIXER] NORM $
41m0162                               	                ;ABS to both MEM and AR.  Fix the number
41m0162 05062 640160001517000440602027	        ACSEL[AC] ALU[0-Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Negate it back again and start next instruction
41m0162                               	
41m0162                               	
41m0162                               	;Fix a number (without sign extension) in MEM, AR=ABS(MEM), Q=magic number
41m0162                               	;(233 for normal fix)
41m0162                               	FIXER:  D[AR] ROT[9] MASK[9] ALU[D-Q] DEST[ROTR Q]
41m0162 05063 511141200137022110000000	                        COND[OBUS<0] JUMP[FIXER2] C550 $
41m0162                               	                ;Calculate number of positions to move
41m0162                               	                ;Jump if we'll be shifting right (n<2^26)
41m0162 05064 640701414435000330000000	        D[CONST 27.] ALU[D+Q] DEST[MASKR] NORM $
41m0162                               	                ;Construct appropriate mask
41m0162 05065 640704404571000330000000	        D[MEM] MASK[27.] DEST[HOLD] NORM $
41m0162                               	                ;Flush exponent, our mask won't reach.
41m0162 05066 511140014477000110000000	        D[CONST 9.] ALU[Q-D] COND[OBUS<0] JUMP[FIXER1] C550 $
41m0162                               	                ;Check for overflow
41m0162                               	;;; Set overflow here.  What kind?  (We can live without it for KAFIX, since it
41m0162                               	;;; never did check, but when KIFIX is done, this will have to be corrected.)
41m0162 05067 640040014555106010006147	        D[CONST 1] ROT[35.] ALU[Q] PUSHJ[QORCRY] NORM $
41m0162                               	                ;Set overflow flag.
41m0162 05070 640701414571000440000000	        D[CONST 44] DEST[MASKR] NORM $
41m0162                               	                ;For those losers who want to see some of the number...
41m0162                               	;Now that we know how much to shift things, do it and return.
41m0162 05071 640300004171201000000000	FIXER1: D[MEM] ROT[R] MASK[R] DEST[Q] NORM POPJ $
41m0162                               	                ;Gee, that was fast.
41m0162                               	;Negative, shift count, the easy case.
41m0162 05072 011141414435000330000000	FIXER2: D[CONST 27.] ALU[D+Q] DEST[MASKR] COND[OBUS<0] JUMP[FIXER3] $
41m0162                               	                ;Construct appropriate mask.  If !x!<1, return zero
41m0162 05073 640141214435000440005071	        D[CONST 36.] ALU[D+Q] DEST[ROTR] JUMP[FIXER1] NORM $
41m0162                               	                ;Hardware doesn't believe in negative shift counts
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

41m0162                               	;Number is fractional, i.e. shift would go off the end.  Return zero
41m0162 05074 640301400215000440000000	FIXER3: ALU[0] DEST[Q MASKR] SHORT POPJ $
41m0162                               	                ;Just return zero.  Set mask just in case
41m0162                               	
41m0162                               	.REPEAT XUCODE [
41m0162                               	  .USE[41m0162                               	XLIST
41m0162                               	 LIST ]   ];FLTR, continued
41m0162 06571 640700014171000330000000	FLTR1:  D[CONST 33] DEST[Q] SHORT $
41m0162 06572 640700214575014020000000	        D[CONST 2] ROT[6] ALU[DORQ] DEST[IR-ADR] NORM $
41m0162                               	                ;Make magic constant for exponent
41m0162 06573 000040000215000440006465	        ALU[0] DEST[Q] PUSHJ[FPNAR] $
41m0162                               	                ;Clear low order word
41m0162                               	                ;Normalize and round (happens to have same bit on as FxxR)
41m0162                               	                ;Result goes to AC
41m0162 06574 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
41m0162                               	                ;Start next instruction fetch
41m0162                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

42m0162                               	
42m0162                               	;;; Device 6 service assembled regardless of whether Tymnet, DR-11,
42m0162                               	;;; or neither is being supported.
42m0162                               	
42m0162                               	;;; Define subdevices of the CFT board for the TYMNET interface
42m0162                               	;;; The first two, if written, reset the interrupt requests.
42m0162                               	
42m0162                               	  .REPEAT OTP [
42m0162                               	;OTP
42m0162                               	
42m0162                               	  .REPEAT NTP [
42m0162       17	TNODIFS = 17    ;OUTPUT DONE INTERRUPT FF SUBSEL = REQ B
42m0162       16	TNIRIFS = 16    ;INPUT READY INTERRUPT FF SUBSEL = REQ A.
42m0162       15	TYM.LD = 15     ;MAPF value for loading output register.
42m0162       5	TYM.RD = 5      ;MAPF value for reading input register.
42m0162                               	  ];NTP
42m0162                               	
42m0162                               	;;; Location 2141 is where device 6 interrupts come.
42m0162                               	
42m0162       6575	TYMFOO = .
42m0162                               	        .ORG[42m0162                               	XLIST
42m0163                               	 LIST ] ;Prepare to call MAPOFF by re-loading DEV-ADR.
42m0163 02141 640141614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM JUMP[TNI] $       
42m0163                               	
42m0163                               	        .USE[XLIST
42m0163                               	 LIST ]
42m0163                               	
42m0163                               	.REPEAT 1 - TYMNET - DR11P [
42m0163                               	1 - TYMNET - DR11P
42m0163                               	
42m0163                               	;;; Device 6 control register hacking.
42m0163                               	;;; Register 1 in device 6's A memory contains the state of the
42m0163                               	;;; control register, since we can't read it back.
42m0163                               	
42m0163                               	;;; Q contains mask for bits not to be changed.  Remaining bits are cleared.
42m0163                               	;;; On return, Q has new value of output register and AR is zeroed.
42m0163 06575 640150000615000440000000	DEV6CL: ALU[0] DEST[AR] NORM JUMP[DEV6ST] $
42m0163                               	
42m0163                               	;;; Q contains mask for bits not to be changed.
42m0163                               	;;; Remaining bits are loaded from AR.
42m0163                               	;;; On return, Q has new value of output register.
42m0163 06576 640701614571000060000000	DEV6ST: D[CONST 6] DEST[DEV-ADR] NORM $
42m0163                               	;;; Enter here if device address already set up to 6.
42m0163 06577 640700044235000440000000	DEV6ST1: D[11] ALU[D&Q] DEST[Q] NORM $                  ;Get AMEM(1), mask it.
42m0163 06600 640702200175000443600000	DEV6ST2: D[AR] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] NORM $       ;Or in new data
42m0163 06601 440300200555000443150000	        MAPF[TYM.LD] ALU[Q] DEST[1] DEST-A-MEM CYLEN[IOB-OUT] POPJ $
42m0163                               	
42m0163                               	.REPEAT TYMNET [
42m0163                               	.INSERT TYMNET.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:TYMNET.SLO  --  of -- F2X

01m0001                               	
01m0001                               	;TYMNET INTERFACE.
01m0001                               	
01m0001       7600	TYMORG = 7600   ;Where to assemble fixed part of TYMNet code.
01m0001                               	
01m0001                               	;A-MEM USAGE.
01m0001                               	; 0: STANDARD.
01m0001                               	; 1: STATE OF OUTPUT FFS (SEE CFTNET)
01m0001                               	; 2: OUTPUT COROUTINE ADR (LO 6 BITS)
01m0001                               	; 3: INPUT COROUTINE ADR (LO 6 BITS)
01m0001                               	; 4: CURRENT -10 WORD BEING OUTPUT (FOR STATE 1 ONLY)
01m0001                               	; 5: CURRENT -10 WORD BEING ASSEMBLED ON INPUT (STATE 1)
01m0001                               	; 6: IOWD FOR PACKET CURRENTLY BEING READ
01m0001                               	; 7: B0-2, STATE OF MAP BEFORE INT; B3-35, INP REG AT INT START
01m0001                               	
01m0001                               	;MAIN MEMORY LOCATIONS:
01m0001                               	; 2000/ KEY:    0               ;FLAGS
01m0001                               	; 2200/ IRING: BLOCK 200        ;INPUT (TO HOST) RING
01m0001                               	; 2400/ ORING: BLOCK 400        ;OUTPUT (FROM HOST) RING
01m0001                               	; 2005/ HIRP:  0        ;HOST IRING PTR (TAKER)
01m0001                               	; 2006/ BIRP:  0        ;BASE IRING PTR (PUTTER)
01m0001                               	; 2011/ HORP:  0        ;HOST ORING PTR (PUTTER)
01m0001                               	; 2012/ BORP:  0        ;BASE ORING PTR (TAKER)
01m0001                               	
01m0001                               	;DR11C FLAG NAMES.  (FIELD VALUES).
01m0001                               	;THE ACTUAL DEFINITIONS ARE IN CFDEF.SLO
01m0001                               	;TNODIBN=2      ;OUTPUT DONE ROTATE AMOUNT (INPUT) = REQ B.
01m0001                               	;TNIRIBN=3      ;INPUT READY ROTATE AMOUNT (INPUT) = REQ A.
01m0001                               	;TNODOBN=6      ;OUTPUT DONE ROTATE AMOUNT (OUTPUT) = CSR1.
01m0001                               	;TNODOBNPO=7
01m0001                               	;TNIROBN=7      ;INPUT READY ROTATE AMOUNT (OUTPUT) = CSR0.
01m0001                               	;TNIROBNPO=10
01m0001                               	
01m0001                               	
01m0001                               	.DEFINE TNOCEC[01m0001                               	.DEFINE GBORP[01m0001                               	.DEFINE GHORP[01m0001                               	.DEFINE GBIRP[01m0001                               	.DEFINE GHIRP[01m0001                               	
01m0001                               	
01m0001                               	;HERE TO SERVICE INPUT READY OR OUTPUT DONE INTERRUPT BY
01m0001                               	; TYMNET INTERFACE.
01m0001                               	        ;SAVE MAP STATE IN A-MEM[7].0-2 & TURN MAP OFF.
01m0001 06602 640042400571000443405402	TNI:    DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] NORM PUSHJ[MAPOFF] $
01m0001 06603 440710034571000030100000	        D[IR] MASK[3] DEST[AR] MAPF[10] CYLEN[IOB-OUT] $        ;MAPOFF NEEDS MAPF,
01m0001                               	 CYLEN.
01m0001 06604 640700000171102440000000	        D[AR] ROT[41] DEST[Q] NORM $
01m0001 06605 640701614571000063400000	        D[CONST 6] DEST[DEV-ADR] SPEC[IOB-IN] NORM $ ;BACK TO 6 FOR TN
01m0001                               	
01m0001                               	        ;SAVE INPUT REG IN A-MEM[7].
01m0001 06606 140710030571000410050000	        MAPF[TYM.RD] D[IOD] MASK[41] DEST[AR] CYLEN[IOB-IN] $
01m0001 06607 640701600175000443000000	        D[AR] ALU[DORQ] DEST[Q 7] DEST-A-MEM NORM $
01m0001 06610 510140014635004010000000	        D[CONST 1] ROT[TNODIBN] ALU[D&Q] COND[OBUS=0] JUMP[TNI1] C550 $
01m0001 06611 440700014171014763600000	        D[CONST (TYMORG / 100)] ROT[6] DEST[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
01m0001 06612 511140050575000440176614	        D[12] ALU[DORQ] COND[OBUS<0] JUMP[. + 2] MAPF[TNODIFS] C550 $   ;OUTPUT DONE.
01m0001 06613 500540050575000440000000	        D[12] ALU[DORQ] SDISP C550 $    ;OUTPUT DONE.
SLOE   Jan ***, 1859 00:00:03  file DSK:TYMNET.SLO  --  of -- F2X

01m0001 06614 640700074171000440000000	TNI0:   D[17] DEST[Q] NORM $    ;RESTORE INP REG
01m0001 06615 510140014635006010000000	TNI1:   D[CONST 1] ROT[TNIRIBN] ALU[D&Q] COND[OBUS=0] JUMP[TNI2] C550 $
01m0001 06616 640040074171070200000000	        D[17] ROT[34] MASK[20] DEST[Q] PUSHJ[BITREV] NORM $
01m0001 06617 440700014171014763600000	        D[CONST (TYMORG / 100)] ROT[6] DEST[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
01m0001 06620 551140054575000440166622	        D[13] ALU[DORQ] COND[OBUS<0] JUMP[. + 2] MAPF[TNIRIFS] CYLEN[C500] $    ;INPUT
01m0001                               	 READY.
01m0001 06621 540540054575000440000000	        D[13] ALU[DORQ] SDISP CYLEN[C500] $     ;INPUT READY.
01m0001 06622 640702274571006030000000	TNI2:   D[17] ROT[3] MASK[3] DEST[IOD] NORM $
01m0001 06623 640141600615000443605401	        ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] JUMP[MPOFF1] NORM $  ;ENDS UP AT MAIN.
01m0001                               	
01m0001                               	;VARIOUS SUBROUTINES.
01m0001                               	;Q LOADED WITH 16. BIT WORD TO SEND, SHIFTED LEFT BY 8.
01m0001 06624 640710000555000440000000	TNSEND: ALU[Q] DEST[AR] NORM $
01m0001 06625 640040000171070440000000	        D[AR] ROT[34] DEST[Q] PUSHJ[BITREV] NORM $
01m0001 06626 640700000171020440000000	        D[AR] ROT[8] DEST[Q] SHORT $
01m0001 06627 640710010635020200000000	        D[MASK 16.] ROT[8] ALU[D&Q] DEST[AR] NORM $
01m0001 06630 640040010171000100006577	        D[MASK 8] DEST[Q] PUSHJ[DEV6ST1] NORM $
01m0001                               	        ;CLEAR THEN SET INPUT READY FLAG TO DR11C.
01m0001 06631 640040010171020430006575	        D[MASK 43] ROT[TNIROBNPO] DEST[Q] PUSHJ[DEV6CL] NORM $
01m0001 06632 640150014571016010006600	        D[CONST 1] ROT[TNIROBN] DEST[AR] NORM JUMP[DEV6ST2] $
01m0001                               	;NO OUTPUT TO DO.  DO NOT CHANGE TNIROBN, SET A-MEM FLAG FOR
01m0001                               	; CLOCK ROUTINE.
01m0001 06633 640140400741000443006614	TNORE:  ALU[-1] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
01m0001                               	;READ WORD FROM BASE-HOST COMMUNICATION AREA, LOCATION 20XX;
01m0001                               	; Q HAS XX.
01m0001 06634 640720014575014200000000	TNRCW:  D[CONST 20] ROT[6] ALU[DORQ] DEST[MA] NORM $
01m0001 06635 640306000550400440000000	        FIXM0 POPJ $
01m0001                               	
01m0001                               	;HERE WHEN INPUT RING FULL.  SET CLOCK FLAG AND RETURN WITHOUT
01m0001                               	; SETTING TNODOBN.
01m0001 06636 640140600741000443006622	TNIRF:  ALU[-1] DEST[3] JUMP[TNI2] DEST-A-MEM NORM $
01m0001                               	;CLEAR THEN SET TNODOBN.
01m0001                               	TNCASODOF:
01m0001 06637 640040010171016430006575	        D[MASK 43] ROT[TNODOBNPO] DEST[Q] PUSHJ[DEV6CL] NORM $
01m0001 06640 640150014571014010006600	        D[CONST 1] ROT[TNODOBN] DEST[AR] NORM JUMP[DEV6ST2] $
01m0001                               	
01m0001                               	.REPEAT SLOWTAPE [
01m0001                               	;SLOWTAPE
01m0001                               	
01m0001                               	.REPEAT 1 - SLOWTAPE [
01m0001                               	
01m0001 06641 640310010235000200000000	BITREV: D[MASK 20] ALU[D&Q] DEST[Q AR] NORM POPJ $
01m0001                               	
01m0001                               	 ]
01m0001                               	        .ORG[XLIST
01m0001                               	 LIST ];$*$*$* Dispatch mechanism is a real loser here.  We
01m0001                               	                        ;       won't be able to flush this one until
01m0001                               	                        ;       references are made relative.  Essentially,
01m0001                               	                        ;       [xx & 77] gets replaced by [. - TNOC0] and
01m0001                               	                        ;       TNOC0 is kept in a A-MEM for speed.  Then,
01m0001                               	                        ;       instead of D[CONST 71] ROT[6] ALU[DORQ], one
01m0001                               	                        ;       uses D[10 + x] ALU[D+Q] to do the dispatch.
01m0001                               	;********** OUTPUT DONE CO-ROUTINE.
01m0001                               	;A-MEM[4] = ROTATED -10 WORD WITH -11 WORD JUST SENT IN 12-27.
01m0001                               	;STATE 0: FETCH NEXT -10 WORD OR QUIT IF RING EMPTY.
01m0001                               	TNOC0:  GBORP
01m0001 07600 640040014171000120006634	        D[CONST 12] DEST[Q] PUSHJ[TNRCW] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:TYMNET.SLO  --  of -- F2X

01m0002 07601 640710004571000440000000	]       D[MEM] DEST[AR] NORM $
01m0002                               	TNOC0A: GHORP
01m0002 07602 640040014171000110006634	        D[CONST 11] DEST[Q] PUSHJ[TNRCW] NORM $
01m0003 07603 640700000171000440000000	]       D[AR] DEST[Q] NORM $
01m0003 07604 450140004537000440006633	        D[MEM] ALU[D-Q] COND[OBUS=0] JUMP[TNORE] C600 $
01m0003 07605 640720014435014240000000	        D[CONST 24] ROT[6] ALU[D+Q] DEST[MA] NORM $
01m0003 07606 640706000550400440000000	        FIXM0 $
01m0003 07607 640041004171060443006624	        D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
01m0003 07610 640140414571000113006614	        D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
01m0003                               	;CLOCK RESTARTS COROUTINE HERE.
01m0003                               	TNOC2:  TNOCEC
01m0003                               	;SEND 0 BYTE IF ESCAPE WORD (-1) JUST SENT.
01m0003 07611 640700060171070200000000	        D[14] ROT[34] MASK[20] DEST[Q] NORM $
01m0003 07612 530140010735000200007615	        D[MASK 20] ALU[D#Q] COND[-OBUS=0] JUMP[. + 3] C550 $
01m0003 07613 640040000215000440006624	        ALU[0] DEST[Q] PUSHJ[TNSEND] NORM $
01m0003 07614 640140414571000153006614	        D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
01m0004                               	];STATE 1: SEND LOW ORDER HALF OF -10 WORD.
01m0004 07615 640700060171040440000000	        D[14] ROT[20] DEST[Q] NORM $
01m0004 07616 640041000555000443006624	        ALU[Q] DEST[4] PUSHJ[TNSEND] DEST-A-MEM NORM $
01m0004 07617 640140414571000203006614	        D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
01m0004                               	        TNOCEC
01m0004                               	;SEND 0 BYTE IF ESCAPE WORD (-1) JUST SENT.
01m0004 07620 640700060171070200000000	        D[14] ROT[34] MASK[20] DEST[Q] NORM $
01m0004 07621 530140010735000200007624	        D[MASK 20] ALU[D#Q] COND[-OBUS=0] JUMP[. + 3] C550 $
01m0004 07622 640040000215000440006624	        ALU[0] DEST[Q] PUSHJ[TNSEND] NORM $
01m0004 07623 640140414571000243006614	        D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
01m0005                               	]       GBORP
01m0005 07624 640040014171000120006634	        D[CONST 12] DEST[Q] PUSHJ[TNRCW] NORM $
01m0006 07625 640700004033000440000000	]       D[MEM] ALU[D+1] DEST[Q] NORM $
01m0006 07626 640154210635000100007602	        D[MASK 8] ALU[D&Q] DEST[AR MEMSTO] JUMP[TNOC0A] CYLEN[MEMSTO] $
01m0006                               	
01m0006                               	;********** INPUT READY CO-ROUTINE.
01m0006                               	; A-MEM[5] HAS CURRENT INPUT WORD BEING ASSEMBLED.
01m0006                               	;STATE 0: AWAITING START OF NEXT MESSAGE.
01m0006                               	
01m0006 07627 640720014571022020000000	TNIC0:  D[CONST 2] ROT[9] DEST[MA] NORM $ ;ADDRESS OF KEY IN MAIN MEM.
01m0006 07630 640704200615000440000000	        ALU[0] DEST[MEMSTO] NORM $ ;CLEAR KEY AT START OF EVERY MESSAGE
01m0006 07631 640701200171000443000000	        D[AR] DEST[Q 5] DEST-A-MEM NORM $
01m0006 07632 510140014635036010000000	        D[CONST 1] ROT[17] ALU[D&Q] COND[OBUS=0] JUMP[TNIC0A] C550 $
01m0006                               	;DATA PACKET MESSAGE.
01m0006 07633 640700000171070070000000	        D[AR] ROT[34] MASK[7] DEST[Q] SHORT $
01m0006 07634 640710014435000050000000	        D[CONST 5] ALU[D+Q] DEST[AR] SHORT $
01m0006 07635 640701400571104223000000	        D[AR] ROT[42] MASK[18.] DEST[6] DEST-A-MEM NORM $
01m0006 07636 640710064571000440000000	        D[15] DEST[AR] SHORT $
01m0006                               	;READ MSG.  A-MEM[6]:=# -10 WORDS IN MESSAGE.
01m0006                               	; AR:=FIRST -11 WORD IN MESSAGE.
01m0006                               	TNICRM:
01m0006                               	        GBIRP
01m0006 07637 640040014171000060006634	        D[CONST 6] DEST[Q] PUSHJ[TNRCW] NORM $
01m0007 07640 640700070073044440000000	]       D[16] ROT[18.] ALU[0-D] DEST[Q] NORM $
01m0007 07641 640701404575000223000000	        D[MEM] MASK[18.] ALU[QORD] DEST[6] DEST-A-MEM NORM $
01m0007                               	;STATE 1: HO 16 BITS OF WORD ARRIVES.
01m0007 07642 640701200571050443000000	TNIC1:  D[AR] ROT[24] DEST[5] DEST-A-MEM NORM $
01m0007                               	        GHIRP
01m0007 07643 640040014171000050006634	        D[CONST 5] DEST[Q] PUSHJ[TNRCW] NORM $
01m0008 07644 640700070033000440000000	]       D[16] ALU[D+1] DEST[Q] NORM $
01m0008 07645 640700010235000070000000	        D[MASK 7] ALU[D&Q] DEST[Q] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:TYMNET.SLO  --  of -- F2X

01m0008 07646 450140004537000440006636	        D[MEM] ALU[D-Q] COND[OBUS=0] JUMP[TNIRF] C600 $
01m0008 07647 640040000571000440006637	        PUSHJ[TNCASODOF] NORM $
01m0008 07650 640140614571000513006622	        D[CONST[. & 77 + 1]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $
01m0008                               	;STATE 2: LO 16 BITS OF WORD ARRIVES.
01m0008                               	; ALSO STARTED HERE BY CLOCK ROUTINE.
01m0008 07651 640700070171000070000000	TNIC2:  D[16] MASK[7] DEST[Q] NORM $
01m0008 07652 640720014435014220000000	        D[CONST 22] ROT[6] ALU[D+Q] DEST[MA] NORM $
01m0008 07653 640700064171000440000000	        D[15] DEST[Q] NORM $
01m0008 07654 640704200575010440000000	        D[AR] ROT[4] ALU[DORQ] DEST[MEMSTO] NORM $
01m0008 07655 640040000571000440006637	        PUSHJ[TNCASODOF] NORM $
01m0008 07656 640700070033000440000000	        D[16] ALU[D+1] DEST[Q] CYLEN[MEMSTO] $
01m0008 07657 471141414435044013000000	        D[CONST 1] ROT[18.] ALU[D+Q] DEST[6] DEST-A-MEM COND[-OBUS<0] JUMP[TNICDN] C600 $
01m0008                               	
01m0008 07660 640140614571000423006622	        D[CONST[77 & TNIC1]] DEST[3] JUMP[TNI2] DEST-A-MEM NORM $
01m0008                               	
01m0008                               	 .RELOC
01m0008                               	USE[01m0008                               	XLIST
01m0009                               	 LIST ]]
01m0009 06642 640700014171000060000000	TNICDN: D[CONST 6] DEST[Q] SHORT $
01m0009 06643 640720014575014200000000	        D[CONST 20] ROT[6] ALU[DORQ] DEST[MA] SHORT $
01m0009 06644 640704270571000070000000	        D[16] MASK[7] DEST[MEMSTO] NORM $
01m0009 06645 640140614571000273006622	        D[CONST[TNIC0 & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] CYLEN[MEMSTO] $
01m0009                               	;1 WD OR 2 WD OR ESCAPE MESSAGE.
01m0009 06646 530140014635034010000000	TNIC0A: D[CONST 1] ROT[16] ALU[D&Q] COND[-OBUS=0] JUMP[TNIC0B] C550 $
01m0009                               	;ONE WORD PACKET.
01m0009 06647 640141414571000013007637	        D[CONST 1] DEST[6] JUMP[TNICRM] DEST-A-MEM NORM $
01m0009 06650 640710014335034010000000	TNIC0B: D[CONST 1] ROT[16] ALU[D#Q] DEST[Q AR] SHORT $
01m0009 06651 640700010235020060000000	        D[MASK 6] ROT[8] ALU[D&Q] DEST[Q] SHORT $
01m0009 06652 510140010735020060000000	        D[MASK 6] ROT[8] ALU[D#Q] COND[OBUS=0] JUMP[TNIC0C] C550 $
01m0009                               	;2 WORD PACKET.
01m0009 06653 640141414571000023007637	        D[CONST 2] DEST[6] JUMP[TNICRM] DEST-A-MEM NORM $
01m0009                               	;ESCAPE SEQUENCE.  BETTER NOT HAPPEN.
01m0009 06654 000140000571000440006654	TNIC0C: JUMP[.] $
01m0009                               	
01m0009                               	;CLOCK ROUTINE, CALLED EVERY TICK OF 60HZ CLOCK.
01m0009                               	
01m0009 06655 640041614571000013405402	TYMCLK: D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPOFF] SPEC[IOB-IN] NORM $
01m0009 06656 440701614571000060100000	        MAPF[10] CYLEN[IOB-OUT] D[CONST 6] DEST[DEV-ADR] $
01m0009 06657 640701634571000443000000	        D[IR] DEST[7] DEST-A-MEM NORM $
01m0009 06660 511040054571000440000000	        D[13] COND[OBUS<0] PUSHJ[TNSI] C550 $
01m0009 06661 511040050571000440000000	        D[12] COND[OBUS<0] PUSHJ[TNSO] C550 $
01m0009 06662 640702274571000030000000	        D[17] MASK[3] DEST[IOD] NORM $
01m0009 06663 640701600615000443600000	        ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
01m0009 06664 440700000571000440100000	        MAPF[10] CYLEN[IOB-OUT] $
01m0009 06665 640301614571000060000000	        D[CONST 6] DEST[DEV-ADR] POPJ NORM $
01m0009                               	
01m0009                               	TNSI:   GHIRP
01m0009 06666 640040014171000050006634	        D[CONST 5] DEST[Q] PUSHJ[TNRCW] NORM $
01m0010 06667 640700070033000440000000	]       D[16] ALU[D+1] DEST[Q] NORM $
01m0010 06670 640700010235000070000000	        D[MASK 7] ALU[D&Q] DEST[Q] SHORT $
01m0010 06671 450300004537000440000000	        D[MEM] ALU[D-Q] COND[OBUS=0] POPJ C600 $
01m0010 06672 640140614571000513006637	        D[CONST[TNIC2 & 77]] DEST[3] DEST-A-MEM JUMP[TNCASODOF] NORM $
01m0010                               	TNSO:   GBORP
01m0010 06673 640040014171000120006634	        D[CONST 12] DEST[Q] PUSHJ[TNRCW] NORM $
01m0011 06674 640710004571000440000000	]       D[MEM] DEST[AR] NORM $
01m0011                               	        GHORP
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

01m0011 06675 640040014171000110006634	        D[CONST 11] DEST[Q] PUSHJ[TNRCW] NORM $
01m0012 06676 640700000171000440000000	]       D[AR] DEST[Q] NORM $
01m0012 06677 450300004537000440000000	        D[MEM] ALU[D-Q] COND[OBUS=0] POPJ C600 $
01m0012 06700 640720014435014240000000	        D[CONST 24] ROT[6] ALU[D+Q] DEST[MA] NORM $
01m0012 06701 640706000550400440000000	        FIXM0 $
01m0012 06702 640041004171060443006624	        D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
01m0012 06703 640300414571000113000000	        D[CONST[TNOC2 & 77]] DEST[2] POPJ DEST-A-MEM NORM $
01m0012                               	
01m0012                               	;RESET TYMNET INTERFACE.  OUTPUT COROUTINE GOES INTO NULL STATE.
01m0012                               	; INPUT COROUTINE GOES INTO STATE 0, INTRPTS GET ENABLED.
01m0012 06704 440710014571004033600000	TYMRS1: D[CONST 3] ROT[2] DEST[AR] CYLEN[IOB-OUT] SPEC[IOB-OUT] $
01m0012                               	         ;GET CONST TO ENB. INTRPTS; IOB-OUT CLEARS FLAGS.
01m0012 06705 440700000571000443770000	TYMRS2: MAPF[TNODIFS] START-OUT C600 $
01m0012 06706 440040010371004020166577	        MAPF[TNIRIFS] D[MASK 2] ALU[NOTD] ROT[2] DEST[Q] PUSHJ[DEV6ST1] C600 $
01m0012 06707 640700400741000443000000	        ALU[-1] DEST[2] DEST-A-MEM NORM $
01m0012 06710 640300614571000273000000	        D[CONST[TNIC0 & 77]] DEST[3] POPJ DEST-A-MEM NORM $
01m0012                               	
01m0012                               	TYMAREA:        ;SAVE LOCATION
01m0012                               	
01m0012                               	        .OPCODE[LIST 
01m0012                               	 LIST            ]  ;RESET TYMNET
01m0012                               	
01m0012 03710 000700000571000440000000	        NOP $
01m0012 03711 640141614571000060000000	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNRESET] $
01m0012                               	
01m0012 03712 000700000571000440000000	        NOP $
01m0012 03713 640141614571000060000000	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNOUT] $
01m0012                               	
01m0012 03714 000700000571000440000000	        NOP $
01m0012 03715 640141614571000060000000	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNIN] $
01m0012                               	
01m0012 03716 000700000571000440000000	        NOP $   ;AS NEAR AS I CAN TELL, THIS ONE (747) ISN'T USED. - PG
01m0012 03717 640141614571000060000000	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[F5DIAG] $
01m0012                               	
01m0012                               	        .USE[XLIST
01m0012                               	 LIST ];RETURN TO MAIN CODE
01m0012                               	
01m0012 06711 640050024571004443606705	TYMNRESET:  SPEC[IOB-OUT] D[MA] ROT[2] DEST[AR] NORM PUSHJ[TYMRS2] $
01m0012                               	                ;RESET CO-ROUTINES, ENB. INTRPTS FROM EFF. ADDR. 34,35
01m0012 06712 000140000571000440002026	        JUMP[MAIN] $
01m0012                               	
01m0012 06713 640700000571000443600000	TYMNOUT: SPEC[IOB-OUT] NORM $  ;CLEAR "RDY FOR DATA" FROM PDP11
01m0012 06714 640040024171020440176624	        MAPF[TNODIFS] D[MA] ROT[8.] DEST[Q] NORM PUSHJ[TNSEND] $
01m0012                               	          ;SEND EFF. ADDR. 20-35 TO PDP11.
01m0012 06715 000140000571000440002026	        JUMP[MAIN] $
01m0012                               	
01m0012 06716 640740014571000310000000	TYMNIN: D[CONST 25.] LLOAD NORM $
01m0012 06717 640240000571000440006717	        NORM LOOP[.] $  ;GIVE DMA DEVICES SOME MEMORY TIME.
01m0012 06720 640700000571000443400000	        SPEC[IOB-IN] NORM $
01m0012 06721 240710030571070440050000	        MAPF[TYM.RD] D[IOD] ROT[27. + 1] DEST[AR] C800 $
01m0012                               	           ;Align input word with 16 data bits at RIGHT end.
01m0012 06722 531140000571010440006724	        D[AR] ROT[4] C550 COND[-OBUS<0] JUMP[. + 2] $
01m0012                               	           ;Don't clear "INPUT RDY" flag unless it's on.
01m0012 06723 640700000571000443600000	        SPEC[IOB-OUT] SHORT $  ;IT'S ON.
01m0012 06724 662104200571000440162032	        MAPF[TNIRIFS] D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
01m0012                               	
01m0012 06725 640706000550400440020000	F5DIAG: FIXM1 $
SLOE   Jan ***, 1859 00:00:03  file DSK:TYMNET.SLO  --  of -- F2X

01m0012 06726 640710034771000440000000	        D[IR] ALU[NOTD] DEST[AR] NORM $
01m0012                               	                ;AR=-IR
01m0012 06727 640710000571032020000000	        D[AR] ROT[13.] MASK[2] DEST[AR] NORM $
01m0012                               	                ;AR=-AC MASK 2
01m0012 06730 640700000171014440000000	        D[AR] ROT[6] DEST[Q] NORM $
01m0012                               	                ;Q=INVERTED 2 LSB'S OF AC SHIFTED INTO STROBES
01m0012 06731 640704404575020440000000	        D[MEM] ROT[8.] ALU[DORQ] DEST[HOLD] NORM $
01m0012                               	                ;DATA SHIFTED WITH STROBES INSERTED
01m0012 06732 640710004571000440000000	        D[MEM] DEST[AR] NORM $
01m0012                               	                ;DATA=(E) (LSH 8) (STB ACTIVE LOW)
01m0012 06733 640040010171060220006577	        D[MASK 18.] ROT[18. + 6] DEST[Q] PUSHJ[DEV6ST1] NORM $
01m0012                               	                ;LEAVE BITS 0-11. AND 30.-35. UNCHANGED
01m0012 06734 640700010171014020000000	        D[MASK 2] ROT[6] DEST[Q] NORM $
01m0012                               	                ;MASK TO FORCE STB'S HIGH
01m0012 06735 640710004575000440000000	        D[MEM] ALU[DORQ] DEST[AR] NORM $
01m0012                               	                ;DATA=(E) (LSH 8) (STB'S FORCED INACTIVE HIGH)
01m0012 06736 640040010171060220006577	        D[MASK 18.] ROT[18. + 6] DEST[Q] PUSHJ[DEV6ST1] NORM $
01m0012                               	                ;LEAVE BITS 0-11. AND 30.-35. UNCHANGED
01m0012 06737 000141600615000440002026	        ALU[0] DEST[DEV-ADR] JUMP[MAIN] $

SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

42m0163                               	]TYMNET
42m0163                               	.REPEAT DR11P [
42m0163                               	DR11P
42m0163                               	
42m0163                               	; SOMETHING IS REALLY FUCKED WITH THIS ASSEMBLER, CAUSING
42m0163                               	; THE .USE, .RELOC, AND SO FORTH MACROS NOT TO WORK.
42m0163                               	; EVIDENTLY THE PREVIOUS PERSON TO EDIT THE MICROCODE
42m0163                               	; HAD PROBLEMS WITH THIS TOO.  MAYBE THIS WILL REMOVE THE SYMPTOM.
42m0163                               	
42m0163       6740	BULLSHIT = .
42m0163                               	        .USE[42m0163                               	XLIST
42m0164                               	 LIST ]
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

43m0164                               	;INTERVAL TIMER CODE.
43m0164                               	
43m0164                               	;a-mem useage:
43m0164                               	;       0       dispatch addr for interrupts
43m0164                               	;       1       pi chn (33: 35) and intrpt waiting flag (32)
43m0164                               	;               (BITS 0,19 ARE ON FOR USE BY TAPE CODE)
43m0164                               	;       2       CONSTANT W/ ONLY BIT 19 ON (USED BY TAPE CODE)
43m0164                               	;       3       INTERVAL TIMER REGISTER.
43m0164                               	
43m0164                               	  .REPEAT OTP [
43m0164                               	;OTP
43m0164                               	
43m0164                               	  .REPEAT NTP [
43m0164       0	        TIM.CLR.ROT = 0
43m0164       11	        TIM.DO = 11
43m0164       1	        TIM.DI = 1
43m0164       10	        TIM.ENB = 10
43m0164       5	        TIM.DEV = 5
43m0164       2134	        TIM.LOC = 2134
43m0164                               	    ];NTP
43m0164                               	
43m0164                               	
43m0164                               	        .ORG[XLIST
43m0164                               	 LIST ] ;$*$*$ INTRPTS FROM DEVICE COME HERE.
43m0164                               	   .REPEAT 1 - TIMER [
43m0164                               	
43m0164                               	   .REPEAT TIMER [
43m0164 02134 640140000571000440000000	        NORM JUMP[TIMINT] $
43m0164                               	     ]
43m0164                               	        .RELOC
43m0164                               	USE[43m0164                               	XLIST
43m0165                               	 LIST ]]
43m0165                               	TIMINT:   ;ALL DEV 5 INTS COME FROM INTERVAL TIMER...
43m0165 06740 640702214571000013600000	        START-OUT D[CONST 1] ROT[TIM.CLR.ROT] DEST[IOD] NORM $
43m0165                               	           ;Clear the TIMER OVERFLOW FLAG.
43m0165 06741 240700054171000440100000	        MAPF[TIM.ENB] D[13] DEST[Q] C800 $
43m0165                               	           ;Get TIMER REGISTER.
43m0165                               	        D[CONST 1] ROT[12.] ALU[D+Q] DEST[Q 3] DEST-A-MEM
43m0165 06742 535140614035030013002026	                  C550 COND[-CRY0] JUMP[MAIN] $
43m0165                               	           ;Increment the count by 2^12, exit if no overflow.
43m0165 06743 510150044571000030002026	        D[11] MASK[3] DEST[AR] C550 COND[OBUS=0] JUMP[MAIN] $
43m0165                               	           ;Timer overflowed. ignore if no PI CHANNEL assigned.
43m0165 06744 640700044171000440000000	        D[11] DEST[Q] NORM $
43m0165                               	           ;Get full contents of A-MEM[1].
43m0165 06745 640140214575000103004562	        D[CONST 10] ALU[DORQ] DEST[1] DEST-A-MEM NORM JUMP[PIGEN] $
43m0165                               	           ;Set the "interrupting" status bit and generate a PI.
43m0165                               	
43m0165                               	   .OPCODE[LIST 
43m0165                               	 LIST            ];TIMER PSEUDO-IOT DISPATCH TABLE ENTRIES.
43m0165                               	
43m0165                               	; TCONO -- 760
43m0165 03740 640701614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] SHORT $
43m0165 03741 640140044171000440000000	        D[11] DEST[Q] NORM JUMP[TCNO1]$
43m0165                               	; TCONI -- 761
43m0165 03742 640041614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
43m0165 03743 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$ ;store them and
43m0165                               	 return.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

43m0165                               	; TCONSO -- 762
43m0165 03744 640041614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
43m0165 03745 530100010635000220000000	        D[MASK 22] ALU[D&Q] C550 COND[-OBUS=0] LBJUMP[DSKP1] $ ;Skip if on.
43m0165                               	; TCONSZ -- 763
43m0165 03746 640041614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
43m0165 03747 510100010635000220000000	        D[MASK 22] ALU[D&Q] C550 COND[OBUS=0] LBJUMP[DSKP1] $ ;Skip if off.
43m0165                               	; TDATAO -- 764  LOAD THE 36-BIT TIMER
43m0165 03750 640701614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM $
43m0165 03751 640146000550400440020000	        FIXM1 JUMP[TDATO] $
43m0165                               	; TDATAI  --  765    READ TIMER REGISTER
43m0165 03752 640041614571000053400000	        START-IN D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TDTI] $ ;get bits.
43m0165 03753 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$ ;Store them and
43m0165                               	 return.
43m0165                               	
43m0165                               	   .RELOC
43m0165                               	USE[43m0165                               	XLIST
43m0166                               	 LIST ]]
43m0166 06746 640700010235010400000000	TCNO1:  D[MASK 32.] ROT[4] ALU[D&Q] DEST[Q] NORM $
43m0166 06747 000140234575000033002026	        D[IR] MASK[3] ALU[DORQ] DEST[1] DEST-A-MEM JUMP[MAIN] $
43m0166                               	           ;Put new PI CHAN. in bits 33-35 of A-MEM[1].
43m0166                               	
43m0166 06750 640710044171000040000000	TCNI1:  D[11] MASK[4] DEST[Q AR] NORM $ ;get intrpt flag and pi chn
43m0166 06751 640300034235000440000000	        D[IR] ALU[D&Q] DEST[Q] NORM POPJ $ ;this is for conso, z
43m0166                               	
43m0166 06752 640700004171000140000000	TDATO:  D[MEM] MASK[12.] DEST[Q] NORM $
43m0166                               	           ;Get low 12 bits of new timer value...
43m0166 06753 640702214575070013600000	        START-OUT D[CONST 1] ROT[35. - 7] ALU[DORQ] DEST[IOD] NORM $
43m0166                               	           ;Place in hardware counter (the "TP TIMER").
43m0166 06754 240700010171030300110000	        MAPF[TIM.DO] D[MASK 24.] ROT[12.] DEST[Q] C800 $
43m0166 06755 640140604635000443002026	        D[MEM] ALU[D&Q] DEST[3] DEST-A-MEM NORM JUMP[MAIN] $
43m0166                               	           ;Put other 24 bits into A-MEM[3] (the "TIMER REGISTER").
43m0166                               	
43m0166 06756 440710030571030143410000	TDTI:   MAPF[TIM.DI] START-IN D[IOD] ROT[12.] MASK[12.] DEST[AR] C600 $
43m0166                               	           ;Read hardware timer.
43m0166 06757 440700030171030140010000	        MAPF[TIM.DI] D[IOD] ROT[12.] MASK[12.] DEST[Q] C600 $
43m0166                               	           ;Read it again.
43m0166 06760 530140000735000443406756	        START-IN D[AR] ALU[D#Q] C550 COND[-OBUS=0] JUMP[TDTI] $
43m0166                               	           ;If it changed, try again (to ensure that we don't get a garbaged
43m0166                               	           ; value because of reading it while it is changing).
43m0166 06761 640310054575000440000000	        D[13] ALU[DORQ] DEST[AR] NORM POPJ $
43m0166                               	           ;Combine high-order bits from A-MEM[3] with
43m0166                               	           ; low-order bits from hardware counter.
43m0166                               	
43m0166                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

44m0166                               	;       IMP,VID,PAN,GRN,DLS,LPT,VC etc.
44m0166                               	;------------------------------------------------------------------------------
44m0166                               	;
44m0166                               	;       Packet Switching Network Interface (IMP)
44m0166                               	;
44m0166                               	;------------------------------------------------------------------------------
44m0166                               	.REPEAT IMP [
44m0166                               	IMP
44m0166                               	;------------------------------------------------------------------------------
44m0166                               	;
44m0166                               	;       Panofsky-Samson Interface
44m0166                               	;
44m0166                               	;------------------------------------------------------------------------------
44m0166                               	.REPEAT STANSW [
44m0166                               	.REPEAT STANSW
44m0166                               	
44m0166                               	;------------------------------------------------------------------------------
44m0166                               	;
44m0166                               	;       Data Line Scanner (TTY scanner)
44m0166                               	;
44m0166                               	;------------------------------------------------------------------------------
44m0166                               	.REPEAT DLS [
44m0166                               	
44m0166                               	.DEFINE ASRC[44m0166                               	.DEFINE ADEST[44m0166                               	
44m0166                               	.REPEAT DLS2 [
44m0166                               	.INSERT DLS.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- F2X

01m0001                               	;#####################################################################
01m0001                               	;   Let's make the dls be macro device 370;  so the
01m0001                               	;   iot's will have opcode 737, dispatch table
01m0001                               	;   entry loc. 3676
01m0001                               	;#########################################################################
01m0001                               	
01m0001                               	;-----------------------------------------------------------------------
01m0001                               	;DLS definitions
01m0001                               	;-----------------------------------------------------------------------
01m0001       37	DLS = 37        ;MACRODEVICE CODE 370
01m0001       6762	DLSORG = .  ;; DWP 1/27/80 %%% DLSORG = 7000    ;UCODE ORIGIN
01m0001       2137	DLSVECTOR = 2137        ;Interrupt dispatch address
01m0001                               	
01m0001                               	.REPEAT DLS2 [D01m0001       20	LSWEBIT = 16.   ;ASTRO write enable bit
01m0001       37	DLSNLINES = 37  ;Highest line number
01m0001       5	DLSLNSIZE = 5   ;Number of bits in line-number field
01m0001                               	.DEFINE DLSIRQ 01m0001                               	.DEFINE DLSNOIRQ .REPEAT 1 - DLS2 [D01m0001                               	
01m0001                               	;
01m0001                               	;A-MEM definitions
01m0001                               	;
01m0001       0	DLSINTAD = 0    ;Interrupt service routine
01m0001       1	DLSPICHN = 1    ;PI channel for DLS
01m0001       2	DLSLINE = 2     ;Line number which the scanner is simulated to have
01m0001                               	                ;stopped on
01m0001       3	DLSACT = 3      ;Active line flags
01m0001                               	                ;   DLSCNI1
01m0001       4	DLSTMP = 4      ;SCRATCH
01m0001                               	;
01m0001                               	;MAPF fields (IO SUBSEL)
01m0001                               	;
01m0001       0	DLSCR1 = 0      ;ASTRA CR1 (Control Register 1)
01m0001                               	;               Async                   Sync
01m0001                               	;       Bit 28          Normal mode (NOT looped)
01m0001                               	;       Bit 29  Send break              Xmit transparent
01m0001                               	;       Bit 30  Single stop bit         Transmit parity
01m0001                               	;                 if xmit enabled         if bit 29 is zero
01m0001                               	;         else  Not MISC OUT = 0        Force DLE
01m0001                               	;       Bit 31  Auto-echo (1/2 duplex)  Not MISC OUT = 0 (bit 29=0)
01m0001                               	;                                       DLE stripping (bit 29=1)
01m0001                               	;       Bit 32  Parity enable           Recieve parity enable
01m0001                               	;       Bit 33          Reciever enabled
01m0001                               	;       Bit 34          not RTS OUT = 0
01m0001                               	;       Bit 35          not DTR OUT = 0
01m0001                               	;
01m0001       1	DLSCR2 = 1      ;ASTRA CR2 (Control Register 2)
01m0001                               	;   Bits 28:29          Character length
01m0001                               	;               00  8 bits      10  6 Bits
01m0001                               	;               01  7 bits      11  5 Bits
01m0001                               	;       Bit 30  0  Asynchronous         1  Synchronous
01m0001                               	;       Bit 31  0  Odd parity           1  Even parity
01m0001                               	;       Bit 32  Rcv clk = xmt clk       SYN strip (CR1 bit 29=0)
01m0001                               	;               else Rcv clk = Rate 1   DEL-SYN strip (CR1 bit 29=1)
01m0001                               	;   Bits 33:35  Transmit clock select
01m0001                               	;       000     Ext. clock (EIA pins:  Xmt=15, Rcv=17 [???])
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- F2X

01m0001                               	;       001     Rate 1          150 baud
01m0001                               	;       010     Rate 2          300 baud
01m0001                               	;       011     Rate 3          109.9 baud      *** 1200 baud Temp.
01m0001                               	;       100     Rate 4          9600 baud
01m0001                               	;       101     Rate 4 / 2      4800 baud
01m0001                               	;       110     Rate 4 / 4      2400 baud
01m0001                               	;       111     Rate 4 / 8      1200 baud
01m0001                               	;
01m0001       2	DLSSTAT = 2     ;ASTRA Status register
01m0001                               	;       Bit 28  Data Set Change (DSR or CD changed while DTR=1, or RI
01m0001                               	;                 changed while DTR=0)
01m0001                               	;       Bit 29  DSR (Data Set Ready)
01m0001                               	;       Bit 30  CD (Carrier Detect)
01m0001                               	;       Bit 31  Framing error or SYN detect
01m0001                               	;       Bit 32  Parity error [Async, too???] or DLE detect
01m0001                               	;       Bit 33  Overrun error
01m0001                               	;       Bit 34  Data recieved
01m0001                               	;       Bit 35  Transmit holding register empty  (Note: this does NOT
01m0001                               	;                 necessarily mean the transmitter is off)
01m0001                               	;On write, this sets the SYN register, and if immediately followed by
01m0001                               	;another write, that write sets the DLE register.
01m0001       3	DLSHOLD = 3     ;ASTRA xmt/rcv Hold register
01m0001       10	DLSCSR = 10     ;Interface Command/Status Register
01m0001       4	DLSIACK = 4     ;Interrupt acknowledge (also, interrupting line)
01m0001       14	DLSNOSEL = 14   ;Don't select anything
01m0001                               	
01m0001                               	;Macros for reading ASTRA registers.  They are macros because the
01m0001                               	;control logic on the prototype didn't have the timing correct for the
01m0001                               	;ASTRA and the problem was pushed onto the microcode.
01m0001                               	
01m0001                               	.DEFINE DLSREAD[01m0001                               	.DEFINE
01m0001                               	
01m0001                               	.DEFINE DLSWRITE[01m0001                               	DEFINE DLSWRITE
01m0001                               	
01m0001                               	.DEFINE DLSRINT[01m0001                               	DEFINE DLSRINT
01m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- F2X

02m0001                               	;-----------------------------------------------------------------------
02m0001                               	;Default configuration.  Lines are reset to this on initialization.
02m0001                               	;See DLS definition page for meaning of this bits.  Three groups of
02m0001                               	;lines may be initialized, allowing for local terminal, 300 buad modems
02m0001                               	;and split speed modems.
02m0001                               	
02m0001                               	;Caution:  Only lower 6 bits are permissible here.  This means you
02m0001                               	;          can't start out with looped, in break mode, or with character
02m0001                               	;          length other than 8.  You must use macro code to set those.
02m0001                               	;
02m0001                               	;Note:  Groups can be omitted by setting DLSGRPxN to zero.
02m0001                               	;-----------------------------------------------------------------------
02m0001                               	;*****  THIS SHOULD BE IN THE SITE DEPENDENT FILE  *****
02m0001                               	.DEFINE DLSINI 02m0001                               	;DLSINI
02m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- F2X

03m0001                               	;-----------------------------------------------------------------------
03m0001                               	; DLS Dispatch
03m0001                               	;-----------------------------------------------------------------------
03m0001       3676	DLSDISP = 3600 + DLS + DLS      ;Dispatch for DLS instructions
03m0001                               	:DLSDISP
03m0001 03676 640141614571000200003677	        D[CONST DLSDEV] DEST[DEV-ADR] JUMP[. + 1] NORM $
03m0001 03677 640140014171014670000000	        D[CONST DLSORG / 100] ROT[6] DEST[Q] JUMP[DLSIOT] NORM $
03m0001                               	:DLSORG         ;DISPATCH ON DLS IOT CODES
03m0001                               	
03m0001                               	DLSDISP2:
03m0001                               	.REPEAT DLSDEB [
03m0001                               	:DLSDISP2 + 40
03m0001                               	].REPEAT 1 - DLSDEB [
03m0001                               	DLSDEB
03m0001                               	
03m0001       62	DLSLOW = DLSORG \ 100
03m0001                               	DLSIOT:
03m0001                               	
03m0001 07022 640700014175000620000000	                D[CONST DLSLOW] ALU[DORQ] DEST[Q] NORM $
03m0001 07023 640700034035032040000000	        D[IR] ROT[13.] MASK[4] ALU[D+Q] DEST[Q] NORM $
03m0001 07024 500540034435032040000000	        D[IR] ROT[13.] MASK[4] ALU[D+Q] SDISP CYLEN[C550] $
03m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- F2X

04m0001                               	;-----------------------------------------------------------------------
04m0001                               	;BLKI DLS,
04m0001                               	DLSBLKI:
04m0001                               	.REPEAT 1 - DLSDEB [
04m0001                               	DLSDEB
04m0001                               	;-----------------------------------------------------------------------
04m0001                               	;DATAI DLS,
04m0001                               	;
04m0001                               	;       Bit 12  This is a modem control line
04m0001                               	;   Bits 13:17  Line number
04m0001                               	;       Bit 27  Interrupt from reciever (always true for modem control)
04m0001                               	;   Bits 28:35  Character (Note: 5 bit characters do NOT use bit 27 for
04m0001                               	;                          flag.  Use TRNN x,777 to test for rcv. int.)
04m0001                               	;Modem control use of bits 28:35
04m0001                               	;       Bit 28  Unused
04m0001                               	;       Bit 29  DTR (Data Terminal Ready)
04m0001                               	;   Bits 30:32  ACU bits (unimplemented - no auto-dialer)
04m0001                               	;       Bit 33  CD (Carrier Detect)
04m0001                               	;       Bit 34  RI (Ring Indicator)
04m0001                               	;       Bit 35  Unused
04m0001                               	;
04m0001                               	;-----------------------------------------------------------------------
04m0001                               	DLSDI1: ;Prepare to insert into dispatch table
04m0001                               	:DLSDISP2 + 2           ;Two instructions here and the rest elsewhere
04m0001 06764 640150050171000440006765	        ASRC[[10 + DLSLINE]]DEST[AR Q] JUMP[. + 1] NORM $
04m0001 06765 640140414675020013007025	        D[CONST 1] ROT[8.] ALU[-D&Q] ADEST[EST[DLSLINE] DEST-A-MEM]JUMP[DLSDI1] NORM $
04m0001                               	:DLSDI1
04m0001 07025 510140014635020010000000	        D[CONST 1] ROT[8.] ALU[D&Q] COND[OBUS=0] JUMP[DLSDI2] C550 $
04m0001                               	                ;Did scanner stop on a receiver?
04m0001 07026 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
04m0001                               	                ;Yes.  Enable interrupt
04m0001 07027 440700044171000440100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] ASRC[[10 + DLSPICHN]]DEST[Q] $
04m0001                               	                ;Clear RCVR flag.
04m0001 07030 640700214675006013000000	        D[CONST 1] ROT[3] ALU[-D&Q] ADEST[EST[DLSPICHN] DEST-A-MEM]NORM $
04m0001 07031 662104200571000440002032	DLSDI2: D[AR] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
04m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- F2X

05m0001                               	
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	;BLKO DLS,
05m0001                               	DLSBLKO:
05m0001                               	.REPEAT 1 - DLSDEB [
05m0001                               	DLSDEB
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	;DATAO DLS,
05m0001                               	;
05m0001                               	;       Bit 11  Use this line
05m0001                               	;   Bits 12:17  Line number if bit 11 is on (else interrupting line)
05m0001                               	;       Bit 27  Turn off transmitter (if this bit is on, then scanner is
05m0001                               	;                 restarted, but termination of transmission is not
05m0001                               	;                 implemented.)  Note: bit 30 is NOT used as alternative
05m0001                               	;                 to bit 27 in 5-bit character mode.)
05m0001                               	;Modem Control usage for bits 27:35
05m0001                               	;       Bit 27  Unused
05m0001                               	;       Bit 28  Set Status Flag (request interrupt).  Not implemented;
05m0001                               	;                  causes bug trap.
05m0001                               	;       Bit 29  DTR (Data Terminal Ready)
05m0001                               	;   Bits 30:35  ACU bits (Not implemented - no auto-dialer)
05m0001                               	;DC10 escape - Bit 0 = 1
05m0001                               	;   Bits 20:27  ASTRA Control Register 1
05m0001                               	;   Bits 28:31  ASTRA Control Register 2
05m0001                               	;
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	DLSDO1: ;Prepare to insert into dispatch table
05m0001                               	:DLSDISP2 + 6           ;Two instructions here and the rest elsewhere
05m0001 06770 640706000550400440020000	          FIXM1 $       ;Fetch operand
05m0001 06771 000140000571000440007032	        JUMP[DLSDO1] $
05m0001                               	:DLSDO1
05m0001 07032 531140004571026440000000	        D[MEM] ROT[11.] COND[-OBUS<0] JUMP[DLSNTHIS] C550 $
05m0001                               	                ;Is "use this line" on?
05m0001 07033 531140044571076440000000	        ASRC[[10 + DLSPICHN]]ROT[31.] COND[-OBUS<0] JUMP[DLSTHIS] C550 $
05m0001                               	                ;Yes.  Use it if scanner not stopped on xmitter.
05m0001 07034 640700004171044050000000	        D[MEM] ROT[18.] MASK[DLSLNSIZE] DEST[Q] NORM $
05m0001                               	                ;It has stopped...
05m0001 07035 510140050735044050000000	        ASRC[[10 + DLSLINE]]ROT[18.] MASK[DLSLNSIZE] ALU[D#Q] COND[OBUS=0] JUMP[DLSSCNR]
05m0001                               	 C550 $
05m0001                               	                ;If it stopped on the line to use, ignore the "use this"
05m0001 07036 640150004171044050000000	DLSTHIS:        D[MEM] ROT[18.] MASK[DLSLNSIZE] DEST[AR Q] JUMP[DLSOUT] NORM $
05m0001                               	                ;Set line # from data.
05m0001 07037 531140044571076440002026	DLSNTHIS:       ASRC[[10 + DLSPICHN]]ROT[31.] COND[-OBUS<0] JUMP[MAIN] C550 $
05m0001                               	                ;No "use this" - NOP if scanner not stopped.
05m0001 07040 640700044171000030000000	DLSSCNR:        ASRC[[10 + DLSPICHN]]MASK[3] DEST[Q] NORM $
05m0001 07041 640700214575006043000000	        D[CONST 4] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]NORM $
05m0001                               	                ;Clear XMIT flag.
05m0001 07042 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
05m0001                               	                ;Enable interrupt.
05m0001 07043 440710050171044050100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] ASRC[[10 + DLSLINE]]ROT[18.] MASK[DLSLNSIZE] DEST[AR
05m0001                               	 Q] $
05m0001                               	                ;Use line # from scanner.
05m0001 07044 640701214537000430000000	DLSOUT: D[CONST 35.] ALU[D-Q] DEST[ROTR] NORM $
05m0001 07045 640700054171000440000000	        ASRC[[10 + DLSACT]]DEST[Q] NORM $       ;Prepare to twiddle active bit
05m0001 07046 511140004571066440000000	        D[MEM] ROT[27.] COND[OBUS<0] JUMP[DLSOFF] C550 $
05m0001                               	                ;"turn off transmitter"?
05m0001 07047 640700614575200013000000	        D[CONST 1] ROT[R] ALU[DORQ] ADEST[EST[DLSACT] DEST-A-MEM]NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- F2X

05m0001                               	                ;No.  Turn it on.
05m0001 07050 640700004171000100000000	        D[MEM] MASK[8] DEST[Q] NORM $
05m0001 07051 640700000175052440000000	        D[AR] ROT[21.] ALU[DORQ] DEST[Q] NORM $
05m0001                               	        DLSWRITE[05m0001 07052 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
05m0001                               	                ;Set TTY number
05m0001 07053 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
05m0001                               	                ;SET CS
05m0001 07054 000702214575046013630000	        MAPF[DLSHOLD] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
05m0001                               	
05m0001                               	                ;DROP CS, SET WE
05m0001 07055 000702200555000443630000	        MAPF[DLSHOLD] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
05m0001                               	                ;DROP WE.
05m0001 07056 000700000571000443770000	        MAPF[DLSHOLD + DLSNOSEL] SPEC[IOB-OUT] $
05m0001                               	        MAPF[DLSHOLD + DLSNOSEL]                ;Finish the last IOB-OUT
05m0001 07057 640140000571000440172026	]JUMP[MAIN] NORM $
05m0001 07060 640140614675200013002026	DLSOFF: D[CONST 1] ROT[R] ALU[-D&Q] ADEST[EST[DLSACT] DEST-A-MEM]JUMP[MAIN] NORM $
05m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- F2X

06m0001                               	;-----------------------------------------------------------------------
06m0001                               	;CONO DLS,
06m0001                               	
06m0001                               	;
06m0001                               	;       Bit 30  Clear DC10
06m0001                               	;       Bit 31  Ready Hold (Not implemented, DTR switch is simulated as
06m0001                               	;                       being on.)
06m0001                               	;       Bit 32  Reset Scanner (more accurately, restart scanner. Allows
06m0001                               	;                        interrupts)
06m0001                               	;   Bits 33:35  PI channel
06m0001                               	;
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	DLSCNO1:
06m0001                               	:DLSDISP2 + 10
06m0001 06772 511040034571074440000000	        D[IR] ROT[30.] COND[OBUS<0] PUSHJ[DLSRST] C550 $
06m0001 06773 640140014171000700007061	        D[CONST 70] DEST[Q] JUMP[DLSCNO1] NORM $
06m0001                               	:DLSCNO1
06m0001 07061 640700044235000440000000	        ASRC[[10 + DLSPICHN]]ALU[D&Q] DEST[Q] NORM $
06m0001 07062 640140234575000033002026	        D[IR] MASK[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[MAIN] NORM $
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	;CONI DLS,
06m0001                               	;
06m0001                               	;    Bits 0:7   ASTRA Control Register 1
06m0001                               	;    Bits 8:13  ASTRA Control Register 2
06m0001                               	;    Bits 14:20 ASTRA Status Register
06m0001                               	;       Bit 30  DTR Distend (Simulated as always on)
06m0001                               	;       Bit 31  Transmit interrupt
06m0001                               	;       Bit 32  Recieve interrupt
06m0001                               	;               (Both bits 31 and 32 will not be on at the same time.
06m0001                               	;                Recieve will take priority.)
06m0001                               	;   Bits 33:35  PI channel
06m0001                               	;
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	DLSCNISV:
06m0001                               	:DLSDISP2 + 12
06m0001                               	                ;Get CONI information
06m0001 06774 662104244571000440002032	        ASRC[[10 + DLSPICHN]]DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
06m0001 06775 000700000571000440000000	        NOP $
06m0001                               	                ;Store and fetch next instruction
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	;CONSZ DLS,
06m0001                               	;-----------------------------------------------------------------------
06m0001 06776 640710044571000440000000	        ASRC[[10 + DLSPICHN]]DEST[AR] NORM $
06m0001 06777 640140034171000220004470	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
06m0001                               	                ;Do standard skip off AR and IR
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	;CONSO DLS,
06m0001                               	;-----------------------------------------------------------------------
06m0001 07000 640710044571000440000000	        ASRC[[10 + DLSPICHN]]DEST[AR] NORM $
06m0001 07001 640140034171000220004472	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
06m0001                               	                ;Do standard skip off AR and IR
06m0001                               	:DLSCNISV
06m0001                               	
06m0001 07063 000144620531000440004366	DLSBAD: d[pc] alu[d-1] dest[pc] jump[dohalt] $
06m0001                               	                ;Halt macro machine on this lossage...
06m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- F2X

07m0001                               	;-----------------------------------------------------------------------
07m0001                               	;Reset DLS
07m0001                               	;
07m0001                               	;Clear PI assignment and A-MEM registers.
07m0001                               	;Turn off interrupts
07m0001                               	;Setup defaults for lines 0:7, 8:5
07m0001                               	;
07m0001                               	;-----------------------------------------------------------------------
07m0001                               	.DEFINE DLSGRP[07m0001                               	;DLSGRP
07m0001                               	DLSRST:
07m0001 07064 640702214571060013600000	        D[CONST 1] ROT[24.] DEST[IOD] SPEC[IOB-OUT] NORM $
07m0001                               	                ;Hit MASTER RESET on all ASTRAs
07m0001 07065 000700214571000403100000	        MAPF[DLSCSR] LONG D[CONST 40] ADEST[EST[DLSPICHN] DEST-A-MEM]$ ;Clear PIA
07m0001 07066 000700400615000443000000	        ALU[0] ADEST[EST[DLSLINE] DEST-A-MEM]LONG $ ;Clear receiver flag
07m0001 07067 000700600615000443000000	        ALU[0] ADEST[EST[DLSACT] DEST-A-MEM]LONG $ ;All transmitters off
07m0001 07070 000712200615000443600000	        ALU[0] DEST[IOD AR] SPEC[IOB-OUT] LONG $ ;Let go of MR
07m0001                               	        MAPF[DLSCSR] LONG
07m0001                               	DLSINI
07m0001                               	DLSGRP[07m0001 07071 000740014571000000100000	        D[CONST 0 - 0] LLOAD $
07m0001 07072 640040014171000320000000	        D[CONST 32] DEST[Q] PUSHJ[DLSSCR2] NORM $
07m0001 07073 640700014171014020000000	        D[CONST 247 / 100] ROT[6] DEST[Q] NORM $
07m0001 07074 640040014175000470000000	        D[CONST 247 & 77] ALU[DORQ] DEST[Q] PUSHJ[DLSSCR1] NORM $
07m0001 07075 640250000433000440007072	        D[AR] ALU[D+1] DEST[AR] LOOP[. - 3] NORM $
07m0001                               	];Line 0 300 baud
07m0001                               	DLSGRP[07m0001 07076 000740014571000020000000	        D[CONST 3 - 1] LLOAD $
07m0001 07077 640040014171000230000000	        D[CONST 23] DEST[Q] PUSHJ[DLSSCR2] NORM $
07m0001 07100 640700014171014020000000	        D[CONST 247 / 100] ROT[6] DEST[Q] NORM $
07m0001 07101 640040014175000470000000	        D[CONST 247 & 77] ALU[DORQ] DEST[Q] PUSHJ[DLSSCR1] NORM $
07m0001 07102 640250000433000440007077	        D[AR] ALU[D+1] DEST[AR] LOOP[. - 3] NORM $
07m0001                               	];Lines 1-3 150/1200    *** Temp.
07m0001                               	DLSGRP[07m0001 07103 000740014571000330000000	        D[CONST DLSNLINES - 4] LLOAD $
07m0001 07104 640040014171000340000000	        D[CONST 34] DEST[Q] PUSHJ[DLSSCR2] NORM $
07m0001 07105 640700014171014020000000	        D[CONST 247 / 100] ROT[6] DEST[Q] NORM $
07m0001 07106 640040014175000470000000	        D[CONST 247 & 77] ALU[DORQ] DEST[Q] PUSHJ[DLSSCR1] NORM $
07m0001 07107 640250000433000440007104	        D[AR] ALU[D+1] DEST[AR] LOOP[. - 3] NORM $
07m0001                               	];Lines 4-LAST 9600
07m0002 07110 640040014171000000000000	]       D[CONST 0] DEST[Q] PUSHJ[DLSCINT] NORM $
07m0002                               	.REPEAT DLS2 [
07m0002 07111 640040014171052200000000	        D[CONST 20] ROT[21.] DEST[Q] PUSHJ[DLSCINT] NORM $
07m0002                               	];DLS2
07m0002 07112 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
07m0002 07113 440300000571000440100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] POPJ $
07m0002                               	DLSCINT:
07m0002                               	.REPEAT DLS2 [
07m0002                               	        D[CONST 1] ROT[26.] ALU[DORQ] DEST[IOD Q] SPEC[IOB-OUT]
07m0002 07114 640702214175064013600000	                        NORM $
07m0002 07115 440700000571000443540000	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
07m0002 07116 000701030571000443140000	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM $
07m0002 07117 011300060571022440000000	        D[10 + DLSTMP] DLSNOIRQ OT[9.] COND[OBUS<0]]POPJ LONG $
07m0002                               	];DLS2
07m0002                               	DLSCINT1:       DLSRINT 07m0002                               	        MAPF[DLSNOSEL] SPEC[IOB-OUT]
07m0002 07120 640702200417000443740000	                ALU[Q+1] DEST[IOD] NORM $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

07m0002                               	        MAPF[DLSIACK] CYLEN[IOB-OUT] SPEC[IOB-OUT] 
07m0002 07121 440702214437050013640000	                D[CONST 1] ROT[20.] ALU[D+Q+1] DEST[IOD] $
07m0002 07122 000702200555000443640000	        MAPF[DLSIACK] SPEC[IOB-OUT] ALU[Q] DEST[IOD] LONG $
07m0002 07123 000700000571000443440000	        MAPF[DLSIACK] SPEC[IOB-IN] LONG $
07m0002 07124 240701030571000443040000	        MAPF[DLSIACK] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002 07125 011300060571022440000000	        D[10 + DLSTMP] ]DLSNOIRQ OT[9.] COND[OBUS<0]]POPJ $
07m0002 07126 000700000571000440000000	        NOP LONG $
07m0002 07127 000140000571000440007120	        JUMP[DLSCINT1] $
07m0002 07130 640700000175052440000000	DLSSCR1:        D[AR] ROT[21.] ALU[DORQ] DEST[Q] NORM $
07m0002                               	        DLSWRITE[07m0002 07131 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
07m0002                               	                ;Set TTY number
07m0002 07132 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;SET CS
07m0002 07133 000702214575046013600000	        MAPF[DLSCR1] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;DROP CS, SET WE
07m0002 07134 000702200555000443600000	        MAPF[DLSCR1] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;DROP WE.
07m0002 07135 000700000571000443740000	        MAPF[DLSCR1 + DLSNOSEL] SPEC[IOB-OUT] $
07m0002                               	        MAPF[DLSCR1 + DLSNOSEL]                 ;Finish the last IOB-OUT
07m0002 07136 640300000571000440140000	]POPJ NORM $
07m0002 07137 640700000175052440000000	DLSSCR2:        D[AR] ROT[21.] ALU[DORQ] DEST[Q] NORM $
07m0002                               	        DLSWRITE[07m0002 07140 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
07m0002                               	                ;Set TTY number
07m0002 07141 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;SET CS
07m0002 07142 000702214575046013610000	        MAPF[DLSCR2] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;DROP CS, SET WE
07m0002 07143 000702200555000443610000	        MAPF[DLSCR2] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;DROP WE.
07m0002 07144 000700000571000443750000	        MAPF[DLSCR2 + DLSNOSEL] SPEC[IOB-OUT] $
07m0002                               	        MAPF[DLSCR2 + DLSNOSEL]                 ;Finish the last IOB-OUT
07m0002 07145 640300000571000440150000	]POPJ NORM $
07m0002                               	
07m0002                               	;-----------------------------------------------------------------------
07m0002                               	;DLS interrupts are fairly straight-forward.  The micro-interrrupt
07m0002                               	;is turned off, the status of the line is obtained, and if enabled, a
07m0002                               	;macro interrupt is requested.  The macro interrupt is responsible for
07m0002                               	;executing some CONO,DATAI,DATAO which restarts the scanner by enabling
07m0002                               	;micro interrupts again.
07m0002                               	;-----------------------------------------------------------------------
07m0002                               	DLSINT:
07m0002                               	: DLSVECTOR     ;Entry to interrupt
07m0002 02137 640142200615000443607146	        ALU[0] DEST[IOD] SPEC[IOB-OUT] JUMP[DLSINT] NORM $ ;Disable int.
07m0002                               	: DLSINT
07m0002                               	.REPEAT DLS2 [
07m0002                               	        MAPF[DLSCSR] D[CONST 3] ROT[25.] DEST[Q IOD] SPEC[IOB-OUT]
07m0002 07146 440702214171062033700000	                        CYLEN[IOB-OUT] $
07m0002 07147 440700000571000443540000	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
07m0002 07150 240701030571000443140000	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002 07151 031140060571022440000000	        D[10 + DLSTMP] DLSIRQ OT[9.] COND[-OBUS<0]]JUMP[DLSINT1] $
07m0002 07152 640702214171062023600000	        D[CONST 2] ROT[25.] DEST[Q IOD] SPEC[IOB-OUT] NORM $
07m0002 07153 440700000571000443540000	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
07m0002 07154 240701030571000443140000	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002 07155 511140060571022440000000	        D[10 + DLSTMP] C550 DLSNOIRQ OT[9.] COND[OBUS<0]]JUMP[DLSIGNORE] $
07m0002                               	];DLS2
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

07m0002                               	DLSINT1:        DLSRINT 07m0002                               	        MAPF[DLSNOSEL] SPEC[IOB-OUT]
07m0002 07156 640702200417000443740000	                ALU[Q+1] DEST[IOD] NORM $
07m0002                               	        MAPF[DLSIACK] CYLEN[IOB-OUT] SPEC[IOB-OUT] 
07m0002 07157 440702214437050013640000	                D[CONST 1] ROT[20.] ALU[D+Q+1] DEST[IOD] $
07m0002 07160 000702200555000443640000	        MAPF[DLSIACK] SPEC[IOB-OUT] ALU[Q] DEST[IOD] LONG $
07m0002 07161 000700000571000443440000	        MAPF[DLSIACK] SPEC[IOB-IN] LONG $
07m0002 07162 240701030571000443040000	        MAPF[DLSIACK] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002 07163 000704460571000440000000	        D[10 + DLSTMP] ]DEST[HOLD] $
07m0002                               	.REPEAT 1 - DLS2 [
07m0002 07164 640710004571102040000000	        D[MEM] ROT[33.] MASK[4] DEST[AR] NORM $
07m0002 07165 640710000575052440000000	        D[AR] ROT[21.] ALU[DORQ] DEST[AR] NORM $
07m0002 07166 640711200571036050000000	        D[AR] ROT[15.] MASK[DLSLNSIZE] DEST[AR ROTR] NORM $
07m0002 07167 640710000571044440000000	        D[AR] ROT[18.] DEST[AR] NORM $
07m0002 07170 511140004571102440000000	        D[MEM] ROT[33.] COND[OBUS<0] JUMP[DLSRCVINT] C550 $
07m0002 07171 531140054571200440000000	        ASRC[[10 + DLSACT]]ROT[R] COND[-OBUS<0] JUMP[DLSIGNORE] C550 $
07m0002 07172 640700400571000443000000	        D[AR] ADEST[EST[DLSLINE] DEST-A-MEM]NORM $
07m0002 07173 650150044171000440000000	        ASRC[[10 + DLSPICHN]]DEST[AR Q] COND[OBUS=0] JUMP[DLSCH0] NORM $
07m0002 07174 640140214575006063004562	        D[CONST 6] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[PIGEN] NORM $
07m0002 07175 640140214575006063002026	DLSCH0: D[CONST 6] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[MAIN] NORM $
07m0002 07176 640700000171006440000000	DLSRCVINT:      D[AR] ROT[3] DEST[Q] NORM $
07m0002                               	        DLSREAD[07m0002 07177 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
07m0002                               	                ;Set TTY number  -- FBUS 9
07m0002 07200 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
07m0002                               	                ;Assert CS
07m0002 07201 440700000571000440020000	        MAPF[DLSSTAT] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
07m0002 07202 000702214171064013420000	        MAPF[DLSSTAT] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
07m0002                               	                ;Setup to drop CS, start read
07m0002 07203 000704430571000103760000	        MAPF[DLSSTAT + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[HOLD] SPEC[IOB-OUT] $
07m0002                               	                ;Finish read, drop CS
07m0002 07204 000700000571000440160000	        MAPF[DLSSTAT + DLSNOSEL] $
07m0002                               	        MAPF[DLSSTAT + DLSNOSEL]  ]D[MEM] ROT[34.]
07m0002 07205 531140004571104440160000	                COND[-OBUS<0] JUMP[DLSIGNORE] C550 $
07m0002 07206 640700000171006440000000	        D[AR] ROT[3] DEST[Q] NORM $
07m0002                               	        DLSREAD[07m0002 07207 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
07m0002                               	                ;Set TTY number  -- FBUS 9
07m0002 07210 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
07m0002                               	                ;Assert CS
07m0002 07211 440700000571000440030000	        MAPF[DLSHOLD] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
07m0002 07212 000702214171064013430000	        MAPF[DLSHOLD] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
07m0002                               	                ;Setup to drop CS, start read
07m0002 07213 000700030171000103770000	        MAPF[DLSHOLD + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[Q] SPEC[IOB-OUT] $
07m0002                               	                ;Finish read, drop CS
07m0002 07214 000700000571000440170000	        MAPF[DLSHOLD + DLSNOSEL] $
07m0002 07215 640704400433070440170000	        MAPF[DLSHOLD + DLSNOSEL]  ]D[AR] ROT[28.] ALU[D+1] DEST[HOLD] NORM $
07m0002 07216 640700404575020443000000	        D[MEM] ROT[8.] ALU[DORQ] ADEST[EST[DLSLINE] DEST-A-MEM]NORM $
07m0002 07217 650150044171000030000000	        ASRC[[10 + DLSPICHN]]MASK[3] DEST[AR Q] COND[OBUS=0] JUMP[DLSRCVIGN] NORM $
07m0002 07220 640140214575006053004562	        D[CONST 5] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[PIGEN] NORM $
07m0002 07221 640140214575006053002026	DLSRCVIGN:      D[CONST 5] ROT[3] ALU[DORQ] ADEST[EST[DLSPICHN] DEST-A-MEM]JUMP[MAIN]
07m0002                               	 NORM $
07m0002 07222 640702214571066013600000	DLSIGNORE:      D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
07m0002 07223 440150000215000440102026	        MAPF[DLSCSR] CYLEN[IOB-OUT] ALU[0] DEST[AR Q] JUMP[MAIN] $
07m0002                               	

SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

44m0166                               	
44m0166                               	.REPEAT DLSDEB [
44m0166                               	.INSERT DLSDEB.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:DLSDEB.SLO  --  of -- F2X

01m0001                               	;DLS DEBUGGING IOTS
01m0001                               	
01m0001                               	.DEFINE SETLIN 01m0001                               	
01m0001                               	.DEFINE MJUMP[01m0001                               	
01m0001                               	;;;;;  DWP 1/27/80:7600
01m0001                               	DLS.DEB:
01m0001                               	:DLSDISP2 + 20          ;IOT DISPATCH FOR DEVICE 374
01m0001                               	
01m0001 07002 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;BLKI 374 = READ
01m0001                               	 CR1
01m0001 07003 640140000571000440000000	JUMP[DLS.RCR1] NORM $
01m0001                               	
01m0001 07004 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;DATAI 374 = READ
01m0001                               	 CR2
01m0001 07005 640140000571000440000000	JUMP[DLS.RCR2] NORM $
01m0001                               	
01m0001 07006 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;BLKO 374 = READ
01m0001                               	 STAT
01m0001 07007 640140000571000440000000	JUMP[DLS.RSTAT] NORM $
01m0001                               	
01m0001 07010 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;DATAO 374 = READ
01m0001                               	 HOLD
01m0001 07011 640140000571000440000000	JUMP[DLS.RHOLD] NORM $
01m0001                               	
01m0001 07012 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;CONO 374 = WRITE
01m0001                               	 CR1
01m0001 07013 640140000175000440000000	MJUMP[[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WCR1] NORM]$
01m0001                               	
01m0001 07014 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;CONI 374 = WRITE
01m0001                               	 CR2
01m0001 07015 640140000175000440000000	MJUMP[[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WCR2] NORM]$
01m0001                               	
01m0001 07016 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;CONSZ 374 =
01m0001                               	 WRITE STAT (SYN,DLE)
01m0001 07017 640140000175000440000000	MJUMP[[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WSTAT] NORM]$
01m0001                               	
01m0001 07020 640040010171000100000000	SETLIN [MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                      ;CONSO 374 =
01m0001                               	 WRITE HOLD
01m0001 07021 640140000175000440000000	MJUMP[[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WHOLD] NORM]$
01m0001                               	
01m0001                               	:DLS.DEB
01m0001                               	
01m0001 07224 640706000550400440020000	DLS.SETLIN:     FIXM1 $                 ;SETUP LINE # IN Q
01m0001 07225 640710004635000440000000	        D[MEM] ALU[D&Q] DEST[AR] NORM $
01m0001 07226 640700010171052050000000	        D[MASK[DLSLNSIZE]] ROT[21.] DEST[Q] NORM $
01m0001 07227 640300004235006440000000	        D[MEM] ROT[3] ALU[D&Q] DEST[Q] POPJ NORM $
01m0001                               	
01m0001                               	DLS.RCR1:       DLSREAD[01m0001 07230 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07231 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07232 440700000571000440000000	        MAPF[DLSCR1] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07233 000702214171064013400000	        MAPF[DLSCR1] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

01m0001 07234 000710030571000103740000	        MAPF[DLSCR1 + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07235 000700000571000440140000	        MAPF[DLSCR1 + DLSNOSEL] $
01m0001 07236 000140000571000440140000	        MAPF[DLSCR1 + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001                               	DLS.RCR2:       DLSREAD[01m0001 07237 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07240 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07241 440700000571000440010000	        MAPF[DLSCR2] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07242 000702214171064013410000	        MAPF[DLSCR2] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
01m0001 07243 000710030571000103750000	        MAPF[DLSCR2 + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07244 000700000571000440150000	        MAPF[DLSCR2 + DLSNOSEL] $
01m0001 07245 000140000571000440150000	        MAPF[DLSCR2 + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001                               	DLS.RSTAT:      DLSREAD[01m0001 07246 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07247 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07250 440700000571000440020000	        MAPF[DLSSTAT] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07251 000702214171064013420000	        MAPF[DLSSTAT] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
01m0001 07252 000710030571000103760000	        MAPF[DLSSTAT + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07253 000700000571000440160000	        MAPF[DLSSTAT + DLSNOSEL] $
01m0001 07254 000140000571000440160000	        MAPF[DLSSTAT + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001                               	DLS.RHOLD:      DLSREAD[01m0001 07255 000702214175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07256 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07257 440700000571000440030000	        MAPF[DLSHOLD] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07260 000702214171064013430000	        MAPF[DLSHOLD] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
01m0001 07261 000710030571000103770000	        MAPF[DLSHOLD + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07262 000700000571000440170000	        MAPF[DLSHOLD + DLSNOSEL] $
01m0001 07263 000140000571000440170000	        MAPF[DLSHOLD + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001 07264 640700010171000100000000	DLS.READ:       D[MASK[8.]] DEST[Q] NORM $
01m0001 07265 640700000235000440000000	        D[AR] ALU[D&Q] DEST[Q] NORM $
01m0001 07266 662104204575000000202032	        D[MEM] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
01m0001                               	
01m0001                               	
01m0001                               	DLS.WCR1:       DLSWRITE[01m0001 07267 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07270 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07271 000702214575046013600000	        MAPF[DLSCR1] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP CS, SET WE
01m0001 07272 000702200555000443600000	        MAPF[DLSCR1] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

01m0001                               	                ;DROP WE.
01m0001 07273 000700000571000443740000	        MAPF[DLSCR1 + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSCR1 + DLSNOSEL]                 ;Finish the last IOB-OUT
01m0001 07274 000140000571000440142026	]JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.WCR2:       DLSWRITE[01m0001 07275 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07276 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07277 000702214575046013610000	        MAPF[DLSCR2] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP CS, SET WE
01m0001 07300 000702200555000443610000	        MAPF[DLSCR2] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP WE.
01m0001 07301 000700000571000443750000	        MAPF[DLSCR2 + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSCR2 + DLSNOSEL]                 ;Finish the last IOB-OUT
01m0001 07302 000140000571000440152026	]JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.WSTAT:      DLSWRITE[01m0001 07303 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07304 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07305 000702214575046013620000	        MAPF[DLSSTAT] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	
01m0001                               	                ;DROP CS, SET WE
01m0001 07306 000702200555000443620000	        MAPF[DLSSTAT] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP WE.
01m0001 07307 000700000571000443760000	        MAPF[DLSSTAT + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSSTAT + DLSNOSEL]                ;Finish the last IOB-OUT
01m0001 07310 000140000571000440162026	]JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.WHOLD:      DLSWRITE[01m0001 07311 000700014175064010000000	D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07312 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07313 000702214575046013630000	        MAPF[DLSHOLD] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	
01m0001                               	                ;DROP CS, SET WE
01m0001 07314 000702200555000443630000	        MAPF[DLSHOLD] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP WE.
01m0001 07315 000700000571000443770000	        MAPF[DLSHOLD + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSHOLD + DLSNOSEL]                ;Finish the last IOB-OUT
01m0001 07316 000140000571000440172026	]JUMP[MAIN] $
01m0001                               	
01m0001 07317 000140000571000440007317	DLS.INT:        JUMP[.] $
01m0001 07320 000140000571000440007321	        JUMP[. + 1] $
01m0001 07321 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $
01m0001 07322 440700000571000440100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] $
01m0001 07323 000142400571000440002026	        DEST[CLR-DEV-FROM-INTR] JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.RINT:
01m0001                               	: DLSDISP2 + 0  ;BLKI 370 - GET INTERRUPT STATUS
01m0001 06762 000140000571000440006762	        JUMP[.] $
01m0001 06763 000140000571000440007324	        JUMP[DLS.RINT] $
01m0001                               	: DLS.RINT
SLOE   Jan ***, 1859 00:00:03  file DSK:DLSDEB.SLO  --  of -- F2X

01m0001 07324 640700014171064010000000	        D[CONST 1] ROT[26.] DEST[Q] NORM $
01m0001                               	        MAPF[DLSNOSEL] SPEC[IOB-OUT] D[CONST 1] ROT[20.]
01m0001 07325 640702214437050013740000	                ALU[D+Q+1] DEST[IOD] NORM $
01m0001 07326 440700000571000440140000	        MAPF[DLSNOSEL] CYLEN[IOB-OUT] $
01m0001 07327 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07330 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07331 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07332 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07333 000702200555000443640000	        MAPF[DLSIACK] SPEC[IOB-OUT] ALU[Q] DEST[IOD] LONG $
01m0001 07334 000700000571000443440000	        MAPF[DLSIACK] SPEC[IOB-IN] LONG $
01m0001 07335 140700030171000440040000	        MAPF[DLSIACK] CYLEN[IOB-IN] D[IOD] DEST[Q] $
01m0001 07336 662104200555000440002032	        ALU[Q] DEST[MEMSTO] MEMST OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
01m0001                               	
01m0001                               	DLS.EINT:
01m0001                               	: DLSDISP2 + 4  ;BLKO 370 - ENABLE INTERRUPT
01m0001 06766 000140000571000440006766	        JUMP[.] $
01m0001 06767 000140000571000440007337	        JUMP[DLS.EINT] $
01m0001                               	:DLS.EINT
01m0001 07337 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
01m0001 07340 440140000571000440102026	        MAPF[DLSCSR] CYLEN[IOB-OUT] JUMP[MAIN] $

SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- F2X

44m0166                               	]DLSDEB
44m0166                               	];DLS2
44m0166                               	.REPEAT 1 - DLS2 [
44m0166                               	;1 - DLS2
44m0166                               	
44m0166                               	]DLS                    9 JAN 80  BO
44m0166                               	
44m0166                               	;------------------------------------------------------------------------------
44m0166                               	;
44m0166                               	;       Line Printer Interface (LPT)
44m0166                               	;
44m0166                               	;------------------------------------------------------------------------------
44m0166                               	.REPEAT LPT [
44m0166                               	LPT
44m0166                               	
44m0166                               	;------------------------------------------------------------------------------
44m0166                               	;
44m0166                               	;       Versatec Interface (VC)
44m0166                               	;
44m0166                               	;------------------------------------------------------------------------------
44m0166                               	.REPEAT VC [
44m0166                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

45m0166                               	; dsk stuff
45m0166                               	
45m0166                               	;a-mem useage:
45m0166                               	;       0       dispatch addr for interrupts
45m0166                               	;       1       pi chn (33: 35) and intrpt waiting flag (32)
45m0166                               	;       2       copy of last cmd sent to controller (by opcode 721)
45m0166                               	
45m0166                               	        .OPCODE[LIST 
45m0166                               	 LIST            ];disk pseudo-iot dispatch table entries.
45m0166                               	
45m0166                               	 ; dcono -- 740
45m0166 03700 640701614571000100000000	        d[const 10] dest[dev-adr] short $
45m0166 03701 640140234571000033000000	        d[ir] mask[3] dest[1] DEST-A-MEM norm jump[dcno1]$
45m0166                               	; dconi -- 741
45m0166 03702 640041614571000100000000	        d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
45m0166 03703 662104200571000440002032	        d[ar] dest[memsto] memst OND[-MA-AC] LBJUMP[MSMAIN] NORM ]$ ;store them and
45m0166                               	 return.
45m0166                               	; dconso -- 742
45m0166 03704 640041614571000100000000	        d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
45m0166 03705 530100010635000220000000	        d[mask 22] alu[d&q] c550 cond[-obus=0] lbjump[dskp1] $
45m0166                               	; dconsz -- 743
45m0166 03706 640041614571000100000000	        d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
45m0166 03707 510100010635000220000000	        d[mask 22] alu[d&q] c550 cond[obus=0] lbjump[dskp1] $
45m0166                               	
45m0166                               	        .RELOC
45m0166                               	USE[45m0166                               	XLIST
45m0167                               	 LIST ]]
45m0167 07341 550140034571000030002026	dcno1:  d[ir] mask[3]  c500 cond[obus=0] jump[main] $
45m0167                               	         ; if assigned pi channel is not 0, then
45m0167                               	         ;  enable interrupt on "not active", by
45m0167                               	         ;  re-loading last cmd with 10 bit on.
45m0167 07342 640700014171000200000000	        D[CONST 20] DEST[Q] NORM $
45m0167 07343 510140034635000440000000	        D[IR] ALU[D&Q] C550 OBUS=0 JUMP[DCNO2] $
45m0167 07344 640140014171000400000000	        D[CONST 40] DEST[Q] NORM JUMP[DCNO3] $
45m0167 07345 640700014171000100000000	DCNO2:  d[const 10] dest[q] short $
45m0167 07346 640702250575000443600000	DCNO3:  d[12] alu[dorq] dest[iod] spec[iob-out] norm $
45m0167 07347 440140000571000440042026	        mapf[4] cylen[iob-out] jump[main] $
45m0167                               	
45m0167 07350 640710044171000440000000	dcni1:  d[11] dest[q ar] norm $ ;get intrpt flag and pi chn
45m0167 07351 640300034235000440000000	        d[ir] alu[d&q] dest[q] norm popj $ ;this is for conso, z
45m0167                               	
45m0167                               	        .ORG[XLIST
45m0167                               	 LIST ];$*$*$ 
45m0167                               	
45m0167                               	        ;interrupts from disk (dev 10) come here.
45m0167 02156 640140014371000500000000	        D[CONST 50] ALU[NOTD] DEST[Q] NORM JUMP[DSKINT] $
45m0167                               	
45m0167                               	        .RELOC
45m0167                               	USE[45m0167                               	XLIST
45m0168                               	 LIST ]]        .PAIR
45m0168                               	. \ 2 + .
45m0169                               	];$*$*$ This exists elsewhere by another name.  TVR-Apr80
45m0169 07352 640140000571000440002026	dskp1:  jump[main] norm $       ;conso and consz lbjump to here.
45m0169 07353 640164620433000440002027	        doskip $
45m0169                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

45m0169 07354 640702250635000443600000	dskint: d[12] ALU[D&Q] dest[iod] spec[iob-out] norm  $
45m0169                               	          ;clear interrrupt enable bit (amem[2] has last cmd)
45m0169 07355 510150044171000440040000	        mapf[4] d[11] dest[q ar] c550 cond[obus=0] jump[ddis] $
45m0169                               	        d[const 10] alu[dorq] dest[1] DEST-A-MEM norm
45m0169 07356 640140214575000103004562	                jump[pigen] $ ;set flag and request intrpt.
45m0169 07357 640142400571000440002026	ddis:   dest[clr-dev-from-intr] norm jump[main] $
45m0169                               	
45m0169 07360 640151614571000100000000	DSKWT1: D[CONST 10] DEST[DEV-ADR AR] NORM JUMP[DSKWT4] $
45m0169 07361 511140004571076440000000	DSKWT3: D[MEM] ROT[31.] C550 COND[OBUS<0] JUMP[DSKWDN] $
45m0169 07362 640740014571014010000000	        D[CONST 1] ROT[6] LLOAD NORM $
45m0169 07363 500240000571000440007363	        C550 LOOP[.] $
45m0169 07364 640700000571000443400000	DSKWT4: START-IN NORM $
45m0169 07365 240144430571000440007361	        MAPF[0] D[IOD] DEST[HOLD] C800  JUMP[DSKWT3] $
45m0169 07366 530150000531000440007364	DSKWDN: D[AR] ALU[D-1] DEST[AR] C550 COND[-OBUS=0] JUMP[DSKWT4] $
45m0169 07367 000140000571000440002026	        JUMP[MAIN] $
45m0169                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

46m0169                               	
46m0169                               	;
46m0169                               	;ECC logging area
46m0169                               	;
46m0169                               	.REPEAT 1 - XUCODE [
46m0169                               	.REPEAT 1 - XUCODE
46m0169                               	.REPEAT XUCODE [
46m0169                               	: 17760
46m0169                               	].REPEAT XUCODE
46m0169                               	
46m0169                               	 .REPEAT 20 [N46m0169 17760 000700000571000440000000	OP $
46m0169 17761 000700000571000440000000	]OP $
46m0169 17762 000700000571000440000000	]OP $
46m0169 17763 000700000571000440000000	]OP $
46m0169 17764 000700000571000440000000	]OP $
46m0169 17765 000700000571000440000000	]OP $
46m0169 17766 000700000571000440000000	]OP $
46m0169 17767 000700000571000440000000	]OP $
46m0169 17770 000700000571000440000000	]OP $
46m0169 17771 000700000571000440000000	]OP $
46m0169 17772 000700000571000440000000	]OP $
46m0169 17773 000700000571000440000000	]OP $
46m0169 17774 000700000571000440000000	]OP $
46m0169 17775 000700000571000440000000	]OP $
46m0169 17776 000700000571000440000000	]OP $
46m0169 17777 000700000571000440000000	]OP $
46m0169                               	]
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- F2X

47m0169                               	;; this should be after everything else
47m0169                               	: 0
47m0169 00000 000140000571000440004000	        JUMP[MSTART] $          ;Auto-load micro code tapes someday.
47m0169                               	

SLOE   Jan ***, 1859 00:00:03  file DSK:F2X.SLO  --  of -- F2X

01m0047                               	
01m0047                               	LIST-LABELS

labels
  0   38     0 .               10   21  3103 ACBI1            4    2  2212 ADJSP
 41  161  5002 ADJSP1          41  161  5010 ADJSP2          17  104  2763 ANDCA1          17  104  2764 ANDCA2
 17  104  2765 ANDCA3          30  142  4701 APDINT          30  146  4715 APIOT           30  142  4671 APRC1
 30  142  4672 APRC2           30  142  4673 APRCHK          30  142  4702 APRCI           30  142  4702 APRCII
 30  142  4674 APRCK1          30  142  4647 APRCO           30  142  4656 APRCO2          30  142  4661 APRCO3
 30  145  4713 APRDI           30  141  5300 APRDSP          30  142  4662 APRIEN          20  138  4523 APRRST
  4    2  2161 AREA216          9   15  2602 AREA260          9   15  2623 AREA262          9   15  2642 AREA264
  9   15  2665 AREA266          9   15  2702 AREA270          9   16  2742 AREA274         12   47  3426 AREA342
 12   49  3444 AREA344         12   49  3470 AREA346         12   51  3504 AREA350         12   51  3526 AREA352
 12   53  3544 AREA354         12   53  3566 AREA356         19  134  5140 AREA51          19  136  3572 AREA52
 16   92  4223 ASHC1           16   92  4241 ASHC2           16   92  4235 ASHC4           16   92  4232 ASHC6
 16   93  4244 ASHC7           16   92  4230 ASHC8           16   92  4234 ASHC9           16   92  4203 ASHDO
 16   90  2734 ASHDO1          16   92  4207 ASHDOP          16   91  4174 ASHNEG          16   91  4175 ASHNN1
 16   91  4172 ASHPLS           9   16  2724 ASOS1            9   16  2722 ASOS2            9   16  2762 ASOS3
 14   59  4023 BADPC           16   92  4221 BIGAS2          16   92  4177 BIGASH          16   90  2725 BIGLSH
 14   68  2651 BII             14   67  2645 BII1            14   68  2654 BII2            14   67  2642 BIIH
  1    1  6641 BITREV          17  103  4255 BLT1            17  103  4264 BLT2            17  103  4263 BLT3
 17  103  4274 BLT4            17  103  4262 BLT5            17  103  4276 BLT6            17  103  4261 BLT7
 17  103  4300 BLT8            17  103  4266 BLT9            17  103  4317 BLTA1           17  103  4331 BLTA10
 17  103  4344 BLTA12          17  103  4254 BLTA2           17  103  4304 BLTA3           17  103  4315 BLTA4
 17  103  4326 BLTAL2          17  103  4312 BLTL1           17  103  4332 BLTL2           18  112  4450 BRPNT
 25  140  6177 BWRTA1           1    6 10301 CCLR            20  138  4510 CLKCLR          20  138  4511 CLKENB
 32  150  6213 CLKINT          32  150  6217 CLKRDFLG        20  138  4510 CLKRST          20  138  4525 CLRDEVINT
 18  112  4425 CONSW           19  136  5235 CTYCI           19  136  5241 CTYCI1          19  136  5240 CTYCI2
 19  136  5251 CTYCI3          19  136  5247 CTYCI8          19  136  5245 CTYCI9          19  136  5233 CTYCO
 19  136  5252 CTYCO1          19  136  5256 CTYCO3          19  136  5261 CTYCO4          19  136  5266 CTYCO5
 19  138  4472 CTYCS           19  138  4470 CTYCZ           19  136  5213 CTYDI           19  136  5222 CTYDO
 19  134  5100 CTYDSP          19  134  2144 CTYIN1          19  134  2130 CTYINT          19  135  5211 CTYIOT
 19  136  3566 CTYRS1          19  136  5270 CTYRST           1    6 10334 D1               1    2 10061 DCG1
  1    2 10056 DCGO             1    2 10075 DCGWR            1    2 10040 DCINIT          45  167  7350 dcni1
 45  167  7341 dcno1           45  167  7345 DCNO2           45  167  7346 DCNO3           45  169  7357 ddis
 18  112  4436 DEPNSW          18  112  4437 DEPSW1          18  112  4435 DEPTSW          42  163  6575 DEV6CL
 42  163  6576 DEV6ST          42  163  6577 DEV6ST1         42  163  6600 DEV6ST2          4    3  2262 DFN
 40  157  6262 DFN1            15   77  4126 DIV1            15   79  4132 DIV2            15   81  4136 DIV3
  7   10  2471 DIV9             1    1  7224 DLS.DEB          1    1  7337 DLS.EINT         1    1  7317 DLS.INT
  1    1  7230 DLS.RCR1         1    1  7237 DLS.RCR2         1    1  7264 DLS.READ         1    1  7255 DLS.RHOLD
  1    1  7324 DLS.RINT         1    1  7246 DLS.RSTAT        1    1  7224 DLS.SETLIN       1    1  7267 DLS.WCR1
  1    1  7275 DLS.WCR2         1    1  7311 DLS.WHOLD        1    1  7303 DLS.WSTAT        6    1  7063 DLSBAD
  4    1  7025 DLSBLKI          5    1  7032 DLSBLKO          7    2  7175 DLSCH0           7    2  7114 DLSCINT
  7    2  7120 DLSCINT1         6    1  7063 DLSCNISV         6    1  7061 DLSCNO1          4    1  7025 DLSDI1
  4    1  7031 DLSDI2           3    1  6762 DLSDISP2         5    1  7032 DLSDO1           7    2  7222 DLSIGNORE
  7    2  7146 DLSINT           7    2  7156 DLSINT1          3    1  7022 DLSIOT           5    1  7037 DLSNTHIS
  5    1  7060 DLSOFF           5    1  7044 DLSOUT           7    2  7221 DLSRCVIGN        7    2  7176 DLSRCVINT
  7    1  7064 DLSRST           5    1  7040 DLSSCNR          7    2  7130 DLSSCR1          7    2  7137 DLSSCR2
  5    1  7036 DLSTHIS          4    3  2240 DMOVE           41  161  5015 DMOVE2           4    3  2250 DMOVEM
 41  162  5026 DMOVM2           4    3  2242 DMOVN           41  161  5020 DMOVN2           4    3  2252 DMOVNM
 41  162  5031 DMVNM2          41  162  5034 DMVNM3          41  162  5035 DMVNM4          41  162  5036 DMVNM5
 15   83  4142 DODDIV          15   83  4147 DODIV           15   83  4151 DODIV1          15   83  4155 DODIV2
 15   83  4154 DODIV3          15   85  2170 DODIV4          15   85  2174 DODIV6          15   84  2161 DODIV7
 18  106  4366 DOHALT          15   70  4055 DOIMUL          15   70  4062 DOMMUL          15   70  4066 DOMUL
 15   70  4067 DOMUL1          15   71  4074 DOMUL4           9   15  2622 DOSKP1           5    3  2276 DPB
 14   63  2636 DPB1            14   66  2671 DPB2            14   66  2672 DPB4            14   63  2637 DPB5
 14   64  4024 DPB7            45  169  7354 DSKINT          45  169  7352 DSKP1           20  138  4474 DSKRST
 45  169  7366 DSKWDN          45  169  7360 DSKWT1          45  169  7361 DSKWT3          45  169  7364 DSKWT4
 31  150  6206 ECC-UNC         23  138  4647 END-OF-PI-CODE  18  112  4443 EXMNSW          18  112  4445 EXMSW1
 18  112  4442 EXMTSW          40  159  6431 EXPUF            1   12  6725 F5DIAG           5    3  2300 FAD
 40  159  6434 FADSU1          40  159  6433 FADSUB          40  157  6300 FAOS1           40  157  6302 FAOS2
 40  157  6304 FAOS3           40  157  6310 FAOS4           40  157  6300 FAOS5           40  161  6543 FD
 40  157  6324 FD1             40  157  6327 FD2             40  157  6340 FD2A            40  159  6364 FD2C
 40  159  6363 FD2D            40  159  6365 FD3             40  159  6370 FD4             40  161  6567 FDAD
 40  161  6535 FDS             40  161  6536 FDS1            40  161  6556 FDSHFT           5    3  2360 FDV
 41  162  5063 FIXER           41  162  5071 FIXER1          41  162  5072 FIXER2          41  162  5074 FIXER3
  4    3  2254 FIXR            41  162  5044 FIXR1           41  162  5056 FIXR2           41  162  5050 FIXRN
  4    3  2256 FLTR            41  162  6571 FLTR1           40  160  6512 FM              40  160  6515 FM1
 40  160  6520 FM2              1    2 10022 FMNBW1           1    2 10021 FMNBWT           5    3  2340 FMP
 40  157  6312 FMP1            40  157  6314 FMP2            40  157  6316 FMP3            40  157  6322 FMP4
 40  157  6312 FMP5             1    2 10030 FMTHNG          40  160  6503 FPLOW           40  160  6465 FPNAR
 40  159  6373 FPNDIV          40  159  6436 FS1             40  159  6441 FS2             40  159  6446 FS3
 40  160  6460 FS4             40  160  6462 FS5              5    3  2320 FSB              4    3  2264 FSC
 40  157  6270 FSC1            40  157  6274 FSC2            40  157  6267 FSCZAP          38  151  6225 GOHIGH
 38  154 10352 GOLOW           38  154 10350 GOMAIN           1    6 10342 GOMSTART        18  125  3474 HHS
 38  154 10346 HIGHSMAIN       18  114  3427 HLAR            18  114  3430 HLLEM1          18  120  3454 HLLES1
 18  123  3470 HLLES2          18  129  3533 HLLM1           18  118  3450 HLLOS1          18  113  2774 HLLZS1
 18  114  3432 HLREM1          18  129  3534 HLRM1           18  113  2777 HLRZS1          18  127  3526 HLSZ
 18  124  3472 HMV             18  128  3531 HOL             18  127  3527 HOR             18  114  3426 HRAR
 18  114  3431 HRLEM1          18  129  3532 HRLM1           18  113  2775 HRLZS1          18  114  3433 HRREM1
 18  121  3456 HRRES1          18  129  3535 HRRM1           18  119  3452 HRROS1          18  113  2776 HRRZS1
 18  128  3530 HRSZ            18  116  3444 HSMAIN          18  117  3446 HSMN1            5    3  2266 IBP
 14   70  4032 IBP1            14   70  4035 IBT1            15   71  4076 IDIV1           15   73  4106 IDIV2
 15   75  4116 IDIV3            7   10  2461 IDIV9            5    3  2274 IDPB            14   61  2610 IDPB1
 14   61  2614 IDPB2           14   66  2666 IDPB3            5    3  2270 ILDB            14   60  2602 ILDB1
 14   60  2606 ILDB2           14   61  2616 ILDB3           15   70  4037 IMUL1           15   70  4041 IMUL2
 15   70  4044 IMUL3           40  159  6423 INSEX1          40  159  6422 INSEXP          18  133  3546 JFCL1
 16   86  4162 JFFO1           16   86  4163 JFFO2           16   86  4166 JFFO3           16   86  4171 JFFO4
 16   86  4167 JFFO5           18  133  3555 JRA1            18  131  3504 JRST1           18  132  3515 JRST2
 18  133  3544 JRST3           18  131  3507 JRST4           18  131  3510 JRST5           18  131  3514 JRST8
 18  131  3513 JRST9           18  133  3553 JSA1            27  141  5551 JSMFR            8   13  2553 JSP1
 18  133  3551 JSR2             4    2  2210 JSYS            28  141  5635 JSYS1           28  141  5642 JSYS2
  4    2  2211 JSYS3           41  162  5042 KAFIXN          41  162  5040 KAFIXP           4    3  2244 KIFIX
 41  162  5055 KIFIX1          41  162  5060 KIFIXN           1    1 10001 KNYCLR           1    2 10014 KNYGOA
  1    3 10167 KNYMTP           1    2 10010 KNYRGO           1    1 10001 KNYRS1           1    6 10322 KNYW1
  1    6 10320 KNYWAIT          5    3  2272 LDB             14   62  2624 LDB1            14   62  2633 LDB2
 14   62  2635 LDB4            14   62  2625 LDB5            17  104  2766 LOG2            17  104  2767 LOG3
 19  134  5120 LPTDSP          16   97  2752 LSHC1           16   99  2735 LSHC2           16   90  2731 LSHDO
 16   90  2733 LSHDO1          16   88  2713 LSHNEG          16   88  2714 LSHNN1          16   90  2726 LSHPDO
 16   88  2711 LSHPLS           4    1  2026 MAIN             4    1  2027 MAIN1            4    1  2030 MAIN2
 25  140  5147 MAPCO0          26  141  5363 MAPCO1          26  141  5400 MAPCO4          26  141  5405 MAPCO6
 26  141  5407 MAPCO7          26  141  5356 MAPCOA          25  140  5170 MAPCOB          25  140  5171 MAPCOC
 26  141  5360 MAPCOE          26  141  5367 MAPCOG          25  141  5344 MAPCW1          25  141  5345 MAPCW2
 26  141  5412 MAPCW9          25  141  5340 MAPCWT          26  141  5414 MAPDO           25  140  5145 MAPIO1
 25  140  5141 MAPIOT          26  141  5402 MAPOFF          27  141  5625 MAPRSL          27  141  5624 MAPRSS
 27  141  5622 MAPRST          25  140  6201 MBLT2           25  140  6126 MBLT3            1    6  5000 MBOOT
  1    7  6221 MBOOTA           1    6 10264 MBOOTH           1    6 10307 MBTBY1           1    6 10315 MBTBY2
  1    6 10306 MBTBYTE          1    6 10317 MBTBYX           1    6 10326 MBTCHECK         1    6 10332 MBTDNX
  1    6 10344 MBTERR          26  141  5444 MFA1            26  141  5452 MFA2            26  141  5426 MFA3
 26  141  5433 MFA4            27  141  5520 MFA5            26  141  5432 MFA6            26  141  5427 MFA7
 26  141  5456 MFB3            27  141  5561 MFB4            27  141  5561 MFB5            27  141  5573 MFC1
 26  141  5443 MFHIEX          25  140  6111 MFOTH           25  140  6110 MFRD            25  140  6104 MFT1
 25  140  6105 MFT1A           26  141  5437 MFT1B           25  140  6106 MFT1D           27  141  5554 MFTR1
 27  141  5557 MFTR10          27  141  5604 MFTR2           27  141  5605 MFTR3           27  141  5607 MFTR4
 27  141  5620 MFTR41          27  141  5607 MFTR5           27  141  5610 MFTR6           27  141  5616 MFTR7
 27  141  5617 MFTR9           26  141  5475 MFTYP0          26  141  5473 MFTYP1          26  141  5423 MFUS
  6    3  2400 MOVE             6    3  2401 MOVE1            6    3  2402 MOVEI            6    3  2404 MOVEM
  6    3  2406 MOVES            6    3  2430 MOVM             6    4  2142 MOVM1            6    4  2432 MOVMI
  6    4  2434 MOVMM            6    4  2436 MOVMS            6    6  2042 MOVMS1           6   10  2054 MOVMS2
  6    7  2044 MOVMS3           6    8  2046 MOVMS4           6    9  2050 MOVMS5           6   10  2052 MOVMS6
  6    3  2420 MOVN             6    3  2422 MOVNI            6    3  2424 MOVNM            6    3  2426 MOVNS
 18  113  2773 MOVNS1           6    3  2410 MOVS             6    3  2412 MOVSI            6    3  2414 MOVSM
  6    3  2416 MOVSS           18  113  2772 MOVSS1          26  141  5401 MPOFF1          15   70  4060 MSETOV
  4    1  2032 MSMAIN           4    1  2033 MSMAIN1         14   58  4000 MSTART          15   70  4061 MSTOV1
 14   59  4001 MSTRT1          27  141  5605 MTRPAL          18  134  4460 MUJSA           18  134  4464 MUJSM1
 18  134  4456 MUJSP           18  134  4453 MUJSR           18  134  4462 MUJSYS          15   70  4046 MUL1
 15   70  4050 MUL2            15   70  4052 MUL3             4    1  2100 MUUO             4    2  2101 MUUO2
  4    2  2103 MUUO3            4    2  2105 MUUO4            4    2  2106 MUUO44           4    2  2120 MUUO5X
  4    2  2124 MUUO5Y           0   38     0*NAF              1    2 10032 NCNTW1           1    2 10032 NCNTWT
 40  159  6405 NEGNOR           4    1  2027 NMAIN1          40  159  6410 NN1              3    1     0*no-@
 40  159  6413 NORMOV          40  160  6477 NORND           18  105  2071 NORSW           18  106  4411 NORSW2
 18  105  2073 NOSW            40  159  6420 NOVNO           40  159  6416 NOVYES          40  159  6376 NRMLIZ
 10   23  3133 OCAI1           10   24  3163 OCBI1           10   24  3153 OCMI1           17  104  2770 ORCM2
 17  104  2771 ORCM3            1    6 10273 P2               1    6 10274 P2A             31  148  4734 PDLMEM
 31  148  4736 PDLO            31  147  4717 PDLO1           31  147  4722 PDLO2           31  147  4724 PDLO3
 31  147  4727 PDLO4           31  147  4723 PDLO5           31  147  4732 PDLO6           31  148  4735 PDLOE
 21  138  4534 PI-CHECK-RQS    22  138  4603 PI-DISMISS      21  138  4526 PI-GET-CHN      23  138  4644 PI-RESET
 23  138  4637 PICONISUB       23  138  4606 PICONO          30  141  5320 PIDSP           22  138  4562 PIGEN
 22  138  4567 PIGEN1          22  138  4574 PIGENWT         21  138  4532 PIGETMASK       21  138  4553 PIINTGO
 21  138  4530 PIL1            21  138  4554 PIL11           23  138  4622 PIL3            23  138  4624 PIL4
 23  138  4626 PIL5            23  138  4630 PIL6            23  138  4613 PIL7            23  138  4615 PIL8
 23  138  4617 PIL9             4    2  2105 PIMUUO          16  102  4247 POP1            16  102  4252 POPJ1
 40  159  6402 POSNOR          16  102  4245 PUSH1           16  102  4253 PUSHJ1          25  140  6147 QORCRY
 18  106  4350 RESET           18  106  4353 RESLOP          18  106  4345 RESW1           18  112  4420 RESW2
 16   94  2742 ROTC1           16   95  2747 ROTC2           16   88  2707 ROTDO           16   87  2704 ROTNEG
 16   87  2705 ROTNN1          16   87  2702 ROTPLS          20  138  4501 SDSKO2          31  149  6042 SECCS
 20  138  4477 SET-DSK-OUT     40  159  6430 SETFOV          25  140  6152 SETHFU          25  140  6146 SETHLF
 18  112  4444 SETLTS          10   17  3030 SETM            16   92  4202 SETOV1          16  101  2034 SJMAIN
  9   15  2663 SKIPX1          12   47  3424 SKMAIN           4    1  2024 SMAIN            4    1  2025 SMAIN1
 31  149  6072 SOEDOV          31  149  6036 SOVRS            1    2 10051 STDC1           31  149  6035 STOPS
 18  106  4367 STPLOP          18  106  4403 STPLP1           1    2 10047 STRTDC          18  112  4424 STRTSW
 18  105  2062 SWINT           38  151  6223 TAPDSP           1    3 10175 TAPEBR           1    3 10174 TAPEFR
  1    3 10147 TAPEMT           1    4 10231 TAPENR           1    2 10005 TAPERD           1    3 10206 TAPERS
  1    3 10173 TAPERW           1    5 10233 TAPERX           1    5 10241 TAPEWR          20  138  4514 TAPRST
 43  166  6750 TCNI1           43  166  6746 TCNO1           43  166  6752 TDATO           12   51  3525 TDC1
 12   53  3565 TDO1            43  166  6756 TDTI            12   49  3466 TDZ1            12   49  3467 TDZ2
  1    3 10165 TERAS1           1    3 10166 TERASE          40  161  6533 TESMUL          13   55  3740 TIMER-IOTS
 43  165  6740 TIMINT          20  138  4517 TIMRST          12   45  3416 TLC1            12   43  3412 TLO1
 12   41  3406 TLZ1             1    1  6637 TNCASODOF        1    1  6602 TNI              1    1  6614 TNI0
  1    1  6615 TNI1             1    1  6622 TNI2             1    6  7627 TNIC0            1    9  6646 TNIC0A
  1    9  6650 TNIC0B           1    9  6654 TNIC0C           1    7  7642 TNIC1            1    8  7651 TNIC2
  1    9  6642 TNICDN           1    6  7637 TNICRM           1    1  6636 TNIRF            1    1  7600 TNOC0
  1    2  7602 TNOC0A           1    3  7611 TNOC2            1    1  6633 TNORE            1    1  6634 TNRCW
  1    5 10237 TNRP3            1    1  6624 TNSEND           1    9  6666 TNSI             1   10  6673 TNSO
  1    3 10204 TPCLRNK          1    2 10115 TPMAOK           1    3 10200 TPSETDMP         1    3 10176 TPSETIND
  1    3 10202 TPSETNK         12   44  3414 TRC1             1    2 10105 TRCHA            1    2 10103 TRCHECK
  1    2 10104 TRCHKB           1    2 10131 TRCRET           1    2 10140 TRCX             1    2 10107 TRDONE
  1    2 10141 TREOF            1    2 10142 TRERR           12   42  3410 TRO1             1    2 10100 TRP2
 12   40  3404 TRZ1            12   49  3465 TSZ2             1    5 10257 TWER1            1    5 10254 TWERR
  1    3 10164 TWREOF           1    5 10242 TWRTRY           1   12  6711 TYMAREA          1    9  6655 TYMCLK
  1   12  6716 TYMNIN           1   12  6713 TYMNOUT          1   12  6711 TYMNRESET        1   12  6704 TYMRS1
  1   12  6705 TYMRS2          20  138  4506 TYMRST           4    2  2125 UAOP            20  138  4502 UDSKST
  4    3  2260 UFA             40  157  6257 UFA1            40  160  6500 UFANOR           4    2  2200 UMOVE
 28  141  5656 UMOVX            1    5 10240 UTAPWR           4    1  2076 UUO0-7           4    1  2020 UUO1
  4    1  2021 UUO2             4    1  2060 UUOGO            4    2  2117 UUOPJ           15    2 11227 VID33L
 14    1 11126 VIDCCL          14    1 11113 VIDCCS          14    2 11213 VIDCE1          14    2 11216 VIDCE2
 14    2 11201 VIDCHE          14    1 11047 VIDCHH          14    1 11014 VIDCHI          14    1 11143 VIDCHL
 14    1 11046 VIDCHM          14    1 11171 VIDCHS          16    2 11247 VIDCOL           5    1  6255 VIDCOM
 15    2 11226 VIDD33          27    8 11755 VIDDIV          10    1 10673 VIDDON          24    8 11651 VIDDOT
 10    1 10454 VIDDPA           7    1 10353 VIDDPI          10    1 10456 VIDDPO          24    8 11653 VIDDT1
 24    8 11657 VIDDT2          24    8 11665 VIDDT3          27    8 11757 VIDDV1          27    8 11763 VIDDV2
 27    8 11764 VIDDVL          11    1 10711 VIDEND           7    1 10403 VIDHER          22    7 11615 VIDHZL
 22    7 11602 VIDHZV           5    1  6246 VIDIN            7    1 10364 VIDIN1           7    1 10405 VIDIN2
  7    1 10407 VIDIN3           7    1 10422 VIDIN4          11    1 10710 VIDINT          20    2 11425 VIDLL1
 20    4 11501 VIDLL2          10    1 10702 VIDMHE          10    1 10630 VIDMHH          10    1 10602 VIDMHL
 10    1 10667 VIDMLE          10    1 10656 VIDMLH          10    1 10641 VIDMLL          26    8 11747 VIDMUL
  9    1 10452 VIDNR1           8    1 10425 VIDNTI           9    1 10440 VIDNTR           5    1  6251 VIDOUT
 16    2 11240 VIDPT1          16    2 11232 VIDPUT          12    1 10735 VIDRET          12    1 11010 VIDRIE
 12    1 11001 VIDRIH          12    1 10775 VIDRIM          11    1 10712 VIDSAM          14    1 11057 VIDSC1
 14    1 11060 VIDSC2          14    1 11053 VIDSCL          14    2 11221 VIDSCN          20    4 11472 VIDSL1
 20    6 11546 VIDSL2           5    1  6226 VIDTAB          10    1 10506 VIDTDE          10    1 10476 VIDTDL
 10    1 10531 VIDTFL          10    1 10526 VIDTNE          10    1 10516 VIDTNL          20    2 11263 VIDVC1
 20    2 11271 VIDVC2          20    2 11277 VIDVC3          20    2 11311 VIDVC4          20    2 11325 VIDVC5
 20    2 11334 VIDVC6          20    2 11347 VIDVCH          20    2 11257 VIDVCI          23    8 11627 VIDVEN
 20    2 11356 VIDVI0          20    2 11365 VIDVI1          20    2 11374 VIDVI2          20    2 11410 VIDVI3
 20    2 11422 VIDVI4          20    2 11343 VIDVIM          25    8 11727 VIDVL1          25    8 11734 VIDVL2
 25    8 11742 VIDVL3          25    8 11720 VIDVLM          21    6 11570 VIDVRL          21    6 11555 VIDVRV
  1    2 10055 WCDONE          29  141  5775 XBLTL           28  141  5736 XBY1            28  141  5756 XBY13
 28  141  5747 XBY14           28  141  5743 XBY15           28  141  5761 XBY3            28  141  5741 XBY4
 28  141  5662 XCT1            28  141  5730 XCT10           28  141  5712 XCT11           28  141  5711 XCT12
 28  141  5702 XCT13           28  141  5703 XCT18           28  141  5714 XCT2            28  141  5675 XCT3
 28  141  5670 XCT4            28  141  5666 XCT5            28  141  5672 XCT6            28  141  5715 XCTAC
 28  141  5732 XCTBLG          29  141  5774 XCTBLT          28  141  5735 XCTBYT          28  141  5724 XCTSTK
 28  141  5665 XCTUMV          28  141  5713 XDISP           29  141  5770 XFIXMA           4    3  2041 XMOVEM1
 29  141  6017 XPDLO2          29  141  6021 XPOP1           29  141  6032 XPOP2           29  141  6034 XPOP3
 29  141  6010 XPUSH1          40  160  6474 YESRND          40  160  6511 ZLOW           
01m0046                               	LIST-CORMAP


			Storage map


     0	X...............................................................
   100	................................................................
   200	................................................................
   300	................................................................
   400	................................................................
   500	................................................................
   600	................................................................
   700	................................................................
  1000	................................................................
  1100	................................................................
  1200	................................................................
  1300	................................................................
  1400	................................................................
  1500	................................................................
  1600	................................................................
  1700	................................................................
  2000	XXXXXXXXXXX.XXXXXXXXXXXXX.XXXX..XXXXXXXXXXXXX...X.XXXXXXXXXX..XX
  2100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXX..XXXXXXXXXX.....X.XXXXXX..XXXXXX..
  2200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  2300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  2400	XXX.X.XXXXX.XXXXXXX.X.XXXXX.XXXXXXX.XXXXXXX.XXXXXXX.XXXXXXX.XXXX
  2500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  2600	XXXXXXX.XXXXX.XXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXX..
  2700	XXXXXXXXXXXXXX..XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXX
  3000	X.X.X.X.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.X.X.XX
  3200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3400	XXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  3500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..XXXXXXXXXXXXXXXXXXXXXXXXXX......
  3600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.X.
  4000	XXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX................................
  5000	XXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX...
  5100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  5200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  5300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6000	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  6100	X...XXXXXX..X...XXXXXXX.XXX.XX..XXXXXXXXXXXXXX..XXXXXXX.X...XXXX
  6200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7000	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX........
  7400	................................................................
  7500	................................................................
  7600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX...............
  7700	................................................................
 10000	XXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXX
 10200	XXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXX
 10400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11000	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX........
 12000	................................................................
 12100	................................................................
 12200	................................................................
 12300	................................................................
 12400	................................................................
 12500	................................................................
 12600	................................................................
 12700	................................................................
 13000	................................................................
 13100	................................................................
 13200	................................................................
 13300	................................................................
 13400	................................................................
 13500	................................................................
 13600	................................................................
 13700	................................................................
 14000	................................................................
 14100	................................................................
 14200	................................................................
 14300	................................................................
 14400	................................................................
 14500	................................................................
 14600	................................................................
 14700	................................................................
 15000	................................................................
 15100	................................................................
 15200	................................................................
 15300	................................................................
 15400	................................................................
 15500	................................................................
 15600	................................................................
 15700	................................................................
 16000	................................................................
 16100	X.......X...X...................................................
 16200	................................................................
 16300	................................................................
 16400	................................................................
 16500	................................................................
 16600	................................................................
 16700	................................................................
 17000	................................................................
 17100	................................................................
 17200	................................................................
 17300	................................................................
 17400	................................................................
 17500	................................................................
 17600	................................................................
 17700	................................................XXXXXXXXXXXXXXXX
  3763 locations used,  highest used = 17777
%Warn    no-@  is an undefined label 
