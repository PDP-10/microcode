COMMENT \

	FOONLY F2-F3 MICRO-CODE

 (SET F2SW TO 1 FOR F2, SET F2SW TO 0 FOR F3)
  (THIS SETTING SHOULD BE DONE IN CFDEF, WHICH HAS
      DIFFERENT DEFINITIONS FOR THE TWO ANYWAY)

\


F3SW = 1 - F2SW

COMMENT \

********************************************************

	USEFUL MICROCDE WORD DEFINITIONS

********************************************************
\
	.DEFINE .PAIR [] [:. \ 2 + .]

FIXM1 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-RD] CYLEN[FIXM] $
FIXML = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-RD] CYLEN[LONG] $
FIXM2 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM] $
FIXM0 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[0] CYLEN[FIXM] $
.DEFINE MEMST [] [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]
  ;  NOTE:  BECAUSE OF XCT MAPPED, MEMST IS SAME AS MEMSTMA
 ; .DEFINE MEMST [] [COND[-MA-AC] LBJUMP[SMAIN] NORM ]
.DEFINE MEMSTMA [] [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]

DOSKIP = D[PC] ALU[D+1] DEST[MA PC] JUMP[MAIN1] NORM $
DONTSKIP = DEST[MA] SPEC[MA_PC] JUMP[MAIN1] $
DOJUMP = D[IR] DEST[MA PC] JUMP[MAIN1] NORM $
DOM1	= SPEC[MA_PC] JUMP[MAIN1] NORM $

CLRR	= ROT 22 D[MASK 22] ALU[D&AC] ACSEL[AC] DEST[AC] $
CLRL	= 	 D[MASK 22] ALU[D&AC] ACSEL[AC] DEST[AC] $

.DEFINE SLFFXM[ JDST ] 
[	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM] COND[-AC=0] JUMP[ JDST ] $
]

BADLOC = JUMP[MAIN] $;NOP FOR NOWJUMP BADPC $		;FOR WORDS WE SHOULDN'T USE
;;;;;ILGIOT = CURRENTLY-UNUSED[1] NORM JUMP[2000] $

.DEFINE ILGIOT[ ]
[  JUMP [MAIN] CURRENTLY-UNUSED[1] ]


UUOLOC = D[CONST 40] JUMP[2020] NORM $

   .DEFINE MUUO1 [][ D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
]
   .DEFINE UAOP1 [][ D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]

;
; THESE OUTLANDISHLY EXPLICIT DEFINITIONS OF NOP ASSURE THAT THE
; DECODER WILL PRINT 'NOP' ONLY WHEN YOU REALLY MEAN IT.
;
NOP =    COND[0] DEST[0] CONT ALU[D]
	ACSEL[AC] NO-MA-STB NO-AR-STB ROT[0] MASK[-1] ALU-D[NONE] $

DONOP  = COND 0 DEST[ 0] ALU[D]
	 ROT[0] MASK[-1] ACSEL[AC] JUMP[MAIN] ALU-D[NONE] NORM $

DODISP	= D[MEM] DEST[IR-ALL MA AR] SPEC[PC+1-IF&] DISP[2374] CYLEN[DISP] $

COMMENT \

*****************************************************

		REAL CODE

*****************************************************
\

	; UUO 0 COMES HERE (ALONG WITH UUO 1 - 7 )
: 2000	D[IR] ROT[9.] MASK[9.] COND[OBUS=0] JUMP[MUUO] C550 $;J IF 0 UUO
	UUOLOC $


.REPEAT F3SW [
	; INDIRECTING TRAPS HERE
: 2002	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
	D[MEM] DEST[IR-23 MA AR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
;STOP SWITCH, OV, & ECC TRAPS HERE (4 & 5)
: 2004	DEST[CLR-DEV-FROM-INTR] JUMP[SOED] NORM $
: 2005	DEST[CLR-DEV-FROM-INTR] JUMP[SOED] NORM $
	; INDEXING TRAPS HERE
: 2006	ALU[IX+D] D[IR] MASK[18.] DEST[AR IR-ADR MA] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP]$

	;INTERRUPTS TRAP HERE
;;;;; : 2007	D[10] SDISP C600       $
: 2007	JUMP[7400] $
: 7400
	D[10] DEST[Q AR] C550 $
	D[CONST 21] ROT[6] ALU[D#Q] DEST[Q] C550 $
	D[CONST 30] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 34] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 41] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 50] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 56] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $

	D[CONST 1] ROT[6] ALU[D#Q] DEST[Q] C550 $
	D[CONST 62] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[AR] DEST[CLR-DEV-FROM-INTR] JUMP[.] CURRENTLY-UNUSED[1] C550 $
INTOK:	D[10] SDISP C600 $

 ]

.REPEAT F2SW [
.REPEAT 1 - DLS [
: 2002 ;I/O INTERRUPTS TRAP HERE
	JUMP[7400] $
: 7400
	D[10] DEST[Q AR] C550 $
	D[CONST 21] ROT[6] ALU[D#Q] DEST[Q] C550 $
	D[CONST 30] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 34] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 41] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 50] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 56] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $

	D[CONST 1] ROT[6] ALU[D#Q] DEST[Q] C550 $
	D[CONST 62] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[AR] DEST[CLR-DEV-FROM-INTR] JUMP[MAIN] CURRENTLY-UNUSED[1] C550 $
INTOK:	D[10] SDISP C600 $
];1 - DLS	9 JAN 80 BO
.REPEAT DLS [
:2002	;I/O INTERRUPTS TRAP HERE
	D[10] SDISP C600 $	;Just dispatch and save time.

;;;;;; : 7400	;Unused device codes come here.
;;;;;; 	D[AR] DEST[CLR-DEV-FROM-INTR] JUMP[MAIN] CURRENTLY-UNUSED[1] C550 $
];DLS

: 2003 ;STOP SWITCH TRAPS HERE
	DEST[CLR-DEV-FROM-INTR] JUMP[STOPS] NORM $
: 2004	;CAN'T GET HERE FROM THERE...
	JUMP[.] $ ;HANG FOR NOW.
: 2005	;ECC ERRORS TRAP HERE
	DEST[CLR-DEV-FROM-INTR] JUMP[SECCS] NORM $
: 2006	;PC OV TRAPS HERE
	DEST[CLR-DEV-FROM-INTR] JUMP[SOVRS] NORM $
: 2007 ;BOTH ECC AND OV (AT THE SAME TIME) TRAPS HERE
	DEST[CLR-DEV-FROM-INTR] JUMP[SECCS] NORM $
: 2010 ;NORMAL INDIRECT TRAPS HERE
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
	D[MEM] DEST[IR-23 MA AR] DISP[2174] SPEC[PC+1-IF] CYLEN[DISP] $
		;WHEN EXTEND HAPPENS, DISP[2176]? NO-- HOW WOULD WE SEE
		;EXTENDED AREA OF IX REG?
: 2012	;NORMAL INDEXING TRAPS HERE
	ALU[IX+D] D[IR] MASK[18.] DEST[AR IR-ADR MA] DISP[2024] SPEC[PC+1-IF] CYLEN[DISP]$
		;WHEN EXTEND HAPPENS, DISP[2026]
: 2014	;EXTENDED INDIRECT TRAPS HERE
; SOMETHING MAKES THIS DIFFERENT FROM 2010 -- MAYBE LOADING H.O. MA??
 JUMP[.] $	;FOR NOW ;;;ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
	D[MEM] DEST[IR-23 MA AR] DISP[2176] SPEC[PC+1-IF] CYLEN[DISP] $
: 2016	;EXTENDED INDEXING TRAPS HERE
 JUMP[.] $	;FOR NOW ;;;D[AR] ROT[6] MASK[4] DEST[AC-SEL] NORM $
	D[AR] ALU[D+AC] ACSEL[REG] DEST[IR-ADR MA AR] SPEC[PC+1-IF] DISP[2026] CYLEN[DISP] $
  ]

: 2020	D[CONST 40] DEST[MA] PUSHJ[UUOPJ] NORM  $
UUO2:	D[IR] ALU[D&Q] DEST[MEMSTO] NORM $
	D[PC] ALU[D-1] DEST[PC] MAPF[MASTO] CYLEN[MEMSTO] $
	D[CONST 41] DEST[MA] JUMP[NMAIN1] NORM $

: 2024 SMAIN: ACSEL[MA] D[MEM] DEST[AC AR MA] SPEC[MA_PC] JUMP[NMAIN1] CYLEN[MEMSTO] MAPF[STO] $
SMAIN1:	D[MEM] SPEC[MA_PC] DEST[AR MA] JUMP[NMAIN1] CYLEN[MEMSTO] MAPF[STO] $

MAIN:	SPEC[MA_PC] DEST[MA CLR-DEV-FROM-INTR] NORM JPOP[MAIN1] $
	   ;START THE INSTR. FETCH (AND POP THE STACK A LITTLE...)

NMAIN1:
MAIN1:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] 
	 JPOP[MAIN2] CYLEN[FIXM] $ ; I.E. FIXM ### AND FLUSH STACK ####

MAIN2:	D[MEM] DEST[IR-ALL MA AR] SPEC[PC+1-IF&] DISP[2374] CYLEN[DISP] $

	.PAIR	;: 2032 ; .PAIR
MSMAIN:	ACSEL[MA] D[MEM] DEST[AC] JUMP[MAIN] CYLEN[MEMSTO] MAPF[MASTO] $
MSMAIN1:	MAPF[MASTO] JUMP[MAIN] CYLEN[MEMSTO] $

: 2040	UUOLOC $
: 2060	UUOLOC $
: 2100	MUUO:	MUUO1
MUUO2:	D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $;CLR USER
	D[CONST 40] DEST[MA] PUSHJ[UUOPJ] NORM $
MUUO3:	D[IR] ALU[D&Q] DEST[MEMSTO] NORM $; STORE INSTR
	D[MA] ALU[D+1] DEST[MA] CYLEN[MEMSTO] $; GET DISP INST.
MUUO4:
PIMUUO:	D[CONST 55] ROT[2] DEST[Q FIXMAC-MAPF-RD] CYLEN[FIXM] $; JSR OPCODE
MUUO44:	D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSR] CYLEN[C650] $ ;J IF JSR
	ALU[Q+1] DEST[Q] SHORT $
	D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSP] C550 $; J IF JSP
	ALU[Q+1] DEST[Q] SHORT $
	D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSA] C550 $; J IF JSA
	D[CONST 42] ROT[1] DEST[Q] SHORT $; JSYS OP
	D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSYS] C550 $; J IF JSYS
	D[PC] ALU[D-1] DEST[PC] SHORT $
	D[AR] DEST[CRYOV] JUMP[MAIN2] $; ELSE DISPATCH

UUOPJ:	D[MASK 37] ROT[27] DEST[Q] POPJ NORM $

: 2120	D[IR] ROT[7] MASK[1] DEST[Q] NORM $
	D[IR] ROT[10] MASK[1] ALU[D#Q] COND[OBUS=0] JUMP[MUUO] C550 $; J IF UUO 50,51,56, OR 57
	ALU[Q] COND[OBUS=0] JUMP[. + 2] CYLEN[C450] $; J IF 52 OR 53
	D[IR] ROT[11] MASK[1] COND[-OBUS=0] JUMP[MUUO] C550 $; J IF 55
	D[PC] DEST[Q AR] SHORT $
UAOP:	D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $; CLR USER
	D[MASK 37] ROT[27] DEST[Q] NORM $
	D[CONST 60] DEST[MA] JUMP[MUUO3] NORM $

: 2140	MUUO1 $
: 2160	MUUO1 $

: 2200

  ;UMOVE
UMOVE:	D[PC] ALU[D-1] DEST[MA PC] NORM $ ;RE-FETCH INSTR.
	FIXM1 JUMP[UMOVX] $	;WAIT FOR FETCH.

; UMOVEI, UMOVEM, UMOVES
	.REPEAT 3 [ JUMP[UMOVE] NORM $
			NOP $ 
  		]

;JSYS
	D[IR] ROT[33] MASK[11] COND[-OBUS=0] JUMP[JSYS1] C550 $; J IF NOT EX JSYS
JSYS3:	D[PC] DEST[Q AR] JUMP[JSYS2] $; GET PC & FLAGS

: 2212	;XMOVE - 105
	ALU[AC] ACSEL[AC+1] DEST[HI-ABS-MA MA] NORM $
	ALU[0] DEST[HI-ABS-MA] JUMP[2401] NORM $
	;XMOVEM - 106
	ALU[AC] ACSEL[AC+1] DEST[HI-ABS-MA MA] NORM $
	ALU[AC] DEST[MEMSTO] NORM JUMP[XMOVEM1] $
SAV16:
 : 2730
XMOVEM1: ALU[0] DEST[HI-ABS-MA] NORM JUMP[MAIN] $

: SAV16

	.REPEAT 21 [ UAOP1
	NOP $
	]

;130, UFA
	FIXM1 $
	D[CONST 11] DEST[DEV-ADR] JUMP[UFA1] $
;131, DFN
	FIXM2 $
	D[MEM] MASK[27.] ALU[0-D] DEST[AR] COND[OBUS=0] LBJUMP[DFN1] C600 $
;132, FSC

	D[MASK 27.] ALU[D&AC] ACSEL[AC] COND[OBUS=0] JUMP[FSCZAP] C550 $
	ACSEL[AC] ALU[AC] DEST[AR] JUMP[FSC1] NORM $

;IBP
 : 2266	FIXM2 COND[HALF] JUMP[MAIN] $
	D[MEM] DEST[Q AR] JUMP[IBP1] NORM $
;ILDB
 : 2270	FIXM2 $
	D[MEM] DEST[Q AR] COND[-HALF] LBJUMP[ILDB1] NORM $
;LDB
 : 2272	FIXM1 $
	D[MEM] DEST[Q AR MA] COND[-MEM-IDX-IND] LBJUMP[LDB1] CYLEN[C500] $
;IDPB
 : 2274	FIXM2 $
	D[MEM] DEST[Q AR] COND[-HALF] LBJUMP[IDPB1] NORM $
;DPB
 : 2276	FIXM1 $
	D[MEM] DEST[Q AR MA] LBJUMP[DPB1] COND[-MEM-IDX-IND] CYLEN[C500]  $

;FAD FADL FADM FADB FADR FADRI FADRM FADRB
: 2300	FIXM1 JUMP[FAOS1] $ NOP $
	FIXM1 JUMP[FAOS2] $ NOP $
	FIXM2 JUMP[FAOS3] $ NOP $
	FIXM2 JUMP[FAOS4] $ NOP $
	FIXM1 JUMP[FAOS1] $ NOP $
	D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] JUMP[FAOS5] NORM $ NOP $
	FIXM2 JUMP[FAOS3] $ NOP $
	FIXM2 JUMP[FAOS4] $ NOP $

;FSB FSBL FSBM FSBB FSBR FSBRI FSBRM FSBRB
.DEFINE FSBMAC[X] [
	D[MEM] ALU[0-D] DEST[HOLD] JUMP[X] NORM 
]
: 2320	FIXM1 $ FSBMAC[FAOS1] $
	FIXM1 $ FSBMAC[FAOS2] $
	FIXM2 $ FSBMAC[FAOS3] $
	FIXM2 $ FSBMAC[FAOS4] $
	FIXM1 $ FSBMAC[FAOS1] $
	D[MA] ROT[18.] DEST[HOLD] ALU[0-D] SPEC[LEFT] JUMP[FAOS5] NORM $ NOP $
	FIXM2 $ FSBMAC[FAOS3] $
	FIXM2 $ FSBMAC[FAOS4] $

;FMP FMPL FMPM FMPB FMPR FMPRI FMPRM FMPRB
: 2340	FIXM1 JUMP[FMP1] $ NOP $
	FIXM1 JUMP[FMP2] $ NOP $
	FIXM2 JUMP[FMP3] $ NOP $
	FIXM2 JUMP[FMP4] $ NOP $
	FIXM1 JUMP[FMP1] $ NOP $
	D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] JUMP[FMP5] NORM $ NOP $
	FIXM2 JUMP[FMP3] $ NOP $
	FIXM2 JUMP[FMP4] $ NOP $

;FDV FDVL FDVM FDVB FDVR FDVRI FDVRM FDVRB
.DEFINE DIVMAC[X] [
	D[CONST 11] DEST[DEV-ADR] JUMP[X] NORM
]
: 2360	FIXM1 $ DIVMAC[FD1] $
	FIXM1 $ DIVMAC[FD2] $
	FIXM2 $ DIVMAC[FD3] $
	FIXM2 $ DIVMAC[FD4] $
	FIXM1 $ DIVMAC[FD1] $
	FIXM1 $ DIVMAC[FD5] $
	FIXM2 $ DIVMAC[FD3] $
	FIXM2 $ DIVMAC[FD4] $

;MOVE
: 2400 MOVE: FIXM1 $
MOVE1:	ACSEL[AC] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
;MOVEI
	ACSEL[AC] D[IR] MASK[18.] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
: 2404
;MOVEM
	ACSEL[AC] ALU[AC] DEST[MEMSTO]  MEMST $
: 2406
;MOVES
	FIXM1 COND[-AC=0] JUMP[MOVE1]  $
	D[MEM] DEST[MEMSTO] MEMST $

;MOVS
 : 2410	FIXM1 $
	ACSEL[AC] D[MEM] ROT[18.] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
;MOVSI
	ACSEL[AC] D[IR] ROT[18.] DEST[AC MA] SPEC[LEFT&MA_PC] JUMP[MAIN1] NORM $
: 2414
;MOVSM
	ALU[AC] ACSEL[AC] DEST[AR] NORM $
	D[AR] ROT[18.] DEST[MEMSTO] MEMST $
;MOVSS
	SLFFXM[MOVSS1] $
	D[MEM] ROT[18.] DEST[MEMSTO] MEMST $

;MOVN
 : 2420	FIXM1 $
	ACSEL[AC] D[MEM] ALU[0-D] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
;MOVNI
	ACSEL[AC] D[IR] ALU[0-D] MASK[18.] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1] NORM $
: 2424
;MOVNM
MOVNM:	ACSEL[AC] ALU[0-AC] DEST[MEMSTO] SPEC[CRYOV] MEMST $
: 2426
;MOVNS
	SLFFXM[MOVNS1] $
	D[MEM] ALU[0-D] DEST[MEMSTO] SPEC[CRYOV] MEMST $

;MOVM
: 2430	FIXM1 $
	ACSEL[AC] D[MEM] DEST[AC] COND[OBUS<0] LBJUMP[MOVM1] C600 $
: 2042	MOVM1: SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
	 ACSEL[AC] ALU[0-AC] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1] NORM$

;MOVMI
: 2432	ACSEL[AC] D[IR] MASK[18.] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
: 2434
;MOVMM
	ACSEL[AC] ALU[AC] COND[OBUS<0] JUMP[MOVNM] CYLEN[C450] $
	ACSEL[AC] ALU[AC] DEST[MEMSTO] SPEC[CRYOV] MEMST $
;MOVMS
	COND[MA-AC] JUMP[MOVMS2] DEST[FIXMAC-MAPF-WRT] CYLEN[FIXM] MAPF[3] $
	COND[AC=0] LBJUMP[MOVMS1] NORM $
: 2044 MOVMS1:	D[MEM] COND[OBUS<0] LBJUMP[MOVMS3] C550 $
	D[MEM] COND[OBUS<0] LBJUMP[MOVMS4] C550 $
MOVMS3:	D[MEM] ACSEL[AC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $
	D[MEM] ALU[0-D] ACSEL[AC] DEST[MEMSTO AC] SPEC[CRYOV] MEMST $
MOVMS4:  SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
	D[MEM] ALU[0-D] DEST[MEMSTO] SPEC[CRYOV] JUMP[MSMAIN1] NORM $
MOVMS2:	ACSEL[MA] ALU[AC] COND[-OBUS<0] LBJUMP[MOVMS5] CYLEN[C500] $
: 2054 MOVMS5:	ACSEL[MA] ALU[0-AC] DEST[AC AR] SPEC[CRYOV] COND[AC=0] LBJUMP[MOVMS6] NORM $
	ACSEL[MA] ALU[AC] DEST[AR] COND[AC=0] LBJUMP[MOVMS6] NORM $
MOVMS6:	ACSEL[AC] D[AR] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $

;IMUL
: 2440	FIXM1 $
	D[MEM] DEST[Q] JUMP[IMUL1] NORM $
;IMULI
	D[IR] MASK[18.] DEST[Q] JUMP[IMUL1] NORM $
	NOP $
;IMULM
	FIXM2 $
	D[MEM] DEST[Q] JUMP[IMUL2] NORM $
;IMULB
	FIXM2 $
	D[MEM] DEST[Q] JUMP[IMUL3] NORM $
;MUL
	FIXM1 $
	D[MEM] DEST[Q] JUMP[MUL1] NORM $
;MULI
	D[IR] MASK[18.] DEST[Q] JUMP[MUL1] NORM $
	NOP $
;MULM
	FIXM2 $
	D[MEM] DEST[Q] JUMP[MUL2] NORM $
;MULB
	FIXM2 $
	D[MEM] DEST[Q] JUMP[MUL3] NORM $

;IDIV
: 2460	FIXM1 $
IDIV9:	ACSEL[AC] ALU[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV1] CYLEN[C500] $
		;LO PART TO Q, CHECK SIGN
;IDIVI
	D[IR] MASK[18.] DEST[HOLD] JUMP[IDIV9]  NORM $ ;IMMD
	NOP $
;IDIVM
	FIXM2 $
	ALU[AC] ACSEL[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV2]  CYLEN[C500] $
		;LO PART TO Q, SAVE AC, CHECK SIGN
;IDIVB
	FIXM2 $
	ACSEL[AC] ALU[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV3] CYLEN[C500] $
;DIV
: 2470	FIXM1 $
DIV9:	ACSEL[AC+1] ALU[AC] DEST[Q] JUMP[DIV1] $ ;LO PART
;DIVI
	D[IR] MASK[18.] DEST[HOLD] JUMP[DIV9] $ ;IMMD
	NOP $
;DIVM
	FIXM2 $
	ALU[AC] ACSEL[AC+1] DEST[Q] JUMP[DIV2] $
;DIVB
	FIXM2 $
	ALU[AC] ACSEL[AC+1] DEST[Q] JUMP[DIV3] $
   .DEFINE SH1ST [LAB1 LAB2]
[	D[IR] COND[OBUS18] DEST[Q] JUMP[LAB1] C550 $
	D[IR] MASK[10] DEST[Q ROTR] JUMP[LAB2] NORM $
]
;ASH
: 2500	SH1ST [ASHNEG ASHPLS]
;ROT
	SH1ST [ROTNEG ROTPLS]
;LSH
	SH1ST [LSHNEG LSHPLS]
;JFFO
	ACSEL[AC] ALU[AC] COND[OBUS=0] JUMP[JFFO1] DEST[AR] CYLEN[C450] $
	ACSEL[AC+1] ALU[0] DEST[AC] JUMP[JFFO2] NORM $
;ASHC
: 2510	ACSEL[AC+1] D[MASK 43] ALU[D&AC]   DEST[AR] NORM $
	D[AR] ROT[1] DEST[Q] JUMP[ASHC1] NORM $
;ROTC
	ACSEL[AC+1] ALU[AC] DEST[Q]   NORM $
	D[IR] COND[-OBUS18] LBJUMP[ROTC1] C550 $
;LSHC
	ACSEL[AC+1] ALU[AC] DEST[Q]   NORM $
	D[IR] COND[-OBUS18] LBJUMP[LSHC1] C550 $
;247 (KAFIX at SAIL)
	DONOP $
	NOP $


;EXCH
: 2520	FIXM2 $
	ACSEL[AC] D[MEM] DEST[MEMSTO O_AC] MEMST $
;BLT
	D[MASK 16] ROT[4] ACSEL[AC] ALU[D&AC] COND[OBUS=0] JUMP[BLTA1] C550 $ ;J IF DEST IS AC
	D[MASK 16] ROT[26] ACSEL[AC] ALU[D&AC] COND[-OBUS=0] LBJUMP[BLTA2] C600 $ ; J ON SRC NOT AC
;AOBJP
	D[CONST 1,,1] ACSEL[AC] ALU[D+AC]   DEST[AC]
	  COND[OBUS<0] JUMP[MAIN] C600 $
	DOJUMP $
;AOBJN
	D[CONST 1,,1] ACSEL[AC] ALU[D+AC]   DEST[AC]
	  COND[-OBUS<0] JUMP[MAIN] C600 $
	DOJUMP $
;JRST
: 2530	D[IR] DEST[MA PC] COND[AC=0] JUMP[MAIN1] NORM $
	D[IR] ROT[12] MASK[1] COND[OBUS=0] LBJUMP[JRST1] C550 $
;JFCL
	D[IR] ROT[15] MASK[4] DEST[AR] COND[AC=0] JUMP[MAIN] NORM $ ;GET AC FLD NOP IF 0
	D[PC] DEST[Q] JUMP[JFCL1] NORM $
;XCT
	FIXM1 COND[-AC=0] JUMP[XCT1] $
	D[PC] ALU[D-1] DEST[PC] JUMP[XCT2] NORM $
;??? 536 -- OP 257
	JUMP[MAIN] NORM $ ;257 IS A NO-OP
	NOP $

;PUSHJ
: 2540	ACSEL[AC] D[CONST 1,,1] ALU[D+AC]   DEST[AC MA]
	  COND[CRY0] JUMP[PDLO1] C600 $
	D[PC] DEST[MEMSTO] JUMP[PUSHJ1] NORM $
;PUSH
	FIXM1 $
	D[MEM] DEST[AR] JUMP[PUSH1] NORM $
;POP
	ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC] COND[-CRY0] JUMP[PDLO3] C600 $
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] JUMP[POP1] CYLEN[FIXM] $
;POPJ
	ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC] COND[-CRY0] JUMP[PDLO4] C600 $
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] JUMP[POPJ1] CYLEN[FIXM] $
;JSR
: 2550	D[PC] DEST[AR MEMSTO] COND[MA-AC] JUMP[JSR2] NORM $
	D[MA] ALU[D+1] DEST[PC] MAPF[STO] SPEC[CLR-HALF] JUMP[MAIN] CYLEN[MEMSTO] $
;JSP
	D[PC] ACSEL[AC] DEST[AC] NORM $
JSP1:	D[MA] DEST[PC] JUMP[MAIN1] SPEC[CLR-HALF] NORM $
;JSA
	D[PC] MASK[18.] DEST[O_AC AR] ACSEL[AC] NORM $; DID SAVE A CYCLE WITH O_AC ****
	D[MA] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC] JUMP[JSA1] NORM $
;JRA
	ACSEL[AC] ALU[AC] DEST[AR] NORM  $
	D[AR] ROT[18.] MASK[18.] DEST[MA] JUMP[JRA1] NORM $


.DEFINE ADOP [OP]
BEGIN ADOP
	FIXM1 $
	ACSEL[AC] D[MEM] ALU[ OP ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $

	ACSEL[AC] D[IR] MASK[18.] ALU[ OP ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1] NORM $
	NOP $

	FIXM2 $
	ACSEL[AC] D[MEM] ALU[ OP ] DEST[MEMSTO]
	  SPEC[CRYOV] MEMST $

	FIXM2 $
	ACSEL[AC] D[MEM] ALU[ OP ] DEST[MEMSTO AC]
	  SPEC[CRYOV] MEMST $
END ADOP

.DEFINE LOGOP [OP]
BEGIN LOGOP
	FIXM1 $
	ACSEL[AC] D[MEM] ALU[ OP ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $

	ACSEL[AC] D[IR] MASK[18.] ALU[ OP ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
	NOP $

	FIXM2 $
	ACSEL[AC] D[MEM] ALU[ OP ] DEST[MEMSTO]
	 MEMST $

	FIXM2 $
	ACSEL[AC] D[MEM] ALU[ OP ] DEST[MEMSTO AC]
	  MEMST $
END LOGOP

;ADD,ADDI,ADDM,ADDB
: 2560	ADOP[D+AC]

;SUB,SUBI,SUBM,SUBB
: 2570	ADOP[AC-D]

;CAI
: 2600	D[IR] MASK[18.] ACSEL[AC] ALU[AC-D] COND[-JCOND] JUMP[MAIN] C600 $
	DOSKIP $

;CAM
: 2620	FIXM1 $
	D[MEM] ACSEL[AC] ALU[AC-D] COND[-JCOND] JUMP[MAIN] C600 $
DOSKP1:	DOSKIP $

;JUMP
: 2640	D[CONST 0] ACSEL[AC] ALU[AC+D] COND[-JCOND] JUMP[MAIN] C600 $
	DOJUMP $

;SKIP
: 2660	FIXM1 COND[AC=0] JUMP[. + 3] $
	D[MEM] ALU[D-0] ACSEL[AC] DEST[AC] COND[-JCOND] JUMP[MAIN] C600 $
	DOSKIP $
	D[MEM] ALU[D-0] COND[-JCOND] JUMP[MAIN] C600 $
	DOSKIP $
;AOJ
: 2700	ACSEL[AC] ALU[AC+1] DEST[AC] SPEC[CRYOV] COND[-JCOND] JUMP[MAIN] C600 $
	DOJUMP $

;AOS
: 2720	FIXM2 COND[AC=0] JUMP[ASOS1]  $
	D[MEM] ALU[D+1] ACSEL[AC] DEST[AC MEMSTO] SPEC[CRYOV] COND[JCOND] LBJUMP[ASOS2] C600 $
ASOS1:	D[MEM] ALU[D+1] DEST[MEMSTO] SPEC[CRYOV] COND[JCOND] LBJUMP[ASOS2] C600 $
: 2724
ASOS2:	MEMST $
	D[PC] ALU[D+1]  DEST[PC] MEMST $

;SOJ
: 2740	ACSEL[AC] ALU[AC-1] DEST[AC] SPEC[CRYOV] COND[-JCOND] JUMP[MAIN] C600 $
	DOJUMP $

;SOS
: 2760	FIXM2 COND[AC=0] JUMP[ASOS3] $
	D[MEM] ALU[D-1] ACSEL[AC] DEST[AC MEMSTO] SPEC[CRYOV] COND[JCOND] LBJUMP[ASOS2] C600 $
ASOS3:	D[MEM] ALU[D-1] DEST[MEMSTO] SPEC[CRYOV] COND[JCOND] LBJUMP[ASOS2] C600 $


.DEFINE CLRAC [] [ ALU[0] ACSEL[AC] DEST[AC] NORM ]

;SETZ
: 3000	CLRAC   JUMP[MAIN] $
: 3002
;SETZI
	CLRAC   JUMP[MAIN] $
: 3004
;SETZM
	  ALU[0] DEST[MEMSTO] MEMST $
: 3006
;SETZB
	  ALU[0] DEST[MEMSTO AC] MEMST $
: 3010
;AND
: 3010	LOGOP[D&AC]

;ANDCA
: 3020	FIXM1 $
	ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA1] CYLEN[FIXM+1] $
;ANDCAI
	  ALU[NOTAC] DEST[Q] ACSEL[AC] NORM $
	D[IR] MASK[18.] ACSEL[AC] ALU[D&Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] $
;ANDCAM
	FIXM2 $
	ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA2] CYLEN[FIXM+1] $
;ANDCAB
	FIXM2 $
	ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA3] CYLEN[FIXM+1] $
;SETM
: 3030	SETM:	LOGOP[ D ] $

;ANDCM
: 3040	LOGOP[-D&AC]

;SETA
: 3050	LOGOP[ AC ] $
;XOR
: 3060	LOGOP[AC#D]

;OR
: 3070	LOGOP[DORAC]

;ANDCB
: 3100	FIXM1 $
	ACSEL[AC] ALU[DORAC] DEST[Q] D[MEM] JUMP[ACBI1] CYLEN[FIXM+1] $
;ANDCBI
	  ACSEL[AC] D[IR] MASK[18.] ALU[DORAC] DEST[Q] NORM $
ACBI1:	ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
;ANDCBM
	FIXM2 $
	ACSEL[AC] ALU[DORAC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $
;ANDCBB
	FIXM2 $
	ACSEL[AC] ALU[DORAC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $
;EQV
: 3110	LOGOP[AC/#D]

;SETCA
: 3120	LOGOP[NOTAC]

;ORCA
: 3130	FIXM1 $
	ACSEL[AC] D[MEM] ALU[-D&AC] DEST[Q] JUMP[OCAI1] CYLEN[FIXM+1] $
;ORCAI
	  ACSEL[AC] D[IR] MASK[18.] ALU[-D&AC] DEST[Q] NORM $
OCAI1:	ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
;ORCAM
	FIXM2 $
	ACSEL[AC] ALU[-D&AC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $
;ORCAB
	FIXM2 $
	ACSEL[AC] ALU[-D&AC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $
;SETCM
: 3140	LOGOP[NOTD]

;ORCM
: 3150	FIXM1 $
	D[MEM] ALU[NOTD] DEST[Q] JUMP[OCMI1] CYLEN[FIXM+1] $
;ORCMI
	  D[IR] MASK[18.] ALU[NOTD] DEST[Q] NORM $
OCMI1:	ACSEL[AC] ALU[QORAC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
;ORCMM
	FIXM2 $
	D[MEM] ALU[NOTD] DEST[Q] JUMP[ORCM2] CYLEN[FIXM+1] $
;ORCMB
	FIXM2 $
	D[MEM] ALU[NOTD] DEST[Q] JUMP[ORCM3] CYLEN[FIXM+1] $
;ORCB
: 3160	FIXM1 $
	ACSEL[AC] D[MEM] ALU[D&AC] DEST[Q] JUMP[OCBI1] CYLEN[FIXM+1] $
;ORCBI
	  ACSEL[AC] D[IR] MASK[18.] ALU[D&AC] DEST[Q] NORM $
OCBI1:	ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
;ORCBM
	FIXM2 $
	ACSEL[AC] ALU[D&AC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $
;ORCBB
	FIXM2 $
	ACSEL[AC] ALU[D&AC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $
;SETO
: 3170	  ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
: 3172
;SETOI
	  ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
: 3174
;SETOM
	  ALU[-1] DEST[MEMSTO] MEMST     $
: 3176
;SETOB
	  ALU[-1] ACSEL[AC] DEST[MEMSTO AC] MEMST $
	NOP $
.DEFINE MH1 [ RR MM SS RR2 D1 OP1 JJ CYL1 D2 SS1  ]
[	FIXM1 $
	D[MEM] ROT[ RR ] MASK[ MM ] SPEC[ SS ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] CYLEN[FIXM+1] $
	D[MA] ROT[RR] MASK[ MM ] SPEC[ SS ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM $
	NOP $
	D[MASK 22] ROT[ RR2 ] ACSEL[AC] ALU[D&AC] DEST[ D1 ] COND[-MA-AC] OP1 [ JJ ]  CYLEN[ CYL1 ] $
	D[AR] ROT[18.] DEST[MEMSTO] MEMST $
	ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ D2 ] DEST[FIXMAC-MAPF-WRT] MAPF[3] CYLEN[FIXM] $
	D[MEM] ROT[ RR ] MASK[ MM ] SPEC[ SS1 ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1] CYLEN[FIXM+1] $
]

.DEFINE MH2 [ RR MM SS CC OP DST RR2 DST2 CC2 OP2 JJ CYL2 RR3 DST3 CC4 ]
[	FIXM1 $
	D[MEM] ROT[ RR ] MASK[ MM ] SPEC[ SS ] ACSEL[AC] DEST[AC AR] COND[ CC ] OP [ DST ] CYLEN[FIXM+1] $
	D[MA] ROT[ RR ] MASK[ MM ] SPEC[ SS ] ACSEL[AC] DEST[AC AR] COND[ CC ] OP [ DST ] NORM $
	NOP $
	D[MASK 22] ROT[ RR2 ] ACSEL[AC] ALU[DORAC] DEST[Q DST2 ] COND[ CC2 ] OP2[JJ] CYLEN[ CYL2 ] $
	D[AR] ROT[RR3] DEST[MEMSTO] MEMST $
	FIXM2 $
	D[MEM] ROT[ RR ] DEST[Q AR] COND[ CC4 ] LBJUMP[ DST3] CYLEN[FIXM+1] $
]

.DEFINE MH3 [ RR MM SS JDST RR2 JDST2 DST OP1 JJ ]
[	FIXM1 $
	D[MEM] ROT[ RR ] MASK[ MM ] SPEC[ SS ] ACSEL[AC] DEST[O_AC AR] JUMP[ JDST ] CYLEN[FIXM+1] $
	D[MA] ROT[ RR ] MASK[ MM ] SPEC[ SS ] ACSEL[AC] DEST[O_AC AR] JUMP[ JDST ] NORM $
	NOP $
	FIXM2 $
	D[MASK 22] ROT[ RR2 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ JDST2 ] CYLEN[FIXM+1] $
	ACSEL[MA] ALU[AC] DEST[ DST ] MAPF[3] COND[-AC=0] OP1[JJ] CYLEN[FIXM] $
	D[MEM] ROT[ RR ] MASK[ MM ] SPEC[ SS ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS] CYLEN[FIXM+1] $
]

;HLL
: 3200	MH3[ 0 0 LEFT HRAR 22 HLLM1 0 LBJUMP HMV ]
;HRL
	MH3[ 22 0 LEFT HRAR 0 HRLM1 FIXMAC-MAPF-WRT CONTA 0]
;HLLZ
	MH1[0 0 LEFT&MA_PC 22 MEMSTO LBJUMP MSMAIN NORM HLLZS1 LEFT]
;HRLZ
	MH1[22 0 LEFT&MA_PC 0 AR CONTA 0 NORM HRLZS1 LEFT]
;HLLO
	MH2[0 44 0 0 JUMP HOR 0 MEMSTO -MA-AC LBJUMP MSMAIN NORM 0 HLLOS1 -AC=0]
;HRLO
	MH2[22 44 0 0 JUMP HOR 22 AR 0 CONTA 0 NORM 22 HLLOS1 -AC=0]
;HLLE
	MH2[0 0 LEFT OBUS<0 LBJUMP HLSZ 0 AR -OBUS<0 JUMP HLLEM1 C550 0 HLLES1 OBUS<0 ]
;HRLE
	MH2[22 0 LEFT OBUS<0 LBJUMP HLSZ 22 AR -OBUS18 JUMP HRLEM1 C550 22 HLLES1 OBUS<0 ]
;HRR
	MH3[0 22 0 HLAR 0 HRRM1 0 LBJUMP HMV ]
;HLR
	MH3[22 22 0 HLAR 22 HLRM1 FIXMAC-MAPF-WRT CONTA 0]
;HRRZ
	MH1[0 22 MA_PC 0 MEMSTO LBJUMP MSMAIN NORM HRRZS1 0]
;HLRZ
	MH1[22 22 MA_PC 22 AR CONTA 0 NORM HLRZS1 0]
;HRRO
	MH2[0 44 0 0 JUMP HOL 22 MEMSTO -MA-AC LBJUMP MSMAIN NORM 0 HRROS1 -AC=0]
;HLRO
	MH2[22 44 0 0 JUMP HOL 0 AR 0 CONTA 0 NORM 22 HRROS1 -AC=0]
;HRRE
	MH2[0 22 0 OBUS18 LBJUMP HRSZ 22 AR -OBUS18 JUMP HRREM1 C550 0 HRRES1 OBUS18]
;HLRE
	MH2[22 22 0 OBUS18 LBJUMP HRSZ 0 AR -OBUS<0 JUMP HLREM1 C550 22 HRRES1 OBUS18]

;TRN GROUP
: 3400	  D[IR] MASK[18.] ACSEL[AC] ALU[D&AC]
	    SPEC[MA_PC] DEST[MA] COND[-JCOND] JUMP[MAIN1] C550 $
	DOSKIP $
;TLN GROUP
	  D[IR] ROT[18.] ACSEL[AC] ALU[D&AC]
	    SPEC[LEFT&MA_PC] DEST[MA] COND[-JCOND] JUMP[MAIN1] C550 $
	DOSKIP $
   .DEFINE T2GRP [OP RR MM SS]
[	ACSEL[AC] D[IR] ROT[RR] MASK[MM] SPEC[SS] ALU[OP] DEST[AC] NORM $
	DOSKIP $
]

TRZ1:	T2GRP [-D&AC 0 22 0 ]
TLZ1:	T2GRP [-D&AC 22 0 LEFT]
TRO1:	T2GRP [DORAC 0 22 0]
TLO1:	T2GRP [DORAC 22 0 LEFT]
TRC1:	T2GRP [D#AC 0 22 0]
TLC1:	T2GRP [D#AC 22 0 LEFT]

;TDN GROUP
: 3420	FIXM1 $
	D[MEM] ACSEL[AC] ALU[D&AC] COND[JCOND] LBJUMP[SKMAIN] C600 $
;TSN GROUP
	FIXM1 $
	D[MEM] ACSEL[AC] ROT[18.] ALU[D&AC] COND[JCOND] LBJUMP[SKMAIN] C600 $
SKMAIN:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
	DOSKIP $

  .DEFINE T1GRP [OP RR MM SS1 SS2 D1]
[	ACSEL[AC] D[IR] ROT[RR] MASK[MM] SPEC[SS1] ALU[D&AC] COND[JCOND] JUMP[D1] C550 $
	ACSEL[AC] D[IR] ROT[RR] MASK[MM] SPEC[SS2] ALU[OP] DEST[AC MA] JUMP[MAIN1] NORM $
]
;TRZ GROUP
: 3440	  T1GRP [-D&AC 0 22 0 MA_PC TRZ1]
;TLZ GROUP
	T1GRP [-D&AC 22 0 LEFT LEFT&MA_PC TLZ1]
;TDZ GROUP
: 3460	FIXM1 $
	ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDZ1] NORM $
;TSZ GROUP
	FIXM1 $
	ALU[AC] ACSEL[AC] DEST[Q] NORM $
	ACSEL[AC] D[MEM] ROT[18.] ALU[-D&AC] DEST[AC] SHORT $
TSZ2:	D[MEM] ROT[18.] ALU[D&Q] COND[JCOND] LBJUMP[SKMAIN] C600 $
TDZ1:	ACSEL[AC] D[MEM] ALU[-D&AC] DEST[AC] SHORT $
TDZ2:	D[MEM] ALU[D&Q] COND[JCOND] LBJUMP[SKMAIN] C600 $
;TRC GROUP
: 3500	T1GRP [D#AC 0 22 0 MA_PC TRC1]
;TLC GROUP
	T1GRP [D#AC 22 0 LEFT LEFT&MA_PC TLC1]
;TDC GROUP
: 3520	FIXM1 $
	ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDC1] NORM $
;TSC GROUP
	FIXM1 $
	ALU[AC] ACSEL[AC] DEST[Q] NORM $
	ACSEL[AC] D[MEM] ROT[18.] ALU[AC#D] DEST[AC] JUMP[TSZ2] NORM $
TDC1:	ACSEL[AC] D[MEM] ALU[AC#D] DEST[AC] JUMP[TDZ2] NORM $
;TRO GROUP
: 3540	T1GRP [DORAC 0 22 0 MA_PC TRO1]
;TLO GROUP
	T1GRP [DORAC 22 0 LEFT LEFT&MA_PC TLO1]
;TDO GROUP
: 3560	FIXM1 $
	ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDO1] NORM $
;TSO GROUP
	FIXM1 $
	ALU[AC] ACSEL[AC] DEST[Q] NORM $
	ACSEL[AC] D[MEM] ROT[18.] ALU[DORAC] DEST[AC] JUMP[TSZ2] NORM $
TDO1:	ACSEL[AC] D[MEM] ALU[DORAC] DEST[AC] JUMP[TDZ2] NORM $

; IOT GROUP -- FOR NOW

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;									;;;;
;;;;	CAUTION:  Neither micro-code nor hardware currently checks      ;;;;
;;;;	This is a bad idea in general and will not work at Stanford,	;;;;
;;;;	as they use the IOT space for additional UUOs in user mode.	;;;;
;;;;	If that isn't bad enough, Stanford users and diagnostics go	;;;;
;;;;	into IOT-USER mode for to manipulate or test special I/O	;;;;
;;;;	I/O devices, so it isn't sufficent to just check USER.  The	;;;;
;;;;	instruction dispatch is probably the right place to fix this.	;;;;
;;;;									;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


.DEFINE IOTDIS [ WHERE ]
[	D[IR] ROT[15] MASK[4] DEST[Q] NORM $
	D[IR] ROT[15] MASK[4] ALU[D+Q] DEST[Q] SHORT $
	D[CONST WHERE] ROT[6] ALU[DORQ] SDISP CYLEN[C500] $
]

: 3600
 ;APR & PI
	MAPF[2] D[CONST 6] DEST[DEV-ADR] JUMP[APIOT] NORM $
	NOP $
	ILGIOT $
	NOP $
;UNUSED & MAP
	MAPF[2] D[CONST 1] DEST[DEV-ADR] NORM $
	D[IR] ROT[15] MASK[4] DEST[Q] JUMP[MAPIOT] NORM $

.REPEAT 7 [ILGIOT $
	NOP $
	 ]

	;CTY & UNUSED
	MAPF[2] D[CONST 4] DEST[DEV-ADR] NORM JUMP[CTYIOT] $
	NOP $
	ILGIOT $
	 NOP $
	ILGIOT $
	 NOP $
  ;DISK CTRL IOTS-- OPCODES 715 TO 724
	D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] $
	 MAPF[0] D[IOD] DEST[MEMSTO] 
		COND[-MA-AC] LBJUMP[SMAIN] $
	D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] $
	 MAPF[1] D[IOD] DEST[MEMSTO] 
		COND[-MA-AC] LBJUMP[SMAIN] $
	D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] $
	 MAPF[2] D[IOD] DEST[MEMSTO] 
		COND[-MA-AC] LBJUMP[SMAIN] $
	D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] $
	 MAPF[3] D[IOD] DEST[MEMSTO] 
		COND[-MA-AC] LBJUMP[SMAIN] $
	FIXML PUSHJ[SET-DSK-OUT] $ ;ld cmd -- opcode 721
	 MAPF[4] d[ar] DEST[2]  DEST-A-MEM JUMP[MAIN] $
	FIXML PUSHJ[SET-DSK-OUT] $
	 MAPF[5] DEST[MA]  SPEC[MA_PC] 	JUMP[MAIN1] $
	FIXML PUSHJ[SET-DSK-OUT] $
	 MAPF[6] DEST[MA]  SPEC[MA_PC] 	JUMP[MAIN1] $
	FIXML PUSHJ[SET-DSK-OUT] $
	 MAPF[7] DEST[MA]  SPEC[MA_PC] 	JUMP[MAIN1] $
	
  ;TAPE IOTS
	D[CONST 7] DEST[DEV-ADR] NORM JUMP[TAPERD] $	
		;READ ONE RECORD-- OPCODE 725
	 NOP $
	D[CONST 7] DEST[DEV-ADR] NORM JUMP[TAPEMT] $	
		;MTAPE-- OPCODE 726
	 NOP $
	D[CONST 7] DEST[DEV-ADR] NORM JUMP[TAPERS] $	
		;READ STATUS-- OPCODE 727
	 NOP $
;730 - READ 1 RECORD, STORE UP TO (AC) WORDS STARTING E.
	D[CONST 7] DEST[DEV-ADR] NORM JUMP[TAPENR] $
	 NOP $
;731 - WRITE 1 RECORD OF E WORDS STARTING FROM CORE LOC IN AC.
	D[CONST 7] DEST[DEV-ADR] NORM NORM $
	D[CONST 2] ROT[6] DEST[IOD] SPEC[IOB-OUT] NORM JUMP[TAPEWR] $
;732 - READ 1 RECORD, STORE UP TO E WORDS STARTING AT (AC).
	D[CONST 7] DEST[DEV-ADR] NORM JUMP[TAPERX] $
	 NOP $

;733 - DEBUGGING KLUGE: GET CHECK CHRS. FROM LAST REC. READ
	D[CONST 7] DEST[DEV-ADR] NORM $
	D[17] DEST[AC] ACSEL[AC] JUMP[MAIN] NORM $

.REPEAT 4 - DLS [ILGIOT $	;SKIP OPCODES 734 - 736
	NOP $
 ]

   ;skip space for disk cono,coni, etc. OPS 740 - 743
   ;locs 3700 to 3707
	  ; these dispatch entries are on dsk page.

: 3710
 .repeat 1 - Tymnet [
	.repeat 4 [ ilgiot $  nop $  ;if no tymnet, 744-747 = nop
		   ]
		   ]

.repeat tymnet [
   ;skip space for TYMNET IOTS.  OPS 744 - 747
	  ; these dispatch entries are on TYMNET page.
    ]

: 3720
 ;; OP 750   READ ECC INFO
	ilgiot $
	NOP $

.REPEAT (754 - 751 + 1) [ILGIOT $	;OPS 751:754
	NOP $
 ]

.REPEAT 1 - IMP [ILGIOT $
	NOP $
];1 - IMP

.REPEAT IMP [	;Reserve space for the IMP IOT dispatch instructions
IMP-IOT:
: IMP-IOT + 2
];IMP

.REPEAT (757 - 756 + 1) [ILGIOT $	;OPS 756:757
	NOP $
 ]

TIMER-IOTS:
  
: TIMER-IOTS + 12.	;LEAVE SPACE FOR OPCODES 760-765


.REPEAT (767 - 766 + 1) [ILGIOT $	;OPS 766:767
	NOP $
 ]

.REPEAT (774 - 770 + 1) [ILGIOT $	;OPS 770:774
	NOP $
 ]

: 3772   ;; OPCODE 775

 .REPEAT DEBUGSW [
	
;CAM -- A COPY OF CAM WHICH HALTS IF IT DOESN'T SKIP.  WOW !
;	FIXM1 $
;	D[MEM] ACSEL[AC] ALU[AC-D] COND[JCOND] JUMP[DOSKP1] C600 $
;	D[MEM] JUMP[.] CURRENTLY-UNUSED[1] $
;;DSKWT  -- DELAY UNTIL DISK NOT BUSY

	JUMP[DSKWT1] $		;OPCODE 775
	NOP $
	NOP $
	NOP $

]

.REPEAT 1 - DEBUGSW [ ILGIOT $
			NOP $

			ILGIOT $
			NOP $  ]

: 3776	;OPCODE 777 --- MAKE IT A UUO
	JUMP[MUUO] $
	NOP $
;NON DISPATCH STUFF HERE

:4000
; INIT THINGS -- INITIALIZE MACHINE, POWER-UP COMES HERE.

MSTART:
JUMP[. + 1] $	;to help operator start from switches (KEEP THIS SIMPLE -- MLB)

.REPEAT 1 - CROCK [
;Set up vectors for unused devices 9JAN80 BO (23JAN MLB/TVR)
;This code fills the zeroth location of all the AMEM blocks with a vector to
;the address SPURIOUS-INTERRUPT, which should contain the handler for them.

DOT = .

: 7777		;this is randomly here, it could be anywhere
SPURIOUS-INTERRUPT:	JUMP[.] $	;here on spurious interrupts

: DOT

D[CONST (SPURIOUS-INTERRUPT / 100)] ROT[6] DEST[Q] $	;Put high 6 bits in Q
..LOW6 = (SPURIOUS-INTERRUPT \ 100)
.IF ..LOW6 /= 0 [	;assemble low order 6 bits if non-zero
D[CONST ..LOW6] ALU[DORQ] DEST[Q] $
]
D[CONST 40] DEST[AR CLR-DEV-FROM-INTR] NORM $	;init AR for device num
ALU[Q] DEST[0] DEST-A-MEM NORM $		;store vector 
D[AR] ALU[D-1] DEST[AR DEV-ADR]			;decrement dev adr
	COND[-OBUS<0] JUMP[. - 1] C550 $	;and loop
];1 - CROCK


;The following code sets up the AMEM zero vectors for various random devices.
;this is a complete CROCK!  The device reset subroutines should do this!!
;I plan to fix this soon (when I have time, ha ha)	-- MLB 23JAN80

	D[CONST 20] ROT[6] DEST[Q CLR-DEV-FROM-INTR] NORM $

	.DEFINE AMLD2 [ DEV ALOC VAL ]
[	D[CONST DEV] DEST[DEV-ADR] NORM $
	D[CONST VAL] ALU[DORQ] DEST-A-MEM DEST[ALOC] NORM $
]
	AMLD2 [ 1 0 62 ] ; INTERRUPTS FROM DEV 1 (SWITCHES) GO TO 2062
	D[CONST 21] ROT[6] DEST[Q] NORM $
	AMLD2 [ 4 0 30 ] ; INTERRUPTS FROM DEV 4 GO TO 2130
	AMLD2 [ 5 0 34 ] ; INTRS FROM DEV 5 GO TO 2134
	AMLD2 [ 6 0 41 ] ; INTS FROM DEV 6 GO TO 2141
	AMLD2 [ 7 0 50 ] ; INTS FROM DEV 7 GO TO 2150
	AMLD2 [ 10 0 56 ] ; INTS FROM DEV 10 GO TO 2156
.REPEAT DLS [
	AMLD2 [ 14 0 37 ] ; DEV 14 (DLS) GOES TO 2137
];DLS
;;	the IMP reset code takes care of this for itself!!

	ALU[0] DEST[DEV-ADR] NORM $
	D[CONST 1] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[14] CYLEN[IOB-OUT] D[CONST 3] DEST[MAP-DISP] $
	ALU[0] DEST[CRYOV] NORM $
	ALU[0] DEST[CLR-MI-ERR] NORM $
	D[CONST 0] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	JUMP[RESLOP] NORM $

BADPC:	BADLOC $

FOOLAB1:

: 2642 ;.PAIR
ILDB1:	D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[ILDB2] NORM $
	D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $;GET S FLD, OVFL?
	D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $;SUB S FROM P
	ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] $
ILDB2:	ALU[Q] DEST[MA] COND[-MEM-IDX-IND] LBJUMP[ILDB3] NORM $
	.PAIR	;: 2650 ;.PAIR
IDPB1:	D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[IDPB2] NORM $
	D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $;GET S FLD, OVFL?
	D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $;SUB S FROM P
	ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] $
IDPB2:	ALU[Q] DEST[MA] COND[-MEM-IDX-IND] LBJUMP[IDPB3] NORM $
: 2624 ;.PAIR
ILDB3:	MAPF[2] PUSHJ[BIIH] NORM $;HANDLE IDX-IND
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BYTE-ILD] CYLEN[FIXM] $
LDB2:	SPEC[CLR-HALF] D[CONST 44] DEST[Q] SHORT $
	D[AR] ROT[6] MASK[6] ALU[Q-D] DEST[ROTR] SHORT $;SUB P FLD FROM 44
	D[MEM] ACSEL[AC] ROT[R] MASK[R] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $; DO THE LDB
IBT1:	D[MASK 36] ALU[D&Q] DEST[Q] SHORT $
	D[CONST 44] ROT[36] ALU[D+Q+1] DEST[Q] POPJ NORM $;NEW P FLD OF 44, ADD 1 TO ADR
	.PAIR	;: 2634 ;.PAIR
LDB1:	MAPF[2] PUSHJ[BII] NORM $
LDB5:	FIXM1 $
	D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[LDB2] NORM $;GET S FLD
: 2162 ; .PAIR
DPB1:	MAPF[2] PUSHJ[BII] NORM $
DPB5:	FIXM2 $
	D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[DPB2] NORM $;GET S FLD
	.PAIR	;: 2166 ;.PAIR
IDPB3:	MAPF[2] PUSHJ[BIIH] NORM $;HANDLE IDX-IND
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[BYTE-IDP] CYLEN[FIXM] $
DPB2:	SPEC[CLR-HALF] D[AR] ROT[6] MASK[6] DEST[ROTR] SHORT $; P FLD TO ROTATE AMT
	D[2] MASK[R] ACSEL[AC] ALU[D&AC] DEST[AR] SHORT $;GET BYTE
	D[MEM] DEST[Q] SHORT $; GET DEST WORD
	D[2] MASK[R] ROT[R] ALU[-D&Q] DEST[Q] SHORT $;CLR DEST BYTE
	D[AR] ROT[R] ALU[DORQ] DEST[MEMSTO] MEMST $;DO IT

.DEFINE BIIMAC[BIMAPF BIIH BIIH1]
[	D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[BIIH1] C550 $;IDX FLD
	D[MA] ACSEL[REG] MASK[18.] ALU[D+AC] DEST[MA] SHORT $;DO INDEXING
	D[AR] ROT[16] MASK[1] MAPF[2] COND[OBUS=0] POPJ CYLEN[C500] $;LEAV IF NO IND
BIIH1:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BIMAPF] CYLEN[FIXM] $
	D[MEM] MASK[27] DEST[Q MA] COND[-MEM-IDX-IND] POPJ CYLEN[C500] $;GET INDIRECT WORD, LEAVE IF NO MORE IND OR IDX
	D[AR] ROT[14] MASK[14] DEST[AR] MAPF[2] NORM $
	D[AR] ROT[30] ALU[DORQ] DEST[Q AR] JUMP[BIIH] NORM $
]
: 2665 ;NO PAIR
BIIH:	BIIMAC [BYTE-IND BIIH BII1]
: 2763 ;NO PAIR
BII:	BIIMAC [NORM-RD BII BII2]
: 2602
IBP1:	D[AR] ROT[14] MASK[6] DEST[AR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $;GET S FLD, OVFL?
	D[AR] ROT[36] ALU[Q-D] DEST[Q MEMSTO] MEMST $

: FOOLAB1


IMUL1:	ALU[0] DEST[AR O_AC] ACSEL[AC] PUSHJ[DOIMUL] NORM $	;0 TO AC,AC TO AR
	ACSEL[AC] ALU[Q] DEST[AC] JUMP[MAIN] NORM $
IMUL2:	ALU[0] DEST[AR O_AC] ACSEL[AC] PUSHJ[DOIMUL] NORM $	;0 TO AC
	ACSEL[AC] D[AR] DEST[AC] NORM $
	ALU[Q] DEST[MEMSTO] MEMST $

IMUL3:	ALU[0] DEST[AR O_AC] ACSEL[AC] PUSHJ[DOIMUL] NORM $
	ACSEL[AC] ALU[Q] DEST[AC MEMSTO] MEMST $

MUL1:	ALU[0] DEST[AR O_AC] ACSEL[AC] PUSHJ[DOMMUL] NORM $
	ACSEL[AC+1] ALU[Q] DEST[AC] JUMP[MAIN] NORM $

MUL2:	ALU[0] DEST[AR O_AC] ACSEL[AC] PUSHJ[DOMMUL] NORM $
	ACSEL[AC] D[AR] DEST[O_AC MEMSTO] MEMST $
MUL3:	ALU[0] DEST[AR O_AC] ACSEL[AC] PUSHJ[DOMMUL] NORM $
	ACSEL[AC+1] ALU[Q] DEST[AC] NORM $
	ACSEL[AC] ALU[AC] DEST[MEMSTO] MEMST $

DOIMUL:	PUSHJ[DOMUL] NORM $
	ACSEL[AC] ALU[AC] COND[OBUS=0] POPJ CYLEN[C500] $; NO OV IF 0
	ACSEL[AC] ALU[NOTAC] COND[OBUS=0] POPJ CYLEN[C500] $; NO OV IF -1
MSETOV:	D[PC] DEST[AC] SHORT $; GET FLAGS
	D[CONST 1] ROT[43] ALU[DORAC] DEST[CRYOV] NORM POPJ $; SET OV
DOMMUL:	D[AR] ALU[D#Q] COND[-OBUS=0] JUMP[DOMUL] CYLEN[C500] $; NO OV IF DIFF OPERS
	D[CONST 1] ROT[43] ALU[D#Q] COND[-OBUS=0] JUMP[DOMUL] CYLEN[C500] $; J IF NOT -2**35
	PUSHJ[MSETOV] NORM $;SET OV
	ALU[0] DEST[AC] SHORT $
DOMUL:	D[CONST 42] LLOAD NORM $	;LOOP 35 TIMES

DOMUL1:	D[AR] ACSEL[AC] ALU[MULAC+D] DEST[D4] MASK[3]
		LOOP[DOMUL1] NORM $ ;SHIFT, END-COND MUL; SOJGE, SH RT
	D[AR] ACSEL[AC] ALU[MULAC+D] DEST[D4] MASK[3]
		COND[-Q0-35] JUMP[. + 2] CYLEN[C450] $ ;J IF QUOT WAS +
	D[AR] ACSEL[AC] ALU[MULAC-D] DEST[D7]
		JUMP[. + 2] NORM $ ; DEST AC SH LFT, ALU=1, ALU S=0
	ALU[SH-AC] ACSEL[AC] DEST[D7] NORM $ ;DEST AC SH LFT
		;SINCE DEST IS >3, ALU[QORAC] IS ALU[AC]
	ALU[AC] ACSEL[AC] COND[OBUS<0] LBJUMP[DOMUL4] CYLEN[C500] $
FOOLAB5:
: 2776 ;.PAIR
DOMUL4:	D[MASK 35.] ALU[D&Q] DEST[Q] POPJ NORM $
	D[CONST 1] ROT[35.] ALU[DORQ] DEST[Q] POPJ NORM $

: FOOLAB5
: 4066 ;. PAIR
  CCC1	= SHORT $
  MEMST1	= MEMST $

.DEFINE DMACFN [AA A2 D1 D2 OP1]
[	ACSEL[AC] ALU[AA] D[AR] DEST[O_AC AR] SHORT $
	ACSEL[AC+1] D[AR] ALU[A2] DEST[D1 D2] OP1 $
	ACSEL[AC] ALU[AC] DEST[MEMSTO] MEMSTMA $
]
.DEFINE DMAC2 []
[	D[MEM] ALU[D#AC] ACSEL[AC] DEST[AR] PUSHJ[DODDIV] NORM $
]
.DEFINE DMAC1 []
[	ALU[-1] DEST[AC] ACSEL[AC] JUMP[. + 2] NORM $
	ALU[0] DEST[AC] ACSEL[AC] SHORT $
	D[MEM] ALU[D#AC] ACSEL[AC] DEST[AR] SHORT $
	D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
	ALU[Q] DEST[AR] PUSHJ[DODIV] NORM $
]

IDIV1:	DMAC1
	DMACFN[Q D AC MA DOM1]
IDIV2:	DMAC1
	DMACFN[D Q MEMSTO AR MEMST1]
IDIV3:	DMAC1
	DMACFN[Q D AC 0 CCC1]
DIV1:	DMAC2
	DMACFN[Q D AC MA DOM1]
DIV2:	DMAC2
	DMACFN[D Q MEMSTO AR MEMST1]
DIV3:	DMAC2
	DMACFN[Q D AC 0 CCC1]

DODDIV:	D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
	ACSEL[AC] ALU[SH-AC] DEST[AR D5] MASK[1] NORM $
	D[AR] MASK[1] COND[OBUS=0] JUMP[. + 2] C550 $
	D[CONST 1] ROT[43] ALU[DORQ] DEST[Q] JUMP[. + 2] NORM $
	D[MASK 43] ALU[D&Q] DEST[Q] NORM $
DODIV:	D[MEM] COND[-OBUS<0] JUMP[. + 2] C550 $
	D[MEM] ALU[0-D] DEST[HOLD] SHORT $
	ALU[AC] ACSEL[AC] COND[-OBUS<0] JUMP[. + 4] CYLEN[C450] $
	ALU[0-Q] DEST[Q] COND[OBUS=0] JUMP[. + 2] CYLEN[C500] $
	ALU[NOTAC] ACSEL[AC] DEST[AC] JUMP[. + 2] NORM $
	ALU[0-AC] ACSEL[AC] DEST[AC] NORM $
DODIV2:	D[CONST 44] LLOAD NORM $ ;LOOP 37 TIMES
	JUMP[DODIV4] NORM $   ;CHECK FOR OVERFLOW HERE *****
TLAB1:
: 2604
DODIV4:	D[MEM] ALU[DIVAC-D] ACSEL[AC] DEST[D6] MASK[3] COND[OBUS<0] SLOOP[DODIV4] C600 $
	ACSEL[AC] ALU[SH-AC] DEST[D5] MASK[0] JUMP[DODIV6] NORM $ ; RE-SHIFT REMAINDER
	D[MEM] ALU[DIVAC+D] ACSEL[AC] DEST[D6] MASK[3] COND[OBUS<0] SLOOP[DODIV4] C600 $
	ACSEL[AC] ALU[SH-AC] DEST[D5] MASK[0] NORM $
DODIV6:	D[CONST 1] ROT[43] ALU[D#AC] ACSEL[AC] DEST[AC] COND[-OBUS<0] JUMP[DODIV5] C550 $ ;ADJUST REM SIGN, CHECK IT
	ACSEL[AC] D[MEM] ALU[D+AC] DEST[AC] SHORT $ ;ADJUST REM.
DODIV5:	D[AR] COND[-OBUS<0] JUMP[. + 2] C550 $; J IF DIVIDEND WAS +
	ACSEL[AC] ALU[0-AC] DEST[AC] SHORT $
	D[IR] MASK[1] COND[OBUS=0] POPJ C550 $ ;LEAVE IF RESULT SHOULD BE +
	ALU[0-Q] DEST[Q] POPJ NORM $
: TLAB1


JFFO1:	ACSEL[AC+1] ALU[0] DEST[AC] JUMP[MAIN] NORM $
JFFO2:	D[AR] ROT[6] MASK[6] COND[-OBUS=0] JUMP[JFFO3] C550 $
	D[AR] ROT[6] DEST[AR] NORM $
	D[CONST 6] ACSEL[AC+1] ALU[AC+D] DEST[AC] JUMP[JFFO2] NORM $
JFFO3:	D[AR] COND[OBUS<0] JUMP[JFFO4] C550 $
JFFO5:	ACSEL[AC+1] ALU[AC+1] DEST[AC] NORM $
	D[AR] ROT[1] DEST[AR] COND[-OBUS<0] JUMP[JFFO5] C550 $
JFFO4:	D[IR] DEST[PC MA] JUMP[MAIN1] NORM $; JUMP
.DEFINE SH2ND [ TYP DST1 DST2 DST3 ]
[TYP`PLS:	D[CONST 44] ALU[Q-D] COND[OBUS18] JUMP[DST3] C600 $
	D[CONST 44] ALU[Q-D] DEST[Q ROTR] JUMP[DST1] NORM $
TYP`NEG:	D[MASK 22] ROT[10] ALU[DORQ] DEST[Q ROTR] NORM $
TYP`NN1:	D[CONST 44] ALU[D+Q] DEST[Q ROTR] COND[-OBUS18] JUMP[TYP`DO] C600 $
	JUMP[DST2] NORM $
]

COMMENT = LINE TO HOLD LEFT QUOTE CHR FOR COPYING
`
  =

FOOLAB2:
: 3444
	SH2ND [ROT ROTPLS ROTNN1 ROTDO]
ROTDO:	ACSEL[AC] ALU[AC] DEST[AR] SHORT $
	D[AR] ROT[R] ACSEL[AC] SPEC[MA_PC] DEST[AC MA] JUMP[MAIN1] NORM $
	SH2ND [LSH BIGLSH BIGLSH LSHPDO]
: 2161
BIGLSH:	ACSEL[AC] ALU[0] SPEC[MA_PC] DEST[AC MA] JUMP[MAIN1] NORM $
: 2175
LSHPDO:	D[CONST 44] ALU[D-Q] DEST[MASKR] SHORT $
	D[2] MASK[R] ALU[D&AC] ACSEL[AC] DEST[AR] SHORT $
	D[AR] ROT[R] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
: 2655
LSHDO:	ALU[Q] DEST[MASKR] SHORT $
	ALU[AC] ACSEL[AC] DEST[AR] SHORT $
LSHDO1:	D[AR] MASK[R] ROT[R] SPEC[MA_PC] DEST[AC MA] ACSEL[AC] JUMP[MAIN1] NORM $
: 2165
ASHDO1:	ALU[Q] DEST[MASKR] JUMP[LSHDO1] NORM $
: FOOLAB2
	SH2ND [ASH BIGASH BIGAS2 ASHDOP]
BIGASH:	ALU[AC] ACSEL[AC] COND[OBUS=0] JUMP[MAIN] CYLEN[C450] $
	D[CONST 1] ROT[43] ACSEL[AC] ALU[D&AC] DEST[AC] SHORT $
	D[PC] DEST[Q] SHORT $
SETOV1:	D[CONST 1] ROT[43] ALU[DORQ] DEST[MA CRYOV] SPEC[MA_PC] NORM JUMP[MAIN1] $
ASHDO:	ACSEL[AC] ALU[AC] DEST[AR] COND[-OBUS<0] JUMP[ASHDO1] CYLEN[C500] $
	D[CONST 44] ALU[D-Q] DEST[MASKR] SHORT $
	D[2] MASK[R] ROT[R] DEST[Q] SHORT $
	D[AR] ROT[R] ALU[DORQ] SPEC[MA_PC] DEST[AC MA] ACSEL[AC] JUMP[MAIN1] NORM $
ASHDOP:	D[CONST 43] ALU[D-Q] DEST[MASKR] SHORT $
	ALU[Q] DEST[IR-ADR] SHORT $; SAVE SH AMT
	D[CONST 1] ROT[43] ACSEL[AC] ALU[D&AC] DEST[Q] SHORT $ ;GET SIGN BIT
	D[2] MASK[R] ACSEL[AC] ALU[D&AC] DEST[AR] SHORT $
	D[AR] ROT[R] ACSEL[AC] ALU[DORQ] DEST[O_AC AR] SHORT $
	D[IR] ALU[D+1] DEST[MASKR] SHORT $
	D[AR] ROT[R] DEST[Q] SHORT $
	D[2] MASK[R] ROT[43] ALU[D&Q] DEST[Q] COND[OBUS=0] JUMP[MAIN] C550 $
	D[2] MASK[R] ROT[43] ALU[D#Q] COND[OBUS=0] JUMP[MAIN] C550 $
	D[PC] DEST[Q] JUMP[SETOV1] NORM $
BIGAS2:	ACSEL[AC] ALU[AC] COND[-OBUS<0] JUMP[BIGLSH] CYLEN[C450] $
	ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $



ASHC1:	D[CONST 1] ROT[43] ALU[D&AC] ACSEL[AC] DEST[HOLD] NORM $ ; SAVE SIGN BIT
	D[IR] MASK[18.] COND[OBUS18] JUMP[ASHC2] C550 $
	D[IR] MASK[10] COND[OBUS=0] JUMP[MAIN] C550 $
	ALU[0] ACSEL[AC+1] DEST[AC] SHORT $
	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
ASHC8:	ALU[SH-AC] DEST[D6] MASK[1] ACSEL[AC] NORM $
	ACSEL[AC] D[MEM] ALU[D#AC] COND[OBUS<0] JUMP[ASHC9] C550 $
ASHC6:	LOOP[ASHC8] NORM $
	D[PC] ACSEL[AC+1] ALU[DORAC] DEST[CRYOV] JUMP[ASHC7] NORM $
ASHC9:	D[CONST 1] ROT[43] ACSEL[AC+1] DEST[AC] JUMP[ASHC6] NORM $

.DEFINE SHLOOP [SHTYP DIR]
[	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
	ALU[SH-AC] DEST[DIR] MASK[SHTYP] ACSEL[AC] LOOP[.] NORM $
]

ASHC4:	D[MEM] DEST[Q] SHORT $
	D[AR] ROT[43] MASK[43] ALU[DORQ] ACSEL[AC+1] DEST[AC] NORM $
	D[MASK 43] ACSEL[AC] ALU[D&AC] DEST[AC] SHORT $
	ACSEL[AC] ALU[QORAC] DEST[AC] JUMP[MAIN] NORM $
ASHC2:	D[IR] ALU[0-D] DEST[IR-ADR] NORM $
	SHLOOP [ 1 D4 ]
ASHC7:	ALU[Q] DEST[AR] JUMP[ASHC4] NORM $
FOOLAB6:
: 3470 ;.PAIR
ROTC1:	D[IR] ALU[0-D] DEST[IR-ADR] JUMP[ROTC2] NORM $
	D[IR] COND[OBUS=0] MASK[10] JUMP[MAIN] C550 $
	SHLOOP[ 0 D6 ]
	ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
ROTC2:	SHLOOP[ 0 D4 ]
	ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
: 3426 ;.PAIR
LSHC1:	D[IR] MASK[18.] ALU[0-D] DEST[IR-ADR] JUMP[LSHC2] NORM $
	D[IR] MASK[10] COND[OBUS=0] JUMP[MAIN] C550 $
	SHLOOP [ 2 D6 ]
	ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
LSHC2:	SHLOOP[ 2 D4 ]
	ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $

SJMAIN:	ACSEL[MA] D[MEM] DEST[AC] $
	D[IR] DEST[MA PC] JUMP[MAIN1] $

: FOOLAB6
PUSH1:	ACSEL[AC] D[CONST 1,,1] ALU[D+AC] DEST[AC MA] COND[CRY0] JUMP[PDLO2] C600 $
	D[AR] DEST[MEMSTO] MEMSTMA $
POP1:	D[MEM] DEST[AR] SHORT $
	D[IR] MASK[18.] DEST[MA] SHORT $
	D[AR] DEST[MEMSTO] MEMST $
POPJ1:	D[MEM] MASK[18.] DEST[PC MA] JUMP[MAIN1] NORM $
PUSHJ1:	MAPF[MASTO] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] MEMST $


	.PAIR	;: 4242 ;.PAIR
BLTA2:	ACSEL[AC] ALU[AC] DEST[AR MA] JUMP[BLTA3] NORM $ ;SRC IS AC GET DEST ADR
BLT1:	D[PC] DEST[O_AC AR] ACSEL[AC] SHORT $
	D[AR] MASK[18.] DEST[Q PC] SHORT $
	D[IR] MASK[18.] ALU[D-Q] DEST[Q] LLOAD NORM $;GET COUNT
	ALU[Q] COND[OBUS<0] JUMP[BLT4] CYLEN[C450] $ ; J IF END PRECEDES STRT
BLT7:	D[AR] MASK[18.] ROT[18.] DEST[Q MA AR] SHORT $; FETCH FIRST WORD
BLT5:	DEST[FIXMAC-MAPF-RD] MAPF[BLT-RD] JUMP[BLT2] CYLEN[FIXM] $
BLT3:	DEST[FIXMAC-MAPF-RD] MAPF[BLT-RD] SPEC[PC+1] CYLEN[FIXM] $
BLT2:	D[MEM] SPEC[MA_PC] DEST[MEMSTO MA] COND[INTRPT] JUMP[BLT6] NORM $
	ALU[Q+1] DEST[Q AR MA] LOOP[BLT3] MAPF[BLT-WRT] CYLEN[MEMSTO] $
BLT9:	D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC] NORM $
	ACSEL[AC] D[IR] MASK[18.] ALU[AC-D] COND[-OBUS<0] JUMP[MAIN] C550 $ ;J IF DONE
	ACSEL[AC] ALU[AC+1] DEST[AC] SHORT $
	D[IR] ACSEL[AC] ALU[D-AC] LLOAD NORM $ ;GET COUNT
	D[PC] ACSEL[AC] DEST[O_AC PC] SHORT $
	ALU[Q] DEST[MA] JUMP[BLT5] NORM $
BLT4:	ALU[0] LLOAD NORM $
	JUMP[BLT7] NORM $
BLT6:	ALU[Q+1] DEST[Q AR] LOOP[BLT8] MAPF[BLT-WRT] CYLEN[MEMSTO] $
	JUMP[BLT9] $
BLT8:	ACSEL[AC] ALU[AC-1] DEST[AC] SPEC[PC+1] NORM $
	ACSEL[AC] D[PC] MASK[18.] DEST[O_AC PC] SHORT $
	D[AR] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC] SHORT $
	DISP[2320] SPEC[PC+1-IF&] CYLEN[DISP] $
BLTA3:	D[AR] ROT[18.] DEST[AC-SEL] SHORT $ ;GET SRC ADR
	D[IR] MASK[18.] DEST[Q] SHORT $
	D[MA] MASK[18.] ALU[Q-D] DEST[Q] LLOAD NORM $
	ALU[Q] COND[OBUS<0] PUSHJ[BLTA4] CYLEN[C450] $
	D[AR] ROT[18.] MASK[18.] ALU[D+Q] DEST[Q] SHORT $
	D[MASK 30] ROT[4] ALU[D&Q] COND[-OBUS=0] JUMP[BLTA10] C550  $;J IF SRC LEAVES AC'S
BLTL1:	ACSEL[REG] ALU[AC] DEST[MEMSTO] NORM $
	D[MA] ALU[D+1] DEST[MA A-MEM-CNTR&INC] MAPF[BLT-WRTA] LOOP[BLTL1] CYLEN[MEMSTO] $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
BLTA4:	ALU[0] DEST[Q] LLOAD NORM $
	POPJ NORM $
BLTA1:	D[MASK 16] ROT[26] ACSEL[AC] ALU[D&AC] COND[OBUS=0] JUMP[BLTA10] C550 $; DEST IS AC, J IF SRC AC?
	D[IR] ROT[40] MASK[16] COND[-OBUS=0] JUMP[BLTA10] C550 $;J IF FINAL DEST NOT AC
	ACSEL[AC] ALU[AC] DEST[AR AC-SEL] SHORT $;GET DEST ADR
	D[IR] MASK[18.] DEST[Q] SHORT $
	D[AR] MASK[18.] ALU[Q-D] DEST[Q] LLOAD NORM $;GET COUNT
	ALU[Q] COND[OBUS<0] PUSHJ[BLTA4] CYLEN[C450] $;ADJUST IF CNT NEG.
	D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $;GET SRC ADR
BLTAL2:	DEST[FIXMAC-MAPF-RD AC] MAPF[BLT-RDA] D[MA] ALU[D+1] ACSEL[REG] CYLEN[FIXM] $
	ACSEL[REG] D[MEM] DEST[O_AC MA A-MEM-CNTR&INC] LOOP[BLTAL2] NORM $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
BLTA10:	ACSEL[AC] ALU[AC] DEST[AR] SHORT $
BLTL2:	D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $;GET WORD
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BLT-RDA] CYLEN[FIXM] $
	D[MEM] DEST[HOLD Q] SHORT $
	D[AR] MASK[18.] DEST[MA STRT-WRT] SHORT $
	MAPF[BLT-WRTA] COND[-MA-AC] JUMP[. + 2] C500 $
	ALU[Q] ACSEL[MA] DEST[AC] SHORT $
	D[AR] MASK[18.] DEST[Q] NORM $
	D[IR] MASK[18.] ALU[Q-D] MAPF[BLT-WRTA] COND[-OBUS<0] JUMP[MAIN] C600 $
	D[CONST 1,,1] DEST[Q]  NORM $
	D[AR] ALU[D+Q] DEST[AR] JUMP[BLTL2] NORM $;*** TEST FOR INTERRUPT HERE?
BLTA12:	MEMST $

FOOLAB3:

: 2157
ANDCA1:	D[MEM] ACSEL[AC] ALU[D&Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
: 2723
ANDCA2:	D[MEM] ALU[D&Q] DEST[MEMSTO] MEMST $
: 2623
ANDCA3:	D[MEM] ACSEL[AC] ALU[D&Q] DEST[AC MEMSTO] MEMST $
: 2633
LOG2:	ALU[NOTQ] DEST[MEMSTO] MEMST $
: 2637
LOG3:	ACSEL[AC] ALU[NOTQ] DEST[AC MEMSTO] MEMST $
: 2647
ORCM2:	ACSEL[AC] ALU[QORAC] DEST[MEMSTO] MEMST $
: 2403
ORCM3:	ACSEL[AC] ALU[QORAC] DEST[AC MEMSTO] MEMST $
: FOOLAB3
RESW1:
: 2062	;SWITCH, AR & ECC INTERRUPTS COME HERE
SWINT:	DEST[CLR-DEV-FROM-INTR] SHORT $
	ALU[0] DEST[DEV-ADR] SPEC[IOB-IN] SHORT $
	D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $ 		;GET SW BITS
	D[AR] ROT[7] MASK[1] COND[-OBUS=0] JUMP[APDINT] C550 $	;JUMP IF OVFL OR ECC INT
	D[CONST 15] ROT[1] DEST[Q] SPEC[IOB-OUT] SHORT $
	D[AR] ROT[14] ALU[D&Q] MAPF[4] COND[OBUS=0] JUMP[NOSW] C550 $	;CHECK FOR RELEVANT SW, & CLR FF.
	D[AR] ROT[10] MASK[1] COND[-OBUS=0] JUMP[RESW1] C550 $	;J IF RESET SW
NORSW:	D[AR] ROT[13] MASK[1] COND[-OBUS=0] PUSHJ[EXMTSW] C550 $	;PUSHJ IF EXAM THIS
	D[AR] ROT[11] MASK[1] COND[-OBUS=0] PUSHJ[DEPTSW] C550 $	;PUSHJ IF DEPO THIS
NOSW:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $

: RESW1
	SPEC[IOB-IN] SHORT $
	D[IOD] DEST[AR]  CYLEN[IOB-IN] $	;DOUBLE CHECK RESET SW
	D[AR] ROT[10] MASK[1] COND[OBUS=0] JUMP[NORSW] CYLEN[C650] $	;DOUBLE CHECK RESET SW

.REPEAT F2SW [
RESET:	D[CONST 0] DEST[IOD] SPEC[IOB-OUT] NORM $
  ]  ;END F2SW

.REPEAT 1 - F2SW [
RESET:	D[CONST 1] DEST[IOD] SPEC[IOB-OUT] NORM $
  ]  ;END 1 - F2SW

	MAPF[10] ALU[0] DEST[CRYOV] CYLEN[IOB-OUT] $	;CLR MAP-IN-USE & PC FLAGS & AR INT ENBL, ETC.
	DEST[CLR-MI-ERR] JUMP[RESLOP] NORM $
RESLOP:	ALU[0] DEST[HI-ABS-MA] NORM $
	D[CONST 0] DEST[DEV-ADR] PUSHJ[APRRST] NORM $
	D[CONST 4] DEST[DEV-ADR] PUSHJ[CTYRST] NORM $
	D[CONST 10] DEST[DEV-ADR] PUSHJ[DSKRST] NORM $
	D[CONST 7] DEST[DEV-ADR] PUSHJ[TAPRST] NORM $
.REPEAT DLS [; 9 JAN 80  BO
	D[CONST 14] DEST[DEV-ADR] PUSHJ[DLSRST] NORM $
];DLS
.REPEAT IMP [; 23JAN80 MLB
	D[CONST 16] DEST[DEV-ADR] PUSHJ[IMP-INIT-RESET] NORM $
];IMP
	D[CONST 6] DEST[DEV-ADR] PUSHJ[CLKRST] NORM $
	D[CONST 6] DEST[DEV-ADR] PUSHJ[TYMRST] NORM $
	D[CONST 6] DEST[DEV-ADR] PUSHJ[PI-RESET] NORM $
DOHALT:	DEST[CLR-DEV-FROM-INTR] NORM $
STPLOP:	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
	MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
	D[CONST 10] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] $; SET PROG HALT LIGHT
	ALU[0] DEST[DEV-ADR MA] SPEC[MA_PC] NORM $
	FIXM1 SPEC[IOB-OUT] $
	D[MEM] MAPF[6] CYLEN[LONG] $
	SPEC[IOB-IN] NORM $
	D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $
	D[AR] COND[OBUS<0] JUMP[BRPNT] C600 $; J IF BRK POINT SW
	SPEC[IOB-IN] NORM $
STPLP1:	D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $	;GET SW BITS
	D[AR] ROT[10] MASK[1] COND[-OBUS=0] JUMP[RESW2] C550 $	;J IF RESET SW
	D[AR] ROT[14] MASK[11] DEST[Q] NORM $
	D[CONST 7] ROT[4] ALU[-D&Q] COND[OBUS=0] SPEC[IOB-IN] JUMP[STPLP1] C600 $; LOOP IF NO SW
	SPEC[IOB-OUT] NORM $
	MAPF[4] CYLEN[IOB-OUT] $    	;CLR SW FF'S
	.DEFINE SWTEST [ RAMT DIS ADR ]
[	D[AR] ROT[RAMT] MASK[1] COND[-OBUS=0] DIS [ ADR ] C550 $
]
NORSW2:	SWTEST[4 JUMP CONSW]
	SWTEST[5 JUMP STRTSW]
	SWTEST[11 PUSHJ DEPTSW]
	SWTEST[12 PUSHJ DEPNSW]
	SWTEST[13 PUSHJ EXMTSW]
	SWTEST[14 PUSHJ EXMNSW]
	D[CONST 0] DEST[DEV-ADR] SPEC[IOB-IN] JUMP[STPLP1] NORM $	;LOOP

RESW2:	SPEC[IOB-IN] SHORT $
	D[IOD] DEST[AR]  CYLEN[IOB-IN] $	;DOUBLE CHECK RESET SW
	D[AR] ROT[10] MASK[1] COND[OBUS=0] JUMP[NORSW2] CYLEN[IOB-IN] $	;DOUBLE CHECK RESET SW
	JUMP[RESET] NORM $
STRTSW:	D[AR] MASK[23] DEST[PC] NORM $
CONSW:	ALU[0] SPEC[MA_PC] DEST[MA HI-ABS-MA] NORM $
	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
	MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] NORM $
	D[CONST 7] ALU[D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] $; CLEAR PROG HALT LIGHT
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
	D[MEM] DEST[IR-ALL AR MA] DISP[2174] SPEC[PC+1-IF] CYLEN[DISP] $; IGNORE STOP SW

DEPTSW:	D[AR] MASK[23] DEST[MA HI-ABS-MA] SPEC[IOB-IN] JUMP[DEPSW1] NORM $
DEPNSW:	D[MA] ALU[D+1] DEST[MA] NORM SPEC[IOB-IN] $
DEPSW1:	D[IOD] DEST[MEMSTO] MAPF[2] CYLEN[IOB-IN] $
	MAPF[TEMP] COND[-MA-AC] POPJ CYLEN[MEMSTO] $
	ACSEL[MA] D[MEM] DEST[AC] POPJ NORM $

EXMTSW:	D[AR] MASK[23] DEST[MA HI-ABS-MA] JUMP[EXMSW1] NORM $
EXMNSW:	D[MA] ALU[D+1] DEST[MA] NORM $
;NOTE: This code is also called by DATAO PI, which displays in the lights
EXMSW1:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[TEMP] CYLEN[FIXM] $
	SPEC[IOB-OUT] NORM $
	D[MEM] MAPF[2] CYLEN[LONG] POPJ $
BRPNT:	D[AR] MASK[27] DEST[Q] NORM $
	D[PC] MASK[27] ALU[D-Q] COND[-OBUS=0] JUMP[CONSW] C600 $
	SPEC[IOB-IN] JUMP[STPLP1] NORM $


FOOLAB4:
: 2405
MOVSS1:	D[MEM] ROT[18.] ACSEL[AC] DEST[AC MEMSTO] MEMST $
: 2413
MOVNS1:	D[MEM] ALU[0-D] ACSEL[AC] DEST[AC MEMSTO] MEMST $
: 2423
HLLZS1:	ACSEL[MA] D[MEM] COND[AC=0] DEST[AC AR MA] SPEC[LEFT&MA_PC] LBJUMP[HSMAIN] NORM $
: 2425
HRLZS1:	ACSEL[MA] D[MEM] ROT[18.] COND[AC=0] DEST[AC AR MA] SPEC[LEFT&MA_PC] LBJUMP[HSMAIN] NORM $
: 2433
HRRZS1:	ACSEL[MA] D[MEM] MASK[18.] COND[AC=0] DEST[AC AR MA] SPEC[MA_PC] LBJUMP[HSMAIN] NORM $
: 3001
HLRZS1:	ACSEL[MA] D[MEM] ROT[18.] MASK[18.] COND[AC=0] DEST[AC AR MA] SPEC[MA_PC] LBJUMP[HSMAIN] NORM $
: 3003
HRAR:	D[AR] MASK[18.] ALU[DORAC] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
: 3005
HLAR:	D[AR] SPEC[LEFT&MA_PC] MASK[0] ALU[DORAC] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM $

: 3007
HLLEM1:	D[AR] MASK[0] SPEC[LEFT] DEST[MEMSTO] MEMST $
: 3171
HRLEM1:	D[AR] ROT[18.] MASK[0] SPEC[LEFT] DEST[MEMSTO] MEMST $
: 3173
HLREM1:	D[AR] ROT[18.] MASK[18.] DEST[MEMSTO] MEMST $
: 3175
HRREM1:	D[AR] MASK[18.] DEST[MEMSTO] MEMST $

: 2074 ;.PAIR
HSMAIN:	ACSEL[AC] D[AR] DEST[AC] NORM $
	FIXM1 JUMP[MAIN2] $
	.PAIR
HSMN1:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] CYLEN[MEMSTO] $
	D[MEM] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[MEMSTO] $
: 2674 ;.PAIR
HLLOS1:	D[MASK 22] ALU[DORQ] DEST[MEMSTO] MEMST $
	D[MASK 22] ALU[DORQ] DEST[MEMSTO AC] ACSEL[AC] MEMST $
	.PAIR
HRROS1:	D[MASK 22] ROT[18.] ALU[DORQ] DEST[MEMSTO] MEMST $
	D[MASK 22] ROT[18.] ALU[DORQ] DEST[MEMSTO AC] ACSEL[AC] MEMST $
: 2702 ;.PAIR
HLLES1:	D[MASK 22] ROT[18.] ALU[D&Q] DEST[Q] COND[-AC=0] LBJUMP[HLLES2] NORM $
	COND[-AC=0] LBJUMP[HLLOS1] NORM $
	.PAIR
HRRES1:	D[MASK 22] ALU[D&Q] DEST[Q] COND[-AC=0] LBJUMP[HLLES2] NORM $
	COND[-AC=0] LBJUMP[HRROS1] NORM $
	.PAIR
HLLES2:	ALU[Q] DEST[MEMSTO] MEMST $
	ALU[Q] ACSEL[AC] DEST[MEMSTO AC] MEMST $
	.PAIR
HMV:	JUMP[MAIN] NORM $
	JUMP[MOVE] NORM $
	.PAIR
HHS:	D[AR] ROT[18.] ALU[DORQ] DEST[MEMSTO] MEMST $
	D[AR] ROT[18.] ALU[DORQ] ACSEL[AC] DEST[MEMSTO AC] MEMST $
	.PAIR
HLSZ:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
HOR:	D[MASK 22] ACSEL[AC] ALU[DORAC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $
	.PAIR
HRSZ:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
HOL:	D[MASK 22] ACSEL[AC] ROT[18.] ALU[DORAC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $
: 2772 ;.PAIR
HRLM1:	D[AR] ROT[18.] DEST[Q] NORM $
HLLM1:	D[MEM] MASK[18.] ALU[DORQ] DEST[MEMSTO] MEMST $
HLRM1:	D[AR] ROT[18.] DEST[Q] NORM $
HRRM1:	D[MEM] MASK[0] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] MEMST $

: 2742 ; .PAIR
JRST1:	COND[USER] JUMP[JRST8] NORM $; ILLEGAL IF USER MODE
	D[IR] ROT[14] MASK[1] COND[-OBUS=0] JUMP[JRST2] C550 $
JRST4:	D[IR] ROT[15] MASK[1] COND[-OBUS=0] JUMP[JRST3] C550 $
JRST5:	D[IR] ROT[13] MASK[1] COND[-OBUS=0] JUMP[JRST9] C550 $;J TO STOP SWITCH IF HALT
	D[IR] ROT[12] MASK[1] COND[-OBUS=0] JUMP[PI-DISMISS] C550 $; J IF DISMISS BIT ON
	JUMP[MAIN1] NORM SPEC[MA_PC] DEST[MA] $
JRST9:	COND[EXEC] JUMP[DOHALT] NORM $; HALT IF EXEC MODE
JRST8:	MUUO1

JRST2:	D[PC] DEST[Q] SHORT $
	D[CONST 1] ROT[36] ALU[D&Q] DEST[Q] SHORT $
	D[AR] ALU[DORQ] DEST[CRYOV] JUMP[JRST4] NORM $
JRST3:	D[CONST 1] ROT[36] DEST[Q] SHORT $
	D[PC] ALU[DORQ] DEST[CRYOV] JUMP[JRST5] NORM $
: 3504
JFCL1:	D[AR] ROT[40] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $;TEST SELECTED FLAGS
	D[AR] ROT[40] ALU[-D&Q] DEST[CRYOV] SHORT $;CLEAR FLAGS
	DOJUMP $
JSR2:	D[MA] ALU[D+1] DEST[PC] SPEC[CLR-HALF] MAPF[STO] NORM $
	ACSEL[MA] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
JSA1:	D[MA] ALU[D+1] DEST[PC] SHORT $
	D[AR] DEST[MEMSTO] MEMST $
JRA1:	FIXM1 $
	ACSEL[AC] D[MEM] DEST[AC] CYLEN[FIXM+1] $
	D[IR] MASK[18.] DEST[PC MA] JUMP[MAIN1] NORM $

: FOOLAB4
MUJSR:	D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
	D[AR] DEST[MEMSTO] COND[MA-AC] JUMP[JSR2] NORM $
	D[MA] ALU[D+1] DEST[MA PC] MAPF[STO] SPEC[CLR-HALF] JUMP[MAIN1] CYLEN[MEMSTO] $
MUJSP:	D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
	D[AR] ACSEL[AC] DEST[AC] JUMP[JSP1] NORM $
MUJSA:	D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
	D[AR] ACSEL[AC] DEST[O_AC AR] JUMP[JSA1] NORM $
MUJSYS:	D[MEM] DEST[IR-ALL MA] SHORT $
	D[IR] ROT[33] MASK[11] COND[OBUS=0] JUMP[JSYS3] C550 $; J IF EX JSYS
MUJSM1:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[MAPFTR] CYLEN[FIXM] $
	D[MEM] MASK[18.] DEST[PC] NORM $; JUMP TO RIGHT HALF
	D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $; GET READY TO STORE
	D[AR] DEST[MEMSTO] MEMSTMA $
CTYSVPC:

: 5100 ;CTY IOT DISPATCH TABLE
	ILGIOT $	;BLKI
	NOP $
	D[12] DEST[Q] SPEC[IOB-IN] NORM $ ;DATAI
	D[IOD] DEST[AR] JUMP[CTYDI] CYLEN[IOB-IN] $
	ILGIOT $	;BLKO
	NOP $
	FIXM1 $		;DATAO
	D[12] DEST[Q] JUMP[CTYDO] NORM $ ; GET CONI BITS
	D[12] MASK[7] DEST[Q] NORM $ ;CONO, GET CONI BITS
	D[IR] MASK[7] ROT[40] ALU[-D&Q] DEST[Q] JUMP[CTYCO] NORM $ ;CLR THE CLR BITS
	D[12] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $; CONI, GET BITS
	D[AR] DEST[MEMSTO] MEMST $
	D[12] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $;CONSZ, GET BITS
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
	D[12] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $;CONSO, GET CONI BITS
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
     .REPEAT 10 [ILGIOT $
	NOP $
]


: 2130 ;CTY INTS COME HERE
	D[12] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $; DO A CONI, GET BITS
	D[11] MASK[11] DEST[IOD] SPEC[IOB-OUT] NORM $; DISABLE INTS
	MAPF[10] CYLEN[IOB-OUT] D[12] MASK[3] DEST[Q AR] $; GET PI CHAN
	NORM  DEST[CLR-DEV-FROM-INTR] JUMP[PIGEN] $;CAUSE INTR.

: 5210
CTYIOT:	IOTDIS [51]

CTYDI:	D[CONST 40] ALU[-D&Q] DEST-A-MEM DEST[2] NORM $; CLR TTI FLAG
	D[CONST 10] ROT[3] DEST[Q] SHORT $
	D[11] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] SHORT $;CLR RCV. CHR
	MAPF[10]  CYLEN[IOB-OUT] $
	D[11] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[10] CYLEN[IOB-OUT] $
	D[AR] MASK[10] DEST[MEMSTO] MEMST $
CTYDO:	D[MEM] DEST[IOD] SPEC[IOB-OUT] NORM $;SEND CHR.
	MAPF[4] CYLEN[IOB-OUT] D[CONST 10] ALU[-D&Q] DEST[Q] $;CLR TTO FLAG
	D[11] ALU[D+1] DEST[IOD] SPEC[IOB-OUT] NORM $; ENABLE UART STB
	MAPF[10] CYLEN[IOB-OUT] D[CONST 20] ALU[DORQ] DEST[2] DEST-A-MEM $;SET TTO BUSY
	D[11] DEST[IOD] SPEC[IOB-OUT] NORM $;CLR UART STB
	MAPF[10] CYLEN[IOB-OUT] D[CONST 7] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] $ ; DONE IF NO PI CHAN
	D[11] DEST[Q] SHORT $; GET IOB-OUT BITS
	D[CONST 4] ROT[11] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] NORM $ ;ENABLE XMT INT
	MAPF[10] CYLEN[IOB-OUT] ALU[Q] DEST[1] DEST-A-MEM JUMP[MAIN] $
CTYCO:	D[CONST 17] ROT[3] ALU[D&Q] DEST[Q] NORM $;CLR PI BITS
	D[IR] MASK[7] ALU[DORQ] DEST[2] DEST-A-MEM JUMP[CTYCO1] NORM $; OR IN NEW
CTYCI:	D[IOD] DEST[HOLD] CYLEN[IOB-IN] $;GET UART BITS
	D[11] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[10] D[MEM] ROT[26] MASK[1] COND[-OBUS=0] JUMP[CTYCI1] CYLEN[MAX,IOB-OUT,C550] $; J IF RCV RDY
CTYCI2:	D[CONST 10] ROT[3] ALU[-D&Q] DEST[Q AR] JUMP[CTYCI9] NORM $;CLR TTI BUSY
CTYCI1:	D[CONST 40] ALU[D&Q] COND[-OBUS=0] JUMP[CTYCI2] C550 $;J IF TTI FLAG ON
	D[CONST 10] ROT[3] ALU[D#Q] DEST[Q AR] NORM $;COMPL BUSY.
	D[CONST 10] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[CTYCI9] C550 $;J IF BUSY NOW ON
	D[CONST 40] ALU[DORQ] DEST[Q AR] NORM $; SET TTI FLAG
CTYCI9:	D[MEM] ROT[25] MASK[1] COND[-OBUS=0] JUMP[CTYCI8] C550 $;J IF XMT RDY
	D[CONST 20] ALU[DORQ] DEST[2] DEST-A-MEM POPJ NORM $;SET BUSY -- NOTE, NO "AR DEST" IS CORRECT
CTYCI8:	D[CONST 20] ALU[D&Q] COND[OBUS=0] JUMP[CTYCI3] C550 $; J IF BUSY OFF
	D[CONST 10] ALU[DORQ] DEST[Q] NORM $; SET FLAG
CTYCI3:	D[CONST 20] ALU[-D&Q] DEST[2] DEST-A-MEM POPJ NORM $ ;CLR BUSY
CTYCO1:	D[IR] ROT[41] MASK[10] DEST[Q] NORM $; GET SET&CLR BITS
	D[CONST 10] ROT[3] ALU[D&Q] COND[OBUS=0] JUMP[CTYCO4] $; J IF CLR TTI FLAG OFF
	D[11] MASK[11] DEST[Q] NORM $;GET IOB-OUT BITS
	D[CONST 10] ROT[3] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $;GET CLR RCV RDY BIT
CTYCO3:	MAPF[10] CYLEN[IOB-OUT] $
	ALU[Q] DEST[IOD] SPEC[IOB-OUT] NORM $;CLR IT
	MAPF[10] CYLEN[IOB-OUT] $
CTYCO4:	D[11] MASK[11] DEST[Q] NORM $; GET IOB-OUT BITS
	D[12] MASK[3] COND[OBUS=0] JUMP[CTYCO5] C550 $; J IF NO PI CHAN
	D[CONST 2] ROT[11] ALU[DORQ] DEST[Q] SHORT $; ENBL RCV INT
	D[12] ROT[41] MASK[2] COND[OBUS=0] JUMP[CTYCO5] C550 $; J IF NO OUT FLAG OR BUSY
	D[CONST 4] ROT[11] ALU[DORQ] DEST[Q] SHORT $;ENBL XMT INT
CTYCO5:	ALU[Q] DEST[IOD] SPEC[IOB-OUT] SHORT $; FIX INT ENBLS
	MAPF[10] CYLEN[IOB-OUT] ALU[Q] DEST[1] DEST-A-MEM JUMP[MAIN] $
; **** HERE IS DEFN. OF CTY UART CONSTANTS ****

CTYRST:	D[CONST 4] ROT[6] DEST[Q] NORM $
	D[CONST 4] DEST[DEV-ADR] NORM $
	DEST[CLR-DEV-FROM-INTR] NORM $
	D[CONST 74] ALU[DORQ] DEST[Q 1] DEST-A-MEM NORM $
	D[CONST 3] ROT[6] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $; RESET UART
	MAPF[10] CYLEN[IOB-OUT] ALU[0] DEST[2] DEST-A-MEM $
	ALU[Q] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] POPJ $
: CTYSVPC

.PAIR

CTYCZ:	D[AR] ALU[D&Q] COND[-OBUS=0] JUMP[MAIN] C550 $
	DOSKIP $
CTYCS:	D[AR] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $
	DOSKIP $



DSKRST:	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $
	  ;SET DSK CTRL COMMAND REGISTER TO 0 (DISABLES INTS).
	MAPF[4] D[CONST 2] DEST[IOD] SPEC[IOB-OUT]
				CYLEN[IOB-OUT] $
	  ;NOW CLEAR THE STATE.
	MAPF[7]  CYLEN[IOB-OUT]  POPJ $

SET-DSK-OUT:
	D[CONST 10] DEST[DEV-ADR] NORM $
	D[MEM] DEST[IOD AR] SPEC[IOB-OUT] NORM POPJ $

TYMRST:		;RESET TYMNET INTERFACE
	D[CONST 1] DEST[Q] PUSHJ[DEV6CL] NORM $
.REPEAT TYMNET [
	JUMP[TYMRS1] NORM $	;SET INITIAL COROUTINE ADR, INT ENBLS.
];TYMNET
.REPEAT 1 - tymnet [
	POPJ NORM $
]; 1 - tymnet

CLKRST:	  ;RESET 60HZ CLOCK FLAG AND DISABLE ITS INTERRUPTS.
	D[CONST 1] ALU[NOTD] DEST[Q] PUSHJ[DEV6CL] NORM $
		;LOAD A MASK INTO Q AND GO TO COMMON ROUTINE.
	;FALLS IN
CLKCLR:	  ;CLEAR 60HZ CLOCK FLAG.
	D[CONST 6] DEST[DEV-ADR] 
	 SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT]  ;THIS CLEARS THE FLAG.
	 D[12] SPEC[A-MEM-APR] ROT[32] MASK[1] DEST[AR] $
	  ;GET THE APR CONDITIONS WD.
	D[CONST 1] ALU[NOTD] DEST[Q] JUMP[DEV6ST] NORM $
	 ;SET OR CLEAR THE HARDWARE INTRPT. ENB. ACCORDING TO
	 ; STATE OF CLK INT ENB BIT IN APR 


DEV6CL:	  ;CLEAR SOME DEV 6 BITS (SEE COMMENT BELOW).
	ALU[0] DEST[AR] NORM JUMP[DEV6ST] $

DEV6ST:	   ;SET SOME OF THE BITS IN DEVICE 6'S OUTPUT REGISTER, A COPY
	   ;OF WHICH IS MAINTAINED IN A-MEM(1).
	   ;ENTER WITH MASK FOR UNCHANGED BITS IN IN Q, DATA IN AR.
	   ; $$$$ ON RETURN, Q HAS NEW VALUE OF AMEM(1) $$$$$
	D[CONST 6] DEST[DEV-ADR] NORM $
DEV6ST1:	;ENTER HERE IF YOU'VE ALREADY SET DEVADR:=6
	D[11] ALU[D&Q] DEST[Q] NORM $ ;GET AMEM(1), MASK IT.
DEV6ST2:	 D[AR] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] NORM $ ;OR IN NEW DATA
	MAPF[1] ALU[Q] DEST[1] DEST-A-MEM CYLEN[IOB-OUT] POPJ $

TAPRST:	 ;RESET THE TAPE CONTROLLER AND ASSOCIATED DEVICES.

	D[CONST 7] DEST[DEV-ADR] NORM $ ;SELECT DEVICE.
   .REPEAT TLXTAPE [ PUSHJ[TLXRST] $ 
			;Clear TELEX formatter, if any. ]
	D[CONST 1] ROT[35.] DEST[Q] NORM $

   .REPEAT TIMER [  ;IF INTERVAL TIMER IS PRESENT...
	D[CONST 1] ROT[35. - 19.] ALU[DORQ] DEST[Q 1] DEST-A-MEM $
	   ;FORM DATA TO CLR TAPE ERR FF'S, ENABLE TIMER INTRPTS
     ] ;TIMER
   .REPEAT 1 - TIMER [  ;IF INTERVAL TIMER IS ABSENT...
	ALU[Q] DEST[Q 1] DEST-A-MEM $
	   ;FORM DATA TO CLR TAPE ERR FF'S, DISABLE TIMER INTRPTS
     ] ;1 - TIMER

	START-OUT D[CONST 1] ROT[35. - 6] ALU[DORQ] DEST[IOD] NORM $
	   ;DO SO;  ALSO CLEAR TIMER OVERFLOW INTRPT FLAG.
	MAPF[1] START-OUT D[CONST 1] ROT[35. - 9] DEST[Q IOD] C800 $
	   ;ALSO CLEAR ALL SIGNALS TO THE DEVICE, SET "CLOCK RUN"
	MAPF[6] ALU[Q] DEST[2] DEST-A-MEM  C800 $
	   ;RECORD THE "CLOCK RUN" BIT IN A-MEM[2]; EVERYONE WHO
	   ; LOADS THE CTL REG (MAPF[4]) SHOULD INCLUDE IT.
	D[CONST 60] ROT[35. - 15.] DEST[Q] NORM $
	D[CONST 30] ROT[35. - 21.] ALU[DORQ] DEST[Q] NORM $
	   ;ASSEMBLE -1000. AS 12-BIT NO. ENDING AT BIT 21.
	START-OUT D[CONST 41] ROT[35. - 7] ALU[DORQ] DEST[IOD] NORM $
	   ;THIS SETS TIMER CLOCK FOR 100 USEC TICKS, ZEROES COUNTER.
	MAPF[1] ALU[0] DEST[3] DEST-A-MEM C800 POPJ $
	   ;INIT THE TIMER REG. TO 0 AND RETURN.

APRRST:
.REPEAT F2SW [
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $	;Clear Addr. Break
];REPEAT F2SW
	MAPF[1] ALU[0] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM] CYLEN[IOB-OUT] POPJ $

CLRDEVINT:	   DEST[CLR-DEV-FROM-INTR] POPJ NORM $
		;CLEAR FLAG WHICH CAUSES DEV-ADR TO BE
		; ADR OF LAST INTERRUPTING DEVICE,
		; SO THE DEV-ADR REGISTER WILL WORK AGAIN.

;PI SYSTEM USE OF APR AMEM---
; 4	MEM PAR ERR(BIT 19), MEM PAR ERR INTRPT ENB(BIT 20),
;	 PI SYSTEM ON(BIT 28) CHN1-7 ON (BITS 29-35)
; 5	WAITING RQ 1-7 (11-18)  IN PROG 1-7 (29-35)
; 6	RQ COUNTS - 4-BIT FIELDS, CHN. 7 AT RIGHT END OF WORD.

PI-GET-CHN:	;MAKE BINARY CHN. NO. FROM MASK IN AR.
	D[AR] ROT[34] DEST[AR] NORM $
		;PUT RQ 1 INTO BIT 1
	D[CONST 6] DEST[MA] NORM $
		;MA WILL GET 7-CHN (FOR USE IN SHIFTING)
PIL1:	D[AR] ROT[1] DEST[AR] C550
	   COND[OBUS<0] JUMP[PIGETMASK] $ ;FOUND FIRST BIT ?
	D[MA] ALU[D-1] DEST[MA] NORM JUMP[PIL1] $
		;NO. DECREMENT COUNT AND LOOP.
PIGETMASK:	D[MA] DEST[ROTR] NORM $ ;LOAD ROTATE AMT.
	D[CONST 1] ROT[R] DEST[AR] NORM 
	  POPJ $	;MAKE MASK OF FIRST BIT ONLY IN AR.

PI-CHECK-RQS:	 ;SEE IF IT IS TIME TO TAKE AN INTRPT.
	D[15] SPEC[A-MEM-APR] ROT[18.] MASK[7] DEST[AR]
	  C550 COND[OBUS=0] JUMP[MAIN] $ ;ANY RQ'S ?
	ALU[0] DEST[DEV-ADR] NORM PUSHJ[PI-GET-CHN] $
		;GET UNARY CHN NO. IN AR, SHIFT AMT. IN MA, ROTR
	D[14] ROT[34] C550 COND[-OBUS<0] JUMP[MAIN] $
		;EXIT IF PI SYS NOT ON.
	D[MASK 7] ROT[R] DEST[Q] NORM $
		;MASK OF CHN AND ALL HIGHER CHNS.
	D[15] ALU[D&Q] C550 COND[-OBUS=0] JUMP[MAIN] $
		;EXIT IF THIS OR HIGHER CHN IN PROGRESS.
	D[AR] DEST[Q] NORM $ ;MOVE UNARY CHN # TO Q.
	D[14] ALU[D&Q] C550 COND[OBUS=0] JUMP[MAIN] $
		;EXIT IF CHN NOT ON.
	D[MA] ROT[2] DEST[ROTR] NORM $
		;GET SHIFT AMT 4 TIMES LARGER, TO ACCESS CNT FIELD
	D[CONST 1] ROT[R] DEST[Q] NORM $
		;A ONE ALIGNED WITH RQ CNT FIELD FOR THIS CHN.
	D[16] ALU[D-Q] DEST[Q HOLD] NORM $
		;DECREMENT OUR WAITING RQ COUNT.
	D[16] ALU[D#Q] DEST[Q] NORM $ ;DID WE OVERFLOW ?
	D[CONST 20] ROT[R] ALU[D&Q] COND[-OBUS=0] C550 JUMP[.] $
	  ;LOOP HERE FOREVER IF WE OVERFLOWED 4-BIT CNT FIELD
	D[MEM] DEST[6 Q] DEST-A-MEM NORM $
		;PUT BACK WORD OF RQ COUNTS.
	D[CONST 17] ROT[R] ALU[D&Q] C550
	  COND[-OBUS=0] JUMP[PIINTGO] $ ;JUMP IF OUR COUNT NEQ 0
	D[AR] ROT[18.] ALU[NOTD] DEST[Q] NORM JUMP[PIL11] $
		;MASK FOR CLEARING THE WAITING RQ BIT.
PIINTGO:	D[CONST 0] ALU[NOTD] DEST[Q] NORM $
		;DON'T CLEAR THE BIT, RQ'S STILL WAITING
PIL11:	D[15] ALU[D&Q] DEST[Q] NORM $
		;GET STATUS B, EITHER DO OR DO NOT CLEAR RQ BIT
	D[AR] ALU[DORQ] DEST[5] DEST-A-MEM NORM $
		;SET IN PROGRESS BIT, STORE STATUS B.
	D[PC] DEST[Q AR] NORM $ ;GET PC INTO Q, AR.
	D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $ ;CLR USR MODE
	D[MA] ROT[18.] ALU[DORQ] DEST[1] DEST-A-MEM NORM $
 ;; FOLLOWING INSTR. IS DEBUGGING AID
	D[CONST 56] DEST[Q] NORM $
		;PREPARE TO CALC. INTRPT. ADDRESS.
	D[MA] ROT[1] ALU[Q-D] DEST[MA] NORM JUMP[PIMUUO] $
		;FETCH INTRPT. INSTR AND GO INTERPRET IT.
PIGEN:	 ;ENTER WITH CHN IN AR TO REQUEST INTRPT.
	ALU[0] DEST[DEV-ADR] NORM PUSHJ[CLRDEVINT] $
	D[14] DEST[Q] NORM $
	D[CONST 1] ROT[18.] ALU[D+Q] DEST[4] DEST-A-MEM
		NORM $
	D[CONST 7] DEST[Q] NORM $
		;7-CHN IS AMT TO SHIFT BY FOR MASK BIT.
	D[AR] MASK[3] ALU[Q-D] DEST[MA] NORM
	  PUSHJ[PIGETMASK] $ ;LOAD ROTR, FORM MASK IN AR
PIGEN1:	D[14] ROT[34] C550 COND[-OBUS<0] JUMP[PIGENWT] $
		;BRANCH IF PI SYS NOT ON.
	MASK[7] D[2] ROT[R] DEST[Q] NORM $
		;MASK OF CHN AND ALL HIGHER CHNS.
	D[15] ALU[D&Q] C550 COND[-OBUS=0] JUMP[PIGENWT] $
		;BRANCH IF THIS OR HIGHER CHN IN PROGRESS.
	D[AR] DEST[Q] NORM $ ;MOVE UNARY CHN # TO Q.
	D[14] ALU[D&Q] C550 COND[-OBUS=0] JUMP[PIINTGO] $
		;IF CHN ON, GO TAKE INTRPT.
PIGENWT:	  ;INTRPT CANNOT HAPPEN NOW, SO SET A WAITING RQ.
	D[MA] ROT[2] DEST[ROTR] NORM $
		;GET SHIFT AMT 4 TIMES LARGER, TO GET CNT FIELD
	D[CONST 1] ROT[R] DEST[Q] NORM $
		;A ONE ALIGNED WITH RQ CNT FIELD FOR THIS CHN.
	D[16] ALU[D+Q] DEST[Q HOLD] NORM $
		;INCREMENT OUR WAITING RQ COUNT.
	D[CONST 10] ROT[R] ALU[D&Q] COND[-OBUS=0] C550 JUMP[. + 2] $
	  ;DON'T LET COUNT GET HIGHER THAN 7.
	D[MEM] DEST[6] DEST-A-MEM NORM $
		;PUT BACK WORD OF RQ COUNTS.
	D[15] DEST[Q] NORM $
		;GET STATUS B.
	D[AR] ROT[18.] ALU[DORQ] DEST[5] DEST-A-MEM
	   NORM JUMP[MAIN] $ ;SET WAITING RQ BIT.

PI-DISMISS:
	D[15] SPEC[A-MEM-APR] MASK[7] DEST[AR]
	  C550 COND[-OBUS=0] PUSHJ[PI-GET-CHN] $
	D[15] SPEC[A-MEM-APR] DEST[Q] NORM $
	D[AR] ALU[-D&Q] DEST[5] SPEC[A-MEM-APR&DEST-A-MEM]
		NORM JUMP[PI-CHECK-RQS] $
PICONO:  ;HERE FROM ANY CONO PI,
	D[MA] MASK[7]  DEST[AR] NORM $
	ALU[0] DEST[DEV-ADR] NORM $
	D[14]  DEST[Q] NORM $ ;GET STATUS A
	D[MA] ROT[21.]  C550 COND[-OBUS<0] JUMP[PIL7] $
	D[CONST 1] ROT[35. - 20.] ALU[DORQ] DEST[Q] NORM $ 
	 ; TURN ON PAR ERR INTRPT ENB.
PIL7:	D[MA] ROT[20.]  C550 COND[-OBUS<0] JUMP[PIL8] $
	D[CONST 1] ROT[35. - 20.] ALU[-D&Q] DEST[Q] NORM $ 
	 ;TURN OFF PAR ERR INT ENB
PIL8:	D[MA] ROT[19.] C550 COND[-OBUS<0] JUMP[PIL9] $
	D[CONST 1] ROT[35. - 19.] ALU[-D&Q] DEST[Q] NORM $ 
	 ;CLEAR MEM PAR ERR FLAG
PIL9:	D[MA] ROT[5]  C550 COND[OBUS18] PUSHJ[PI-RESET] $
	D[MA] ROT[12]  C550 COND[-OBUS18] JUMP[PIL3] $
	D[CONST 1] ROT[7] ALU[DORQ] DEST[Q] NORM $ ; PI ON
PIL3:	D[MA] ROT[11]  C550 COND[-OBUS18] JUMP[PIL4] $
	D[CONST 1] ROT[7] ALU[-D&Q] DEST[Q] NORM $ ; PI OFF
PIL4:	D[MA] ROT[7]  C550 COND[-OBUS18] JUMP[PIL5] $
	D[AR] ALU[DORQ] DEST[Q] NORM $ ; CHNS ON
PIL5:	D[MA] ROT[10]  C550 COND[-OBUS18] JUMP[PIL6] $
	D[AR] ALU[-D&Q] DEST[Q] NORM $ ; CHNS OFF
PIL6:	ALU[Q] DEST[4] DEST-A-MEM NORM $
	D[MA] ROT[6]  C550 COND[-OBUS18] JUMP[PI-CHECK-RQS] $
	D[AR] MASK[7] ALU[0-D] DEST[Q] NORM $
		;GENERATED INTRPTS REQUESTED. CHECK TO
		; MAKE SURE ONLY ONE CHN IS SPECIFIED.
	D[AR] MASK[7] ALU[D&Q] DEST[Q] NORM $
	D[AR] MASK[7] ALU[D-Q] C600
	  COND[-OBUS=0] JUMP[.] $ ;HANG HERE IF MORE THAN ONE.
	D[AR] MASK[7]  DEST[AR] NORM PUSHJ[PI-GET-CHN] $
		;GET BINARY CHN. NUMBER AND UNARY MASK.
	NORM JUMP[PIGEN1] $ ;GO GENERATE REQUEST.


PICONISUB:
	D[14] SPEC[A-MEM-APR] MASK[18.] DEST[Q] NORM $
	  ;GET SYS ON AND CHN ON BITS.
	D[15] SPEC[A-MEM-APR] MASK[10] DEST[AR] NORM $
	  ;GET PI IN PROG BITS
	D[AR] ROT[10] ALU[DORQ] DEST[AR Q] NORM $
	D[15] SPEC[A-MEM-APR] ROT[18.] MASK[10] DEST[AR] NORM $
	  ;GET WAITING RQ BITS, AND RETURN IN LEFT HALF.
	D[AR] ROT[18.] ALU[DORQ] DEST[AR Q] NORM POPJ $

PI-RESET:
	ALU[0] DEST[4] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	ALU[0] DEST[5] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	ALU[0] DEST[6 Q] SPEC[A-MEM-APR&DEST-A-MEM] NORM  $
	ALU[0] DEST[1] SPEC[A-MEM-APR&DEST-A-MEM] NORM POPJ $

END-OF-PI-CODE:
;; MBOOT MOVED TO PAGE WITH REST OF TAPE STUFF

; MAP CONO DISP TABLE
: 5200
	JUMP[MAPCO0] NORM $; CONO 0
	DEST[CLR-MAP] JUMP[MAPCO1] NORM $; CONO1- START MAP CLEARING
	JUMP[.] $ ;  CONO 2 -- ILLEGAL
	DEST[CLR-MAP] JUMP[MAPCO1] NORM $; CONO 3 -- START MAP CLR
	D[CONST 1] DEST[DEV-ADR] JUMP[MAPCO4] NORM $; CONO 4
	D[CONST 1] DEST[DEV-ADR] JUMP[MAPCO4] NORM $; CONO 5
	JUMP[MAPCO6] NORM $ ;CONO 6
	DEST[CLR-MAP] JUMP[MAPCO7] NORM $; CONO 7

: 5140
MAPIOT:	D[IR] ROT[9.] COND[-OBUS<0] JUMP[MAIN] C550 $ ;NOP IF DEV. 20
	D[CONST 14] ALU[D#Q] COND[OBUS=0] JUMP[MAPIO1] C550 $; IS IT CONO ?
	D[CONST 13] ALU[D#Q] COND[OBUS=0] JUMP[MAPDO] C550 $; NO IS IT DATAO?
	ILGIOT $   ;ELSE ILLEGAL
MAPIO1:	D[IR] MASK[3] DEST[Q] NORM $
	D[CONST 52] ROT[6] ALU[DORQ] SDISP C600 $
MAPCO0:	D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $
	D[12] DEST[Q] NORM $; GET SIGN BIT = ENBL FOR EXEC 0-77777
	ALU[0] DEST[DEV-ADR] SHORT $
	D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[10] CYLEN[IOB-OUT] DEST[CLR-MAP] D[CONST 20] LLOAD $; TURN OFF MAPPING & START CLEARING MAP
	LOOP [.] C550 $  ;WAIT FOR MAP CLR TO FINISH -- OTHERWISE THE
	  	; READS OF 71 AND 72 BELOW DON'T HAPPEN (ON F2 #1).
	D[CONST 71] DEST[MA] SHORT $; FETCH MAGIC LOC
	D[CONST 1] DEST[DEV-ADR] CYLEN[FIXM]  $; WAIT FOR DATA
	D[MEM] MASK[13] DEST[AR] SHORT $
	D[AR] ROT[11] DEST-A-MEM DEST[4] NORM $; MBR
	D[MEM] ROT[18.] MASK[13] DEST[AR] SHORT $
	D[AR] ROT[11] DEST-A-MEM DEST[1] NORM $; UBR
	D[MEM] ROT[27] MASK[5] DEST[AR] SHORT $
	D[AR] ROT[4] DEST-A-MEM DEST[3] NORM $; AC BASE REG
	D[MEM] ROT[7] MASK[3] ALU[0-D] DEST[AR] COND[OBUS=0] JUMP[MAPCOB] C600 $; ADDRS LIMIT, J IF 0
	D[AR] MASK[3] DEST[AR] SHORT $
	D[AR] ROT[16] DEST[AR] JUMP[MAPCOC] NORM $; FORM SMALLEST ILLEGAL ADDRESS
MAPCOB:	D[CONST 20] ROT[16] DEST[AR] SHORT $
MAPCOC:	D[CONST 1] ROT[43] ALU[D&Q] DEST[Q] SHORT $; GET SIGN BIT = ENBL FOR EXEC 0-77777
	D[AR] ALU[DORQ] DEST-A-MEM DEST[AR 2] NORM $; ADDRS LIMIT
	D[CONST 72] DEST[MA] SHORT $; GET NEXT WORD
	C600 $ ;WAIT FOR DATA
	D[MEM] DEST[Q] NORM $
	D[CONST 1] ROT[32] ALU[-D&Q] DEST-A-MEM DEST[5] JUMP[MAPCOE] NORM $; AGE & PROCESS BITS
: 6100  ;MAP FAULT DISPATCHES COME HERE (6100 + MAPF*4 )
	JUMP[.] $   ;ILLEGAL MAP FAULT -- MICROCODE BUG IF YOU GET HERE
: 6104	;EXECUTE (&INDIRECT) FAULTS HERE
MFT1:	D[CONST 2] ROT[18.] DEST[Q] NORM $; CODE FOR EXECUTE
MFT1A:	D[CONST 1] DEST[DEV-ADR] NORM $
MFT1D:	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
	D[IOD] MASK[3] DEST[AR IR-ADR] JUMP[MFT1B] MAPF[4] CYLEN[IOB-IN] $
: 6110	;NORMAL READ FAULT
MFRD:	D[CONST 10] ROT[18.] DEST[Q] NORM $;CODE FOR RD
MFOTH:	D[PC] ALU[D-1] DEST[PC] JUMP[MFT1A] NORM $
: 6114	;RMW HERE, DECREMENTS PC
	D[CONST 14] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $
: 6120	;WRITES (NORMAL) HERE (NO DECREMENT PC)
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[AR] DEST-A-MEM DEST[7] NORM $;SAVE STORE DATA
	D[IR] MASK[18.] DEST[MA] NORM JUMP[MFT1D] $; RESTORE MA
: 6124 ; 5-- BLT-RD
	D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC] NORM $; RESTORE PC & DEST ADR
	D[CONST 10] ROT[18.] DEST[Q] SHORT $; CODE FOR RD
MBLT3:	D[AR] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC] JUMP[MFOTH] NORM $; GET SRC ADR
: 6130 ;6-- BLT-WRT
	D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC MA] SPEC[MA_PC] NORM $; RESTORE PC, GET DEST ADR
	ALU[Q-1] DEST[AR] NORM $;  ADJUST SRC ADR
	D[CONST 4] ROT[18.] DEST[Q] JUMP[MBLT3] NORM $; CODE FOR WRT
: 6134 ;7-- BLT-RDA
	ACSEL[AC] D[AR] DEST[AC] NORM $; NEW DEST ADR
	D[CONST 10] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $; CODE FOR RD
: 6140 ; 10-- BLT-WRTA
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; CODE FOR WRT
	D[MA] MASK[18.] DEST[Q] PUSHJ[BWRTA1] NORM $; GET MA, SAVE STORE DAT
	D[AR] MASK[18.] ALU[D#Q] COND[OBUS=0] JUMP[MBLT2] C550 $
	ALU[Q-1] DEST[Q MA] JUMP[MBLT2] NORM $; CORRECT MA
: 6144 ;11-- BYTE-ILD
	PUSHJ[SETHLF] NORM $; SET HALF
	JUMP[6110] NORM $; NORMAL READ
SETHLF:	D[CONST 2] ROT[36] DEST[Q] NORM $;BIT 4--HALF
	D[PC] ALU[DORQ] DEST[CRYOV] POPJ NORM $;SET HALF
: 6150 ;12 -- BYTE-IDP
	PUSHJ[SETHLF] NORM $; SET HALF
	JUMP[6114] NORM $;NORMAL RMW
: 6154 ;13 -- BYTE-IND
	PUSHJ[SETHLF] NORM $; SET HALF
	JUMP[6104] NORM $; NORMAL INDIRECT
: 6160 ;BLT-WRTB -- XCT MAPPED BLT STORES
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; CODE FOR WRT
	D[MA] MASK[18.] DEST[Q] PUSHJ[BWRTA1] NORM $; GET MA, SAVE STORE DAT
	D[CONST 4] ROT[18.] DEST[Q] NORM $
	D[AR] ACSEL[AC] DEST[AC] JUMP[MFOTH] NORM $; RESTORE AC
: 6164 ;-- MAPFTR -- TRAP WHIILE FETCHING JSYS TARGET
	D[CONST 50] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; PI CODE
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[AR] DEST-A-MEM DEST[7] JUMP[MFOTH] NORM $
: 6170 ;PPOP-- 16 -- POP & POPJ FETCH- RE-INCR PDL PNTR -- THEN LIKE READ FAULT
	D[CONST 1,,1] ACSEL[AC] ALU[D+AC] DEST[AC] JUMP[MFRD] NORM $
: 6174 ;17-- WRITES WITH RELEVANT ADRS IN MA (NO DECR PC)
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $
	D[CONST 1] DEST[DEV-ADR] SHORT $
	D[MEM] DEST-A-MEM DEST[7] JUMP[MFT1D] NORM $;SAVE STORE DATA
BWRTA1:	D[CONST 1] DEST[DEV-ADR] NORM $
	D[MEM] DEST-A-MEM DEST[7] POPJ NORM $
MBLT2:	D[AR] MASK[18.] ALU[Q-D] DEST[Q] SHORT $; COUNT HOW MANY WORDS MOVED
	D[AR] ROT[18.] ALU[Q+D] DEST[AR] SHORT $;FORM NEW SRC
	ACSEL[AC] D[MA] MASK[18.] DEST[AC] SHORT $;NEW DEST
	D[CONST 4] ROT[18.] DEST[Q] NORM $
	D[AR] ACSEL[AC] ROT[18.] SPEC[LEFT] ALU[DORAC] DEST[AC] JUMP[MFOTH] NORM $; OR IN NEW SRC

: 5440
MAPCWT:	ALU[Q] LLOAD NORM $
	LOOP[.] CYLEN[LONG] $; WAIT FOR MAP TO CLEAR
	D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $;TURN ON MAP
	MAPF[10] D[AR] COND[OBUS<0] JUMP[MAPCW9] CYLEN[MAX,IOB-OUT,C550] $; J IF WHOLE MAP ON (INCLUDING EXEC 0-77777)- DONE
MAPCW1:	D[CONST 77]  MAPF[10] LLOAD NORM $
MAPCW2:	D[PC]  DEST[AR] SHORT $;SAVE FLAGS
	ALU[0] DEST[MA CRYOV] SHORT $;INIT MA, SET EXEC
	D[CONST 10] ROT[6]  DEST[Q] SHORT $

 .REPEAT NEWMAP [
	D[CONST 1] DEST[DEV-ADR] NORM $ ; -- FOR WRITING MAP
	SPEC[IOB-OUT] SHORT $  ;SET FIRST PART OF 
	   ; EXEC MAP TO POINT TO "NULL MAP" LOCS(UNMAPPED)
 	MAPF[2] D[MA] MASK[18.] C800 $ ;MAP DATA COMES FROM OBUS.
	D[MA] ALU[D+Q] DEST[MA] LOOP[. - 2] NORM $;LOOP
   ] ; NEWMAP

 .REPEAT 1 - NEWMAP [
	D[MA] MASK[18.] DEST[STO-MAP] NORM $;SET FIRST PART OF EXEC MAP TO POINT TO "NULL MAP" LOCS(UNMAPPED)
	D[MA] ALU[D+Q] DEST[MA] LOOP[. - 1] NORM $;LOOP
  ] ; 1 - NEWMAP

	D[IR] MASK[3]  DEST[IOD] SPEC[IOB-OUT] SHORT $; RESTORE MAP
	D[AR]  DEST[CRYOV] JUMP[MAIN] MAPF[10] CYLEN[IOB-OUT] $; RESTORE FLAGS, DONE

MAPCOA:	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
	D[IOD]  MASK[3] DEST[IR-ADR] MAPF[4] POPJ CYLEN[IOB-IN] $;GET MAP, ECC & OV ENBL BITS
MAPCOE:	ALU[0] DEST[DEV-ADR] SHORT $
	D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE MAP STATE
	MAPF[10] D[CONST 1] DEST[Q] JUMP[MAPCWT] CYLEN[IOB-OUT] $
MAPCO1:	D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $;GET ENABLE BITS IN IR
	D[12] DEST[AR] NORM $; GET SIGN BIT = ENBL EXEC 0-77777
	ALU[0] DEST[DEV-ADR] SHORT $
	D[CONST 5] DEST[Q] JUMP[MAPCWT] NORM $
MAPCOG:	D[CONST 1] DEST[DEV-ADR] NORM $
	D[12] MASK[43] DEST[Q] NORM $
	D[IR] MASK[1] DEST[AR] SHORT $;GET LOW BIT OF CONO
	D[AR] ROT[43] ALU[DORQ] DEST-A-MEM DEST[2] NORM $;GET SIGN BIT = EXEC 0-77777 MAP ENBL
	SPEC[IOB-IN] SHORT $
	MAPF[4] D[IOD] MASK[3] DEST[Q] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
	D[CONST 4] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] SHORT $
	D[CONST 4] ALU[DORQ] DEST[IR-ADR] MAPF[10] POPJ CYLEN[IOB-OUT] $;TURN ON MAP
MAPCO4:	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] NORM PUSHJ[MAPOFF] $

MPOFF1:	MAPF[10] CYLEN[IOB-OUT] JUMP[MAIN] $; DONE
MAPOFF:	D[IOD] MASK[3] DEST[IR-ADR] MAPF[4] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
	D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM POPJ $
MAPCO6:	DEST[CLR-DEV-FROM-INTR] PUSHJ[MAPCOG] NORM $
	JUMP[MAPCW1] NORM $
MAPCO7:	DEST[CLR-DEV-FROM-INTR] PUSHJ[MAPCOG] CYLEN[LONG] $
	CYLEN[LONG] $; WAIT FOR MAP TO CLEAR
	CYLEN[LONG] $
MAPCW9:	ALU[0] LLOAD NORM $; SET UP ONLY PAGE 0
	JUMP[MAPCW2] NORM $

;DATAO CLEARS THE "ASSOCIATIVE" REGISTER MAPPING THE ADDRESS OF THE DATAO
; THIS REPLACES CONO 2.

MAPDO:	D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $;GET MAP BITS
 .REPEAT 1 - NEWMAP [ ALU[0] DEST[DEV-ADR] NORM $ ]
	D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $;TURN ON MAP
	MAPF[10] CYLEN[IOB-OUT] $
 .REPEAT NEWMAP [
	SPEC[IOB-OUT] SHORT $  ;REQUEST MAP WRITE CYCLE.
	MAPF[2] D[CONST 1] ROT[32] C800 $ ]

 .REPEAT 1 - NEWMAP [
	D[CONST 1] ROT[32] DEST[STO-MAP] NORM $ ]
	  ;CLR MAP ENTRY ASSOCIATED WITH MA
	D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] C800 $; RESTORE ENABLES
	MAPF[10] CYLEN[IOB-OUT] JUMP[MAIN] $

MFUS:	D[12] MASK[40] DEST[Q] NORM $;GET LIMIT REG
	D[MA] ALU[D-Q] COND[-OBUS<0] JUMP[MTRPAL] C600 $;J IF MA PAST ADDRS LIMIT
	D[11] DEST[Q] JUMP[MFA1] NORM $;GET USER BASE REG.
MFA3:	D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFA4] C550 $ ;J IF MODIF. BIT ON
MFA7:	D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
	D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
	D[CONST 1] ROT[27] ALU[DORQ] DEST[AR] SHORT $; TURN ON WRT-PREVENT, SAVE NEW MAP WORD
MFA6:	D[MEM] MASK[33] DEST[Q] JUMP[MFA5] NORM $; GET CST ENTRY, GO DO
MFA4:	D[IR] ROT[26] MASK[1] COND[OBUS=0] JUMP[MFA7] C550 $; J IF NO WRT-PERMIT
	D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
	D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
	D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] JUMP[MFA6] NORM $; CLEAR WRT-PREVENT
MFT1B:	D[MA] MASK[18.] ALU[DORQ] DEST[AR] COND[USER] JUMP[MFUS] NORM $;GET FAILED ADDRS, J IF USER
	D[MA] ROT[24] MASK[2] DEST[Q] NORM $; HIGH ORDER 2 BITS
	D[CONST 3] ALU[D-Q] COND[OBUS=0] JUMP[MFHIEX] C600 $; J IF PRIVATELY MAPPED PART
	D[CONST 30] ROT[6] DEST[Q] JUMP[MFA1] NORM $; PAGE TAB @ 3000
MFHIEX:	D[14] DEST[Q] NORM $
MFA1:	ALU[0] DEST[DEV-ADR] NORM $
	D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM $ ;CLEAR MAPPING
	D[IR] MASK[3] DEST-A-MEM DEST[7] MAPF[10] CYLEN[IOB-OUT] $; SAVE AR, ECC INT
	D[MA] ROT[33] MASK[11] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE ENTRY
	D[CONST 16] ROT[14] DEST[IR-ADR] NORM $; PREPARE INITIAL PERMIT BITS
	D[CONST 1] DEST[DEV-ADR] NORM $
MFA2:	D[CONST 3] DEST[Q] CYLEN[FIXM] $; DON'T CLEAR IND PNTR. COUNT, WAIT FOR FETCH
	D[MEM] ROT[18.] ALU[DORQ] DEST[Q] CYLEN[FIXM+1] $;GET PERMIT BITS
	D[IR] ALU[D&Q] DEST[IR-ADR] SHORT $; AND THEM IN
	D[MEM] ROT[13] MASK[3] COND[-OBUS=0] JUMP[MFTR1] C550 $; CHECK FOR TRAP BITS
MFB3:	D[MEM] ROT[15] MASK[1] COND[OBUS=0] JUMP[MFTR2] C550 $; J IF NO ACCESS PERMIT
	D[MEM] ROT[2] MASK[2] DEST[Q] COND[OBUS=0] JUMP[MFTYP0] C550 $; GET TYPE CODE, J IF 0
	ALU[Q-1] DEST[Q] COND[OBUS=0] JUMP[MFTYP1] C550 $; J IF 1
	ALU[Q-1] DEST[Q] COND[-OBUS=0] JUMP[MFTR3] C550 $; J IF NOT 2
	D[IR] ROT[43] MASK[1] COND[-OBUS=0] JUMP[MFTR41] C550 $; TYPE 2, J IF >2 INDR. PNTRS
	D[IR] ALU[D+1] DEST[IR-ADR] SHORT $; COUNT IND. PNTRS
	D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET PAGE TABLE #
	D[MEM] DEST-A-MEM DEST[6] NORM $; SAVE PNTR
	D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE PNTR
	D[16] MASK[11] DEST[Q] CYLEN[FIXM] $; GET PAGE #, WAIT FOR MEM
	D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR4] C550 $; PAGE OUT-OF-CORE?
	D[MEM] MASK[13] DEST[HOLD] NORM $
	D[MEM] ROT[11] ALU[DORQ] DEST[MA HI-ABS-MA] JUMP[MFA2] NORM $; LOOP
MFTYP1:	D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET SHARED PAGE #
	D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH SHARED PNTR
MFTYP0:	D[CONST 12] ROT[14] DEST[Q] CYLEN[FIXM] $; GET R-X MASK
	D[IR] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C600 $; J IF NEITHER R NOR X
	D[IR] ALU[DORQ] DEST[IR-ADR] NORM $; TURN ON R AND X
	D[IR] ROT[27] MASK[3] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX ENBL BITS, INVERTED
	D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR5] CYLEN [C550] $; J IF OUT-OF-CORE
	D[AR] ROT[21] MASK[3] ALU[D&Q] DEST[Q] COND[-OBUS=0] JUMP[MFTR6] C550 $; J IF ILLEGAL ACCESS TYPE (RWX)
	D[MEM] MASK[13] DEST[Q] SHORT $; GET ABS PAGE #
	D[CONST 40] ROT[6] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; GET CORE STATUS ENTRY
	D[IR] ROT[12] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX DISABLES
	D[CONST 24] ROT[25] ALU[D&Q] DEST[Q] SHORT $; GET ONLY R & X
	D[CONST 4] ROT[25] ALU[D+Q] DEST[Q] SHORT $; MOVE X BIT LEFT 1
	D[MA] ROT[11] MASK[24] ALU[DORQ] DEST[Q] SHORT $; OR IN PAGE ADDRS
	D[MEM] ROT[3] MASK[3] COND[OBUS=0] JUMP[MFTR7] C550 $; J IF CST AGE SAYS TRAP
	D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFA3] C550 $;J IF NO WRT RQ
	D[AR] DEST[IR-ADR] SHORT $; SAVE ORRIGINAL MA
	D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
	D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] SHORT $; TURN OFF WRT PREVENT, SAVE NEW MAP WORD
	D[CONST 1] ROT[32] DEST[Q] SHORT $; GET MODIFICATION BIT
	D[MEM] MASK[32] ALU[DORQ] DEST[Q] SHORT $; OR INTO CST WORD
MFA5:	D[15] ALU[DORQ] DEST[HOLD] NORM $;OR IN AGE, ETC
	D[MA] DEST[Q] SHORT $; SAVE CST ADDRS

	D[IR] MASK[18.] DEST[MA HI-ABS-MA] NORM $; GET ORIGINAL MA

 .REPEAT NEWMAP [
	D[CONST 1] DEST[DEV-ADR] SHORT $ ;NOW TURN MAP ON.
	D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[10] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
	MAPF[2] D[AR] C800$; LOAD MAP
  NOP $ ;%%%%%%% FOR DEBUGGING $$$$$$$$
  ] ; NEWMAP

 .REPEAT 1 - NEWMAP [
	ALU[0] DEST[DEV-ADR] SHORT $ ;NOW TURN MAP ON.
	D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[10] CYLEN[IOB-OUT] $
	D[AR] DEST[STO-MAP] NORM $; LOAD MAP
  ] ; 1-NEWMAP

	ALU[0] DEST[IOD] SPEC[IOB-OUT] C800 $ ;MAP OFF
	MAPF[10] CYLEN[IOB-OUT] COND[-USER] JUMP[. + 2] $

	D[CONST 17] ROT[11] DEST[MAP-EXEC-SR] NORM $
	ALU[Q] DEST[MA STRT-WRT] NORM $; STORE CST
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[16] DEST[AR] NORM $
	ALU[0] DEST[DEV-ADR] NORM $
	D[17] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN MAP BACK ON, ETC.
	D[AR] ROT[15] MASK[1] COND[-OBUS=0] JUMP[JSMFR] MAPF[10] CYLEN[MAX,IOB-OUT,C550] $; DO SPECIAL JSYS STUFF IF APPROPRIATE
	D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MAIN]  C550 $; DONE IF NO WRT
	D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MAIN] C550 $; DONE IF READ
	D[AR] MASK[18.] DEST[MA] SHORT $;GET ORRIG. MA
	D[CONST 1] DEST[DEV-ADR] SHORT $
	D[17] DEST[MEMSTO] JUMP[MSMAIN1] NORM $; STORE THE STORE DATA, & PROCEDE
JSMFR:	D[AR] MASK[18.] DEST[MA] NORM $
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[17] DEST[AR] JUMP[MUJSM1] NORM $; RESOTRE STORE DATA

MFTR1:	D[MEM] ROT[11] MASK[1] COND[-OBUS=0] JUMP[MFTR9] C550 $; J IF TRAP TO USER
	D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFTR10] C550 $;J IF WRT TRAP
	D[MEM] JUMP[MFTR2] NORM $; TREAT BOTH "TRAP-TO-MON" CODES AS IMMEDIATE
MFTR10:	D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFB3] C550 $; WRT RQ? J IF NO
	D[CONST 44] ROT[36] DEST[Q] SHORT $; GET ERROR CODE BITS -- WRT TRAP
MFB5:
MFB4:	D[AR] ALU[DORQ] DEST[AR Q] COND[USER] JUMP[. + 2] NORM $; OR ERROR BITS IN, J IF USER MODE
	D[CONST 1] ROT[18.] ALU[DORQ] DEST[AR] NORM $; TURN ON EXEC BIT
	D[CONST 5] ROT[6] DEST[Q] SHORT $
	D[CONST 71] ALU[DORQ] DEST[Q] SHORT $; FORM 571
	D[14] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; ADD PSB (MON BASE TAB)
	D[AR] DEST[MEMSTO] CYLEN[FIXM] $; STORE ERROR BITS THERE
	D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFC1] C550 $; J IF NO WRT RQ
	D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MFC1] C550 $; J IF RD RQ
	D[MA] ALU[D+1] DEST[MA] SHORT $; GO TO 572
	D[17] DEST[MEMSTO] NORM $; SAVE STORE DATA
MFC1:	ALU[0] DEST[DEV-ADR] CYLEN[MEMSTO] $
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN OFF MAP
	MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $
	D[CONST 70] DEST[MA] SHORT $; FETCH TRAP INSTR
	ALU[0] DEST[DEV-ADR] CYLEN[FIXM] $
	D[17] DEST[IOD] SPEC[IOB-OUT] SHORT $; TURN ON MAP
	D[PC] DEST[Q AR] MAPF[10] CYLEN[IOB-OUT] $
	D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $;CLR USER
	D[CONST 55] ROT[2] DEST[Q] JUMP[MUUO44] NORM $
MFTR2:	D[CONST 41] ROT[36] DEST[Q] JUMP[MFB5] NORM $; ASCCESS PERMISSION TRAP
MTRPAL:
MFTR3:	D[CONST 40] ROT[36] DEST[Q] SHORT $
	D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB5] NORM $; ILLEGAL PT ENTRY TYPE, ADDRESS LIMIT
MFTR4:	;ALL THESE ARE NOT-IN-CORE
MFTR5:	D[CONST 22] ROT[36] DEST[Q] JUMP[MFB5] NORM $; NOT-IN-CORE
MFTR6:	D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[. + 3] C550 $; J IF NO R OR X ERROR
	D[CONST 4] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN "R OR X ERROR" BIT
	D[CONST 2] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C550 $; J IF NO W ERROR
	D[CONST 2] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN W ERROR BIT
	D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
	D[CONST 40] ROT[36] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; GROUP 2
MFTR7:	D[CONST 10] ROT[36] DEST[Q] JUMP[MFB4] NORM $; AGE ERR -- GROUP 0
MFTR9:	D[CONST 42] ROT[36] DEST[Q] JUMP[MFB4] NORM $; USER TRAP
MFTR41:	D[CONST 20] ROT[36] DEST[Q] NORM $; GROUP 1
	D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; TOO MANY INDR. PNTRS

JSYS1:	FIXM1 $
	D[PC] DEST[AR] NORM $	;SAVE PC & FLAGS
	D[MEM] MASK[18.] DEST[PC] NORM $; JUMP TO RIGHT HALF
	D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $
	D[AR] DEST[MEMSTO] MEMSTMA $
JSYS2:	C550 D[CONST 1] ROT[36] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] $; J IF EXEC MODE
	ALU[0] DEST[MAP-EXEC-SR] JUMP[. + 2] NORM $; TEMP TURN OFF USER
	D[CONST 1] ROT[34] ALU[DORQ] DEST[CRYOV] SHORT $; TURN ON FLAG BIT 7
	D[CONST 10] ROT[6] DEST[Q] SHORT $
	D[MA] ALU[DORQ] DEST[MA] SHORT $; FETCH POINTER WORD
	FIXM1  $
	D[MEM] MASK[18.] DEST[PC] NORM $; J TO RIGHT HALF
	D[PC] DEST[Q] SHORT $
	D[CONST 1] ROT[36] ALU[-D&Q] DEST[CRYOV] SHORT $; TURN OFF USER
	D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $; LEFT HALF
	D[AR] DEST[MEMSTO] MEMSTMA $; STORE PC

SET-TEMP-USER = D[CONST 17] ROT[11] DEST[MAP-EXEC-SR] NORM $
SET-TEMP-EXEC = D[CONST 0] ROT[11] DEST[MAP-EXEC-SR] NORM $
  .DEFINE JCFM [JAD]
[	D[PC] ROT[10] MASK[1] COND[-OBUS=0] JUMP[JAD] C550 $;J IF CALL FM MON]

UMOVX:	COND[USER] JUMP[MUUO] NORM $
	D[MEM] DEST[Q] NORM $
	D[CONST 1] ROT[41] ALU[D+Q] DEST[HOLD] NORM $
	D[CONST 5] DEST[Q] JUMP[XCTUMV] NORM $

XCT1:	D[PC] ALU[D-1] DEST[PC] NORM $
	COND[USER] JUMP[XCT2] NORM $
	D[IR] ROT[15] MASK[4] DEST[Q] SHORT $; SAVE XCT AC FLD
XCTUMV:	D[MEM] DEST[AR IR-ALL MA] COND[-MEM-IDX-IND] JUMP[XCT3] NORM $
XCT5:	D[IR] ROT[18.] MASK[4] COND[OBUS=0] JUMP[XCT4] C550 MAPF[2] $; J IF NO IDX FLD
	D[IR] MASK[18.] ALU[IX+D] DEST[MA IR-ADR AR] $; DO INDEX
XCT4:	D[IR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XCT3] C550 MAPF[2] $; J IF NO INDR
	D[CONST 10] ALU[D&Q] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF ADDR CALC USER
XCT6:	FIXM1 $
	SET-TEMP-EXEC $
	D[MEM] DEST[AR IR-23 MA] COND[MEM-IDX-IND] JUMP[XCT5] NORM $
XCT3:	ALU[Q] DEST[IR-ADR] SHORT  MAPF[2] $; SAVE XCT AC FLD
	D[IR] ROT[7] MASK[7] DEST[Q] SHORT $; GET HO 7 BITS OF OPCODE
	D[CONST 54] ALU[D#Q] COND[OBUS=0] JUMP[XCTSTK] C550 $; J IF STACK GROUP
	D[CONST 27] ALU[D#Q] COND[OBUS=0] JUMP[XCTBYT] C550 $; J IF BYTE GROUP
	D[CONST 52] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLG] C550 $; J IF GROUP WITH BLT IN IT
XCT13:	D[IR] MASK[4] DEST[Q] SHORT $; GET XCT AC FLD
XCT18:	D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[XDISP] C550 $; J IF NEITHER RELEVANT BIT
	COND[MA-AC] JUMP[XCT10] NORM $; J IF EF ADR IS AC
	JCFM[XDISP] ;J IF CALL FM MON
	D[CONST 1] ALU[D&Q] COND[OBUS=0] JUMP[XCT11] C550 $;J IF BIT OFF
	D[CONST 4] ALU[D&Q] COND[OBUS=0] JUMP[XCT12] C550 $; J IF OTHER BIT OFF
	D[CONST 03] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET SRC & DEST TO USER
XCT12:	D[CONST 02] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET DEST TO USER
XCT11:	D[CONST 01] ROT[11] DEST[MAP-EXEC-SR] NORM $; SET SRC TO USER
XDISP:	D[MA] DEST[MA IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
XCT2:	D[MEM] DEST[IR-ALL AR MA] DISP[2174] SPEC[PC+1-IF] CYLEN[DISP] $
XCTAC:	ACSEL[AC] ALU[AC] DEST[HOLD]  SHORT $; SAVE AC
	ACSEL[AC] DEST[CLR-DEV-FROM-INTR AC] D[MA] SHORT $; GET AC ADDRS
	D[CONST 1] DEST[DEV-ADR] SHORT $
	ACSEL[AC] D[13] ALU[D+AC] DEST[AC] SHORT $; ADD IN AC BASE REG.
	ACSEL[AC] D[CONST 75] ROT[11] ALU[D+AC] DEST[AC] SHORT $
	ACSEL[AC] D[CONST 7] ROT[17] ALU[D+AC] DEST[AC] NORM $
	D[MEM] ACSEL[AC] DEST[O_AC MA] POPJ NORM $
XCTSTK:	COND[-MA-AC] JUMP[XCT13] NORM $; J IF EF ADR NOT AC (TREAT NORMALLY)
	D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LOW ORDER BITS OF OP CODE, J IF PUSHJ
	D[CONST 3] ALU[D#Q] COND[OBUS=0] JUMP[XCT13] C550 $; J IF POPJ
	D[CONST 2] ALU[D#Q] COND[OBUS=0] JUMP[XCTS1] C550 $; J IF POP
	D[CONST 4] DEST[Q] JUMP[XCTS2] NORM $
XCTS1:	D[CONST 1] DEST[Q] SHORT $
XCTS2:	D[IR] ALU[D&Q] COND[OBUS=0] JUMP[XCT13] C550 $; J IF AC REF NOT USER
	D[IR] ALU[D-Q] DEST[IR-ADR] PUSHJ[XCTAC] NORM $; FIX EF ADR.
	MAPF[2] JUMP[XCT13] NORM $
XCT10:	PUSHJ[XCTAC] NORM $; FIX EF ADR
	MAPF[2] D[MA] MASK[4] DEST[IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
XCTBLG:	D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LO BITS OF OPCODE, J IF EXCH
	D[CONST 1] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLT] C550 $; J IF BLT
	D[IR] MASK[4] DEST[Q] JUMP[XCT18] NORM $; GET XCT AC FLD, PROCEDE

XCTBYT:	D[IR] ROT[42] MASK[1] SPEC[PC+1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF B.P. FETCH IS NOT EXEC
XBY1:	D[IR] ROT[11] MASK[1] COND[OBUS=0] JUMP[XBY3] C550 MAPF[2] $;J IF BP WILL BE INCR
	FIXM1 $
	D[MEM] DEST[AR Q] NORM $; GET BP
XBY4:	SET-TEMP-EXEC $
	D[AR] MASK[18.] DEST[MA] COND[-MEM-IDX-IND] JUMP[XBY13] NORM $; J IF BP HAS NO IDX OR INDR
XBY15:	D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[XBY14] C550 MAPF[2] $; J IF NO IX FLD
	D[MASK 22] ROT[18.] ALU[D&Q] DEST[Q] NORM $
	D[AR] MASK[18.] ACSEL[REG] ALU[D+AC] DEST[AR] SHORT $
	D[AR] MASK[18.] ALU[DORQ] DEST[Q AR MA] SHORT $
XBY14:	D[AR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XBY13] C550 MAPF[2] $; J IF NO INDR
	D[IR] ROT[43] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF BP ADR CALC IS USER
	FIXM1 $
	SET-TEMP-EXEC $
	D[AR] ROT[14] MASK[14] DEST[AR] SHORT $
	D[AR] ROT[30] DEST[Q] SHORT $
	D[MEM] MASK[27] ALU[DORQ] DEST[Q AR MA] COND[MEM-IDX-IND] JUMP[XBY15] NORM $
XBY13:	D[IR] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] MAPF[2] $; MAKE MA OK
	D[IR] ROT[10] MASK[1] COND[OBUS=0] JUMP[LDB5] C550 MAPF[2] $; DISTINGUISH LOADS FROM DEPOSITS, J IF LOAD
	JUMP[DPB5] NORM $

XBY3:	FIXM2 $
	D[MEM] DEST[AR Q] COND[HALF] JUMP[XBY4] NORM $;GET BP, J IF NO INCR
	D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $; GET S FLD, HANDLE OVERFLOW
	D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $; SUB S FROM P
	ACSEL[MA] D[MEM] DEST[AC] NORM $
	PUSHJ[SETHLF] NORM $; SET HALF
	JUMP[XBY4] NORM $; (IN CASE OF MAP FAULTS)
XFIXMA:	COND[MA-AC] JUMP[XCTAC] NORM $; J IF ADDRS IS AC
	D[PC] ROT[10] MASK[1] COND[-OBUS=0] POPJ C550 MAPF[2] $; LEAVE IF CALL FM MON
	SET-TEMP-USER $
	D[MA] DEST[MA] POPJ NORM $

XCTBLT:	D[MA] SPEC[PC+1] DEST[O_AC AR] NORM $; END ADR IN AC, AC IN AR
XBLTL:	D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $; GET WORD
	D[IR] ROT[42] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; FIX IF USER ADDRS
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BLT-RDA] CYLEN[FIXM] $
	D[MEM] DEST[Q] SHORT $; GET DATA WORD
	D[AR] MASK[18.] DEST[MA] SHORT $; GET DEST ADR
	D[IR] MASK[1] DEST[MAP-EXEC-SR] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $;FIX MA ADDRS
	ALU[Q] DEST[MEMSTO] SHORT $
	D[AR] MASK[18.] ALU[D-AC] MAPF[BLT-WRTB] COND[-OBUS<0] JUMP[BLTA12] C600 $
	D[CONST 1,,1] DEST[Q MAP-EXEC-SR] COND[-MA-AC] JUMP[. + 2] NORM $
	D[MEM] ACSEL[MA] DEST[AC] SHORT $
	D[AR] ALU[D+Q] DEST[AR] JUMP[XBLTL] NORM $; TEST FOR INTERPT HERE ? *****

: 5300 ;APR & PI IOT DISP TABLE
	ILGIOT $; BLKI APR
	NOP $
	ALU[0] DEST[DEV-ADR] NORM $; DATAI -- RD SW
	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] JUMP[APRDI] NORM $
	ILGIOT $ ;BLKO APR
	NOP $
	JUMP[MAIN] $; DATAO
	NOP $
	D[IR] MASK[13] DEST[Q] NORM $; GET CONO BITS
	D[CONST 33] ROT[5] ALU[-D&Q] DEST[Q] JUMP[APRCO] NORM $
	PUSHJ[APRCI] NORM $; CONI -- GET BITS IN AR & Q
	D[AR] MASK[18.] DEST[MEMSTO] MEMST $
	PUSHJ[APRCI] NORM $; CONSZ -- GET BITS IN AR & Q
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
	PUSHJ[APRCI] NORM $; CONSO -- GET BITS IN AR & Q
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
	.REPEAT 3[ ILGIOT $
	NOP $
]
	;DATAO PI -- Set lights
	D[CONST 0] DEST[DEV-ADR] PUSHJ[EXMSW1] NORM $	;Just like examine...?
	JUMP[MAIN] SHORT $
	JUMP[PICONO] NORM $; PI CONO
	NOP $
	PUSHJ[PICONISUB] NORM $; CONI -- GET BITS IN AR & Q
	D[AR] DEST[MEMSTO] MEMST $
	PUSHJ[PICONISUB] NORM $; CONSZ -- GET BITS IN AR & Q
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
	PUSHJ[PICONISUB] NORM $; CONSO -- GET BITS IN AR & Q
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $

: END-OF-PI-CODE

APRCO:	D[CONST 1] ROT[3] ALU[-D&Q] DEST[AR] SHORT $
	D[IR] ROT[43] MASK[21] ALU[NOTD] DEST[Q] SHORT $; GET CLR BITS
	D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
	D[12] SPEC[A-MEM-APR] ALU[D&Q] DEST[Q CLR-DEV-FROM-INTR] SHORT $; CLEAR INDICATED BITS
	D[AR] ALU[DORQ] SPEC[A-MEM-APR&DEST-A-MEM] DEST[2 AR] NORM $; SET INDICATED BITS & CHAN
	D[IR] ROT[41] MASK[1] COND[OBUS=0] JUMP[. + 2] C550 $; J IF NO CLR OVERFLOW BIT
	D[PC] MASK[43] DEST[CRYOV] SHORT $; CLR OV
	D[IR] ROT[36] MASK[1] COND[OBUS=0] JUMP[. + 3] C550 $; J IF NO CLR FLT OV
	D[MASK 43] ROT[41] DEST[Q] SHORT $
	D[PC] ALU[D&Q] DEST[CRYOV] SHORT $; CLR FLT OV
	D[IR] ROT[33] MASK[1] COND[-OBUS=0] PUSHJ[CLKCLR] C550 $; CLR CLOCK FLAG IF INDICATED
APRCHK:	PUSHJ[APRCI] NORM $; GET CONI BITS IN AR & Q
	D[AR] MASK[3] COND[OBUS=0] JUMP[MAIN] NORM $; DONE IF PI=0
	D[AR] ROT[20] MASK[1] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF PDLOV INT
	D[AR] ROT[43] ALU[D&Q] DEST[Q] SHORT $; AND MASK WITH FLAG
	D[CONST 11] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF OV INT
	D[CONST 10] ROT[6] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF NO CLOCK INT

APDINT:	D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; GET CHAN #, CAUSE INTERRUPT

; TEMP **** APRCI:	PUSHJ[APRCII] DEST[CLR-DEV-FROM-INTR] NORM $; GET BITS
	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
	D[IOD] MAPF[4] MASK[3] DEST[Q] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
	D[AR] MASK[3] COND[OBUS=0] JUMP[APRC1] C550 $; J IF NO PI
	D[AR] ROT[40] MASK[1] COND[OBUS=0] JUMP[APRC1] C550 $; J IF NO OV INT ENBL
	D[CONST 2] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] JUMP[APRC2] NORM $; ENABLE OV INT
APRC1:	D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
APRC2:	MAPF[10] CYLEN[IOB-OUT] D[AR] DEST[Q] POPJ $

APRCI:	;TEMP -- LATER WE FIX OV
APRCII:	PUSHJ[CLKRDFLG] NORM $
	 ;GET CLOCK FLAG IN AR 35, REST OF AR = 0
	.DEFINE APRGBT [R1 R2]
[	D[PC] ROT[R1] MASK[1] DEST[Q] SHORT $
	D[AR] ROT[R2] ALU[DORQ] DEST[AR] SHORT $
]
	APRGBT[1 6]
	APRGBT[4 41]
	APRGBT[7 33]
	D[AR] ROT[17] DEST[Q] SHORT $; SET FLAGS
	D[12] SPEC[A-MEM-APR] ALU[DORQ] DEST[Q AR] POPJ NORM $
APRDI:	MAPF[2] D[IOD] DEST[MEMSTO] COND[-MA-AC] LBJUMP[MSMAIN] CYLEN[IOB-IN] $

APIOT:	IOTDIS[53]

PDLO1:	PUSHJ[PDLO] NORM $ ;SET PDLO BIT
	D[PC] DEST[AR MEMSTO] NORM $
	MAPF[MASTO] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] COND[-MA-AC] LBJUMP[PDLMEM] NORM $
PDLO2:	PUSHJ[PDLO] NORM $; SET FLAG
PDLO5:	D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PDLMEM] NORM $
PDLO3:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
	D[MEM] DEST[AR] PUSHJ[PDLO] NORM $
	D[IR] MASK[18.] DEST[MA] JUMP[PDLO5] NORM $
PDLO4:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
	PUSHJ[PDLO] NORM $
	D[MEM] MASK[18.] DEST[PC] JUMP[PDLOE] NORM $
PDLO:
: 2616 ;.PAIR
PDLMEM:	ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] MAPF[MASTO] $
PDLOE:	MAPF[MASTO] D[12] MASK[3] DEST[AR] SPEC[A-MEM-APR]
	JUMP[PIGEN] NORM $; CHAN # IN AR, TRY INTERRUPT

: PDLO
	D[12] SPEC[A-MEM-APR] DEST[Q] NORM $; APR CONI WORD
	D[CONST 1] ROT[20] ALU[DORQ] SPEC[A-MEM-APR&DEST-A-MEM] DEST[2] NORM POPJ $;SET PDLOV BIT

.REPEAT F3SW [

SOED:	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
	D[IOD] MAPF[2] DEST[Q HOLD] CYLEN[IOB-IN] $
	D[CONST 1] ROT[25] ALU[D&Q] COND[OBUS=0] JUMP[DOHALT] C600 $
	D[PC] COND[-OBUS<0] SPEC[IOB-IN] JUMP[. + 3] C550 $; J IF NO OV
	D[IOD] MAPF[4] DEST[Q CLR-DEV-FROM-INTR] CYLEN[IOB-IN] $
	D[CONST 2] ALU[D&Q] COND[-OBUS=0] JUMP[SOEDOV] C550 $ ;J IF OV INT EN

	D[13] SPEC[A-MEM-APR] MASK[4] DEST[Q] NORM $
	D[MASK 8.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
	  NORM SPEC[IOB-IN] $  ;;7760 IS NEW LOC. OF ERROR LOG.
  	MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
	D[CONST 1] ROT[7] ALU[D&Q] COND[-OBUS=0] JUMP[.] C550 $

	ALU[0] DEST[MUCODE-HI] CYLEN[MUSTO] $
	D[MEM] DEST[Q] NORM $
	D[MASK 42] ROT[25] ALU[D&Q] DEST[MUCODE-LO] CYLEN[MUSTO] $
	D[AR] ALU[D+1] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	SPEC[IOB-IN] D[CONST 1] DEST[DEV-ADR] NORM $
	 ;NOW READ STATE OF MAP ON, OV ENBL, ETC.
	D[IOD] DEST[IR-ADR]  MAPF[4] CYLEN[IOB-IN] $
	 ;PRESERVE IN IR.
	ALU[0] DEST[DEV-ADR] SHORT $
;;;  	D[IR] ROT[31.] COND[OBUS<0] PUSHJ[ECC-UNC] C550 $
	 ;IF ERROR WAS UNCORRECTABLE, GO SEE ABOUT INTERRUPTING.
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;PUT JUNK IN LIGHTS
	MAPF[2] D[MEM] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ;LTS_OBUS
	MAPF[10] DEST[CLR-MI-ERR] CYLEN[IOB-OUT] $; TURN OFF MAP
	D[MEM] DEST[MA HI-ABS-MA] NORM $; GET DATA
	CYLEN[C500] $;WAIT
	D[MEM] DEST[MEMSTO] NORM $; RE-STORE IT
	NORM $; WAIT -- FOR LUCK
	D[IR] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE STATE OF MAP, ETC.
	 MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $;
	DEST[CLR-MI-ERR] JUMP[MAIN] $  ;CLEAR THE ERROR FLIPFLOP

  ]  ;; END OF .REPEAT F3SW

ECC-UNC:  ;SEE IF WE SHOULD GIVE INTERRUPT FOR HARD ECC ERR
	  ;RETURN TO CALLER IF NOT, BUT STILL SET PAR ERR FLAG.
	D[14] DEST[Q] NORM $
	 ;FIRST, SET PAR ERR FLAG IN PI CONI BITS.
	D[CONST 1] ROT[35. - 19.] ALU[DORQ] 
		DEST[AR 4] DEST-A-MEM NORM $
	D[AR] ROT[35. - 20.] C550 COND[-OBUS<0] POPJ $
	 ;IF PAR ERR INTRPT ENABLE OFF, DO NO MORE.
	D[12] MASK[3] DEST[Q AR] C550 COND[OBUS=0] POPJ $
	 ;IF APR PI CHAN IS 0, DON'T GIVE INTRPT.
	DEST[CLR-MI-ERR] NORM JPOP[PIGEN] $ 
	 ;CLEAR ERR FF AND GIVE INTERRUPT ON APR CHANNEL.


 .REPEAT F2SW [ 

STOPS:	D[CONST 1] DEST[DEV-ADR] JUMP[DOHALT] NORM $

SOVRS:	D[PC] COND[-OBUS<0] SPEC[IOB-IN] JUMP[. + 3] C550 $; J IF NO OV
	D[IOD] MAPF[4] DEST[Q CLR-DEV-FROM-INTR] CYLEN[IOB-IN] $
	D[CONST 2] ALU[D&Q] COND[-OBUS=0] JUMP[SOEDOV] C550 $ ;J IF OV INT EN
	JUMP[.] $ ; HOW COULD WE GET HERE?

SECCS:	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
	D[IOD] MAPF[2] DEST[Q HOLD] CYLEN[IOB-IN] $
	D[13] SPEC[A-MEM-APR] MASK[4] DEST[Q] NORM $
	D[MASK 8.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
	  NORM SPEC[IOB-IN] $  ;;7760 IS NEW LOC. OF ERROR LOG.
  	MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
 ;;;;;	D[CONST 1] ROT[7] ALU[D&Q] COND[-OBUS=0] JUMP[.] C550 $

	ALU[0] DEST[MUCODE-HI] CYLEN[MUSTO] $
	D[MEM] DEST[Q] NORM $
	D[MASK 42] ROT[25] ALU[D&Q] DEST[MUCODE-LO] CYLEN[MUSTO] $
	D[AR] ALU[D+1] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	D[CONST 1] DEST[DEV-ADR] NORM $
	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
	D[IOD] DEST[IR-ADR]  MAPF[4] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
;NOTE:	This conflicts with the use of the lights by diagnostics.
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;PUT JUNK IN LIGHTS
	MAPF[2] ALU[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ;LTS_OBUS
	MAPF[10] DEST[CLR-MI-ERR] CYLEN[IOB-OUT] $; TURN OFF MAP
	D[MEM] DEST[MA HI-ABS-MA] NORM $; GET DATA
	CYLEN[C500] $;WAIT
	D[MEM] DEST[MEMSTO] NORM $; RE-STORE IT
	NORM $; WAIT -- FOR LUCK
	D[IR] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE STATE OF MAP, ETC.
	 MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $;
	DEST[CLR-MI-ERR] JUMP[MAIN] NORM $

  ] ;; END OF .REPEAT F2SW

SOEDOV:	ALU[0] DEST[DEV-ADR] NORM $
	D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
	MAPF[10] CYLEN[IOB-OUT] PUSHJ[APRCII] $; GET CONI BITS
	D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; DO INTR.

;; 60 HZ CLOCK READING AND INTERRUPT ROUTINES


: 2134	;ABS. LOC. ASSIGNED FOR 60 HZ CLK INTS.

CLKINT:	PUSHJ[CLRDEVINT] NORM $ ;ENABLE ADDRESSING OF OTHER DEVS
	D[CONST 1] ALU[NOTD] DEST[Q] PUSHJ[DEV6CL] NORM $
	  ;CLEAR HARDWARE INT. ENB. FOR 60HZ CLK.

.REPEAT TYMNET [
	PUSHJ[TYMCLK] NORM $	;START UP TYMNET INTERFACE IF NEEDED.
];TYMNET
	JUMP[APRCHK] NORM $ ;CAUSE INT. IF ENABLED.

: 6210
CLKRDFLG:  ;PUT HARDWARE 60HZ CLK FLAG INTO AR35
	D[CONST 6] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
	  ;SELECT DEVICE 6.
	D[IOD] ROT[43] MASK[1] DEST[AR] 
	  CYLEN[IOB-IN] POPJ $
		  ;GET BIT AND RETURN.

.REPEAT 0 [  ;SOME STUFF FOR OVERLAPPED (INTERRUPT-DRIVEN)
		; TAPE XFERS.

TRINT:		;HERE ON DEV 7 INTRPT. DURING TAPE READ
		;WE WILL READ 6 WORDS FROM THE CONTROLLER'S FIFO.
	START-OUT D[CONST 1] ROT[35. - 4] DEST[IOD] NORM $
	   ;CLEAR "TP BT CNT OVERFLOW" (WHICH CAUSED INTRPT.)
	MAPF[1] D[PC] DEST[IR-ADR] C500 $
	   ;PRESERVE THE PC, SO THAT WE CAN USE IT.
	D[16] DEST[Q HI-ABS-MA] NORM $
	   ;GET CURRENT IOWD & SET EXTENDED PART OF MA.
	D[CONST 6] ROT[23.] ALU[Q-D-1] DEST[Q AR PC]
	 C550 COND[OBUS<0] JUMP[TR1] $
	   ;DECREMENT THE COUNT BY 6; BRANCH IF IT UNDERFLOWS.
	   ;AR PRESERVES RESULT OF THIS CALCULATION FOR LATER.
	   ;ALSO DECREMENT THE ADDRESS BY 1 AND PLACE IN PC.
	D[CONST 7] ALU[Q+D] DEST[6] DEST-A-MEM NORM $
	   ;MAKE ADDR. 6 MORE THAN IT WAS AND REPLACE IOWD.
	START-IN D[CONST 5] NORM LLOAD $
	   ;PREPARE TO DO READ LOOP 6 TIMES.

		;HERE IS THE LOOP TO READ ONE WORD (5 BYTES).
		;EACH BYTE COMES IN COMPLEMENTED IN 28-35, WITH
		;REST OF WORD =0 UNLESS SOMETHING IS WRONG (SUCH
		;AS NO MORE BYTES), IN WHICH CASE BIT 0 IS ON AND
		;BITS 1-3 TELL WHAT IS WRONG.  TO FACILITATE THE
		;LATER INTERPRETATION OF THESE BITS, THE FIRST
		;4 PARTIALLY ASSEMBLED STAGES OF THE DATA
		;WORD ARE SAVED IN A-MEM 1-4.
TRL:	MAPF[10] START-IN D[IOD] ROT[28.] ALU[NOTD] 
	   DEST[Q 1] DEST-A-MEM C600 $ 
	MAPF[10] START-IN D[IOD] ROT[20.] ALU[D#Q] 
	   DEST[Q 2] DEST-A-MEM C600 $ 
	MAPF[10] START-IN D[IOD] ROT[12.] ALU[D#Q] 
	   DEST[Q 3] DEST-A-MEM C600 $ 
	MAPF[10] START-IN D[IOD] ROT[4.] ALU[D#Q] 
	   DEST[Q 4] DEST-A-MEM C600 $ 
	MAPF[10] D[IOD] DEST[HOLD] C600 $
	   ;GET LAST BYTE OF WORD.
	PC+1 D[MEM] C550 COND[OBUS<0] JUMP[TRERR] $
	   ;INC. THE PC AND TEST "TP RD FLAG" (DISK CAN USE MEM HERE)
	START-IN D[MEM] MASK[4] ALU[D#Q] DEST[MEMSTO MA] MA_PC
	  C500 LOOP[TRL] $
	   ;ASSEMBLE LAST BYTE, STORE WORD IN MEM, AND LOOP.

TR3:	D[AR] ROT[1] MASK[1] DEST[HI-ABS-MA]  ;CLEAR HI-ABS-MA
	  C550 COND[-OBUS=0] PUSHJ[TR2] $
	   ;JUMP IF AR<0 (IOWD COUNT RAN OUT)
	D[IR] DEST[PC] NORM JUMP[MAIN] $   ;RESTORE CONTENTS OF PC
	   ;EMD OF INTRPT. ("MAIN" DOES THE CLR-DEV-FROM-INTR)

TR1:	D[16] ROT[13.] LLOAD NORM JUMP[TRL] $
	   ;READ FULL # OF WORDS IN COUNT FIELD OF IOWD.

TR2:	D[15] MASK[18.] DEST[MA HI-ABS-MA Q] NORM $
	   ;FETCH THE NEXT IOWD FROM MEM.
	FIXM0 $ ;ALLOW IT TO BE IN AN AC.
	ALU[Q+1] DEST[5] DEST-A-MEM NORM $
	   ;INCREMENT POINTER TO NEXT IOWD.
	D[MEM] DEST[Q HI-ABS-MA] SHORT $
	   ;PLACE EXTENDED ADDR. FROM NEW IOWD INTO MA.
	D[CONST 1] ROT[23.] ALU[Q-D] DEST[6] DEST-A-MEM
	  C550 COND[OBUS<0] JPOP[TR2X] $
	   ;ADJUST COUNT BY ONE (SO ENDING CONDITION IS RIGHT),
	   ;AND BRANCH IF COUNT WAS 0 (EMD OF IOWD LIST).
	D[AR] ROT[13.] ALU[NOTD] DEST[HOLD] LLOAD NORM $
	   ;GET # OF WORDS REMAINING TO BE READ DURING THIS INTRPT.
	D[MEM] MASK[13.] DEST[HOLD] NORM LOOP[TR2A] $
	   ;REMOVE JUNK BITS; BRANCH IF # REMAINING IS >0.
	   ;IF SO, LOOP COUNTER NOW HAS #-1, AS NEEDED FOR TRL.
	ALU[0] DEST[HI-ABS-MA] NORM POPJ $
	   ;NO REMAINING WORDS FOR THIS INTRPT.
TR2A:	D[MEM] ROT[23.] ALU[Q-D-1] DEST[Q AR PC]
	 C550 COND[OBUS<0] JPOP[TR1] $
	   ;DECREMENT THE COUNT BY #; BRANCH IF IT UNDERFLOWS.
	   ;AR PRESERVES RESULT OF THIS CALCULATION FOR LATER.
	   ;ALSO DECREMENT THE ADDRESS BY 1 AND PLACE IN PC.
	D[MEM] ALU[Q+D+1] DEST[6] DEST-A-MEM NORM JPOP[TRL] $
	   ;MAKE ADDR. # MORE THAN IT WAS AND REPLACE IOWD.
	   ;GO READ SOME MORE WORDS.

;; ### HERE TO SET UP FIRST IOWD.

	D[MASK 18.] ALU[D&AC] DEST[Q] NORM $
	   ;GET PTR. TO IOWD LLIST (FROM RT HALF OF AC).
	D[15] LEFT ALU[DORQ] DEST[Q] NORM $
	   ;STORE IN RT HALF OF A-MEM 15.
	ALU[Q] DEST[5] DEST-A-MEM NORM $
	ALU[-1] DEST[AR] NORM PUSHJ[TR2] $
	   ;FETCH 1ST IOWD (THE -1 IS AN ARGUMENT TO TR2)

;;; ### RETURNS HERE READY TO TAKE FIRST INTRPT.

 ] ;REPEAT 0
 .REPEAT KNYTAPE [ .DEFINE FOOLIST[] [ LIST ] ]
FOOLIST

.REPEAT KNYTAPE [ ;KENNEDY TAPE CONTROL UCODE

;TAPE READING AND WRITING CODE
; A-MEM USEAGE:
;		0	DISPATCH ADDR.
;		1	RETRY COUNT (WRITE)
;		4	CURRENT CONTENTS OF MODE CTRL REG
;		5	SAVED COPY OF WORD COUNT (WRITE)
;		6	MASK FOR TESTING ERROR STATUS (WRITE)

KNYRST:  ;RESET the formatter and drive.
	START-OUT ALU[0]  DEST[IOD] $
	 ;TURN OFF "FORMATTER ENABLE"
	MAPF[2] LONG POPJ $

   ;727 - OBSOLETE VERSION OF READ
TAPERD:	NORM PUSHJ[KNYRGO] $
	D[MASK 17.] DEST[IR-ADR] PUSHJ[TRP2] NORM $
		;MOVE STATUS INTO AC.
	ALU[Q] DEST[AC] ACSEL[AC] MAPF[2] JUMP[MAIN] C-OUT $

; KNYRGO -- CALLED START TAPE MOTION.   WAITS FOR FIRST BYTE.
KNYRGO:	D[CONST 22] ROT[27.] DEST[Q] NORM $
		;Construct mode information for KENNEDY formatter
	D[12] ALU[DORQ] DEST[Q] NORM $
	   	;INCLUDE STANDARD BITS (FOR TIMERS AND STUFF).
	START-OUT D[CONST 2] ROT[6] ALU[DORQ] DEST[IOD] NORM $
		;Set mode for tape controller to talk to KENNEDY
		;22000,,200 means:
		; SEL RD DAT, CTRL KNY, IN
	MAPF[4] D[CONST 0] DEST[Q]   C-OUT PUSHJ[KNYGOA] $
	 ;SEND COMMAND TO FORMATTER.
;	\ /
KNYWAIT:	START-IN SHORT $
	; command register by caller
	MAPF[1] D[CONST 77] ROT[12.] DEST[AR] NORM $
		;Clear read data ready flag
KNYW1:	START-IN D[AR] ALU[D-1] DEST[AR] 
		C550 COND[OBUS=0] JUMP[KNYW2] $
	MAPF[2] D[IOD] DEST[HOLD] C800 $
	D[MEM] ROT[27.] MASK[1] COND[-OBUS=0] POPJ C550 $
	NORM JUMP[KNYW1] $
KNYW2:	NORM POPJ $

KNYGOA:	START-IN D[CONST 1] ROT[35. - 26.] ALU[DORQ] DEST[Q]
	 PUSHJ[FMNBWT] $
	  ;Add the FMTR ENBL bit to the command word.
	  ;WAIT FOR FORMATTER NOT BUSY.
	START-OUT D[CONST 41] ROT[35. - 8.] DEST[IOD] NORM $
		;RESET THE CONTROLLER ERROR CONDITIONS.
	MAPF[1] START-OUT D[11] DEST[IOD] C800 $
	  ;Clear the pulse-catching tape status flags (FMK, etc.)
	   ; A-MEM[1] IS SET UP BY TAPE RESET CODE (TAPRST)
	MAPF[1] START-OUT 
	 D[CONST 1] ROT[35. - 33.] ALU[D#Q] DEST[IOD] C-OUT $
	  ;Set the GO bit to fmtr (on RWD, CLEAR the bit !)
	MAPF[2] START-OUT ALU[Q] DEST[IOD] C800 $
	  ;Send command word again, without GO bit.
	MAPF[2] LONG POPJ $

FMNBWT:	  ;Wait for formatter to be not busy.
	MAPF[4] D[IOD] DEST[HOLD] C800 $ ;GET STATUS BITS.
	C550 $
	C550 $
	START-IN D[MEM] ROT[7] C550 COND[-OBUS<0] JUMP[FMNBWT] $
	  ;CHECK FOR 'DATA BUSY'
	NORM POPJ $

;READ A RECORD.  STORE UP TO C(IR-ADR) WORDS.

TRP2:	START-IN NORM PUSHJ[TRBY3] $ ;READ FIRST BYTE.
	NORM JUMP[TRP2B] $
TRP2A:	PUSHJ[TRBYTE] C500 $
TRP2B:	 D[MEM] ROT[34] DEST[Q] PUSHJ[TRBYTE] C500 $
	 D[MEM] ROT[24] ALU[DORQ] DEST[Q] PUSHJ[TRBYTE] C500 $
	 D[MEM] ROT[14] ALU[DORQ] DEST[Q] PUSHJ[TRBYTE] C500 $
	 D[MEM] ROT[4] ALU[DORQ] DEST[Q] PUSHJ[TRBYTE] C500 $
	 D[IR] MASK[18.] ALU[D-1] DEST[IR-ADR] C600 
		COND[OBUS18] JUMP[TRP2A] $
	D[MEM] MASK[4]  ALU[DORQ] DEST[MEMSTO] NORM $
	D[MA] ALU[D+1] DEST[MA] JUMP[TRP2A] NORM $

;READ 1 BYTE.  IF ERROR, EOR, EOF, SET Q_2,HIGHEST LOC WRITTEN+1,1 & POP
; ONE OFF THE STACK AND RETURN.  IF BYTE SUCCESSFULLY
; READ, JUST RETURN WITH BYTE IN HOLD.

TRBYTE:	START-IN D[CONST 35]  LLOAD NORM $
		;Ask tape for a byte and status thereof
		;Set loop counter to do timeout
		;(TIMEOUT IN ABOUT 78. USEC)
TRBY1:	MAPF[2] D[IOD] ALU[NOTD] DEST[HOLD] LONG LOOP[TRBY2] $
		;Read byte and status.  Byte comes complemented.
		;Result is put in HOLD to avoid synchronizer problems
		;Do timeout check and branch if still waiting
	START-IN NORM JUMP[TRCHECK] $
		;Byte wasn't ready in time.  Go find out why
;	---
TRBY2:
	C550 $
	C550 $
	START-IN D[MEM] ROT[26.] COND[OBUS<0] C550 JUMP[TRBY1] $
		;Check for byte ready (this is a 4 instruction loop)
		;Start getting byte and status again in case we have
		;  to loop
TRBY3:	START-IN MAPF[2] D[IOD] ALU[NOTD] DEST[HOLD] C800 $
	        ;READ THE DATA AGAIN (NOW THAT IT'S STABLE !)
	MAPF[1] D[MEM] MASK[10] DEST[HOLD] C550 POPJ $
		;MAPF[1] clears byte ready
		;Extract data byte from other status information
;	---


TRCHECK:	
	START-IN NORM PUSHJ[FMNBWT] $
	  ;WAIT FOR FORMATTER NOT BUSY.
	D[MEM] ROT[32.] C550 COND[-OBUS<0] JUMP[TRERR] $
	  ;CHECK FOR HARD ERROR STATUS.
;;;;;	D[MEM] ROT[16.] C550 COND[-OBUS<0] JUMP[TRERR] $
	  ;CHECK FOR OVERRUN ERROR.
	D[MEM] ROT[33.] C550 COND[-OBUS<0] JUMP[TREOF] $
	  ;IF ENDX OF FILE NOT SEEN, WE ARE DONE.
TREOR:	D[MA] MASK[24] DEST[Q] NORM JUMP[TRDONE] $ ;ENDX OF REC.
TRDONE:	NORM JPOP[. + 1] $  ;REMOVE ONE RETURN ADDR FROM STACK.
	NORM POPJ $	;RETURN UPLEVEL (CODE IN Q)
TREOF:	D[CONST 60] ROT[36] DEST[Q]  NORM JUMP[TRDONE] $
TRERR:	D[CONST 50] ROT[36] DEST[Q] NORM JUMP[TRDONE] $


TAPEMT:	;OPCODE 726 -- MTAPE FUNCTIONS.
	D[MA] DEST[Q] COND[OBUS=0] PUSHJ[TAPERW] C550 $
	D[CONST 5] ALU[D-Q] COND[OBUS=0] PUSHJ[TAPEFR] C550 $
	D[CONST 6] ALU[D-Q] COND[OBUS=0] PUSHJ[TAPEBR] C550 $
	D[CONST 1] ALU[D-Q] COND[OBUS=0] PUSHJ[TWREOF] C550 $
	JUMP[MAIN] $ ;UNKNOWN CODE -- TREAT AS NOP.

TWREOF:	 ;WRITE AN ENDX OF FILE (TAPE MARK)
	D[CONST 1] ROT[35. - 28.] DEST[Q] NORM $ ; WRT EOF cmd bit
TERASE:	D[CONST 1] ROT[35. - 22.] ALU[DORQ] DEST[HOLD] 
	   NORM JUMP[KNYMTP] $  ;Add WRT CMD bit and start command.

KNYMTP:	START-OUT D[12] DEST[IOD] NORM $
	MAPF[4] D[MEM] DEST[Q] C-OUT PUSHJ[KNYGOA] $
	START-OUT D[CONST 1] ROT[35. - 26.] DEST[IOD] NORM $
	   ;CLEAR ALL COMMAND BITS EXCEPT FORMATTER ENABLE.
	MAPF[2] ALU[-1] DEST[Q] LONG POPJ $
	  ;PUT -1 IN Q IN CASE WE ARE RETURNING TO TAPEMT.

TAPERW:	;REWIND
	D[CONST 24] DEST[HOLD] NORM JUMP[KNYMTP] $
	  ;RWD AND GO BITS -- KNYGOA WILL DELETE THE GO BIT !

TAPEFR:	;SKIP FORWARD ONE RECORD.
	D[CONST 0] DEST[HOLD] NORM JUMP[KNYMTP] $
	  ;START A READ, BUT IGNORE THE DATA.

TAPEBR:	;SKIP BACKWARD ONE RECORD.
	D[CONST 1] ROT[35. - 27.] DEST[HOLD] NORM JUMP[KNYMTP] $
	  ;JUST A READ BACKWARD, WITH THE DATA IGNORED.

TAPERS:	;OPCODE 727 -- READ STATUS BITS FROM TAPE DRIVE.

.DEFINE TSS[A B]   
[  ;MOVE BIT A OF AR TO BIT B OF Q.
  	D[AR] ROT[1 + A] MASK[1] DEST[HOLD] NORM $
	D[MEM] ROT[35. - B] ALU[DORQ] DEST[Q] NORM $ ]

	START-OUT D[12] DEST[IOD] NORM $
	  ;CLEAR THE MODE CTRL REGISTER.
	MAPF[4] START-OUT 
	 D[CONST 1] ROT[35. - 26.] DEST[IOD] C-OUT $
	  ;ENABLE THE FORMATTER.
	MAPF[2] START-IN ALU[0] DEST[Q] C800 $
	  ;READ STATUS BITS.
	MAPF[4] D[IOD] ALU[NOTD] DEST[AR] C800 $
	  ;NOW RE-ARRANGE THE BITS
	TSS[ 3 30. ]	;ON LINE
	TSS[ 11. 31. ]	;REWINDING
	TSS[ 4 32. ]	;FILE PROTECT
	TSS[ 12. 33. ]	;LOAD POINT
	TSS[ 10. 34. ]	;READY
	TSS[ 5 35. ]	;ENDX OF TAPE
	ALU[Q] DEST[MEMSTO] NORM
		COND[-MA-AC] LBJUMP[SMAIN] $


TAPENR:	;730, AC/COUNT.  READ WHOLE RECORD,
	;STORING UP TO COUNT WORDS STARTING AT EFF ADR.
	;IF AC<>0 RETURN STATUS AS FOR 727.
	 ;SWAP AC AND MA, THEN DO TAPERX.
	D[MA] DEST[O_AC MA] ACSEL[AC]  NORM JUMP[TAPERX] $ 

TAPERX:	;732 - (AC) IS START ADDR., E IS # OF WORDS TO READ.
	NORM PUSHJ[KNYRGO] $ ;GET TAPE STARTED.
	ALU[AC] ACSEL[AC] DEST[MA] PUSHJ[TRP2] NORM $ ;READ REC.
		;MOVE STATUS INTO AC.
	D[IR] COND[-OBUS18] JUMP[TNRP3] C550 $ ; WAS RECORD TOO LONG ?
	D[CONST 44] ROT[30.] ALU[DORQ] DEST[Q] NORM $ ;YES, SET BIT 3.
TNRP3:	ALU[Q] DEST[AC] ACSEL[AC] JPOP[MAIN] NORM $  ;NO, NOT TOO LONG.


TAPEWR:	;731, AC/ADR, E/+COUNT.  WRITE RECORD OF +COUNT
	; WORDS, DATA FROM ADR.
	;SET AC:=0 IF OPERATION COMPLETED SUCCESSFULLY.
	; SET AC:=<SETZ> + HIGHEST ADR READ IF REACHED
	; EOT DURING OPERATION (CURRENTLY THIS IS THE ONLY
	; ERROR CONDITION.)  OPERATION IS COMPLETED EVEN
	; IF EOT IS PASSED.

	D[CONST 10.] DEST[7] DEST-A-MEM NORM $
	  ;SET UP ERROR RETRY COUNT.
TWRTRY:	START-OUT D[12] DEST[Q IOD] NORM $ ;CLEAR MODE CTRL REG.
	MAPF[4] START-OUT D[CONST 1] ROT[35. - 3] DEST[IOD]  $
	   ;GIVE "MR" TO CLEAR TP RD DAT RDY
	MAPF[1] D[CONST 31] ROT[35. - 8] ALU[DORQ] DEST[Q] C-OUT $
	   ;Construct mode information for KENNEDY formatter
	START-OUT D[CONST 1] ROT[35. - 16.] ALU[DORQ] DEST[Q IOD] $
		;Set mode for tape controller to talk to KENNEDY
		;31002,,0 means:
		;SEL BT DAT, CTRL TLX, FIFO ENB
	MAPF[4] ALU[Q] DEST[4] DEST-A-MEM $
	   ;SAVE CONTENTS OF MODE REGISTER.
	D[CONST 1] ROT[35. - 22.] DEST[Q] C-OUT PUSHJ[KNYGOA] $
	   ;GO GIVE WRITE COMMAND TO FORMATTER.
	
	D[CONST 1] ROT[35. - 5] DEST[Q] NORM $
	 ;Mask bit for testing EOT in fmtr.
	D[CONST 1] ROT[35. - 32.] ALU[DORQ] DEST[6] DEST-A-MEM $
	 ;Add bit for HARD ERROR - store mask in AMEM(6)
	D[MA] MASK[18.] DEST[AR 5] DEST-A-MEM NORM $
	 ;Move wc to AR, and preserve in AMEM(5) for retry.
	ALU[AC] ACSEL[AC] DEST[MA] NORM $
	 ;Fetch first word to be written.
TWNW:	FIXM1 $
	START-IN D[MEM] ROT[8] MASK[8] DEST[IOD] PUSHJ[TWBYTE] NORM $
	START-IN D[MEM] ROT[20] MASK[8] DEST[IOD] PUSHJ[TWBYTE] NORM $
	START-IN D[MEM] ROT[30] MASK[8] DEST[IOD] PUSHJ[TWBYTE] NORM $
	START-IN D[MEM] ROT[40] MASK[8] DEST[IOD] PUSHJ[TWBYTE] NORM $
	D[AR] ALU[D-1] DEST[AR] C600 COND[OBUS=0] JUMP[TWNW1] $
	START-IN D[MEM] MASK[4] DEST[IOD] PUSHJ[TWBYTE] NORM $
	D[MA] ALU[D+1] DEST[MA] NORM JUMP[TWNW] $ ;Fetch next word.

TWNW1:	D[MEM] MASK[4] DEST[Q] NORM $  ;LAST BYTE OF RECORD...
	START-IN D[CONST 1] ROT[35. - 1] ALU[DORQ]  
	DEST[IOD] NORM PUSHJ[TWBYTE] $ ;SET  'BT DAT LAST' BIT.

	D[14] DEST[Q] NORM $ ;RECOVER MODE REGISTER CONTENTS.
	START-OUT D[CONST 1] ROT[35. - 1] 
	   ALU[DORQ] DEST[IOD] NORM $ ;SET "LAST BYTE ENBL"
	START-IN MAPF[4] PUSHJ[FMNBWT] $
	  ;WAIT FOR FORMATTER NOT BUSY.

	D[CONST 1] ROT[15.] DEST[AR] $
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[.] C550 $

	D[MEM] ALU[NOTD] DEST[Q] NORM $ ;Complement of status
	D[CONST 1] ROT[35. - 32.]  ALU[D&Q] C550 
	  COND[-OBUS=0] JUMP[TWERR] $ ;Test HARD ERR.
	ALU[0] DEST[AC] NORM $ ;We return 0 in AC if no EOT.
	D[MEM] ROT[35. - 5] C550 COND[OBUS<0] JUMP[MAIN] $
	 ;If no EOT seen, all done.
	D[MA] MASK[18.] DEST[AC] NORM $ ;EOT seen. Get ending MA.
	D[CONST 40] ROT[35. - 5] ALU[DORAC] DEST[AC] NORM JUMP[MAIN] $
	 ;Turn on bit 0 to indicate EOT seen during operation.

TWBYTE:	MAPF[4] D[IOD] ALU[NOTD] DEST[Q] LONG $
	 ;Read TP STAT (complemented).
	D[16] ALU[D&Q] C550 COND[-OBUS=0] JPOP[TWERR] $ ;Test err bits.
	SHORT $
	START-IN D[CONST 2] ALU[D&Q] C550 COND[-OBUS=0] JUMP[TWBYTE] $
	START-OUT SHORT $
	MAPF[14] C800 POPJ $

TWERR:	START-IN NORM PUSHJ[FMNBWT] $  ;WAIT FOR NOT BUSY.
	NORM PUSHJ[KNYRST] $ 
	  ;Blast the tape formatter and drive 
	D[17] ALU[D-1] DEST[Q] C550 COND[-OBUS<0] JUMP[TWER1] $
	  ;SEE IF WE HAVE HAD TO MANY RETRY'S ALREADY...
	D[CONST 50] ROT[30.] DEST[AC] JUMP[MAIN] $
	   ;HOPELESS. GIVE ERROR RETURN TO PRGM.
TWER1:	ALU[Q] DEST[7] DEST-A-MEM NORM PUSHJ[TAPEBR] $
	 ;Start a BACKSPACE RECORD command.
	START-IN NORM PUSHJ[FMNBWT] $ ;Wait for completion.
	D[CONST 3] ROT[35. - 29.] DEST[Q] NORM PUSHJ[TERASE] $
	  ;ERASE A 3.5" GAP ON THE TAPE.
	START-IN NORM PUSHJ[FMNBWT] $ ;Wait for completion.
	D[15] DEST[MA] NORM JUMP[TWRTRY] $
	  ;RECOVER WC AND START WRITE OP AGAIN.

;BOOTSTRAP LOADER FOR MACROCODE.

MBSAVP:	;SAVE LOC. CTR.

: 5000
MBOOT:	JUMP[MBOOT + 1] CYLEN[LONG] $
	ALU[0] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
	D[CONST 1] ROT[18.] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
	D[CONST 7] DEST[DEV-ADR] CYLEN[LONG] PUSHJ[KNYRGO] $
		;SELECT DEVICE 7, START READ.
	START-IN ALU[0] DEST[MA HI-ABS-MA] NORM PUSHJ[MBTBY3] $
	NORM JUMP[P2A] $
P2:	PUSHJ[MBTBYTE] C500 $
P2A:	MAPF[2] D[MEM] ROT[34] DEST[Q] PUSHJ[MBTBYTE] C500 $
	MAPF[2] D[MEM] ROT[24] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] C500 $
	MAPF[2] D[MEM] ROT[14] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] C500 $
	MAPF[2] D[MEM] ROT[4] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] C500 $
	MAPF[2] D[MEM] MASK[4]  ALU[DORQ] DEST[MEMSTO] C500 $
	D[MA] ALU[D+1] DEST[MA] JUMP[P2] C500 $

CCLR:	ALU[0] DEST[MA] NORM $
	ALU[0] DEST[MEMSTO] NORM $
	D[MA] ALU[D+1] DEST[MA] NORM $
	D[MA] MASK[18.] COND[-OBUS=0] JUMP[. - 2] C600 $
	POPJ NORM $

MBTBYTE:
	START-IN D[CONST 35] ROT[1] LLOAD NORM $
		;Ask tape for a byte and status thereof
		;Set loop counter to do timeout
		;(TIMEOUT ABOUT 78 USEC)
MBTBY1:	MAPF[2] D[IOD] ALU[NOTD] DEST[HOLD] C800 LOOP[MBTBY2] $
		;Read byte and status.  Byte comes complemented.
		;Result is put in HOLD to avoid synchronizer problems
		;Do timeout check and branch if still waiting
	START-IN NORM PUSHJ[MBTCHECK] $
		;Byte wasn't ready in time.  Go find out why
	PUSHJ [KNYRGO] $ ;START NEXT RECORD.
	NORM JPOP[P2] $
		;Go for another record
;	---
MBTBY2:
	START-IN D[MEM] ROT[26.] COND[OBUS<0] C550 JUMP[MBTBY1] $
		;Check for byte ready (this is a two instruction loop)
		;Start getting byte and status again in case we have
		;  to loop
MBTBY3:	START-IN MAPF[2] D[IOD] ALU[NOTD] DEST[HOLD] C800 $
	        ;READ THE DATA AGAIN (NOW THAT IT'S STABLE !)
	MAPF[1] D[MEM] MASK[10] DEST[HOLD] C550 POPJ $
		;MAPF[1] clears byte ready
		;Extract data byte from other status information

;	---


MBTCHECK:	START-IN NORM PUSHJ[FMNBWT] $
	  ;WAIT FOR FORMATTER IDLE.
	D[MEM] ROT[32.] C550 COND[-OBUS<0] JUMP[MBTERR] $
	  ;CHECK FOR ERROR STATUS.
	D[MEM] ROT[33.] C550 COND[OBUS<0] POPJ $
	  ;IF ENDX OF FILE NOT SEEN, RETURN FOR MORE, ELSE DONE.
	ALU[0] DEST[Q] NORM $ ;CLEAR LIGHTS TO INDICATE NO ERRORS.
MBTDNX: START-OUT ALU[0] DEST[DEV-ADR] $
		;Setup to display code in lights
	START-OUT MAPF[2] ALU[Q] $	;LOAD LIGHTS FROM Q, CLR SW FF'S
D1:	MAPF[4] START-IN $
	   ;CHECK START AND CONT SWITCHES.  RD NEXT FILE ON CONT
	MAPF[4] D[IOD] DEST[AR] $
	D[AR]  ROT[5] MASK[2] DEST[AR]
		COND[OBUS=0] JUMP[D1] CYLEN[LONG] $
		;WAIT FOR A SWITCH.
	D[AR] MASK[1] COND[-OBUS=0] JUMP[MSTART] C550 $
	   ;  ... START MAIN MICROCODE ON START SWITCH.
	START-OUT NORM $  ;CLEAR SWITCH FF'S
	MAPF[4] JUMP[MBOOT] CYLEN[LONG] $

MBTERR:	D[CONST 0] ALU[NOTD] DEST[Q] JUMP[MBTDNX] $
;	---

: MBSAVP	;RETURN TO OLD LOC. CTR.

] ;ENDX OF KENNEDY TAPE CODE

.DEFINE FOOLIST[] [ XLIST ] 
LIST
.REPEAT TLXTAPE [.DEFINE FOOLIST[] [ LIST ] ]
FOOLIST

.REPEAT TLXTAPE [ ;TELEX TAPE CONTROL UCODE

;TAPE READING AND WRITING CODE
; A-MEM USEAGE:
;		0	DISPATCH ADDR.
;		5	SAVED COPY OF WORD COUNT (WRITE)
;		6	MASK FOR TESTING ERROR STATUS (WRITE)

TLXRST:  ;RESET the formatter and drive.
	SPEC[IOB-OUT] D[CONST 1] ROT[35. - 30.] DEST[IOD] $
	 ;Set the SYSTEM RESET line to fmtr.
	MAPF[2] D[CONST 8] C800 LLOAD $ ;Get wait count.
	LOOP[.] $ ;Wait about 8 microseconds.
	SPEC[IOB-OUT] ALU[0] DEST[IOD] $ ;Clear the signal.
	MAPF[2] LONG POPJ $

   ;727 - OBSOLETE VERSION OF READ
TAPERD:	NORM PUSHJ[TLXRGO] $
	D[MASK 17.] DEST[IR-ADR] PUSHJ[TRP2] NORM $
		;MOVE STATUS INTO AC.
	ALU[Q] DEST[AC] ACSEL[AC] MAPF[2] JUMP[MAIN] CYLEN[IOB-OUT] $

; TLXRGO -- CALLED START TAPE MOTION.   WAITS FOR FIRST BYTE.
TLXRGO:	D[CONST 7] ROT[27.] DEST[Q] $
		;Construct mode information for TELEX formatter
	SPEC[IOB-OUT] D[CONST 6] ROT[6] ALU[DORQ] DEST[IOD] NORM $
		;Set mode for tape controller to talk to TELEX
		;7000,,600 means:
		;[Put meaning of command here]
	MAPF[4] SPEC[IOB-OUT] D[CONST 2] ROT[9.] DEST[IOD Q] 
	  CYLEN[IOB-OUT] PUSHJ[TLXGOA] $
		;? Initialize command register
;	\ /
TLXWAIT:
	MAPF[2] SPEC[IOB-IN] $
		;MAPF[2] is used to finish clearing 
	; command register by caller
	MAPF[1] D[CONST 77] ROT[12.] DEST[AR] NORM $
		;Clear read data ready flag
TLXW1:	SPEC[IOB-IN] D[AR] ALU[D-1] DEST[AR] 
		C550 COND[OBUS=0] JUMP[TLXW2] $
	MAPF[2] D[IOD] DEST[HOLD] C800 $
	D[MEM] ROT[27.] MASK[1] COND[OBUS=0] JUMP[TLXW1] C550 $
TLXW2:	NORM POPJ $

TLXGOA:	MAPF[2] SPEC[IOB-IN] CYLEN[IOB-OUT] $
	MAPF[4] D[IOD] DEST[HOLD] $ ;GET STATUS BITS.
	D[MEM] ROT[13.] C550 COND[-OBUS<0] JUMP[TLXGOA] $
	  ;WAIT FOR FORMATTER NOT BUSY.
	SPEC[IOB-OUT] D[CONST 41] ROT[35. - 8.] DEST[IOD] NORM $
		;RESET THE CONTROLLER ERROR CONDITIONS.
	MAPF[1] SPEC[IOB-OUT] D[CONST 1] ROT[6] ALU[DORQ] DEST[IOD] 
		CYLEN[IOB-OUT] $
		;Start tape going forward
TLXL1:	MAPF[2] SPEC[IOB-IN] CYLEN[IOB-OUT] $
		;Finish setting tape moving [fall thru case]
		;Get status from formatter
	MAPF[4] D[IOD] DEST[HOLD] LONG $
		;Put it in hold to avoid synchronizer problems
	D[MEM] ROT[13.] COND[OBUS<0] C550 JUMP[TLXL1] $
		;Wait for formatter to say it's going
	SPEC[IOB-OUT] ALU[Q] DEST[IOD] NORM $
	MAPF[2] CYLEN[IOB-OUT] POPJ $
		;Drop move forward request

FMNBWT:	  ;Wait for formatter to be not busy.
	MAPF[4] D[IOD] DEST[HOLD] $ ;GET STATUS BITS.
	SPEC[IOB-IN] D[MEM] ROT[13.] C550 COND[-OBUS<0] JUMP[FMNBWT] $
	NORM POPJ $

;READ A RECORD.  STORE UP TO C(IR-ADR) WORDS.
TRP2:	PUSHJ[TRBYTE] C500 $
	MAPF[2] D[MEM] ROT[34] DEST[Q] PUSHJ[TRBYTE] C500 $
	MAPF[2] D[MEM] ROT[24] ALU[DORQ] DEST[Q] PUSHJ[TRBYTE] C500 $
	MAPF[2] D[MEM] ROT[14] ALU[DORQ] DEST[Q] PUSHJ[TRBYTE] C500 $
	MAPF[2] D[MEM] ROT[4] ALU[DORQ] DEST[Q] PUSHJ[TRBYTE] C500 $
	MAPF[2] D[IR] MASK[18.] ALU[D-1] DEST[IR-ADR] C600 
		COND[OBUS18] JUMP[TRP2] $
	D[MEM] MASK[4]  ALU[DORQ] DEST[MEMSTO] NORM $
	D[MA] ALU[D+1] DEST[MA] JUMP[TRP2] NORM $

;READ 1 BYTE.  IF ERROR, EOR, EOF, SET Q_2,HIGHEST LOC WRITTEN+1,1 & POP
; ONE OFF THE STACK AND RETURN.  IF BYTE SUCCESSFULLY
; READ, JUST RETURN WITH BYTE IN HOLD.

TRBYTE:	SPEC[IOB-IN] D[CONST 35] DEST[IOD] LLOAD NORM $
		;Ask tape for a byte and status thereof
		;Set loop counter to do timeout
		;Set IOD hold register for later use to acknowledge
		;byte.  (The acknowledge bit is the only bit in the
		;constant 35 that is seen by the hardware.)
TRBY1:	MAPF[2] D[IOD] ALU[NOTD] DEST[HOLD] C800 LOOP[TRBY2] $
		;Read byte and status.  Byte comes complemented.
		;Result is put in HOLD to avoid synchronizer problems
		;Do timeout check and branch if still waiting
	SPEC[IOB-IN] NORM JUMP[TRCHECK] $
		;Byte wasn't ready in time.  Go find out why
;	---
TRBY2:
	SPEC[IOB-IN] D[MEM] ROT[26.] COND[OBUS<0] C550 JUMP[TRBY1] $
		;Check for byte ready (this is a two instruction loop)
		;Start getting byte and status again in case we have
		;  to loop
;;;;	MAPF[2] SPEC[IOB-IN] D[IOD] ALU[NOTD] DEST[HOLD] LONG $
	MAPF[1] SPEC[IOB-OUT] D[MEM] MASK[10] DEST[HOLD] C550 $
		;MAPF[1] clears byte ready
		;Raise acknowledge.  Note that IOD was set up at the top
		;  of the loop to contain acknowledge bit (and some junk
		;  which the hardware will ignore)
		;Extract data byte from other status information
	MAPF[2] SPEC[IOB-OUT] ALU[0] DEST[IOD] C550 POPJ $
		;Drop acknowledge again.
		;WARNING: MAPF[2] must be in instruction at return
		;  address for this to work.
;	---


TRCHECK:	MAPF[4] D[IOD] DEST[HOLD] $ ;GET STATUS BITS.
	SPEC[IOB-IN] D[MEM] ROT[13.] C550 COND[-OBUS<0] JUMP[TRCHECK] $
	  ;WAIT FOR FORMATTER NOT BUSY.
	D[MEM] ROT[17.] C550 COND[-OBUS<0] JUMP[TRERR] $
	  ;CHECK FOR ERROR STATUS.
	D[MEM] ROT[16.] C550 COND[-OBUS<0] JUMP[TRERR] $
	  ;CHECK FOR OVERRUN ERROR.
	D[MEM] ROT[22.] C550 COND[-OBUS<0] JUMP[TREOF] $
	  ;IF ENDX OF FILE NOT SEEN, WE ARE DONE.
TREOR:	D[MA] MASK[24] DEST[Q] NORM JUMP[TRDONE] $ ;ENDX OF REC.
TRDONE:	NORM JPOP[. + 1] $  ;REMOVE ONE RETURN ADDR FROM STACK.
	NORM POPJ $	;RETURN UPLEVEL (CODE IN Q)
TREOF:	D[CONST 60] ROT[36] DEST[Q]  NORM JUMP[TRDONE] $
TRERR:	D[CONST 50] ROT[36] DEST[Q] NORM JUMP[TRDONE] $


TAPEMT:	;OPCODE 726 -- MTAPE FUNCTIONS.
	D[MA] DEST[Q] COND[OBUS=0] JUMP[TAPERW] C550 $
	D[CONST 5] ALU[D-Q] COND[OBUS=0] JUMP[TAPEFR] C550 $
	D[CONST 6] ALU[D-Q] COND[OBUS=0] JUMP[TAPEBR] C550 $
	D[CONST 1] ALU[D-Q] COND[OBUS=0] JUMP[TWREOF] C550 $
	JUMP[MAIN] $ ;UNKNOWN CODE -- TREAT AS NOP.

TWREOF:	 ;WRITE AN ENDX OF FILE (TAPE MARK)
	D[CONST 37] DEST[HOLD] NORM JUMP[TLXMTP] $

TLXMTP:	SPEC[IOB-OUT] ALU[0] DEST[IOD] NORM $
	MAPF[4] SPEC[IOB-OUT] D[MEM] ROT[9.] DEST[IOD Q]
	    CYLEN[IOB-OUT] PUSHJ[TLXGOA] $
	MAPF[2] JUMP[MAIN] $

TAPERW:	;REWIND
	D[CONST 7] DEST[HOLD] NORM JUMP[TLXMTP] $

TAPEFR:	;SKIP FORWARD ONE RECORD.
	D[CONST 4] DEST[HOLD] NORM JUMP[TLXMTP] $

TAPEBR:	;SKIP BACKWARD ONE RECORD.
	D[CONST 5] DEST[HOLD] NORM JUMP[TLXMTP] $

TAPERS:	;OPCODE 727 -- READ STATUS BITS FROM TAPE DRIVE.

.DEFINE TSS[A B]   
[  ;MOVE BIT A OF AR TO BIT B OF Q.
  	D[AR] ROT[1 + A] MASK[1] DEST[HOLD] NORM $
	D[MEM] ROT[35. - B] ALU[DORQ] DEST[Q] NORM $ ]

	SPEC[IOB-OUT] ALU[0] DEST[IOD] NORM $
	MAPF[4] SPEC[IOB-OUT] D[CONST 24] ROT[9.] DEST[IOD Q]
	    CYLEN[IOB-OUT] PUSHJ[TLXGOA] $
	MAPF[2] SPEC[IOB-IN] ALU[0] DEST[Q] C800 $
	MAPF[4] D[IOD] ALU[NOTD] DEST[AR] C800 $
	D[AR] ROT[13.] C550 COND[OBUS<0] JUMP[. - 2] $
	TSS[ 5 30. ]	;ON LINE
	TSS[ 0 31. ]	;REWINDING
	TSS[ 7 32. ]	;FILE PROTECT
	TSS[ 3 33. ]	;LOAD POINT
	TSS[ 6 34. ]	;READY
	TSS[ 4 35. ]	;ENDX OF TAPE
	ALU[Q] DEST[MEMSTO] NORM
		COND[-MA-AC] LBJUMP[SMAIN] $


TAPENR:	;730, AC/COUNT.  READ WHOLE RECORD,
	;STORING UP TO COUNT WORDS STARTING AT EFF ADR.
	;IF AC<>0 RETURN STATUS AS FOR 727.
	 ;SWAP AC AND MA, THEN DO TAPERX.
	D[MA] DEST[O_AC MA] ACSEL[AC]  NORM JUMP[TAPERX] $ 

TAPERX:	;732 - (AC) IS START ADDR., E IS # OF WORDS TO READ.
	NORM PUSHJ[TLXRGO] $ ;GET TAPE STARTED.
	ALU[AC] ACSEL[AC] DEST[MA] PUSHJ[TRP2] NORM $ ;READ REC.
		;MOVE STATUS INTO AC.
	D[IR] COND[-OBUS18] JUMP[TNRP3] C550 $ ; WAS RECORD TOO LONG ?
	D[CONST 44] ROT[30.] ALU[DORQ] DEST[Q] NORM $ ;YES, SET BIT 3.
TNRP3:	ALU[Q] DEST[AC] ACSEL[AC] JPOP[MAIN] NORM $  ;NO, NOT TOO LONG.


TAPEWR:	;731, AC/ADR, E/+COUNT.  WRITE RECORD OF +COUNT
	; WORDS, DATA FROM ADR.
	;SET AC:=0 IF OPERATION COMPLETED SUCCESSFULLY.
	; SET AC:=<SETZ> + HIGHEST ADR READ IF REACHED
	; EOT DURING OPERATION (CURRENTLY THIS IS THE ONLY
	; ERROR CONDITION.)  OPERATION IS COMPLETED EVEN
	; IF EOT IS PASSED.

	SPEC[IOB-OUT] ALU[0] DEST[IOD] NORM $ ;CLEAR CTRL REG.
	MAPF[4] D[CONST 31] ROT[27.] DEST[Q] CYLEN[IOB-OUT] $
		;Construct mode information for TELEX formatter
	SPEC[IOB-OUT] D[CONST 2] ROT[18.] ALU[DORQ] DEST[IOD] NORM $
		;Set mode for tape controller to talk to TELEX
		;31002,,0 means:
		;[Put meaning of command here]
	MAPF[4] SPEC[IOB-OUT] D[CONST 1] ROT[9.] DEST[IOD Q] 
	  CYLEN[IOB-OUT] PUSHJ[TLXGOA] $
		;? Initialize command register
	
	D[CONST 1] ROT[9. + 18.] DEST[Q] NORM $
	 ;Mask bit for testing ROM PAR ERR in fmtr.
	D[CONST 3] ROT[18.] ALU[DORQ] DEST[6] DEST-A-MEM NORM $
	 ;Add bits for OVRRUN and DATA CHK  - store mask in AMEM(6)
	D[MA] MASK[18.] DEST[AR 5] DEST-A-MEM NORM $
	 ;Move wc to AR, and preserve in AMEM(5) for retry.
TWRTRY:	ALU[AC] ACSEL[AC] DEST[MA] NORM $
	 ;Fetch first word to be written.
TWNW:	FIXM1 $
	SPEC[IOB-IN] D[MEM] ROT[8] MASK[8] DEST[IOD] PUSHJ[TWBYTE] NORM $
	SPEC[IOB-IN] D[MEM] ROT[20] MASK[8] DEST[IOD] PUSHJ[TWBYTE] NORM $
	SPEC[IOB-IN] D[MEM] ROT[30] MASK[8] DEST[IOD] PUSHJ[TWBYTE] NORM $
	SPEC[IOB-IN] D[MEM] ROT[40] MASK[8] DEST[IOD] PUSHJ[TWBYTE] NORM $
	D[AR] ALU[D-1] DEST[AR] C600 COND[OBUS=0] JUMP[TWNW1] $
	SPEC[IOB-IN] D[MEM] MASK[4] DEST[IOD] PUSHJ[TWBYTE] NORM $
	D[MA] ALU[D+1] DEST[MA] NORM JUMP[TWNW] $ ;Fetch next word.

TWNW1:	D[MEM] MASK[4] DEST[Q] NORM $
	SPEC[IOB-IN] D[CONST 1] ROT[35. - 1] ALU[DORQ] DEST[IOD] NORM PUSHJ[TWBYTE] $

	SPEC[IOB-IN] PUSHJ[FMNBWT] $
	  ;WAIT FOR FORMATTER NOT BUSY.
	D[MEM] ALU[NOTD] DEST[Q] NORM $ ;Complement of status to Q
	D[16] ALU[D&Q] C550 COND[-OBUS=0] JUMP[TWERR] $ ;Test err bits.
	ALU[0] DEST[AC] NORM $ ;We return 0 in AC if no EOT.
	D[MEM] ROT[4] C550 COND[OBUS<0] JUMP[MAIN] $
	 ;If no EOT seen, all done.
	D[MA] MASK[18.] DEST[AC] NORM $ ;EOT seen. Get ending MA.
	D[CONST 40] ROT[35. - 5] ALU[DORAC] DEST[AC] NORM JUMP[MAIN] $
	 ;Turn on bit 0 to indicate EOT seen during operation.

TWBYTE:	MAPF[4] D[IOD] ALU[NOTD] DEST[Q] C800 $
	 ;Read TP STAT (complemented).
	D[16] ALU[D&Q] C550 COND[-OBUS=0] JUMP[TWERR] $ ;Test err bits.
	SPEC[IOB-IN] D[CONST 2] ALU[D&Q] C550 COND[-OBUS=0] JUMP[TWBYTE] $
	SPEC[IOB-OUT] SHORT $
	MAPF[14] C800 POPJ $

TWERR:	SPEC[IOB-IN] NORM PUSHJ[FMNBWT] $  ;WAIT FOR NOT BUSY.
	NORM PUSHJ[TLXRST] $ ;Blast the tape formatter and drive
	SPEC[IOB-IN] NORM PUSHJ[FMNBWT] $ ;Wait for formatter idle.
	SPEC[IOB-OUT] D[CONST 5] ROT[9.] DEST[IOD Q] PUSHJ[TLXGOA] $
	 ;Start a BACKSPACE RECORD command.
	SPEC[IOB-IN] NORM PUSHJ[FMNBWT] $ ;Wait for completion.
	SPEC[IOB-OUT] D[CONST 27] ROT[9.] DEST[IOD Q] PUSHJ[TLXGOA] $
	 ;Start an ERASE 3.5" GAP command.
	SPEC[IOB-IN] NORM PUSHJ[FMNBWT] $ ;Wait for completion.
	SPEC[IOB-OUT] D[CONST 1] ROT[9.] DEST[IOD Q] NORM
	  PUSHJ[TLXGOA] $ ;Start write operation over again.
	D[15] DEST[AR] NORM JUMP[TWRTRY] $ ;Recover WC and retry op.

;BOOTSTRAP LOADER FOR MACROCODE.

MBSAVP:	;SAVE LOC. CTR.

: 5000
MBOOT:	JUMP[5001] CYLEN[LONG] $
	ALU[0] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
	D[CONST 1] ROT[18.] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
	D[CONST 7] DEST[DEV-ADR] CYLEN[LONG] PUSHJ[TLXRGO] $
		;SELECT DEVICE 7, START READ.
	ALU[0] DEST[MA HI-ABS-MA] NORM $
P2:	PUSHJ[MBTBYTE] C500 $
	MAPF[2] D[MEM] ROT[34] DEST[Q] PUSHJ[MBTBYTE] C500 $
	MAPF[2] D[MEM] ROT[24] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] C500 $
	MAPF[2] D[MEM] ROT[14] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] C500 $
	MAPF[2] D[MEM] ROT[4] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] C500 $
	MAPF[2] D[MEM] MASK[4]  ALU[DORQ] DEST[MEMSTO] C500 $
	D[MA] ALU[D+1] DEST[MA] JUMP[P2] C500 $

CCLR:	ALU[0] DEST[MA] NORM $
	ALU[0] DEST[MEMSTO] NORM $
	D[MA] ALU[D+1] DEST[MA] NORM $
	D[MA] MASK[18.] COND[-OBUS=0] JUMP[. - 2] C600 $
	POPJ NORM $

MBTBYTE:
	SPEC[IOB-IN] D[CONST 35] DEST[IOD] LLOAD NORM $
		;Ask tape for a byte and status thereof
		;Set loop counter to do timeout
		;Set IOD hold register for later use to acknowledge
		;byte.  (The acknowledge bit is the only bit in the
		;constant 35 that is seen by the hardware.)
MBTBY1:	MAPF[2] D[IOD] ALU[NOTD] DEST[HOLD] C800 LOOP[MBTBY2] $
		;Read byte and status.  Byte comes complemented.
		;Result is put in HOLD to avoid synchronizer problems
		;Do timeout check and branch if still waiting
	SPEC[IOB-IN] NORM PUSHJ[MBTCHECK] $
		;Byte wasn't ready in time.  Go find out why
	PUSHJ [TLXRGO] $ ;START NEXT RECORD.
	NORM JUMP[MBTBYTE] $
		;Go for another record
;	---
MBTBY2:
	SPEC[IOB-IN] D[MEM] ROT[26.] COND[OBUS<0] C550 JUMP[MBTBY1] $
		;Check for byte ready (this is a two instruction loop)
		;Start getting byte and status again in case we have
		;  to loop
;;;;	MAPF[2] SPEC[IOB-IN] D[IOD] ALU[NOTD] DEST[HOLD] LONG $
	MAPF[1] SPEC[IOB-OUT] D[MEM] MASK[10] DEST[HOLD] C550 $
		;MAPF[1] clears byte ready
		;Raise acknowledge.  Note that IOD was set up at the top
		;  of the loop to contain acknowledge bit (and some junk
		;  which the hardware will ignore)
		;Extract data byte from other status information
	MAPF[2] SPEC[IOB-OUT] ALU[0] DEST[IOD] C550 POPJ $
		;Drop acknowledge again.
		;WARNING: MAPF[2] must be in instruction at return
		;  address for this to work.
;	---


MBTCHECK:	MAPF[4] D[IOD] DEST[HOLD] $
	SPEC[IOB-IN] D[MEM] ROT[13.] C550 COND[-OBUS<0] JUMP[MBTCHECK] $
	  ;WAIT FOR FORMATTER IDLE.
	D[MEM] ROT[17.] C550 COND[-OBUS<0] JUMP[MBTERR] $
	  ;CHECK FOR ERROR STATUS.
	D[MEM] ROT[22.] C550 COND[OBUS<0] POPJ $
	  ;IF ENDX OF FILE NOT SEEN, RETURN FOR MORE, ELSE DONE.
	ALU[0] DEST[Q] NORM $ ;CLEAR LIGHTS TO INDICATE NO ERRORS.
MBTDNX: SPEC[IOB-OUT] ALU[0] DEST[DEV-ADR] $
		;Setup to display code in lights
	SPEC[IOB-OUT] MAPF[2] ALU[Q] $	;LOAD LIGHTS FROM Q, CLR SW FF'S
D1:	MAPF[4] SPEC[IOB-IN] $
	   ;CHECK START AND CONT SWITCHES.  RD NEXT FILE ON CONT
	MAPF[4] D[IOD] DEST[AR] $
	D[AR]  ROT[5] MASK[2] DEST[AR]
		COND[OBUS=0] JUMP[D1] CYLEN[LONG] $
		;WAIT FOR A SWITCH.
	D[AR] MASK[1] COND[-OBUS=0] JUMP[MSTART] C550 $
	   ;  ... START MAIN MICROCODE ON START SWITCH.
	SPEC[IOB-OUT] NORM $  ;CLEAR SWITCH FF'S
	MAPF[4] JUMP[MBOOT] CYLEN[LONG] $

MBTERR:	D[CONST 0] ALU[NOTD] DEST[Q] JUMP[MBTDNX] $
;	---

: MBSAVP	;RETURN TO OLD LOC. CTR.

] ;ENDX OF TELEX TAPE CODE

.DEFINE FOOLIST[] [ XLIST ] 
LIST
.REPEAT SLOWTAPE [.DEFINE FOOLIST[] [ LIST ] ]
FOOLIST

.REPEAT SLOWTAPE [ ;UCODE FOR BARE 800 BPI TAPE DRIVE


;TAPE READING AND WRITING CODE
; A-MEM USEAGE:
;		0	DISPATCH ADDR.
;		4	COPY OF HDWR CTRL REGISTER (WRITE)
;		5	READ ERROR FLAGS
;		6	TEMP WITHIN TRP2 (HOLDS TP PAR ERR FLG)
;			WHEN WRITING, HOLDS ODD-EVEN WC FLAG.

   ;727 - OBSOLETE VERSION OF READ
TAPERD:	D[CONST 22] ROT[6] DEST[IOD] SPEC[IOB-OUT] 
		NORM PUSHJ[TPRDGO] $
	D[MASK 17.] DEST[IR-ADR] PUSHJ[TRP2] NORM $
		;MOVE STATUS INTO AC.
	ALU[Q] DEST[AC] ACSEL[AC] MAPF[2] JUMP[MAIN] CYLEN[IOB-OUT] $

; TPRDGO -- CALLED AS TAPE MOTION IS STARTED.  WAITS FOR
;	FIRST GAP TO PASS.
	   ;FIRST SET "CTL WD SEL" TO 1 (SELECT TP RD DAT)
TPRDGO:	MAPF[2] D[CONST 2] ROT[36] DEST[IOD]
	  SPEC[IOB-OUT] CYLEN[IOB-OUT] $
	 ;WAIT 8.3MSEC FOR 45IPS TAPE (77MSEC IF AT BOT).
	 ; (GET 2*DELAY-COUNT)
	MAPF[4] D[CONST 73] ROT[9.] DEST[AR] CYLEN[IOB-OUT]
	  SPEC[IOB-IN] PUSHJ[TPBOTD] $  ;HANDLE BOT CASE.
	D[AR] ROT[35.] MASK[20.] DEST[AR] NORM $ ;GET DELAY-COUNT
	 ;IF FOLLOWING CYLEN IS MADE 1000, DMA XFERS LOSE.
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[.] C550 $
	SPEC[IOB-IN] D[CONST 40] ROT[14.] DEST[Q] NORM $ ;CLEAR DATA RDY FLAGI, GET TIMOUT COUNT IN Q
	MAPF[1] NORM ALU[0] DEST[5] DEST-A-MEM $ ;CLR ERROR REG
P1:	SPEC[IOB-IN]  C550 $ ;NOW WAIT FOR FIRST BYTE
	D[IOD] DEST[HOLD] MAPF[2] C550 $
	D[MEM] ROT[33] MASK[1] COND[-OBUS=0] C550 POPJ $
	ALU[Q-1] DEST[Q] COND[-OBUS=0] JUMP[P1] C550 $
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;TIMEOUT... STOP TAPE.
	MAPF[2] D[CONST 41] ROT[36] DEST[Q] JPOP[TNRP3] NORM $ ;ABORT 

	;IF WE ARE AT BOT, SET DELAY TIME FOR LARGE GAP.
TPBOTD:	D[IOD] MAPF[4] ROT[15.] DEST[Q] CYLEN[IOB-IN] $
	ALU[Q] COND[OBUS<0] POPJ C550 $ ;RET IF NOT BOT
TP3IDL:	D[CONST 42] ROT[12.] DEST[AR] NORM POPJ $ ;ABOUT 77MSEC

;READ A RECORD.  STORE UP TO C(IR-ADR) WORDS.
TRP2:	ALU[0] DEST[6] DEST-A-MEM PUSHJ[TRBYTE] CYLEN[LONG] $
	D[MEM] ROT[34] DEST[Q] PUSHJ[TRBYTE] CYLEN[LONG] $
	D[MEM] ROT[24] ALU[DORQ] DEST[Q] PUSHJ[TRBYTE] CYLEN[LONG] $
	D[MEM] ROT[14] ALU[DORQ] DEST[Q] PUSHJ[TRBYTE] CYLEN[LONG] $
	D[MEM] ROT[4] ALU[DORQ] DEST[Q] PUSHJ[TRBYTE] CYLEN[LONG] $
	D[IR] MASK[18.] ALU[D-1] DEST[IR-ADR] COND[OBUS18] JUMP[TRP2] C600 $
	D[MEM] MASK[4]  ALU[DORQ] DEST[MEMSTO] CYLEN[LONG] $
	D[16] DEST[Q] NORM$
	D[15] ALU[DORQ] DEST[Q] NORM $ ;GET ERROR FLG FOR WORD.
	ALU[Q] DEST[5] DEST-A-MEM NORM $
	D[MA] ALU[D+1] DEST[MA] JUMP[TRP2] CYLEN[LONG] $

;READ 1 BYTE.  IF ERROR, EOR, EOF, SET Q_2,HIGHEST LOC WRITTEN+1,1 & POP
; ONE OFF THE STACK AND RETURN.  IF BYTE SUCCESSFULLY
; READ, JUST RETURN WITH BYTE IN HOLD.
TRBYTE:	D[CONST 61.] LLOAD CYLEN[LONG] $
TRB2:	SPEC[IOB-IN] LOOP[TRB1] C550 $
	D[CONST 20] ROT[6] LLOAD C550 $
	LOOP[.] C550 $
	SPEC[IOB-IN] C550 $
	MAPF[1] D[AR] ROT[42] MASK[21]	; IS RECORD <4 CHRS (MEAN-
		COND[-OBUS=0] JUMP[TREOR] C550 $ ; ING END-OF-FILE) ?
	D[CONST 60] ROT[36] DEST[5] DEST-A-MEM NORM $ ;YES
	ALU[Q] DEST[AR] NORM $
	D[AR] ROT[28.] DEST[Q] JPOP[TRDONE] NORM $
TREOR:	ALU[Q] DEST[7] DEST-A-MEM NORM $ ;SAVE CHECK CHRS.
	D[MA] MASK[24] DEST[Q] NORM JPOP[TRDONE] $ ;ENDX OF REC.

TRB1:	D[IOD] ALU[NOTD] DEST[HOLD] MAPF[2] LONG $
	C550 $ ;GIVE DMA DEVICES A CHANCE AT THE BUS !!
	D[MEM] ROT[33] MASK[1] COND[-OBUS=0] JUMP[TRB2] C550 $
TRB3:	SPEC[IOB-IN] D[AR] ALU[D+1] DEST[AR] CYLEN[LONG] $
	MAPF[2] D[IOD] ALU[NOTD] DEST[HOLD] SPEC[IOB-IN] CYLEN[LONG] $
	MAPF[1] D[MEM] ROT[31] C550
	   COND[OBUS<0] JUMP[TRERR] $  ;TEST THE ERROR BIT.
TRB4:	D[MEM] MASK[10] DEST[HOLD] POPJ CYLEN[LONG] $

TRDONE:	D[CONST 0] DEST[IOD] SPEC[IOB-OUT] NORM $  ;STOP TAPE.
	 ;COMBINE ERROR CODE WITH MA AND RETURN (UPLEVEL).
	MAPF[2] CYLEN[IOB-OUT]  D[15] ALU[DORQ] DEST[Q] POPJ $

		;BYTE PARITY ERROR, Q_2, DOUBLE RETURN.
TRERR:	D[CONST 50] ROT[36] DEST[6] DEST-A-MEM 
	 NORM JUMP[TRB4] $  ;SET BIT 2 OF ERROR FLAGS.


TAPEMT:	;MTAPE FUNCTIONS.
	D[MA] DEST[Q] COND[OBUS=0] JUMP[TAPERW] C550 $
	D[CONST 5] ALU[D-Q] COND[OBUS=0] JUMP[TAPEFR] C550 $
	D[CONST 6] ALU[D-Q] COND[OBUS=0] JUMP[TAPEBR] C550 $
	D[CONST 1] ALU[D-Q] COND[OBUS=0] JUMP[TWREOF] C550 $
	JUMP[MAIN] $ ;UNKNOWN CODE -- TREAT AS NOP.
TWREOF:	ALU[0] DEST[MA] NORM PUSHJ[TP3IDL] $ ;SET FLG AND GET 
	D[CONST 0] DEST[6] DEST-A-MEM NORM JUMP[TWEOF] $ ; 3" GAP DLY CNT, THEN GO TO WRITE CODE.

TAPERW:	;REWIND
	D[CONST 6] ROT[6] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[2] CYLEN[IOB-OUT] ALU[0] DEST[IOD] SPEC[IOB-OUT] $
	MAPF[2] JUMP[MAIN] CYLEN[IOB-OUT] $

TAPEFR:	;SKIP FORWARD ONE RECORD.
	D[CONST 22] ROT[6] DEST[IOD] SPEC[IOB-OUT] 
		NORM PUSHJ[TPRDGO] $
	D[CONST 0] DEST[IR-ADR] PUSHJ[TRP2] NORM $
		;MOVE STATUS INTO AC.
	ALU[Q] DEST[AC] ACSEL[AC] MAPF[2] JUMP[MAIN] CYLEN[LONG] $
TAPEBR:	;SKIP BACKWARD ONE RECORD.
	D[CONST 2] ROT[6] DEST[IOD] SPEC[IOB-OUT] CYLEN[LONG] $
	MAPF[2] SPEC[IOB-IN] CYLEN[IOB-OUT] $
	D[IOD] ROT[18.] MASK[6] DEST[Q] MAPF[4] CYLEN[IOB-IN] $
	D[CONST 4] ALU[D&Q] COND[OBUS=0] JUMP[TBRLP] C550 $	;JUMP IF AT LP
	D[CONST 12] ROT[6] DEST[IOD] SPEC[IOB-OUT] 
		NORM PUSHJ[TPRDGO] $
	D[CONST 0] DEST[IR-ADR] PUSHJ[TRP2] NORM $
	ALU[Q] DEST[AC] ACSEL[AC] MAPF[2] JUMP[MAIN] NORM $

TAPERS:	;READ STATUS BITS FROM TAPE DRIVE.
	D[CONST 2] ROT[6] DEST[IOD] SPEC[IOB-OUT] 
		NORM $  ;; SELECT THE DRIVE.
	MAPF[2] CYLEN[IOB-OUT] SPEC[IOB-IN] $
	MAPF[4] D[IOD] ROT[18.] MASK[6] DEST[Q] CYLEN[IOB-IN] $
	D[MASK 6] ALU[D#Q] DEST[MEMSTO] NORM
		COND[-MA-AC] LBJUMP[SMAIN] $

TBRLP:	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[6] JUMP[MAIN] CYLEN[IOB-OUT] $


TAPENR:	;730, AC/COUNT.  READ WHOLE RECORD,
	;STORING UP TO COUNT WORDS STARTING AT EFF ADR.
	;IF AC<>0 RETURN STATUS AS FOR 727.
	 ;SWAP AC AND MA, THEN DO TAPERX.
	D[MA] DEST[O_AC MA] ACSEL[AC]  NORM JUMP[TAPERX] $ 

TAPERX:	;732 - (AC) IS START ADDR., E IS # OF WORDS TO READ.
	D[CONST 22] ROT[6] DEST[IOD] SPEC[IOB-OUT] 
		NORM PUSHJ[TPRDGO] $ ;GET TAPE STARTED.
	ALU[AC] ACSEL[AC] DEST[MA] PUSHJ[TRP2] NORM $ ;READ REC.
		;MOVE STATUS INTO AC.
	D[IR] COND[-OBUS18] JUMP[TNRP3] C550 $ ; WAS RECORD TOO LONG ?
	D[CONST 44] ROT[30.] ALU[DORQ] DEST[Q] NORM $ ;YES, SET BIT 3.
TNRP3:	ALU[Q] DEST[AC] ACSEL[AC] JPOP[MAIN] NORM $  ;NO, NOT TOO LONG.


TAPEWR:	;731, AC/ADR, E/+COUNT.  WRITE RECORD OF +COUNT
	; WORDS, DATA FROM ADR.
	;SET AC:=0 IF OPERATION COMPLETED SUCCESSFULLY.
	; SET AC:=<SETZ> + HIGHEST -10 ADR READ IF REACHED
	; EOT DURING OPERATION (CURRENTLY THIS IS THE ONLY
	; ERROR CONDITION.)

	ALU[0] DEST[AR] SPEC[IOB-IN] MAPF[2] CYLEN[IOB-OUT] 
	  PUSHJ[TPBOTD] $ ;GET 3.5 IN. DLY CNT IN AR IFF AT BOT
	D[MA] MASK[1] ALU[NOTD] DEST[6] DEST-A-MEM NORM $ ;SAVE LSB OF WC

 ;### AR HOLDING GOOD STUFF BETWEEN HERE AND TPWR2. #############

TWEOF:	;CLEAR FLAG WHICH WHEN DONE WILL SAY IF PASSED PHYSICAL EOT.
	ALU[0] DEST[5] DEST-A-MEM NORM $
	;TP WR CLK:=-270.
	D[CONST 73] ROT[24] DEST[Q] SHORT $
	D[CONST 62] ROT[16] ALU[DORQ] DEST[Q] NORM $
	D[CONST 1] ROT[41] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $
	;-CTL WD SEL:=1,1; TP WR DIRECT GO:=0.
	D[CONST 3] ROT[36] DEST[Q] MAPF[1] CYLEN[IOB-OUT] $
	D[CONST 1] ROT[11] ALU[DORQ] DEST[4] DEST-A-MEM NORM $
	D[14] DEST[IOD] SPEC[IOB-OUT] NORM $
			MAPF[4] CYLEN[IOB-OUT] $
	;SEND TP MR, TP CLEAR LPCC
	D[CONST 1] ROT[40] DEST[Q] NORM $
	D[CONST 1] ROT[32] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $
			MAPF[1] CYLEN[IOB-OUT] $
	;SET SWS, SLT.
	D[CONST 3] ROT[6] DEST[IOD] SPEC[IOB-OUT] NORM $
	;SET SFC, SWS, SLT.
	MAPF[2] D[CONST 23] ROT[6] DEST[IOD] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
	MAPF[2] CYLEN[IOB-OUT] D[CONST 44] ROT[11] DEST[Q] $ ;GET 10.1MSEC DLY

;#######  SEE ABOVE NOTE ABOUT AR ###############################

TPWR2:	D[AR] ALU[D+Q] DEST[AR] SHORT $ ;GET TOTAL DELAY
	;SPACE OVER GAP (10.1 MSEC, + ABOUT .077 SEC IFF AT BOT)
	 ;IF FOLLOWING CYLEN IS MADE 1000, DMA XFERS LOSE.
 	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[.] C550 $
	;START WRITE CLOCK.
	D[14] DEST[Q] SHORT $
	D[CONST 1] ROT[32] ALU[DORQ] DEST[4] DEST-A-MEM NORM $
	D[14] DEST[IOD] SPEC[IOB-OUT] NORM $
	D[MA] MASK[18.] DEST[AR]  MAPF[4] CYLEN[IOB-OUT]
		COND[OBUS=0] JUMP[TWEOF1] $ ;WRT FILE MARK ESCAPE
	;NEXT WORD.  AR:=+COUNT, AC:=ADR.
TWNW:	ALU[AC] ACSEL[AC] DEST[MA] NORM $
	FIXM1 $
	D[MEM] ROT[8] DEST[Q] PUSHJ[TWBYTE] NORM $
	D[MEM] ROT[20] DEST[Q] PUSHJ[TWBYTE] NORM $
	D[MEM] ROT[30] DEST[Q] PUSHJ[TWBYTE] NORM $
	D[MEM] ROT[40] DEST[Q] PUSHJ[TWBYTE] NORM $
	D[MEM] MASK[4] DEST[Q] PUSHJ[TWBYTE] NORM $
	ALU[AC+1] ACSEL[AC] DEST[AC] SHORT $
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[TWNW] C600 $
	;WAIT 3 BYTE TIMES, WRITE CRCC BYTE.
TWNW1:	
	D[CONST 50] DEST[Q] SPEC[IOB-IN] NORM $ ;GET CRCC BYTE
	MAPF[2] D[IOD] ROT[8] MASK[8] ; ...AND COMP. CERTAIN BITS.
	  ALU[D/#Q] DEST[HOLD] CYLEN[IOB-IN] $ 
	D[CONST 3] DEST[AR] PUSHJ[TWDLY] $
	D[MEM] DEST[Q] NORM $
	D[16] MASK[1] DEST[AR] NORM $
	D[AR] ROT[43] ALU[-D&Q] DEST[IOD] ;IF WC WAS ODD, WRITE THE
	  SPEC[IOB-IN] NORM PUSHJ[TWBYT1] $ ; CRCC WITH EVEN PAR.
	;WAIT 3 BYTE TIMES, SEND WARS TO WRITE LPCC.
	D[CONST 3] DEST[AR] PUSHJ[TWDLY] $
TWEOFX:	D[14] DEST[Q] SHORT $ ;PREPARE TO SEND WARS.
	D[CONST 1] ROT[11] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $
	;CLEAR TP WR CLK RUN, WARS.
TWEXIT:	D[14] DEST[Q] MAPF[4] CYLEN[IOB-OUT] $	;WARS ON.
	D[CONST 1] ROT[10] ALU[DORQ] DEST[Q] SHORT $
	D[CONST 1] ROT[32] ALU[-D&Q] DEST[4] DEST-A-MEM NORM $
	D[14] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[4] SPEC[IOB-IN] CYLEN[IOB-OUT] $	;WARS OFF, WIDTH SHORT + NORM + SHORT +IOB-OUT = 2.0US.
	;CHECK TO SEE IF REACHED EOT.
	D[IOD] DEST[Q] MAPF[4] CYLEN[IOB-IN] $
	D[CONST 1] ROT[18.] ALU[D&Q] COND[-OBUS=0] JUMP[TWEX1] $
	ALU[-1] DEST[5] NORM DEST-A-MEM $	;YES, SET FLAG.
TWEX1:	D[MA] MASK[18.] 	COND[OBUS=0] C550 JUMP[TWEOF2] $ ;WRT FILE MARK ESCAPE
	D[15] DEST[AC] ACSEL[AC] NORM $
TWEOF2:	 ;NOW DELAY FOR 7071 CYCLES (*C550 = 3.89MS = .175" OF TAPE).
	D[CONST 67] ROT[7] DEST[AR] NORM $
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[.] C550 $

	;CLEAR SWS, DESELECT TAPE, STOP MOTION.
	JUMP[TBRLP] $

    ;TAPEWR&TWBYTE.  WRITE BYTE IN Q.
TWBYTE:	D[MASK 8] ALU[D&Q] DEST[IOD] SPEC[IOB-IN] NORM $
TWBYT1:	D[IOD] DEST[Q] MAPF[4] CYLEN[IOB-IN] SPEC[IOB-OUT] $
	D[CONST 1] ROT[18.] ALU[D&Q] COND[OBUS=0] MAPF[14] JUMP[TWEOT] SPEC[IOB-IN] CYLEN[IOB-OUT] $
TWBLP:	D[IOD] ROT[24] DEST[Q] MAPF[2] CYLEN[IOB-IN] $
TWBLP1:	C550 $
	C550 $
	ALU[Q] COND[-OBUS<0] JUMP[TWBLP] SPEC[IOB-IN] C550 $
	POPJ MAPF[2] CYLEN[IOB-IN] $
	;EOT DETECTED, SET FLAG AND CONTINUE.
TWEOT:	D[IOD] ROT[24] DEST[Q] MAPF[2] CYLEN[IOB-IN] $
	ALU[-1] DEST[5] DEST-A-MEM JUMP[TWBLP1] NORM $

TWEOF1:	D[CONST 23] DEST[Q] NORM $ ;23 IS FILE MARK CHAR.
	D[CONST 1] ROT[43] ALU[DORQ] DEST[IOD]  ;SET BIT 0 IN ORDER TO
	 SPEC[IOB-IN] NORM PUSHJ[TWBYT1] $ ;WRITE IT WITH EVEN PARITY.
	D[CONST 7] DEST[AR] PUSHJ[TWDLY] NORM $ ;SKIP 7 FRAMES.
	NORM JUMP[TWEOFX] $ ;COMPLETE THE RECORD AS USUAL.

    ;TAPEWR&TWDLY.  WRITE EVEN PARITY 0S UNTIL TP BYTE DAT COMES ON C(AR) TIMES
TWDLY:	D[CONST 1] ROT[43] DEST[IOD] SPEC[IOB-OUT] NORM $
	PUSHJ[TWBLP] MAPF[14] SPEC[IOB-IN] CYLEN[IOB-OUT] $
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[TWDLY] C600 $
	POPJ NORM $

;BOOTSTRAP LOADER FOR MACROCODE.

MBSAVP:	;SAVE LOC. CTR.

: 5000
MBOOT:	JUMP[5001] CYLEN[LONG] $
	ALU[0] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
	D[CONST 1] ROT[18.] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
	D[CONST 7] DEST[DEV-ADR] CYLEN[LONG] $
		;SELECT DEVICE 7.
	D[CONST 22] ROT[6] DEST[IOD] SPEC[IOB-OUT]
	   NORM PUSHJ[TPRDGO] $  ;SET "SELECT" AND "FORWARD MOTION"
	ALU[0] DEST[MA HI-ABS-MA] NORM $
P2:	PUSHJ[BYTE] CYLEN[LONG] $
	D[MEM] ROT[34] DEST[Q] PUSHJ[BYTE] CYLEN[LONG] $
	D[MEM] ROT[24] ALU[DORQ] DEST[Q] PUSHJ[BYTE] CYLEN[LONG] $
	D[MEM] ROT[14] ALU[DORQ] DEST[Q] PUSHJ[BYTE] CYLEN[LONG] $
	D[MEM] ROT[4] ALU[DORQ] DEST[Q] PUSHJ[BYTE] CYLEN[LONG] $
	D[MEM] MASK[4]  ALU[DORQ] DEST[MEMSTO] CYLEN[LONG] $
	D[MA] ALU[D+1] DEST[MA] JUMP[P2] CYLEN[LONG] $
CCLR:	ALU[0] DEST[MA] NORM $
	ALU[0] DEST[MEMSTO] NORM $
	D[MA] ALU[D+1] DEST[MA] NORM $
	D[MA] MASK[18.] COND[-OBUS=0] JUMP[. - 2] C600 $
	POPJ NORM $

BYTE:	D[CONST 16] LLOAD CYLEN[LONG] $
B2:	SPEC[IOB-IN] LOOP[B1] CYLEN[LONG] $
	D[CONST 10] ROT[6] LLOAD CYLEN[LONG] $
	LOOP[.] CYLEN[LONG] $
	SPEC[IOB-IN] CYLEN[LONG] $
	MAPF[1] D[AR] ROT[43] MASK[21]
		COND[OBUS=0] JUMP[DONE] CYLEN[LONG] $
B5:	SPEC[IOB-IN] D[CONST 0] DEST[AR] CYLEN[LONG] $
	MAPF[2] D[IOD] ALU[NOTD] DEST[HOLD] CYLEN[LONG] $
	D[MEM] ROT[33] MASK[1] COND[-OBUS=0] JUMP[B5] CYLEN[LONG] $
	JUMP[B3] CYLEN[LONG] $
B1:	D[IOD] ALU[NOTD] DEST[HOLD] MAPF[2] CYLEN[LONG] $
	D[MEM] ROT[33] MASK[1] COND[-OBUS=0] JUMP[B2] CYLEN[LONG] $
B3:	SPEC[IOB-IN] D[AR] ALU[D+1] DEST[AR] CYLEN[LONG] $
	MAPF[2] D[IOD] ALU[NOTD] DEST[HOLD] SPEC[IOB-IN] CYLEN[LONG] $
	MAPF[1] D[MEM] ROT[31] C550
	   COND[OBUS<0] JUMP[MBERR] $ ;TEST FOR GOOD PARITY IN BYTE.
	D[MEM] MASK[10] DEST[HOLD] POPJ CYLEN[LONG] $

MBERR:	JUMP[DONE] $ ;;D[CONST 0] DEST[MA] NORM JUMP[DONE] $

DONE:	D[CONST 0] DEST[IOD] SPEC[IOB-OUT] CYLEN[LONG] $
D1:	MAPF[2] D[CONST 0] DEST[DEV-ADR] SPEC[IOB-IN] CYLEN[LONG] $
	   ;CHECK START AND CONT SWITCHES.  RD NEXT FILE ON CONT
	MAPF[4] D[IOD] ROT[5] MASK[2] DEST[AR]
		COND[OBUS=0] JUMP[D1] CYLEN[LONG] $
	   ;  ... START MAIN MICROCODE ON START SWITCH.
	D[AR] MASK[1] COND[-OBUS=0] JUMP[MSTART] C550 $
	SPEC[IOB-OUT] NORM $
	MAPF[4] JUMP[MBOOT] CYLEN[LONG] $

: MBSAVP	;RETURN TO OLD LOC. CTR.

] ;END OF SLOW TAPE CODE

.DEFINE FOOLIST[] [ XLIST ]
LIST
.REPEAT 125TAPE [.DEFINE FOOLIST[] [ LIST ] ]
FOOLIST

.REPEAT 125TAPE [ ;UCODE FOR BARE 800 BPI, 125 IPS TAPE DRIVE

;TAPE DELAY CONSTANTS

 .REPEAT 0 [	;45 IPS VALUES
TP-RD-STRT-DLY = 59.
TP-BOT-DLY = 34.
TP-GAP-DETECT-DLY = 61.
TP-EOR-DLY = 18.
TP-WR-STRT-DLY = 36.
TP-MBOOT-GAP-DLY = 14.

 ]

 .REPEAT 1 [	;125 IPS VALUES
TP-RD-STRT-DLY = 20.
TP-BOT-DLY = 12.
TP-GAP-DETECT-DLY = 22.
TP-EOR-DLY = 7.
TP-WR-STRT-DLY = 13.
TP-MBOOT-GAP-DLY = 9.

 ]

;TAPE READING AND WRITING CODE
; A-MEM USAGE:
;		0	DISPATCH ADDR.
TPMODE =	1       ;MODE BITS (SEE BELOWS)
;		4	COPY OF HDWR CTRL REGISTER (WRITE)
;		5	READ ERROR FLAGS
;		6	TEMP WITHIN TRP2 (HOLDS TP PAR ERR FLG)
;			WHEN WRITING, HOLDS ODD-EVEN WC FLAG.
;
;Mode bits:
;	Bit 35		Industry compatable mode (4 bytes/word)
;			(Otherwise, PDP-10 dump mode)
;
;PDP-10 Dump mode
;  ------------------------------------------------------------------------
; |               |               |               |               |        |
; |    Byte 1     |    Byte 2     |    Byte 3     |    Byte 4     |        |
; |               |               |               |               |        |
;  ------------------------------------------------------------------------
;								  |        |
;								  V        V
;							  -----------------
;							 |        |  Bits  |
;							 |    0   |  32:35 |
;							 |     Byte 5      |
;							  -----------------
;
;Industry Compatable Mode
;  ------------------------------------------------------------------------
; |               |               |               |               |        |
; |    Byte 1     |    Byte 2     |    Byte 3     |    Byte 4     |   0    |
; |               |               |               |               |        |
;  ------------------------------------------------------------------------
;


   ;727 - OBSOLETE VERSION OF READ
TAPERD:	D[CONST 22] ROT[6] DEST[IOD] SPEC[IOB-OUT] 
		NORM PUSHJ[TPRDGO] $
	D[MASK 17.] DEST[IR-ADR] PUSHJ[TRP2] NORM $
		;MOVE STATUS INTO AC.
	ALU[Q] DEST[AC] ACSEL[AC] MAPF[2] JUMP[MAIN] CYLEN[IOB-OUT] $

; TPRDGO -- CALLED AS TAPE MOTION IS STARTED.  WAITS FOR
;	FIRST GAP TO PASS.

TPRDGO:	MAPF[2] D[CONST 2] ROT[35. - 5] DEST[Q] C800 $
	   ;FIRST SET "CTL WD SEL" TO 1 (SELECT TP RD DAT)
	SPEC[IOB-OUT] D[CONST 1] ROT[35. - 28.] ALU[DORQ]  DEST[IOD] NORM $
	   ;..ALSO SET THE "IN" BIT.

	 ;NOW WAIT 8.3MSEC FOR 45IPS TAPE (38MSEC IF AT BOT).
	 ; (GET 2*DELAY-COUNT)
	MAPF[4] D[CONST TP-RD-STRT-DLY] ROT[9.] DEST[AR] CYLEN[IOB-OUT]
	  SPEC[IOB-IN] PUSHJ[TPBOTD] $  ;HANDLE BOT CASE.
	D[AR] ROT[35.] MASK[20.] DEST[AR] NORM $ ;GET DELAY-COUNT
	 ;IF FOLLOWING CYLEN IS MADE 1000, DMA XFERS LOSE.
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[.] C550 $

	SPEC[IOB-IN] D[CONST 40] ROT[14.] DEST[Q] NORM $ 
	  ;CLEAR DATA RDY FLAGI, GET TIMOUT COUNT IN Q
	MAPF[1] NORM ALU[0] DEST[5] DEST-A-MEM $ ;CLR ERROR REG
P1:	SPEC[IOB-IN]  C550 $ ;NOW WAIT FOR FIRST BYTE
	D[IOD] DEST[HOLD] MAPF[2] C550 $
	D[MEM] ROT[33] MASK[1] COND[-OBUS=0] C550 POPJ $
	ALU[Q-1] DEST[Q] COND[-OBUS=0] JUMP[P1] C550 $
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;TIMEOUT... STOP TAPE.
	MAPF[2] D[CONST 41] ROT[36] DEST[Q] JPOP[TNRP3] NORM $ ;ABORT 

	;IF WE ARE AT BOT, SET DELAY TIME FOR LARGE GAP.
TPBOTD:	D[IOD] MAPF[4] ROT[15.] DEST[Q] CYLEN[IOB-IN] $
	ALU[Q] COND[OBUS<0] POPJ C550 $ ;RET IF NOT BOT
TP3IDL:	D[CONST TP-BOT-DLY] ROT[12.] DEST[AR] NORM POPJ $ ;ABOUT 77MSEC

;READ A RECORD.  STORE UP TO C(IR-ADR) WORDS.

TRP2:	ALU[0] DEST[6] DEST-A-MEM NORM PUSHJ[TRBA] $
	JUMP[TRP2B] NORM $	;Already have first byte, Jump into loop
;This loop is repeated for each word.  At end-of-record, TRBYTE terminates
;the loop by popping off return address and returning to the routine that
;requested that a record be read.
TRP2A:	ALU[0] DEST[6] DEST-A-MEM PUSHJ[TRBYTE] NORM $
TRP2B:	D[MEM] ROT[34] DEST[Q] PUSHJ[TRBYTE] NORM $
	D[MEM] ROT[24] ALU[DORQ] DEST[Q] PUSHJ[TRBYTE] NORM $
	D[10 + TPMODE] MASK[1] NORM COND[-OBUS=0] JUMP[TRP2D] $
		;While we have the time to decide, handle last
		;byte of industry-compatable mode differently
	D[MEM] ROT[14] ALU[DORQ] DEST[Q] PUSHJ[TRBYTE] NORM $
	D[MEM] ROT[4] ALU[DORQ] DEST[Q] PUSHJ[TRBYTE] NORM $
	D[IR] MASK[18.] ALU[D-1] DEST[IR-ADR] COND[OBUS18] JUMP[TRP2A] C600 $
		;Decrement count.  If word count exhausted, finish reading
		;record but don't write anything.
	D[MEM] MASK[4]  ALU[DORQ] DEST[MEMSTO] NORM $
		;Note that it is presumed here that the operating system has
		;already dealt with page faults before we get here.
TRP2C:	D[16] DEST[Q] NORM$
	D[15] ALU[DORQ] DEST[Q] NORM $ ;GET ERROR FLG FOR WORD.
	ALU[Q] DEST[5] DEST-A-MEM NORM $
	D[MA] ALU[D+1] DEST[MA] JUMP[TRP2A] NORM $
;Special for industry compatable mode.
TRP2D:	D[MEM] ROT[14] ALU[DORQ] DEST[Q] PUSHJ[TRBYTE] NORM $
		;Deposit byte 3, get byte 4
	D[IR] MASK[18.] ALU[D-1] DEST[IR-ADR] COND[OBUS18] JUMP[TRP2A] C600 $
		;Decrement count.  If word count exhausted, finish reading
		;record but don't write anything.
	D[MEM] ROT[4] ALU[DORQ] DEST[MEMSTO] NORM JUMP[TRP2C] $
		;Deposit byte 4 (last) and store away.  Rejoin regular program.
		
;READ 1 BYTE.  IF ERROR, EOR, EOF, SET Q_2,HIGHEST LOC WRITTEN+1,1 & POP
; ONE OFF THE STACK AND RETURN.  IF BYTE SUCCESSFULLY
; READ, JUST RETURN WITH BYTE IN HOLD.
TRBYTE:	D[CONST TP-GAP-DETECT-DLY] LLOAD NORM $
TRB2:	SPEC[IOB-IN] LOOP[TRB1] C550 $
	D[CONST TP-EOR-DLY] ROT[6] LLOAD C550 $
	LOOP[.] C550 $
	SPEC[IOB-IN] C550 $
	MAPF[1] D[AR] ROT[42] MASK[21]	; IS RECORD <4 CHRS (MEAN-
		COND[-OBUS=0] JUMP[TREOR] C550 $ ; ING END-OF-FILE) ?
	D[CONST 60] ROT[36] DEST[5] DEST-A-MEM NORM $ ;YES
	ALU[Q] DEST[AR] NORM $
	D[AR] ROT[28.] DEST[Q] JPOP[TRDONE] NORM $
TREOR:	ALU[Q] DEST[7] DEST-A-MEM NORM $ ;SAVE CHECK CHRS.
	D[MA] MASK[24] DEST[Q] NORM JPOP[TRDONE] $ ;ENDX OF REC.

TRB1:	D[IOD] ALU[NOTD] DEST[HOLD] MAPF[2] LONG $
	C550 $ ;GIVE DMA DEVICES A CHANCE AT THE BUS !!
	D[MEM] ROT[33] MASK[1] COND[-OBUS=0] JUMP[TRB2] C550 $
TRBA:	SPEC[IOB-IN] D[AR] ALU[D+1] DEST[AR] NORM $
	MAPF[2] SPEC[IOB-IN] D[IOD] ALU[NOTD] DEST[HOLD] C800 $
	MAPF[1] D[MEM] ROT[31] C550
	   COND[OBUS<0] JUMP[TRERR] $  ;TEST THE ERROR BIT.
TRB4:	D[MEM] MASK[10] DEST[HOLD] POPJ NORM $

TRDONE:	D[CONST 0] DEST[IOD] SPEC[IOB-OUT] NORM $  ;STOP TAPE.
	 ;COMBINE ERROR CODE WITH MA AND RETURN (UPLEVEL).
	MAPF[2] CYLEN[IOB-OUT]  D[15] ALU[DORQ] DEST[Q] POPJ $

		;BYTE PARITY ERROR - CODE TO AMEM(6), CONT.
TRERR:	D[CONST 50] ROT[36] DEST[6] DEST-A-MEM 
	 NORM JUMP[TRB4] $  ;SET BIT 2 OF ERROR FLAGS.


TAPEMT:	;MTAPE FUNCTIONS.
	D[MA] DEST[Q] COND[OBUS=0] JUMP[TAPERW] C550 $
		;Start rewinding
	D[CONST 5] ALU[D-Q] COND[OBUS=0] JUMP[TAPEFR] C550 $
		;Forward space one record
	D[CONST 6] ALU[D-Q] COND[OBUS=0] JUMP[TAPEBR] C550 $
		;Backspace space one record
	D[CONST 1] ALU[D-Q] COND[OBUS=0] JUMP[TWREOF] C550 $
		;Write EOF
	D[CONST 50] ALU[D-Q] COND[OBUS=0] JUMP[TPSETIND] C550 $
		;Code ?, set industry compatable mode.
	D[CONST 51] ALU[D-Q] COND[OBUS=0] JUMP[TPSETDMP] C550 $
		;Code ?, set PDP-10 dump mode.
	JUMP[MAIN] $ ;UNKNOWN CODE -- TREAT AS NOP.
TWREOF:	ALU[0] DEST[MA] NORM PUSHJ[TP3IDL] $ ;SET FLG AND GET 
	D[CONST 0] DEST[6] DEST-A-MEM NORM JUMP[TWEOF] $ ; 3" GAP DLY CNT, THEN GO TO WRITE CODE.

TAPERW:	;REWIND
	D[CONST 6] ROT[6] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[2] CYLEN[IOB-OUT] ALU[0] DEST[IOD] SPEC[IOB-OUT] $
	MAPF[2] JUMP[MAIN] CYLEN[IOB-OUT] $

TAPEFR:	;SKIP FORWARD ONE RECORD.
	D[CONST 22] ROT[6] DEST[IOD] SPEC[IOB-OUT] 
		NORM PUSHJ[TPRDGO] $
	D[CONST 0] DEST[IR-ADR] PUSHJ[TRP2] NORM $
		;MOVE STATUS INTO AC.
	ALU[Q] DEST[AC] ACSEL[AC] MAPF[2] JUMP[MAIN] CYLEN[LONG] $

TAPEBR:	;SKIP BACKWARD ONE RECORD.
	D[CONST 2] ROT[6] DEST[IOD] SPEC[IOB-OUT] CYLEN[LONG] $
	MAPF[2] SPEC[IOB-IN] CYLEN[IOB-OUT] $
	D[IOD] ROT[18.] MASK[6] DEST[Q] MAPF[4] CYLEN[IOB-IN] $
	D[CONST 4] ALU[D&Q] COND[OBUS=0] JUMP[TBRLP] C550 $	;JUMP IF AT LP
	D[CONST 12] ROT[6] DEST[IOD] SPEC[IOB-OUT] 
		NORM PUSHJ[TPRDGO] $
	D[CONST 0] DEST[IR-ADR] PUSHJ[TRP2] NORM $
	ALU[Q] DEST[AC] ACSEL[AC] MAPF[2] JUMP[MAIN] NORM $

TPSETIND:	;Set industry compatable mode
	D[10 + TPMODE] DEST[Q] NORM $	;Stupid A-MEM
	D[CONST 1] ALU[DORQ] DEST[TPMODE] DEST-A-MEM JUMP[MAIN] NORM $
		;Set appropriate bit and done

TPSETDMP:	;Set PDP-10 Dump Mode
	D[10 + TPMODE] DEST[Q] NORM $	;Stupid A-MEM
	D[CONST 1] ALU[-D&Q] DEST[TPMODE] DEST-A-MEM JUMP[MAIN] NORM $
		;Clear industry compatable mode and done.

TAPERS:	;READ STATUS BITS FROM TAPE DRIVE.
	D[CONST 2] ROT[6] DEST[IOD] SPEC[IOB-OUT] 
		NORM $  ;; SELECT THE DRIVE.
	MAPF[2] CYLEN[IOB-OUT] SPEC[IOB-IN] $
	MAPF[4] D[IOD] ROT[18.] MASK[6] DEST[Q] CYLEN[IOB-IN] $
	D[MASK 6] ALU[D#Q] DEST[MEMSTO] NORM
		COND[-MA-AC] LBJUMP[SMAIN] $

TBRLP:	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[6] JUMP[MAIN] CYLEN[IOB-OUT] $


TAPENR:	;730, AC/COUNT.  READ WHOLE RECORD,
	;STORING UP TO COUNT WORDS STARTING AT EFF ADR.
	;IF AC<>0 RETURN STATUS AS FOR 727.
	;SWAP AC AND MA, THEN DO TAPERX.
	D[MA] DEST[O_AC MA] ACSEL[AC]  NORM JUMP[TAPERX] $ 

TAPERX:	;732 - (AC) IS START ADDR., E IS # OF WORDS TO READ.
	D[CONST 22] ROT[6] DEST[IOD] SPEC[IOB-OUT] 
		NORM PUSHJ[TPRDGO] $ ;GET TAPE STARTED.
	ALU[AC] ACSEL[AC] DEST[MA] PUSHJ[TRP2] NORM $ ;READ REC.
		;MOVE STATUS INTO AC.
	D[IR] COND[-OBUS18] JUMP[TNRP3] C550 $ ; WAS RECORD TOO LONG ?
	D[CONST 44] ROT[30.] ALU[DORQ] DEST[Q] NORM $ ;YES, SET BIT 3.
TNRP3:	ALU[Q] DEST[AC] ACSEL[AC] JPOP[MAIN] NORM $  ;NO, NOT TOO LONG.


TAPEWR:	;731, AC/ADR, E/+COUNT.  WRITE RECORD OF +COUNT
	; WORDS, DATA FROM ADR.
	;SET AC:=0 IF OPERATION COMPLETED SUCCESSFULLY.
	; SET AC:=<SETZ> + HIGHEST -10 ADR READ IF REACHED
	; EOT DURING OPERATION (CURRENTLY THIS IS THE ONLY
	; ERROR CONDITION.)

	ALU[0] DEST[AR] SPEC[IOB-IN] MAPF[2] CYLEN[IOB-OUT] 
	  PUSHJ[TPBOTD] $ ;GET 3.5 IN. DLY CNT IN AR IFF AT BOT
	D[MA] MASK[1] ALU[NOTD] DEST[6] DEST-A-MEM NORM $ ;SAVE LSB OF WC

 ;### AR HOLDING GOOD STUFF BETWEEN HERE AND TPWR2. #############

TWEOF:	;CLEAR FLAG WHICH WHEN DONE WILL SAY IF PASSED PHYSICAL EOT.
	ALU[0] DEST[5] DEST-A-MEM NORM $

	;TP WR CLK:=-97.
	D[CONST 76] ROT[24] DEST[Q] SHORT $
	D[CONST 37] ROT[16] ALU[DORQ] DEST[Q] NORM $
	D[CONST 1] ROT[41] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $

	;-CTL WD SEL:=1,1; DISABLE TP I WARS
	D[CONST 3] ROT[35. - 5] DEST[Q] MAPF[1] CYLEN[IOB-OUT] $
	D[CONST 1] ROT[35. - 26.] ALU[DORQ] DEST[4] DEST-A-MEM NORM $
	D[14] DEST[IOD] SPEC[IOB-OUT] NORM $
			MAPF[4] CYLEN[IOB-OUT] $
	;SEND TP MR, TP CLEAR LPCC
	D[CONST 1] ROT[40] DEST[Q] NORM $
	D[CONST 1] ROT[32] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $
			MAPF[1] CYLEN[IOB-OUT] $
	;SET SWS, SLT.
	D[CONST 3] ROT[6] DEST[IOD] SPEC[IOB-OUT] NORM $
	;SET SFC, SWS, SLT.
	MAPF[2] D[CONST 23] ROT[6] DEST[IOD] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
	MAPF[2] CYLEN[IOB-OUT] D[CONST TP-WR-STRT-DLY] ROT[9.] DEST[Q] $ ;GET 10.1MSEC DLY

;#######  SEE ABOVE NOTE ABOUT AR ###############################

TPWR2:	D[AR] ALU[D+Q] DEST[AR] SHORT $ ;GET TOTAL DELAY
	;SPACE OVER GAP (10.1 MSEC, + ABOUT .077 SEC IFF AT BOT)
	 ;IF FOLLOWING CYLEN IS MADE 1000, DMA XFERS LOSE.
 	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[.] C550 $
	;START WRITE CLOCK.
	D[14] DEST[Q] SHORT $
	D[CONST 3] ROT[35. - 10.]  ALU[DORQ] DEST[4] DEST-A-MEM NORM $
	D[14] DEST[IOD] SPEC[IOB-OUT] NORM $
	D[MA] MASK[18.] DEST[AR]  MAPF[4] CYLEN[IOB-OUT]
		COND[OBUS=0] JUMP[TWEOF1] $ ;WRT FILE MARK ESCAPE
	;NEXT WORD.  AR:=+COUNT, AC:=ADR.
TWNW:	ALU[AC] ACSEL[AC] DEST[MA] NORM $
	NORM $ ;WAIT FOR FIRST MEMORY FETCH.
TWNWL:	D[MEM] ROT[8] DEST[Q] PUSHJ[TWBYTE] NORM $
	D[MEM] ROT[20] DEST[Q] PUSHJ[TWBYTE] NORM $
	D[MEM] ROT[30] DEST[Q] PUSHJ[TWBYTE] NORM $
	D[10 + TPMODE] MASK[1] C550 COND[-OBUS=0] JUMP[TWNWI] $
		;Check for industry compatable mode while we have time.
	D[MEM] ROT[40] DEST[Q] PUSHJ[TWBYTE] NORM $
  ;Write last byte of PDP-10 dump mode and decide what's left to do.
	D[MEM] MASK[4] DEST[Q] PUSHJ[TWBYTE] NORM $
	ALU[AC+1] ACSEL[AC] DEST[AC MA] SHORT $
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[TWNWL] C600 $
   ;DONE. WRITE A BLANK FRAME.
	D[CONST 1] DEST[AR] NORM PUSHJ[TWDLY] $
    ;PREPARE TO WRITE CRCC BYTE.
	D[CONST 50] DEST[Q] SPEC[IOB-IN] NORM JUMP[TWNW1X] $ ;GET CRCC BYTE
;Write last byte of industry compatable mode and decide what's left to do.
TWNWI:	D[MEM] ROT[40] DEST[Q] PUSHJ[TWBYTE] NORM $
		;Write byte 4, the last byte in this mode
	ALU[AC+1] ACSEL[AC] DEST[AC MA] SHORT $
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[TWNWL] C600 $
   ;DONE. WRITE A BLANK FRAME.
	D[CONST 1] DEST[AR] NORM PUSHJ[TWDLY] $
	D[CONST 50] DEST[Q] SPEC[IOB-IN] NORM $ ;GET CRCC BYTE
;Previous three lines are same as normal mode and are included separately for
;speed considerations.
TWNW1X:	MAPF[2] D[IOD] ROT[8] MASK[8] ; ...AND COMP. CERTAIN BITS.
	  ALU[D/#Q] DEST[HOLD] CYLEN[IOB-IN] $ 
	D[CONST 2] DEST[AR] NORM PUSHJ[TWDLY] $
	  ;WRITE 2 MORE BLANK FRAMES.
	D[MEM] DEST[Q] NORM $
	D[16] MASK[1] DEST[AR] NORM $
	D[AR] ROT[43] ALU[-D&Q] DEST[IOD] ;IF WC WAS ODD, WRITE THE
	  SPEC[IOB-IN] NORM PUSHJ[TWBYT1] $ ; CRCC WITH EVEN PAR.
	;WAIT 3 BYTE TIMES, SEND WARS TO WRITE LPCC.
	D[CONST 3] DEST[AR] PUSHJ[TWDLY] $
TWEOFX:	D[14] DEST[Q] SHORT $ ;PREPARE TO SEND WARS.
	D[CONST 1] ROT[11] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $
	;CLEAR TP WR CLK RUN, WARS.
TWEXIT:	D[14] DEST[Q] MAPF[4] CYLEN[IOB-OUT] $	;WARS ON.
	D[CONST 1] ROT[10] ALU[DORQ] DEST[Q] SHORT $
	D[CONST 1] ROT[32] ALU[-D&Q] DEST[4] DEST-A-MEM NORM $
	D[14] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[4] SPEC[IOB-IN] CYLEN[IOB-OUT] $	;WARS OFF, WIDTH SHORT + NORM + SHORT +IOB-OUT = 2.0US.
	;CHECK TO SEE IF REACHED EOT.
	D[IOD] DEST[Q] MAPF[4] CYLEN[IOB-IN] $
	D[CONST 1] ROT[18.] ALU[D&Q] COND[-OBUS=0] JUMP[TWEX1] $
	ALU[-1] DEST[5] NORM DEST-A-MEM $	;YES, SET FLAG.
TWEX1:	D[MA] MASK[18.] 	COND[OBUS=0] C550 JUMP[TWEOF2] $ ;WRT FILE MARK ESCAPE
	D[15] DEST[AC] ACSEL[AC] NORM $
TWEOF2:	 ;NOW DELAY FOR 7071 CYCLES (*C550 = 3.89MS = .175" OF TAPE).
	D[CONST 67] ROT[7] DEST[AR] NORM $
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[.] C550 $

	;CLEAR SWS, DESELECT TAPE, STOP MOTION.
	JUMP[TBRLP] $


    ;TAPEWR&TWBYTE.  WRITE BYTE IN Q.
TWBYTE:	D[MASK 8] ALU[D&Q] DEST[IOD] SPEC[IOB-IN] NORM $
TWBYT1:	D[IOD] DEST[Q] MAPF[4] CYLEN[IOB-IN] SPEC[IOB-OUT] $
	D[CONST 1] ROT[18.] ALU[D&Q] COND[OBUS=0] MAPF[14] JUMP[TWEOT] SPEC[IOB-IN] CYLEN[IOB-OUT] $
TWBLP:	D[IOD] ROT[21.] DEST[Q] MAPF[2] CYLEN[IOB-IN] $
	ALU[Q] COND[-OBUS<0] C600 POPJ $
	C550 $
TWBLP1:	SPEC[IOB-IN] NORM JUMP[TWBLP] $

	;EOT DETECTED, SET FLAG AND CONTINUE.
TWEOT:	ALU[-1] DEST[5] DEST-A-MEM JUMP[TWBLP1] NORM $

TWEOF1:	D[CONST 23] DEST[Q] NORM $ ;23 IS FILE MARK CHAR.
	D[CONST 1] ROT[43] ALU[DORQ] DEST[IOD]  ;SET BIT 0 IN ORDER TO
	 SPEC[IOB-IN] NORM PUSHJ[TWBYT1] $ ;WRITE IT WITH EVEN PARITY.
	D[CONST 7] DEST[AR] PUSHJ[TWDLY] NORM $ ;SKIP 7 FRAMES.
	NORM JUMP[TWEOFX] $ ;COMPLETE THE RECORD AS USUAL.

    ;TAPEWR&TWDLY.  WRITE EVEN PARITY 0S UNTIL TP BYTE DAT COMES ON C(AR) TIMES
TWDLY:	D[CONST 1] ROT[43] DEST[IOD] SPEC[IOB-OUT] NORM $
	PUSHJ[TWBLP] MAPF[14] SPEC[IOB-IN] CYLEN[IOB-OUT] $
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[TWDLY] C600 $
	POPJ NORM $

;BOOTSTRAP LOADER FOR MACROCODE.

MBSAVP:	;SAVE LOC. CTR.

: 5000
MBOOT:	JUMP[5001] CYLEN[LONG] $
	ALU[0] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
	D[CONST 1] ROT[18.] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
	D[CONST 7] DEST[DEV-ADR] CYLEN[LONG] $
		;SELECT DEVICE 7.
	D[CONST 22] ROT[6] DEST[IOD] SPEC[IOB-OUT]
	   NORM PUSHJ[TPRDGO] $  ;SET "SELECT" AND "FORWARD MOTION"
	ALU[0] DEST[MA HI-ABS-MA] NORM PUSHJ[B3] $
	 ;MAKE MA RIGHT AND GET FIRST BYTE.
	NORM JUMP[P2A] $
P2:	PUSHJ[BYTE] NORM $
P2A:	D[MEM] ROT[34] DEST[Q] PUSHJ[BYTE] NORM $
	D[MEM] ROT[24] ALU[DORQ] DEST[Q] PUSHJ[BYTE] NORM $
	D[MEM] ROT[14] ALU[DORQ] DEST[Q] PUSHJ[BYTE] NORM $
	D[MEM] ROT[4] ALU[DORQ] DEST[Q] PUSHJ[BYTE] NORM $
	D[MEM] MASK[4]  ALU[DORQ] DEST[MEMSTO] NORM $
	D[MA] ALU[D+1] DEST[MA] JUMP[P2] NORM $
CCLR:	ALU[0] DEST[MA] NORM $
	ALU[0] DEST[MEMSTO] NORM $
	D[MA] ALU[D+1] DEST[MA] NORM $
	D[MA] MASK[18.] COND[-OBUS=0] JUMP[. - 2] C600 $
	POPJ NORM $

BYTE:	D[CONST TP-MBOOT-GAP-DLY] LLOAD NORM $
B2:	SPEC[IOB-IN] LOOP[B1] C550 $
	D[CONST 10] ROT[6] LLOAD CYLEN[LONG] $
	LOOP[.] CYLEN[LONG] $
	SPEC[IOB-IN] CYLEN[LONG] $
	MAPF[1] D[AR] ROT[43] MASK[21]
		COND[OBUS=0] JUMP[DONE] CYLEN[LONG] $
B5:	SPEC[IOB-IN] D[CONST 0] DEST[AR] NORM $
	MAPF[2] D[IOD] ALU[NOTD] DEST[HOLD] CYLEN[C800] $
	D[MEM] ROT[33] MASK[1] COND[-OBUS=0] JUMP[B5] C550 $
	JUMP[B3] NORM $
B1:	D[IOD] ALU[NOTD] DEST[HOLD] MAPF[2] CYLEN[LONG] $
	D[MEM] ROT[33] MASK[1] COND[-OBUS=0] JUMP[B2] C550 $
B3:	SPEC[IOB-IN] D[AR] ALU[D+1] DEST[AR] NORM $
	MAPF[2] SPEC[IOB-IN] D[IOD] ALU[NOTD] DEST[HOLD] C800 $
	MAPF[1] D[MEM] ROT[31] C550
	   COND[OBUS<0] JUMP[MBERR] $ ;TEST FOR GOOD PARITY IN BYTE.
	D[MEM] MASK[10] DEST[HOLD] POPJ NORM $

MBERR:	JUMP[DONE] $ ;;D[CONST 0] DEST[MA] NORM JUMP[DONE] $

DONE:	D[CONST 0] DEST[IOD] SPEC[IOB-OUT] CYLEN[LONG] $
D1:	MAPF[2] D[CONST 0] DEST[DEV-ADR] SPEC[IOB-IN] CYLEN[LONG] $
	   ;CHECK START AND CONT SWITCHES.  RD NEXT FILE ON CONT
	MAPF[4] D[IOD] ROT[5] MASK[2] DEST[AR]
		COND[OBUS=0] JUMP[D1] CYLEN[LONG] $
	   ;  ... START MAIN MICROCODE ON START SWITCH.
	D[AR] MASK[1] COND[-OBUS=0] JUMP[MSTART] C550 $
	SPEC[IOB-OUT] NORM $
	MAPF[4] JUMP[MBOOT] CYLEN[LONG] $

: MBSAVP	;RETURN TO OLD LOC. CTR.

] ;END OF SLOW TAPE CODE


.DEFINE FOOLIST[] [ XLIST ]
LIST

;FLOATING POINT, KA10 STYLE.
;NONDISPATCH CODE.
.DEFINE CFPLOW[] [D[AR] ACSEL[AC+1] DEST[AC] JUMP[FPLOW] NORM ]
.DEFINE JINSEXP[] [D[AR] ROT[27.] DEST[Q] JUMP[INSEX1] NORM ]
.DEFINE CINSEXP[] [D[AR] ROT[27.] DEST[Q] PUSHJ[INSEX1] NORM ]
.DEFINE CFDS[] [D[MEM] ALU[D#AC] ACSEL[AC] DEST[AR] PUSHJ[FDS1] NORM]
UFA1:	ALU[AC] ACSEL[AC] DEST[0 AR] DEST-A-MEM PUSHJ[FADSUB] NORM $
	D[10] ACSEL[AC] DEST[AR O_AC] SHORT $
	D[AR] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] $
	.PAIR	;: 6460		;.PAIR
DFN1:	ACSEL[AC] ALU[NOTAC] DEST[AC] JUMP[. + 2] NORM $
	ACSEL[AC] ALU[0-AC] DEST[AC] SHORT $
	D[MEM] DEST[Q] SHORT $
	D[MASK 9] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
	D[AR] MASK[27.] ALU[DORQ] DEST[MEMSTO] MEMSTMA $
FSCZAP:	ALU[0] DEST[MA AC] ACSEL[AC] SPEC[MA_PC] JUMP[MAIN1] NORM $
FSC1:	D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
	D[MASK 8] ROT[27.] ACSEL[AC] ALU[-D&AC] DEST[AC] COND[-OBUS<0] JUMP[FSC2] C550 $
	D[MASK 9] ALU[D#Q] DEST[Q AR] SHORT $
	D[MASK 8] ROT[27.] ACSEL[AC] ALU[DORAC] DEST[AC] SHORT $
FSC2:	D[MA] MASK[18.] ALU[D+Q] DEST[IR-ADR] SHORT $
	ALU[0] DEST[Q] PUSHJ[NRMLIZ] NORM $
	CINSEXP $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
FAOS1: FAOS5:
	ACSEL[AC] ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
	DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
FAOS2:	ACSEL[AC] ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
	CFPLOW $
FAOS3:	ACSEL[AC] ALU[AC] DEST[AR] NORM $
	D[CONST 11] DEST[DEV-ADR] SHORT $
	ACSEL[AC] ALU[AC] DEST[0] DEST-A-MEM PUSHJ[FADSUB] NORM $
	D[10] ACSEL[AC] DEST[MEMSTO O_AC] MEMST $
FAOS4:	ACSEL[AC] ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
	ACSEL[AC] ALU[AC] DEST[MEMSTO] MEMST $

FMP1: FMP5:
	ACSEL[AC] ALU[AC] DEST[AR] PUSHJ[FM] NORM $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
FMP2:	ACSEL[AC] ALU[AC] DEST[AR] PUSHJ[FM] NORM $
	CFPLOW $
FMP3:	ACSEL[AC] ALU[AC] DEST[AR] NORM $
	D[CONST 11] DEST[DEV-ADR] SHORT $
	ACSEL[AC] ALU[AC] DEST-A-MEM PUSHJ[FM] DEST[0] NORM $
	D[10] ACSEL[AC] DEST[MEMSTO O_AC] MEMST $
FMP4:	ACSEL[AC] ALU[AC] DEST[AR] PUSHJ[FM] NORM $
	ACSEL[AC] ALU[AC] DEST[MEMSTO] MEMST $

.DEFINE DIVTST[] [D[MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]
FD5:	D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] NORM $
FD1:	DIVTST $
	CFDS $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
;LONG MODE FLOATING DIVIDE.
FD2:	DIVTST $
	;AR.0,IR.35:=XOR(DIVIDEND SIGN,DIVISOR SIGN).
	D[MEM] ALU[D#AC] ACSEL[AC] DEST[AR] SHORT $
	D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
	;FLUSH SIGN & EXPONENT FROM DIVIDEND LOW
	ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
	D[AR] ROT[9] DEST[AC] ACSEL[AC+1] SHORT $
	D[MASK 27.] ROT[9] ALU[D&AC] ACSEL[AC+1] DEST[AC] SHORT $
	;+ FORM OF DIVIDEND TO (AC,A-MEM[1]).  ORIG. DIVIDEND TO AR.
	ALU[AC] ACSEL[AC] DEST[AR] COND[-OBUS<0] JUMP[FD2A] CYLEN[C450] $
	ALU[0-AC] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[. + 2] C550 $
	ALU[NOTAC] ACSEL[AC] DEST[AC] JUMP[. + 2] SHORT $
	ALU[0-AC] ACSEL[AC] DEST[AC] JUMP[FD2B] NORM $
FD2A:	ALU[AC] ACSEL[AC+1] DEST[1] DEST-A-MEM NORM $
FD2B:	PUSHJ[FD] NORM $	;FOR NOW.
	;AC+1 GETS 0 IF REMAINDER = 0.
	ALU[0] ACSEL[AC+1] DEST[AC] JUMP[FD2D] NORM $	;FOR NOW.
.REPEAT 0 [
	D[11] ALU[AC] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[FD2D] C550 $
	;SETUP EXPONENT OF REMAINDER.
	D[AR] DEST[Q] SHORT $
	;A-MEM[2] HAS ORIGINAL (DIVIDEND HOW)-(DIVISOR).
	D[12] COND[-OBUS<0] JUMP[. + 2] C550 $
	D[CONST 1] ALU[Q-D] DEST[Q] SHORT $
	D[CONST 26.] ALU[Q-D] DEST[Q] COND[OBUS18] JUMP[FD2C] C600 $
.DEFINE SWAPAC[] [
	ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
	D[AR] ACSEL[AC] DEST[AR O_AC] SHORT $
	D[AR] ACSEL[AC+1] DEST[AC] SHORT $
]
	;SWAP QUOTIENT (AC) AND REMAINDER (AC+1)
	SWAPAC
	;INSERT EXPONENT INTO REMAINDER.
	ALU[Q] DEST[AR] PUSHJ[INSEXP] NORM $
	SWAPAC
];REPEAT 0,
FD2D:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
FD2C:	ALU[0] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
FD3:	DIVTST $
	ALU[AC] ACSEL[AC] DEST[0] DEST-A-MEM PUSHJ[FDS] NORM $
	D[10] ACSEL[AC] DEST[MEMSTO O_AC] MEMST $
FD4:	DIVTST $
	CFDS $
	ALU[AC] ACSEL[AC] DEST[MEMSTO] MEMST $
;HERE ON DIVISOR=0.  SET NO DIVIDE, OVF,FLOV,RETURN.
FPNDIV:	D[PC] DEST[Q] SHORT $
	D[CONST 1] ROT[23.] ALU[DORQ] DEST[Q] PUSHJ[SETFOV] NORM $
	DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

;NORMALIZE DOUBLE PRECISION NUMBER IN AC,Q WHOSE EXPONENT
; IS IN IR-ADR.  LEAVE EXPONENT IN AR, NORMALIZED NUMBER IN AC,Q.
; IF NUMBER IS 0, LEAVE 0 IN AR,AC, AND Q.
	;A. RETURN IMMEDIATELY IF 0.
.DEFINE CNORM[] [D[AR] ACSEL[AC] DEST[AC] PUSHJ[NRMLIZ] NORM]
NRMLIZ:	ALU[QORAC] ACSEL[AC] DEST[AR] COND[OBUS=0] POPJ C550 $
	;B. CHECK FOR MANTISSA OVERFLOW, MOVE EXPONENT TO AR.
	ALU[AC] DEST[AR] ACSEL[AC] PUSHJ[NORMOV] NORM $
	D[IR] MASK[18.] COND[-OBUS=0] POPJ C550 $
	;C. LEFT SHIFT UNTIL NORMALIZED.
	ALU[AC] ACSEL[AC] COND[OBUS<0] JUMP[NEGNOR] CYLEN[C450] $
POSNOR:	D[CONST 1] ROT[26.] ALU[D&AC] ACSEL[AC] COND[-OBUS=0] POPJ C550 $
	D[AR] ALU[D-1] DEST[AR] SHORT $
	ALU[SH-AC] ACSEL[AC] MASK[2] DEST[D6] JUMP[POSNOR] NORM $
NEGNOR:	D[CONST 1] ROT[26.] ALU[D&AC] ACSEL[AC] COND[OBUS=0] JUMP[NN1] C550 $
	D[AR] ALU[D-1] DEST[AR] SHORT $
	ALU[SH-AC] ACSEL[AC] MASK[2] DEST[D6] JUMP[NEGNOR] NORM $
NN1:	D[MASK 27.] ALU[D&AC] ACSEL[AC] COND[-OBUS=0] POPJ C550 $
	D[CONST 1] ROT[26.] ALU[DORAC] ACSEL[AC] DEST[AC] SHORT $
	D[AR] ALU[D+1] DEST[AR] POPJ NORM $

;CHECK FOR MANTISSA OVERFLOW INTO EXPONENT FIELD.  CALL WITH
; AR&AC,Q: # TO NORMALIZE, IR-ADR: IT'S EXPONENT.
; LEAVE EXPONENT IN AR.  SET IR-ADR=0 IF NO OVERFLOW.  SET IR-ADR<>0
; IF OVERFLOW, AND NORMALIZE.
NORMOV:	;M.O.<=> [AR0<>AR8] OR [(AR8=1)AND(AR9-35=0)]
	D[AR] ROT[8] ALU[D#AC] ACSEL[AC] COND[OBUS<0] JUMP[NOVYES] C550 $
	D[MASK 27.] ALU[D&AC] ACSEL[AC] COND[-OBUS=0] JUMP[NOVNO] C550 $
	D[CONST 1] ROT[27.] ALU[D&AC] ACSEL[AC] COND[OBUS=0] JUMP[NOVNO] C550 $
NOVYES:	ALU[SH-AC] ACSEL[AC] MASK[1] DEST[D4] SHORT $
	D[IR] MASK[18.] ALU[D+1] DEST[AR IR-ADR] POPJ NORM $
NOVNO:	D[IR] MASK[18.] DEST[AR] SHORT $
	ALU[0] DEST[IR-ADR] POPJ NORM $

;INSERT EXPONENT IN AR INTO WORD IN AC.
;SET FLOV,FLUN,OVF FLAGS AS REQUIRED.
;PRESERVES AR, CLOBBERS Q.
INSEXP:	D[AR] ROT[27.] DEST[Q] NORM $
INSEX1:	D[MASK 8.] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
	ALU[Q#AC] ACSEL[AC] DEST[AC] SHORT $
	D[AR] COND[OBUS18] JUMP[EXPUF] C550 $
	D[AR] MASK[10.] ROT[28.] COND[OBUS=0] POPJ C550 $
	D[PC] DEST[Q] SHORT $
SETFOV:	D[CONST 11] ROT[32.] ALU[DORQ] DEST[CRYOV] POPJ NORM $
EXPUF:	D[PC] DEST[Q] SHORT $
	D[CONST 1] ROT[24.] ALU[DORQ] DEST[Q] JUMP[SETFOV] NORM$

;FLOATING ADD AC&AR TO MEM.  RESULT, NORMALIZED AND ROUNDED
; IF REQUIRED IN AC,Q.
.DEFINE BLEXPS[DES1 TIME DES2] [
	D[MASK 8] ROT[27.] ALU[DORAC] ACSEL[AC] DEST[DES2] COND[OBUS<0] JUMP[. + 2] C550 $
	D[MASK 8] ROT[27.] ALU[-D&AC] ACSEL[AC] DEST[DES2] SHORT $
	D[MEM] DEST[Q] COND[OBUS<0] JUMP[. + 2] C550 $
	D[MASK 8] ROT[27.] ALU[-D&Q] DEST[DES1] JUMP[. + 2] NORM $
	D[MASK 8] ROT[27.] ALU[DORQ] DEST[DES1] CYLEN[TIME] $
];BLEXPS
	;A. + FORM EXPONENT OF AC,MEM RTO AR,Q RESP.
FADSUB:	D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
FADSU1:	D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS1] C550 $
	D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
FS1:	D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
	D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS2] C550 $
	D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
	;B. COMPUTE DIFFERENCE, SWAP OPRANDS IF AC HAS LARGER EXP.
	;   LEAVE + DIFFERENCE IN Q, DIFF -1 IN LOOP CTR.
	;   LEAVE LARGER EXPONENT IN IR-ADR.
FS2:	ALU[Q] DEST[IR-ADR] SHORT $
	D[AR] ALU[Q-D] DEST[Q] COND[-OBUS<0] JUMP[FS3] C600 $
	D[AR] DEST[IR-ADR] SHORT $
	D[MEM] ACSEL[AC] DEST[HOLD O_AC] NORM $
	ALU[0-Q] DEST[Q] NORM $
FS3:	ALU[Q-1] DEST[AR] LLOAD NORM $
	;C. BLANK EXPONENTS.
	BLEXPS[HOLD NORM AC]
	;D. IF DELTA EXPONENTS >62., AC GOES TO OBLIVION.
	D[AR] ALU[D+1] DEST[Q] COND[OBUS=0] JUMP[FS5] C600 $
	D[CONST 63.] ALU[Q-D] COND[OBUS<0] JUMP[FS4] C600 $
	ALU[0] DEST[AC] ACSEL[AC] SHORT $
	ALU[0] DEST[Q] JUMP[FS5] NORM $
FS4:	ALU[0] DEST[Q] SHORT $
	ACSEL[AC] ALU[SH-AC] DEST[D4] MASK[1] LOOP [.] NORM $
	;E. ADD.
FS5:	D[MEM] ALU[D+AC] ACSEL[AC] DEST[AR] SHORT $
	;F. NORMALIZE RESULT.
	D[IR] ACSEL[AC] DEST[AC] SHORT $	;CHECK FOR UFA
	D[CONST 1] ROT[40] ALU[D&AC] ACSEL[AC] COND[OBUS=0] JUMP[UFANOR] C550 $
	;ENTER HERE WITH RESULT IN AR,Q, EXP IN IR-ADR.
FPNAR:	CNORM $				;NOPE, NORMALIZE
	;G. ROUND IF NECESSARY, INSERT EXPONENT INTO
	;   HIGH ORDER WORD OF RESULT.
	ALU[Q] COND[-OBUS<0] DEST[HOLD] JUMP[NORND] CYLEN[C450] $
	D[IR] DEST[Q] NORM $
	D[CONST 1] ROT[35] ALU[D&Q] COND[OBUS=0] JUMP[NORND] C550 $
	D[MEM] DEST[Q] SHORT $
	D[MASK 43] ALU[D&Q] COND[-OBUS=0] JUMP[YESRND] C550 $
	ALU[AC] ACSEL[AC] COND[OBUS<0] JUMP[INSEXP] CYLEN[C450] $
YESRND:	D[AR] DEST[IR-ADR] SHORT $
	ALU[AC+1] ACSEL[AC] DEST[AC] PUSHJ[NRMLIZ] NORM $
	JINSEXP $
NORND:	D[MEM] DEST[Q] JUMP[INSEXP] NORM $
	;UFA NORMALIZATION -- ONLY ON MANTISSA OVERFLOW.
UFANOR:	D[AR] ALU[DORQ] ACSEL[AC] DEST[AC] COND[OBUS=0] POPJ C600 $
	D[AR] ACSEL[AC] DEST[AC] PUSHJ[NORMOV] NORM $
	JINSEXP $

;SETUP LOW ORDER FP RESULT, STORE BOTH IN AC,AC+1
;ENTER WITH LOW WORD IN MEM, HIGH WORD IN AC, HIGH
;WORD'S EXPONENT IN AR&AC+1.
FPLOW:	D[CONST 27.] ACSEL[AC+1] ALU[AC-D] DEST[AC AR] SHORT $
	D[CONST 1] ROT[7] ACSEL[AC+1] ALU[D&AC] COND[-OBUS=0] JUMP[ZLOW] C550 $
	D[MEM] ROT[27.] MASK[27.] DEST[Q] COND[OBUS=0] JUMP[ZLOW] C550 $
	D[AR] ROT[27.] ACSEL[AC+1] DEST[AC] SHORT $
	D[MASK 8] ROT[27.] ALU[D&AC] ACSEL[AC+1] DEST[AC] SHORT $
	ACSEL[AC+1] ALU[QORAC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
ZLOW:	ACSEL[AC+1] ALU[0] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

;FLOATING MULTIPLY.  AC&AR BY MEM.
FM:	;A. SUM OF + FORM EXPONENTS -128.+1 TO IR-ADR.  +1 BECAUSE 28
	; STEPS ARE USED TO PROVIDE ONE GUARD DIGIT.
	D[AR] MASK[9] ROT[9] DEST[Q AR] NORM$
	D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM1] C550 $
	D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
FM1:	D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
	D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM2] C550 $
	D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
FM2:	D[AR] ALU[D+Q] CARRY DEST[Q] SHORT $	;+1. FOR GUARD DIGIT.
	D[CONST 1] ROT[7] ALU[Q-D] DEST[IR-ADR] SHORT $
	;B. BLANK EXPONENTS.
	BLEXPS[Q SHORT AR]
	ALU[0] DEST[AC] ACSEL[AC] PUSHJ[TESMUL] NORM $ ;28. STEPS.
	ALU[Q] DEST[AR] SHORT $	;FLUSH SIGN IN LO WD.
	D[AR] ALU[D+Q] DEST[Q] SHORT $
	ALU[AC] ACSEL[AC] DEST[AR] JUMP[FPNAR] NORM $
;28. STEP INTEGER MULTIPLY FOR USE BY FM.
TESMUL:	D[CONST 27.] LLOAD NORM $	;LOOP 28 TIMES
	JUMP[DOMUL1] NORM $	;TEST.

;SHORT STYLE FLOATING DIVIDE AC BY MEM.
; XOR OF DIVISOR&DIVIDEND SIGNS IN AR BIT 0.
FDS:	D[MEM] ALU[D#AC] ACSEL[AC] DEST[AR] SHORT $
FDS1:	D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
	ALU[AC] ACSEL[AC] DEST[AR] COND[-OBUS<0] JUMP[. + 2] CYLEN[C450] $
	ALU[0-AC] ACSEL[AC] DEST[AC] SHORT $
	ALU[0] DEST[1] DEST-A-MEM NORM $
	;FALLS THROUGH...

;DIVIDE, DIVIDEND HOW IN AC, LOW IN A-MEM[1]. DIVISOR IN MEM.
; BOTH IN POSITIVE FORM.  IR.35=XOR(DIVIDEND SIGN,DIVISOR SIGN).
; HOW DIVIDEND IN AR IN ORIGINAL (MAY BE <0) FORM.
FD:	;A. PUT DIVISOR IN + FORM, GET DIVISOR EXPONENT.
	;.1 SHUFFLE IR.35 INTO A-MEM.
	D[IR] MASK[18.] DEST[4] DEST-A-MEM NORM $
	D[MEM] DEST[Q] COND[-OBUS<0] JUMP[. + 2] C550 $
	D[MEM] ALU[0-D] DEST[Q HOLD] NORM $
	D[MEM] ROT[9] MASK[8] DEST[IR-ADR] NORM $
	D[MASK 8] ROT[27.] ALU[-D&Q] DEST[HOLD] NORM $
	;B. FETCH AND BLANK HOW DIVIDEND EXPONENT.
	D[AR] ROT[9] MASK[8] DEST[Q] NORM $
	D[AR] COND[-OBUS<0] JUMP[. + 2] C550 $
	D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
	D[MASK 8] ROT[27.] ALU[-D&AC] ACSEL[AC] DEST[AC] SHORT $
	;C. COMPUTE RESULTANT EXPONENT.
	D[IR] MASK[18.] ALU[Q-D] DEST[Q] SHORT $
	D[CONST 1] ROT[7] ALU[D+Q] DEST[IR-ADR] NORM $
	;D. MOVE LOW DIVIDEND TO Q.
	D[11] DEST[Q] SHORT $
	;E. IF DIVISOR<=DIVIDEND,  SHIFT DIVIDEND RIGHT, INC
	; RESULTANT EXPONENT.  SAVE DIFF. IN A-MEM[2] FOR LONG MODE.
	D[MEM] ALU[AC-D] ACSEL[AC] DEST[2] DEST-A-MEM COND[-OBUS<0] JUMP[FDAD] C600 $
	;F. SHIFT DIVIDEND RIGHT BY 8 SO RESULT WILL BE
	; NORMALIZED AFTER ROUNDING.  28. STEP DIVIDE WILL
	; FIX THIS.
FDSHFT:	D[CONST 7] LLOAD NORM $
	ALU[SH-AC] ACSEL[AC] MASK[2] DEST[D4] LOOP[.] NORM $
	;GET 1. EXP TO A-MEM[4], 2. SIGN XOR TO IR-ADR.
	D[AR] DEST[5] DEST-A-MEM NORM $
	D[IR] DEST[AR] SHORT $
	D[14] DEST[IR-ADR] SHORT $
	D[AR] DEST[4] DEST-A-MEM NORM $
	D[15] DEST[AR] SHORT $
	PUSHJ[DODIV2] NORM $	;36. STEP.  RESULT HAS SIGNS ADJUSTED.
	;G. SAVE REMAINDER IN A-MEM[1], PUT QUOTIENT IN AC, 0 IN Q.
	ALU[AC] ACSEL[AC] DEST[1] DEST-A-MEM NORM $
	ALU[Q] ACSEL[AC] DEST[AC] SHORT $
	ALU[0] DEST[Q] SHORT $
	;H. PREPARE TO ROUND 29. BIT RESULT.
	ALU[SH-AC] ACSEL[AC] MASK[1] DEST[D4] SHORT $
	D[14] DEST[IR-ADR] SHORT $	;MOVE EXP FOR FPNAR.
	ALU[AC] ACSEL[AC] DEST[AR] JUMP[FPNAR] NORM $
    ;HERE WHEN DIVIDEND IS >= DIVISOR.  SHIFT DIVIDEND RIGHT
    ; AND INCREMENT RESULTANT AC.  THIS WILL ALLOW DIVIDE TO
    ; SUCCEED IF BOTH DIVISOR & DIVIDEND WERE NORMALIZED
    ; AND DIVISOR <> 0.
FDAD:	ALU[SH-AC] ACSEL[AC] MASK[2] DEST[D4] SHORT $
	D[IR] MASK[18.] ALU[D+1] DEST[IR-ADR] JUMP[FDSHFT] NORM $
.REPEAT TYMNET [.DEFINE FOOLIST[] [ LIST ] ]
FOOLIST

.REPEAT TYMNET [

;TYMNET INTERFACE.

;A-MEM USAGE.
; 0: STANDARD. 1: STATE OF OUTPUT FFS (SEE CFTNET)
; 2: OUTPUT COROUTINE ADR (LO 6 BITS)
; 3: INPUT COROUTINE ADR (LO 6 BITS)
; 4: CURRENT -10 WORD BEING OUTPUT (FOR STATE 1 ONLY)
; 5: CURRENT -10 WORD BEING ASSEMBLED ON INPUT (STATE 1)
; 6: IOWD FOR PACKET CURRENTLY BEING READ
; 7: B0-2, STATE OF MAP BEFORE INT; B3-35, INP REG AT INT START

;MAIN MEMORY LOCATIONS:
; 2000/	KEY:	0		;FLAGS
; 2200/	IRING: BLOCK 200	;INPUT (TO HOST) RING
; 2400/ ORING: BLOCK 400	;OUTPUT (FROM HOST) RING
; 2005/ HIRP:  0	;HOST IRING PTR (TAKER)
; 2006/ BIRP:  0	;BASE IRING PTR (PUTTER)
; 2011/ HORP:  0	;HOST ORING PTR (PUTTER)
; 2012/ BORP:  0	;BASE ORING PTR (TAKER)

;DR11C FLAG NAMES.  (FIELD VALUES).
;THE ACTUAL DEFINITIONS ARE IN CFDEF.SLO
;TNODIBN=2	;OUTPUT DONE ROTATE AMOUNT (INPUT) = REQ B.
;TNODIFS=2	;OUTPUT DONE INTERRUPT FF SUBSEL = REQ B.
;TNIRIBN=3	;INPUT READY ROTATE AMOUNT (INPUT) = REQ A.
;TNIRIFS=4	;INPUT READY INTERRUPT FF SUBSEL = REQ A.
;TNODOBN=6	;OUTPUT DONE ROTATE AMOUNT (OUTPUT) = CSR1.
;TNODOBNPO=7
;TNIROBN=7	;INPUT READY ROTATE AMOUNT (OUTPUT) = CSR0.
;TNIROBNPO=10

.DEFINE TNOCEC[] [ ;SEND 0 BYTE IF ESCAPE WORD (-1) JUST SENT.
	D[14] ROT[34] MASK[20] DEST[Q] NORM $
	D[MASK 20] ALU[D#Q] COND[-OBUS=0] JUMP[. + 3] C550 $
	ALU[0] DEST[Q] PUSHJ[TNSEND] NORM $
	D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
]
.DEFINE GBORP[] [
	D[CONST 12] DEST[Q] PUSHJ[TNRCW] NORM $
]
.DEFINE GHORP[] [
	D[CONST 11] DEST[Q] PUSHJ[TNRCW] NORM $
]
.DEFINE GBIRP[] [
	D[CONST 6] DEST[Q] PUSHJ[TNRCW] NORM $
]
.DEFINE GHIRP[] [
	D[CONST 5] DEST[Q] PUSHJ[TNRCW] NORM $
]


;HERE TO SERVICE INPUT READY OR OUTPUT DONE INTERRUPT BY
; TYMNET INTERFACE.
	;SAVE MAP STATE IN A-MEM[7].0-2 & TURN MAP OFF.
TNI:	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] NORM PUSHJ[MAPOFF] $
	D[IR] MASK[3] DEST[AR] MAPF[10] CYLEN[IOB-OUT] $	;MAPOFF NEEDS MAPF, CYLEN.
	D[AR] ROT[41] DEST[Q] NORM $
	D[CONST 6] DEST[DEV-ADR] SPEC[IOB-IN] NORM $ ;BACK TO 6 FOR TN

	;SAVE INPUT REG IN A-MEM[7].
	D[IOD] MASK[41] DEST[AR] CYLEN[IOB-IN] $
	D[AR] ALU[DORQ] DEST[Q 7] DEST-A-MEM NORM $
	D[CONST 1] ROT[TNODIBN] ALU[D&Q] COND[OBUS=0] JUMP[TNI1] C550 $
	D[CONST 71] ROT[6] DEST[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
	D[12] ALU[DORQ] COND[OBUS<0] JUMP[. + 2] MAPF[TNODIFS] C550 $	;OUTPUT DONE.
	D[12] ALU[DORQ] SDISP C550 $	;OUTPUT DONE.
TNI0:	D[17] DEST[Q] NORM $	;RESTORE INP REG
TNI1:	D[CONST 1] ROT[TNIRIBN] ALU[D&Q] COND[OBUS=0] JUMP[TNI2] C550 $
	D[17] ROT[34] MASK[20] DEST[Q] PUSHJ[BITREV] NORM $
	D[CONST 71] ROT[6] DEST[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
	D[13] ALU[DORQ] COND[OBUS<0] JUMP[. + 2] MAPF[TNIRIFS] CYLEN[C500] $	;INPUT READY.
	D[13] ALU[DORQ] SDISP CYLEN[C500] $	;INPUT READY.
TNI2:	D[17] ROT[3] MASK[3] DEST[IOD] NORM $
	ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] JUMP[MPOFF1] NORM $	;ENDS UP AT MAIN.

;VARIOUS SUBROUTINES.
;Q LOADED WITH 16. BIT WORD TO SEND, SHIFTED LEFT BY 8.
TNSEND:	ALU[Q] DEST[AR] NORM $
	D[AR] ROT[34] DEST[Q] PUSHJ[BITREV] NORM $
	D[AR] ROT[8] DEST[Q] SHORT $
	D[MASK 16.] ROT[8] ALU[D&Q] DEST[AR] NORM $
	D[MASK 8] DEST[Q] PUSHJ[DEV6ST1] NORM $
	;CLEAR THEN SET INPUT READY FLAG TO DR11C.
	D[MASK 43] ROT[TNIROBNPO] DEST[Q] PUSHJ[DEV6CL] NORM $
	D[CONST 1] ROT[TNIROBN] DEST[AR] NORM JUMP[DEV6ST2] $
;NO OUTPUT TO DO.  DO NOT CHANGE TNIROBN, SET A-MEM FLAG FOR
; CLOCK ROUTINE.
TNORE:	ALU[-1] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
;READ WORD FROM BASE-HOST COMMUNICATION AREA, LOCATION 20XX;
; Q HAS XX.
TNRCW:	D[CONST 20] ROT[6] ALU[DORQ] DEST[MA] NORM $
	FIXM0 POPJ $

;HERE WHEN INPUT RING FULL.  SET CLOCK FLAG AND RETURN WITHOUT
; SETTING TNODOBN.
TNIRF:	ALU[-1] DEST[3] JUMP[TNI2] DEST-A-MEM NORM $
;CLEAR THEN SET TNODOBN.
TNCASODOF:
	D[MASK 43] ROT[TNODOBNPO] DEST[Q] PUSHJ[DEV6CL] NORM $
	D[CONST 1] ROT[TNODOBN] DEST[AR] NORM JUMP[DEV6ST2] $

.REPEAT SLOWTAPE [

;REVERSE RIGHTMOST 16. BITS IN Q.  LEAVES RESULT IN Q&AR.
; CLOBBERS IR, MEM.
BITREV:	ALU[Q] DEST[AR] SHORT $
	D[CONST 17] LLOAD NORM $
	D[AR] ROT[23] DEST[AR] SHORT $
	ALU[0] DEST[Q HOLD] NORM $
	D[CONST 1] DEST[IR-ALL] NORM $
BRLP:	D[AR] ROT[1] DEST[AR] COND[-OBUS<0] JUMP[BRLP1] C550 $
	D[IR] ALU[QORD] DEST[Q] SHORT $
BRLP1:	D[IR] ROT[1] DEST[IR-ALL] LOOP[BRLP] NORM $
	ALU[Q] DEST[AR] POPJ NORM $

 ] ;SLOWTAPE

.REPEAT 1 - SLOWTAPE [

BITREV:	D[MASK 20] ALU[D&Q] DEST[Q AR] NORM POPJ $

 ]

: 7100
;********** OUTPUT DONE CO-ROUTINE.
;A-MEM[4] = ROTATED -10 WORD WITH -11 WORD JUST SENT IN 12-27.
;STATE 0: FETCH NEXT -10 WORD OR QUIT IF RING EMPTY.
TNOC0:	GBORP
	D[MEM] DEST[AR] NORM $
TNOC0A:	GHORP
	D[AR] DEST[Q] NORM $
	D[MEM] ALU[D-Q] COND[OBUS=0] JUMP[TNORE] C600 $
	D[CONST 24] ROT[6] ALU[D+Q] DEST[MA] NORM $
	FIXM0 $
	D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
	D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
;CLOCK RESTARTS COROUTINE HERE.
TNOC2:	TNOCEC
;STATE 1: SEND LOW ORDER HALF OF -10 WORD.
	D[14] ROT[20] DEST[Q] NORM $
	ALU[Q] DEST[4] PUSHJ[TNSEND] DEST-A-MEM NORM $
	D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
	TNOCEC
	GBORP
	D[MEM] ALU[D+1] DEST[Q] NORM $
	D[MASK 8] ALU[D&Q] DEST[AR MEMSTO] JUMP[TNOC0A] CYLEN[MEMSTO] $

;********** INPUT READY CO-ROUTINE.
; A-MEM[5] HAS CURRENT INPUT WORD BEING ASSEMBLED.
;STATE 0: AWAITING START OF NEXT MESSAGE.

TNIC0:	D[CONST 2] ROT[9] DEST[MA] NORM $ ;ADDRESS OF KEY IN MAIN MEM.
	ALU[0] DEST[MEMSTO] NORM $ ;CLEAR KEY AT START OF EVERY MESSAGE
	D[AR] DEST[Q 5] DEST-A-MEM NORM $
	D[CONST 1] ROT[17] ALU[D&Q] COND[OBUS=0] JUMP[TNIC0A] C550 $
;DATA PACKET MESSAGE.
	D[AR] ROT[34] MASK[7] DEST[Q] SHORT $
	D[CONST 5] ALU[D+Q] DEST[AR] SHORT $
	D[AR] ROT[42] MASK[18.] DEST[6] DEST-A-MEM NORM $
	D[15] DEST[AR] SHORT $
;READ MSG.  A-MEM[6]:=# -10 WORDS IN MESSAGE.
; AR:=FIRST -11 WORD IN MESSAGE.
TNICRM:
	GBIRP
	D[16] ROT[18.] ALU[0-D] DEST[Q] NORM $
	D[MEM] MASK[18.] ALU[QORD] DEST[6] DEST-A-MEM NORM $
;STATE 1: HO 16 BITS OF WORD ARRIVES.
TNIC1:	D[AR] ROT[24] DEST[5] DEST-A-MEM NORM $
	GHIRP
	D[16] ALU[D+1] DEST[Q] NORM $
	D[MASK 7] ALU[D&Q] DEST[Q] SHORT $
	D[MEM] ALU[D-Q] COND[OBUS=0] JUMP[TNIRF] C600 $
	PUSHJ[TNCASODOF] NORM $
	D[CONST[. & 77 + 1]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $
;STATE 2: LO 16 BITS OF WORD ARRIVES.
; ALSO STARTED HERE BY CLOCK ROUTINE.
TNIC2:	D[16] MASK[7] DEST[Q] NORM $
	D[CONST 22] ROT[6] ALU[D+Q] DEST[MA] NORM $
	D[15] DEST[Q] NORM $
	D[AR] ROT[4] ALU[DORQ] DEST[MEMSTO] NORM $
	PUSHJ[TNCASODOF] NORM $
	D[16] ALU[D+1] DEST[Q] CYLEN[MEMSTO] $
	D[CONST 1] ROT[18.] ALU[D+Q] DEST[6] DEST-A-MEM COND[-OBUS<0] JUMP[TNICDN] C600 $
	D[CONST[77 & TNIC1]] DEST[3] JUMP[TNI2] DEST-A-MEM NORM $
TNICDN:	D[CONST 6] DEST[Q] SHORT $
	D[CONST 20] ROT[6] ALU[DORQ] DEST[MA] SHORT $
	D[16] MASK[7] DEST[MEMSTO] NORM $
	D[CONST[TNIC0 & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] CYLEN[MEMSTO] $
;1 WD OR 2 WD OR ESCAPE MESSAGE.
TNIC0A:	D[CONST 1] ROT[16] ALU[D&Q] COND[-OBUS=0] JUMP[TNIC0B] C550 $
;ONE WORD PACKET.
	D[CONST 1] DEST[6] JUMP[TNICRM] DEST-A-MEM NORM $
TNIC0B:	D[CONST 1] ROT[16] ALU[D#Q] DEST[Q AR] SHORT $
	D[MASK 6] ROT[8] ALU[D&Q] DEST[Q] SHORT $
	D[MASK 6] ROT[8] ALU[D#Q] COND[OBUS=0] JUMP[TNIC0C] C550 $
;2 WORD PACKET.
	D[CONST 2] DEST[6] JUMP[TNICRM] DEST-A-MEM NORM $
;ESCAPE SEQUENCE.  BETTER NOT HAPPEN.
TNIC0C:	JUMP[.] $
;CLOCK ROUTINE, CALLED EVERY TICK OF 60HZ CLOCK.
TYMCLK:	D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPOFF] SPEC[IOB-IN] NORM $
	MAPF[10] CYLEN[IOB-OUT] D[CONST 6] DEST[DEV-ADR] $
	D[IR] DEST[7] DEST-A-MEM NORM $
	D[13] COND[OBUS<0] PUSHJ[TNSI] C550 $
	D[12] COND[OBUS<0] PUSHJ[TNSO] C550 $
	D[17] MASK[3] DEST[IOD] NORM $
	ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] $
	D[CONST 6] DEST[DEV-ADR] POPJ NORM $

TNSI:	GHIRP
	D[16] ALU[D+1] DEST[Q] NORM $
	D[MASK 7] ALU[D&Q] DEST[Q] SHORT $
	D[MEM] ALU[D-Q] COND[OBUS=0] POPJ C600 $
	D[CONST[TNIC2 & 77]] DEST[3] DEST-A-MEM JUMP[TNCASODOF] NORM $
TNSO:	GBORP
	D[MEM] DEST[AR] NORM $
	GHORP
	D[AR] DEST[Q] NORM $
	D[MEM] ALU[D-Q] COND[OBUS=0] POPJ C600 $
	D[CONST 24] ROT[6] ALU[D+Q] DEST[MA] NORM $
	FIXM0 $
	D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
	D[CONST[TNOC2 & 77]] DEST[2] POPJ DEST-A-MEM NORM $

;RESET TYMNET INTERFACE.  OUTPUT COROUTINE GOES INTO NULL STATE.
; INPUT COROUTINE GOES INTO STATE 0, INTRPTS GET ENABLED.
TYMRS1:	D[CONST 3] ROT[2] DEST[AR] CYLEN[IOB-OUT] SPEC[IOB-OUT] $
	 ;GET CONST TO ENB. INTRPTS; IOB-OUT CLEARS FLAGS.
TYMRS2:	D[MASK 2] ALU[NOTD] ROT[2] DEST[Q] PUSHJ[DEV6ST1] MAPF[6] NORM $
	ALU[-1] DEST[2] DEST-A-MEM NORM $
	D[CONST[TNIC0 & 77]] DEST[3] POPJ DEST-A-MEM NORM $

TYMNLL:		;SAVE LOCATION

: 3710  ;DISPATCH TABLE ENTRY FOR OP 744 -- RESET TYMNET

	NOP $
	D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNRESET] $

	NOP $
	D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNOUT] $

	NOP $
	D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNIN] $

: TYMNLL	;RETURN TO MAIN CODE

TYMNRESET:  SPEC[IOB-OUT] D[MA] ROT[2] DEST[AR] NORM PUSHJ[TYMRS2] $
		;RESET CO-ROUTINES, ENB. INTRPTS FROM EFF. ADDR. 34,35
	JUMP[MAIN] $

TYMNOUT: SPEC[IOB-OUT] NORM $  ;CLEAR "RDY FOR DATA" FROM PDP11
	MAPF[TNODIFS] D[MA] ROT[8.] DEST[Q] NORM PUSHJ[TNSEND] $
	  ;SEND EFF. ADDR. 20-35 TO PDP11.
	JUMP[MAIN] $

TYMNIN:	D[CONST 25.] LLOAD NORM $
	NORM LOOP[.] $  ;GIVE DMA DEVICES SOME MEMORY TIME.
	SPEC[IOB-IN] NORM $
	D[IOD] ROT[34] DEST[AR] C800 $
	   ;ALIGN INPUT WORD WITH 16 DATA BITS AT RIGHT END.
	D[AR] ROT[4] C550 COND[-OBUS<0] JUMP[. + 2] $
	   ;DON'T CLEAR "INPUT RDY" FLAG UNLESS IT'S ON.
	SPEC[IOB-OUT] SHORT $  ;IT'S ON.
	MAPF[TNIRIFS] D[AR] DEST[MEMSTO] MEMST $


];TYMNET

list  ;matches the XLIST at top of page.

FOOGARP:

: 2141	;DISP HERE ON TYMNET INTERFACE INTERRUPT.
	; PREPARE TO CALL MAPOFF BY RE-LOADING DEV-ADR.
	D[CONST 1] DEST[DEV-ADR] NORM JUMP[TNI] $	

: FOOGARP

.REPEAT 1 - TYMNET [
TNI:	DEST[CLR-DEV-FROM-INTR] JUMP[MAIN] $		;"It can't happen here"
];1 - TYMNET
;INTERVAL TIMER CODE.

;a-mem useage:
;	0	dispatch addr for interrupts
;	1	pi chn (33: 35) and intrpt waiting flag (32)
;		(BITS 0,19 ARE ON FOR USE BY TAPE CODE)
;	2	CONSTANT W/ ONLY BIT 19 ON (USED BY TAPE CODE)
;	3	INTERVAL TIMER REGISTER.

SAVPCX:

: 2150		;INTRPTS FROM DEVICE 7 COME HERE.
   .REPEAT 1 - TIMER [
	DEST[CLR-DEV-FROM-INTR] JUMP[MAIN] $ ;FLUSH DEV 7 INTERRUPTS 
     ]

   .REPEAT TIMER [
	NORM JUMP[DEV-7-INT] $
     ]

: SAVPCX

DEV-7-INT:   ;FOR NOW, ALL DEV 7 INTS COME FROM INTERVAL TIMER...
	START-OUT D[CONST 1] ROT[35. - 6] DEST[IOD] NORM $
	   ;CLEAR THE TIMER OVERFLOW FLAG.
	MAPF[1] D[13] DEST[Q] C800 $
	   ;GET TIMER REGISTER.
	D[CONST 1] ROT[12.] ALU[D+Q] DEST[Q 3] DEST-A-MEM
	          C550 COND[-CRY0] JUMP[MAIN] $
	   ;INCREMENT THE COUNT BY 2^12, EXIT IF NO OVERFLOW.
	D[11] MASK[3] DEST[AR] C550 COND[OBUS=0] JUMP[MAIN] $
	   ;TIMER OVERFLOWED. IGNORE IF NO PI CHANNEL ASSIGNED.
	D[11] DEST[Q] NORM $
	  ;GET FULL CONTENTS OF A-MEM[1].
	D[CONST 10] ALU[DORQ] DEST[1] DEST-A-MEM NORM JUMP[PIGEN] $
	   ;SET THE "INTERRUPTING" STATUS BIT AND GENERATE A PI.

SAVPCY:

: 3740	;TIMER PSEUDO-IOT DISPATCH TABLE ENTRIES.

 ; TCONo -- 760
	d[CONST 7] dest[dev-adr] short $
	D[11] dest[Q] norm jump[TCNo1]$
; TCONi -- 761
	d[CONST 7] dest[dev-adr] norm pushj[TCNi1] $ ;get bits.
	d[ar] dest[memsto] memst $ ;store them and return.
; TCONso -- 762
	d[CONST 7] dest[dev-adr] norm pushj[TCNi1] $ ;get bits.
	d[mask 22] alu[d&q] c550 cond[-obus=0] lbjump[dskp1] $
; TCONsz -- 763
	d[CONST 7] dest[dev-adr] norm pushj[TCNi1] $ ;get bits.
	d[mask 22] alu[d&q] c550 cond[obus=0] lbjump[dskp1] $
; TDATAO -- 764  LOAD THE 36-BIT TIMER
	d[CONST 7] dest[dev-adr] norm $
	FIXM1 JUMP[TDATO] $
; TDATAI  --  765    READ TIMER REGISTER
TDATAI:	START-IN d[CONST 7] dest[dev-adr] norm pushj[TDTI] $ ;get bits.
	d[ar] dest[memsto] memst $ ;store them and return.

: SAVPCY

TCNO1:	D[MASK 31.] ROT[4] ALU[D&Q] DEST[Q] NORM $
	D[IR] MASK[3] ALU[DORQ] DEST[1] DEST-A-MEM JUMP[MAIN] $
	   ;PUT NEW PI CHAN. IN BITS 33-35 OF A-MEM[1].

TCNi1:	d[11] MASK[4] dest[q ar] norm $ ;get intrpt flag and pi chn
	d[ir] alu[d&q] dest[q] norm popj $ ;this is for conso, z

TDATO:	D[MEM] MASK[12.] DEST[Q] NORM $
	   ;GET LOW 12 BITS OF NEW TIMER VALUE...
	START-OUT D[CONST 1] ROT[35. - 7] ALU[DORQ] DEST[IOD] NORM $
	   ;PLACE IN HARDWARE COUNTER (THE "TP TIMER").
	MAPF[1] D[MASK 24.] ROT[12.] DEST[Q] C800 $
	D[MEM] ALU[D&Q] DEST[3] DEST-A-MEM NORM JUMP[MAIN] $
	   ;PUT OTHER 24 BITS INTO A-MEM[3] THE "TIMER REGISTER".

TDTI:	MAPF[1] START-IN D[IOD] ROT[12.] MASK[12.] DEST[AR Q] C800 $
	MAPF[1] D[IOD] ROT[12.] MASK[12.] ALU[D#Q] C550
		COND[-OBUS=0] JPOP[TDATAI] $
	D[13] ALU[DORQ] DEST[AR] NORM POPJ $
	   ;COMBINE HIGH-ORDER BITS FROM A-MEM[3] WITH
	   ; LOW-ORDER BITS FROM HARDWARE COUNTER.

;	IMP stuff
.REPEAT IMP [

;Insert main code body here
.INSERT IMP.SLO

;Save location counter for niceness
DOT = .

;	IMP IOTs
: IMP-IOT		;opcode 755 (IMP IOT) dispatches to here
	D[IR] .LDB[10. 3] DEST[Q CLR-DEV-FROM-INTR] $	;Q:= which IOT
	D[CONST IMP-DEVNUM] DEST[DEV-ADR]	;set the device address
		JUMP[IMP-DISPATCH] $		;jump to the dispatcher

;Restore location counter
: DOT

];IMP

.REPEAT DLS [
.DEFINE ASRC[ X ] [D[10 + X]]
.DEFINE ADEST[ X ] [DEST[X] DEST-A-MEM]
DLSDEB = 1	;Set to 1 for debugging
.INSERT DLS.SLO
.REPEAT DLSDEB [
.INSERT DLSDEB.SLO
];DLSDEB
];DLS			9 JAN 80  BO
; dsk stuff

dskstf:

;a-mem useage:
;	0	dispatch addr for interrupts
;	1	pi chn (33: 35) and intrpt waiting flag (32)
;	2	copy of last cmd sent to controller (by opcode 721)

: 3700	;disk pseudo-iot dispatch table entries.

 ; dcono -- 740
	d[const 10] dest[dev-adr] short $
	d[ir] mask[3] dest[1] DEST-A-MEM norm jump[dcno1]$
; dconi -- 741
	d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
	d[ar] dest[memsto] memst $ ;store them and return.
; dconso -- 742
	d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
	d[mask 22] alu[d&q] c550 cond[-obus=0] lbjump[dskp1] $
; dconsz -- 743
	d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
	d[mask 22] alu[d&q] c550 cond[obus=0] lbjump[dskp1] $

: dskstf

dcno1:	d[ir] mask[3]  c500 cond[obus=0] jump[main] $
	 ; if assigned pi channel is not 0, then
	 ;  enable interrupt on "not active", by
	 ;  re-loading last cmd with 10 bit on.
	d[const 10] dest[q] short $
	d[12] alu[dorq] dest[iod] spec[iob-out] norm $
	mapf[4] cylen[iob-out] jump[main] $

dcni1:	d[11] dest[q ar] norm $ ;get intrpt flag and pi chn
	d[ir] alu[d&q] dest[q] norm popj $ ;this is for conso, z

dskint:

: 2156	;interrupts from disk (dev 10) come here.
	d[12] dest[iod] spec[iob-out] norm jump[dskint] $
	  ;clear interrrupt enable bit (amem[2] has last cmd)

: 2154
dskp1:	jump[main] norm $	;conso and consz lbjump to here.
	doskip $

: dskint
	mapf[4] d[11] dest[q ar] c550 cond[obus=0] jump[ddis] $
	d[const 10] alu[dorq] dest[1] DEST-A-MEM norm
		jump[pigen] $ ;set flag and request intrpt.
ddis:	dest[clr-dev-from-intr] norm jump[main] $

DSKWT1:	D[CONST 10] DEST[DEV-ADR AR] NORM JUMP[DSKWT4] $
DSKWT3:	D[MEM] ROT[31.] C550 COND[OBUS<0] JUMP[DSKWDN] $
	D[CONST 1] ROT[6] LLOAD NORM $
	C550 LOOP[.] $
DSKWT4:	START-IN NORM $
	MAPF[0] D[IOD] DEST[HOLD] C800  JUMP[DSKWT3] $
DSKWDN:	D[AR] ALU[D-1] DEST[AR] C550 COND[-OBUS=0] JUMP[DSKWT4] $
	JUMP[MAIN] $
: 7400	;TEMP DEBUGGING STUFF.
  ;; NOTHING USED IN THIS AREA NOW -- 14 JULY DWP


: 7760
 .REPEAT 20 [NOP $
]
;; this should be after everything else

list-labels	;print symbol table
list-cormap	;print map of memory used.


                                                                                                                                                                                                                   